(function(){/*
 ****************************** !*\
  !*** ./closure/goog/base.js ***!
  \***************************** no static exports found  *********************** !*\
  !*** ./core/block.js ***!
  \********************** ********************************** !*\
  !*** ./core/block_animations.js ***!
  \********************************* ************************************ !*\
  !*** ./core/block_drag_surface.js ***!
  \*********************************** ******************************* !*\
  !*** ./core/block_dragger.js ***!
  \****************************** *************************** !*\
  !*** ./core/block_svg.js ***!
  \************************** ************************* !*\
  !*** ./core/blockly.js ***!
  \************************ ********************************* !*\
  !*** ./core/blockly_options.js ***!
  \******************************** ************************ !*\
  !*** ./core/blocks.js ***!
  \*********************** ******************************** !*\
  !*** ./core/browser_events.js ***!
  \******************************* ************************ !*\
  !*** ./core/bubble.js ***!
  \*********************** ******************************** !*\
  !*** ./core/bubble_dragger.js ***!
  \******************************* ****************************** !*\
  !*** ./core/bump_objects.js ***!
  \***************************** *************************** !*\
  !*** ./core/clipboard.js ***!
  \************************** ************************* !*\
  !*** ./core/comment.js ***!
  \************************ ************************ !*\
  !*** ./core/common.js ***!
  \*********************** *********************************** !*\
  !*** ./core/component_manager.js ***!
  \********************************** ************************ !*\
  !*** ./core/config.js ***!
  \*********************** **************************** !*\
  !*** ./core/connection.js ***!
  \*************************** ************************************ !*\
  !*** ./core/connection_checker.js ***!
  \*********************************** ******************************* !*\
  !*** ./core/connection_db.js ***!
  \****************************** ********************************* !*\
  !*** ./core/connection_type.js ***!
  \******************************** *************************** !*\
  !*** ./core/constants.js ***!
  \************************** ***************************** !*\
  !*** ./core/contextmenu.js ***!
  \**************************** *********************************** !*\
  !*** ./core/contextmenu_items.js ***!
  \********************************** ************************************** !*\
  !*** ./core/contextmenu_registry.js ***!
  \************************************* ********************* !*\
  !*** ./core/css.js ***!
  \******************** ***************************** !*\
  !*** ./core/delete_area.js ***!
  \**************************** ************************ !*\
  !*** ./core/dialog.js ***!
  \*********************** ***************************** !*\
  !*** ./core/drag_target.js ***!
  \**************************** ***************************** !*\
  !*** ./core/dropdowndiv.js ***!
  \**************************** ******************************* !*\
  !*** ./core/events/events.js ***!
  \****************************** **************************************** !*\
  !*** ./core/events/events_abstract.js ***!
  \*************************************** ****************************************** !*\
  !*** ./core/events/events_block_base.js ***!
  \***************************************** ******************************************** !*\
  !*** ./core/events/events_block_change.js ***!
  \******************************************* ******************************************** !*\
  !*** ./core/events/events_block_create.js ***!
  \******************************************* ******************************************** !*\
  !*** ./core/events/events_block_delete.js ***!
  \******************************************* ****************************************** !*\
  !*** ./core/events/events_block_drag.js ***!
  \***************************************** ****************************************** !*\
  !*** ./core/events/events_block_move.js ***!
  \***************************************** ******************************************* !*\
  !*** ./core/events/events_bubble_open.js ***!
  \****************************************** ************************************* !*\
  !*** ./core/events/events_click.js ***!
  \************************************ ******************************************** !*\
  !*** ./core/events/events_comment_base.js ***!
  \******************************************* ********************************************** !*\
  !*** ./core/events/events_comment_change.js ***!
  \********************************************* ********************************************** !*\
  !*** ./core/events/events_comment_create.js ***!
  \********************************************* ********************************************** !*\
  !*** ./core/events/events_comment_delete.js ***!
  \********************************************* ******************************************** !*\
  !*** ./core/events/events_comment_move.js ***!
  \******************************************* ******************************************* !*\
  !*** ./core/events/events_marker_move.js ***!
  \****************************************** **************************************** !*\
  !*** ./core/events/events_selected.js ***!
  \*************************************** ******************************************** !*\
  !*** ./core/events/events_theme_change.js ***!
  \******************************************* *************************************************** !*\
  !*** ./core/events/events_toolbox_item_select.js ***!
  \************************************************** ********************************************* !*\
  !*** ./core/events/events_trashcan_open.js ***!
  \******************************************** ********************************** !*\
  !*** ./core/events/events_ui.js ***!
  \********************************* *************************************** !*\
  !*** ./core/events/events_ui_base.js ***!
  \************************************** **************************************** !*\
  !*** ./core/events/events_var_base.js ***!
  \*************************************** ****************************************** !*\
  !*** ./core/events/events_var_create.js ***!
  \***************************************** ****************************************** !*\
  !*** ./core/events/events_var_delete.js ***!
  \***************************************** ****************************************** !*\
  !*** ./core/events/events_var_rename.js ***!
  \***************************************** **************************************** !*\
  !*** ./core/events/events_viewport.js ***!
  \*************************************** ****************************** !*\
  !*** ./core/events/utils.js ***!
  \***************************** ***************************************** !*\
  !*** ./core/events/workspace_events.js ***!
  \**************************************** **************************** !*\
  !*** ./core/extensions.js ***!
  \*************************** *********************** !*\
  !*** ./core/field.js ***!
  \********************** ***************************** !*\
  !*** ./core/field_angle.js ***!
  \**************************** ******************************** !*\
  !*** ./core/field_checkbox.js ***!
  \******************************* ****************************** !*\
  !*** ./core/field_colour.js ***!
  \***************************** ******************************** !*\
  !*** ./core/field_dropdown.js ***!
  \******************************* ***************************** !*\
  !*** ./core/field_image.js ***!
  \**************************** ***************************** !*\
  !*** ./core/field_label.js ***!
  \**************************** ****************************************** !*\
  !*** ./core/field_label_serializable.js ***!
  \***************************************** ************************************** !*\
  !*** ./core/field_multilineinput.js ***!
  \************************************* ****************************** !*\
  !*** ./core/field_number.js ***!
  \***************************** ******************************** !*\
  !*** ./core/field_registry.js ***!
  \******************************* ********************************* !*\
  !*** ./core/field_textinput.js ***!
  \******************************** ******************************** !*\
  !*** ./core/field_variable.js ***!
  \******************************* ***************************** !*\
  !*** ./core/flyout_base.js ***!
  \**************************** ******************************* !*\
  !*** ./core/flyout_button.js ***!
  \****************************** *********************************** !*\
  !*** ./core/flyout_horizontal.js ***!
  \********************************** **************************************** !*\
  !*** ./core/flyout_metrics_manager.js ***!
  \*************************************** ********************************* !*\
  !*** ./core/flyout_vertical.js ***!
  \******************************** *************************** !*\
  !*** ./core/generator.js ***!
  \************************** ************************* !*\
  !*** ./core/gesture.js ***!
  \************************ ********************** !*\
  !*** ./core/grid.js ***!
  \********************* ********************** !*\
  !*** ./core/icon.js ***!
  \********************* ************************ !*\
  !*** ./core/inject.js ***!
  \*********************** *********************** !*\
  !*** ./core/input.js ***!
  \********************** ***************************** !*\
  !*** ./core/input_types.js ***!
  \**************************** ****************************************** !*\
  !*** ./core/insertion_marker_manager.js ***!
  \***************************************** ************************************************ !*\
  !*** ./core/interfaces/i_ast_node_location.js ***!
  \*********************************************** **************************************************** !*\
  !*** ./core/interfaces/i_ast_node_location_svg.js ***!
  \*************************************************** *********************************************************** !*\
  !*** ./core/interfaces/i_ast_node_location_with_block.js ***!
  \********************************************************** ******************************************* !*\
  !*** ./core/interfaces/i_autohideable.js ***!
  \****************************************** ******************************************** !*\
  !*** ./core/interfaces/i_block_dragger.js ***!
  \******************************************* ********************************************** !*\
  !*** ./core/interfaces/i_bounded_element.js ***!
  \********************************************* ************************************* !*\
  !*** ./core/interfaces/i_bubble.js ***!
  \************************************ ******************************************************* !*\
  !*** ./core/interfaces/i_collapsible_toolbox_item.js ***!
  \****************************************************** **************************************** !*\
  !*** ./core/interfaces/i_component.js ***!
  \*************************************** ************************************************* !*\
  !*** ./core/interfaces/i_connection_checker.js ***!
  \************************************************ ****************************************** !*\
  !*** ./core/interfaces/i_contextmenu.js ***!
  \***************************************** *************************************** !*\
  !*** ./core/interfaces/i_copyable.js ***!
  \************************************** **************************************** !*\
  !*** ./core/interfaces/i_deletable.js ***!
  \*************************************** ****************************************** !*\
  !*** ./core/interfaces/i_delete_area.js ***!
  \***************************************** ****************************************** !*\
  !*** ./core/interfaces/i_drag_target.js ***!
  \***************************************** **************************************** !*\
  !*** ./core/interfaces/i_draggable.js ***!
  \*************************************** ************************************* !*\
  !*** ./core/interfaces/i_flyout.js ***!
  \************************************ ************************************************** !*\
  !*** ./core/interfaces/i_keyboard_accessible.js ***!
  \************************************************* ********************************************** !*\
  !*** ./core/interfaces/i_metrics_manager.js ***!
  \********************************************* ************************************** !*\
  !*** ./core/interfaces/i_movable.js ***!
  \************************************* ******************************************* !*\
  !*** ./core/interfaces/i_positionable.js ***!
  \****************************************** ****************************************** !*\
  !*** ./core/interfaces/i_registrable.js ***!
  \***************************************** ************************************************ !*\
  !*** ./core/interfaces/i_registrable_field.js ***!
  \*********************************************** ***************************************** !*\
  !*** ./core/interfaces/i_selectable.js ***!
  \**************************************** ****************************************************** !*\
  !*** ./core/interfaces/i_selectable_toolbox_item.js ***!
  \***************************************************** ***************************************** !*\
  !*** ./core/interfaces/i_serializer.js ***!
  \**************************************** **************************************** !*\
  !*** ./core/interfaces/i_styleable.js ***!
  \*************************************** ************************************** !*\
  !*** ./core/interfaces/i_toolbox.js ***!
  \************************************* ******************************************* !*\
  !*** ./core/interfaces/i_toolbox_item.js ***!
  \****************************************** ************************************ !*\
  !*** ./core/internal_constants.js ***!
  \*********************************** *************************************** !*\
  !*** ./core/keyboard_nav/ast_node.js ***!
  \************************************** ******************************************* !*\
  !*** ./core/keyboard_nav/basic_cursor.js ***!
  \****************************************** ************************************* !*\
  !*** ./core/keyboard_nav/cursor.js ***!
  \************************************ ************************************* !*\
  !*** ./core/keyboard_nav/marker.js ***!
  \************************************ ************************************************** !*\
  !*** ./core/keyboard_nav/tab_navigate_cursor.js ***!
  \************************************************* ******************************** !*\
  !*** ./core/marker_manager.js ***!
  \******************************* ********************** !*\
  !*** ./core/menu.js ***!
  \********************* ************************** !*\
  !*** ./core/menuitem.js ***!
  \************************* ********************************* !*\
  !*** ./core/metrics_manager.js ***!
  \******************************** ********************* !*\
  !*** ./core/msg.js ***!
  \******************** ************************* !*\
  !*** ./core/mutator.js ***!
  \************************ *********************** !*\
  !*** ./core/names.js ***!
  \********************** ************************* !*\
  !*** ./core/options.js ***!
  \************************ ************************************** !*\
  !*** ./core/positionable_helpers.js ***!
  \************************************* **************************** !*\
  !*** ./core/procedures.js ***!
  \*************************** ************************** !*\
  !*** ./core/registry.js ***!
  \************************* ************************************* !*\
  !*** ./core/rendered_connection.js ***!
  \************************************ ************************************************** !*\
  !*** ./core/renderers/common/block_rendering.js ***!
  \************************************************* ******************************************** !*\
  !*** ./core/renderers/common/constants.js ***!
  \******************************************* **************************************** !*\
  !*** ./core/renderers/common/debug.js ***!
  \*************************************** ******************************************* !*\
  !*** ./core/renderers/common/debugger.js ***!
  \****************************************** ***************************************** !*\
  !*** ./core/renderers/common/drawer.js ***!
  \**************************************** ************************************************ !*\
  !*** ./core/renderers/common/i_path_object.js ***!
  \*********************************************** *************************************** !*\
  !*** ./core/renderers/common/info.js ***!
  \************************************** ********************************************* !*\
  !*** ./core/renderers/common/marker_svg.js ***!
  \******************************************** ********************************************** !*\
  !*** ./core/renderers/common/path_object.js ***!
  \********************************************* ******************************************* !*\
  !*** ./core/renderers/common/renderer.js ***!
  \****************************************** ******************************************* !*\
  !*** ./core/renderers/geras/constants.js ***!
  \****************************************** **************************************** !*\
  !*** ./core/renderers/geras/drawer.js ***!
  \*************************************** *************************************** !*\
  !*** ./core/renderers/geras/geras.js ***!
  \************************************** ***************************************************** !*\
  !*** ./core/renderers/geras/highlight_constants.js ***!
  \**************************************************** ********************************************* !*\
  !*** ./core/renderers/geras/highlighter.js ***!
  \******************************************** ************************************** !*\
  !*** ./core/renderers/geras/info.js ***!
  \************************************* ********************************************************** !*\
  !*** ./core/renderers/geras/measurables/inline_input.js ***!
  \********************************************************* ************************************************************* !*\
  !*** ./core/renderers/geras/measurables/statement_input.js ***!
  \************************************************************ ********************************************* !*\
  !*** ./core/renderers/geras/path_object.js ***!
  \******************************************** ****************************************** !*\
  !*** ./core/renderers/geras/renderer.js ***!
  \***************************************** ******************************************** !*\
  !*** ./core/renderers/measurables/base.js ***!
  \******************************************* ************************************************** !*\
  !*** ./core/renderers/measurables/bottom_row.js ***!
  \************************************************* ************************************************** !*\
  !*** ./core/renderers/measurables/connection.js ***!
  \************************************************* ************************************************************ !*\
  !*** ./core/renderers/measurables/external_value_input.js ***!
  \*********************************************************** ********************************************* !*\
  !*** ./core/renderers/measurables/field.js ***!
  \******************************************** ******************************************* !*\
  !*** ./core/renderers/measurables/hat.js ***!
  \****************************************** ******************************************** !*\
  !*** ./core/renderers/measurables/icon.js ***!
  \******************************************* ***************************************************** !*\
  !*** ./core/renderers/measurables/in_row_spacer.js ***!
  \**************************************************** **************************************************** !*\
  !*** ./core/renderers/measurables/inline_input.js ***!
  \*************************************************** ******************************************************** !*\
  !*** ./core/renderers/measurables/input_connection.js ***!
  \******************************************************* ************************************************* !*\
  !*** ./core/renderers/measurables/input_row.js ***!
  \************************************************ *************************************************** !*\
  !*** ./core/renderers/measurables/jagged_edge.js ***!
  \************************************************** ******************************************************* !*\
  !*** ./core/renderers/measurables/next_connection.js ***!
  \****************************************************** ********************************************************* !*\
  !*** ./core/renderers/measurables/output_connection.js ***!
  \******************************************************** *********************************************************** !*\
  !*** ./core/renderers/measurables/previous_connection.js ***!
  \********************************************************** **************************************************** !*\
  !*** ./core/renderers/measurables/round_corner.js ***!
  \*************************************************** ******************************************* !*\
  !*** ./core/renderers/measurables/row.js ***!
  \****************************************** ************************************************** !*\
  !*** ./core/renderers/measurables/spacer_row.js ***!
  \************************************************* ***************************************************** !*\
  !*** ./core/renderers/measurables/square_corner.js ***!
  \**************************************************** ******************************************************* !*\
  !*** ./core/renderers/measurables/statement_input.js ***!
  \****************************************************** *********************************************** !*\
  !*** ./core/renderers/measurables/top_row.js ***!
  \********************************************** ********************************************* !*\
  !*** ./core/renderers/measurables/types.js ***!
  \******************************************** ************************************************ !*\
  !*** ./core/renderers/minimalist/constants.js ***!
  \*********************************************** ********************************************* !*\
  !*** ./core/renderers/minimalist/drawer.js ***!
  \******************************************** ******************************************* !*\
  !*** ./core/renderers/minimalist/info.js ***!
  \****************************************** ************************************************* !*\
  !*** ./core/renderers/minimalist/minimalist.js ***!
  \************************************************ *********************************************** !*\
  !*** ./core/renderers/minimalist/renderer.js ***!
  \********************************************** **************************************** !*\
  !*** ./core/renderers/thrasos/info.js ***!
  \*************************************** ******************************************** !*\
  !*** ./core/renderers/thrasos/renderer.js ***!
  \******************************************* ******************************************* !*\
  !*** ./core/renderers/thrasos/thrasos.js ***!
  \****************************************** ******************************************* !*\
  !*** ./core/renderers/zelos/constants.js ***!
  \****************************************** **************************************** !*\
  !*** ./core/renderers/zelos/drawer.js ***!
  \*************************************** ************************************** !*\
  !*** ./core/renderers/zelos/info.js ***!
  \************************************* ******************************************** !*\
  !*** ./core/renderers/zelos/marker_svg.js ***!
  \******************************************* ******************************************************** !*\
  !*** ./core/renderers/zelos/measurables/bottom_row.js ***!
  \******************************************************* **************************************************** !*\
  !*** ./core/renderers/zelos/measurables/inputs.js ***!
  \*************************************************** ********************************************************** !*\
  !*** ./core/renderers/zelos/measurables/row_elements.js ***!
  \********************************************************* ***************************************************** !*\
  !*** ./core/renderers/zelos/measurables/top_row.js ***!
  \**************************************************** ********************************************* !*\
  !*** ./core/renderers/zelos/path_object.js ***!
  \******************************************** ****************************************** !*\
  !*** ./core/renderers/zelos/renderer.js ***!
  \***************************************** *************************************** !*\
  !*** ./core/renderers/zelos/zelos.js ***!
  \************************************** *************************** !*\
  !*** ./core/scrollbar.js ***!
  \************************** ******************************** !*\
  !*** ./core/scrollbar_pair.js ***!
  \******************************* ************************************** !*\
  !*** ./core/serialization/blocks.js ***!
  \************************************* ****************************************** !*\
  !*** ./core/serialization/exceptions.js ***!
  \***************************************** ****************************************** !*\
  !*** ./core/serialization/priorities.js ***!
  \***************************************** **************************************** !*\
  !*** ./core/serialization/registry.js ***!
  \*************************************** ***************************************** !*\
  !*** ./core/serialization/variables.js ***!
  \**************************************** ****************************************** !*\
  !*** ./core/serialization/workspaces.js ***!
  \***************************************** ******************************** !*\
  !*** ./core/shortcut_items.js ***!
  \******************************* *********************************** !*\
  !*** ./core/shortcut_registry.js ***!
  \********************************** ************************* !*\
  !*** ./core/sprites.js ***!
  \************************ *********************** !*\
  !*** ./core/theme.js ***!
  \********************** ******************************* !*\
  !*** ./core/theme/classic.js ***!
  \****************************** ****************************** !*\
  !*** ./core/theme/themes.js ***!
  \***************************** ***************************** !*\
  !*** ./core/theme/zelos.js ***!
  \**************************** ******************************* !*\
  !*** ./core/theme_manager.js ***!
  \****************************** ********************************** !*\
  !*** ./core/toolbox/category.js ***!
  \********************************* ********************************************** !*\
  !*** ./core/toolbox/collapsible_category.js ***!
  \********************************************* *********************************** !*\
  !*** ./core/toolbox/separator.js ***!
  \********************************** ********************************* !*\
  !*** ./core/toolbox/toolbox.js ***!
  \******************************** ************************************** !*\
  !*** ./core/toolbox/toolbox_item.js ***!
  \************************************* ************************* !*\
  !*** ./core/tooltip.js ***!
  \************************ *********************** !*\
  !*** ./core/touch.js ***!
  \********************** ******************************* !*\
  !*** ./core/touch_gesture.js ***!
  \****************************** ************************** !*\
  !*** ./core/trashcan.js ***!
  \************************* *********************** !*\
  !*** ./core/utils.js ***!
  \********************** **************************** !*\
  !*** ./core/utils/aria.js ***!
  \*************************** ***************************** !*\
  !*** ./core/utils/array.js ***!
  \**************************** ****************************** !*\
  !*** ./core/utils/colour.js ***!
  \***************************** ********************************** !*\
  !*** ./core/utils/coordinate.js ***!
  \********************************* *********************************** !*\
  !*** ./core/utils/deprecation.js ***!
  \********************************** *************************** !*\
  !*** ./core/utils/dom.js ***!
  \************************** ****************************** !*\
  !*** ./core/utils/global.js ***!
  \***************************** *********************************** !*\
  !*** ./core/utils/idgenerator.js ***!
  \********************************** ******************************** !*\
  !*** ./core/utils/keycodes.js ***!
  \******************************* **************************** !*\
  !*** ./core/utils/math.js ***!
  \*************************** ******************************* !*\
  !*** ./core/utils/metrics.js ***!
  \****************************** ****************************** !*\
  !*** ./core/utils/object.js ***!
  \***************************** ******************************* !*\
  !*** ./core/utils/parsing.js ***!
  \****************************** **************************** !*\
  !*** ./core/utils/rect.js ***!
  \*************************** ******************************** !*\
  !*** ./core/utils/sentinel.js ***!
  \******************************* **************************** !*\
  !*** ./core/utils/size.js ***!
  \*************************** ****************************** !*\
  !*** ./core/utils/string.js ***!
  \***************************** ***************************** !*\
  !*** ./core/utils/style.js ***!
  \**************************** *************************** !*\
  !*** ./core/utils/svg.js ***!
  \************************** ******************************** !*\
  !*** ./core/utils/svg_math.js ***!
  \******************************* ********************************* !*\
  !*** ./core/utils/svg_paths.js ***!
  \******************************** ******************************* !*\
  !*** ./core/utils/toolbox.js ***!
  \****************************** ********************************* !*\
  !*** ./core/utils/useragent.js ***!
  \******************************** *************************** !*\
  !*** ./core/utils/xml.js ***!
  \************************** ****************************** !*\
  !*** ./core/variable_map.js ***!
  \***************************** ******************************** !*\
  !*** ./core/variable_model.js ***!
  \******************************* *************************** !*\
  !*** ./core/variables.js ***!
  \************************** *********************************** !*\
  !*** ./core/variables_dynamic.js ***!
  \********************************** ************************* !*\
  !*** ./core/warning.js ***!
  \************************ *************************** !*\
  !*** ./core/widgetdiv.js ***!
  \************************** *************************** !*\
  !*** ./core/workspace.js ***!
  \************************** ********************************* !*\
  !*** ./core/workspace_audio.js ***!
  \******************************** *********************************** !*\
  !*** ./core/workspace_comment.js ***!
  \********************************** *************************************** !*\
  !*** ./core/workspace_comment_svg.js ***!
  \************************************** ******************************************** !*\
  !*** ./core/workspace_drag_surface_svg.js ***!
  \******************************************* *********************************** !*\
  !*** ./core/workspace_dragger.js ***!
  \********************************** ******************************* !*\
  !*** ./core/workspace_svg.js ***!
  \****************************** ********************* !*\
  !*** ./core/xml.js ***!
  \******************** ******************************* !*\
  !*** ./core/zoom_controls.js ***!
  \****************************** *********************************** !*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
(function(c){function a(d){if(b[d])return b[d].exports;var e=b[d]={i:d,l:!1,exports:{}};c[d].call(e.exports,e,e.exports,a);e.l=!0;return e.exports}var b={};a.m=c;a.c=b;a.d=function(d,e,f){a.o(d,e)||Object.defineProperty(d,e,{enumerable:!0,get:f})};a.r=function(d){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(d,Symbol.toStringTag,{value:"Module"});Object.defineProperty(d,"__esModule",{value:!0})};a.t=function(d,e){e&1&&(d=a(d));if(e&8||e&4&&"object"===typeof d&&d&&d.__esModule)return d;
var f=Object.create(null);a.r(f);Object.defineProperty(f,"default",{enumerable:!0,value:d});if(e&2&&"string"!=typeof d)for(var g in d)a.d(f,g,function(h){return d[h]}.bind(null,g));return f};a.n=function(d){var e=d&&d.__esModule?function(){return d["default"]}:function(){return d};a.d(e,"a",e);return e};a.o=function(d,e){return Object.prototype.hasOwnProperty.call(d,e)};a.p="";return a(a.s="./core/blockly.js")})({"./closure/goog/base.js":function(c,a,b){eval("/* WEBPACK VAR INJECTION */(function(goog) {/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Bootstrap for the Google JS Library (Closure).\n *\n * In uncompiled mode base.js will attempt to load Closure's deps file, unless\n * the global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects\n * to include their own deps file(s) from different locations.\n *\n * Avoid including base.js more than once. This is strictly discouraged and not\n * supported. goog.require(...) won't work properly in that case.\n *\n * @provideGoog\n */\n\n\n/**\n * @define {boolean} Overridden to true by the compiler.\n */\nvar COMPILED = false;\n\n\n/**\n * Base namespace for the Closure library.  Checks to see goog is already\n * defined in the current scope before assigning to prevent clobbering if\n * base.js is loaded more than once.\n *\n * @const\n */\nvar goog = goog || {};\n\n/**\n * Reference to the global object.\n * https://www.ecma-international.org/ecma-262/9.0/index.html#sec-global-object\n *\n * More info on this implementation here:\n * https://docs.google.com/document/d/1NAeW4Wk7I7FV0Y2tcUFvQdGMc89k2vdgSXInw8_nvCI/edit\n *\n * @const\n * @suppress {undefinedVars} self won't be referenced unless `this` is falsy.\n * @type {!Global}\n */\ngoog.global =\n    // Check `this` first for backwards compatibility.\n    // Valid unless running as an ES module or in a function wrapper called\n    //   without setting `this` properly.\n    // Note that base.js can't usefully be imported as an ES module, but it may\n    // be compiled into bundles that are loadable as ES modules.\n    this ||\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n    // For in-page browser environments and workers.\n    self;goog.global = window; goog.global.CLOSURE_NO_DEPS = true;\n\n\n/**\n * A hook for overriding the define values in uncompiled mode.\n *\n * In uncompiled mode, `CLOSURE_UNCOMPILED_DEFINES` may be defined before\n * loading base.js.  If a key is defined in `CLOSURE_UNCOMPILED_DEFINES`,\n * `goog.define` will use the value instead of the default value.  This\n * allows flags to be overwritten without compilation (this is normally\n * accomplished with the compiler's \"define\" flag).\n *\n * Example:\n * <pre>\n *   var CLOSURE_UNCOMPILED_DEFINES = {'goog.DEBUG': false};\n * </pre>\n *\n * @type {Object<string, (string|number|boolean)>|undefined}\n */\ngoog.global.CLOSURE_UNCOMPILED_DEFINES;\n\n\n/**\n * A hook for overriding the define values in uncompiled or compiled mode,\n * like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In\n * uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.\n *\n * Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or\n * string literals or the compiler will emit an error.\n *\n * While any @define value may be set, only those set with goog.define will be\n * effective for uncompiled code.\n *\n * Example:\n * <pre>\n *   var CLOSURE_DEFINES = {'goog.DEBUG': false} ;\n * </pre>\n *\n * Currently the Closure Compiler will only recognize very simple definitions of\n * this value when looking for values to apply to compiled code and ignore all\n * other references.  Specifically, it looks the value defined at the variable\n * declaration, as with the example above.\n *\n * TODO(user): Improve the recognized definitions.\n *\n * @type {!Object<string, (string|number|boolean)>|null|undefined}\n */\ngoog.global.CLOSURE_DEFINES;\n\n\n/**\n * Builds an object structure for the provided namespace path, ensuring that\n * names that already exist are not overwritten. For example:\n * \"a.b.c\" -> a = {};a.b={};a.b.c={};\n * Used by goog.provide and goog.exportSymbol.\n * @param {string} name The name of the object that this file defines.\n * @param {*=} object The object to expose at the end of the path.\n * @param {boolean=} overwriteImplicit If object is set and a previous call\n *     implicitly constructed the namespace given by name, this parameter\n *     controls whether object should overwrite the implicitly constructed\n *     namespace or be merged into it. Defaults to false.\n * @param {?Object=} objectToExportTo The object to add the path to; if this\n *     field is not specified, its value defaults to `goog.global`.\n * @private\n */\ngoog.exportPath_ = function(name, object, overwriteImplicit, objectToExportTo) {\n  var parts = name.split('.');\n  var cur = objectToExportTo || goog.global;\n\n  // Internet Explorer exhibits strange behavior when throwing errors from\n  // methods externed in this manner.  See the testExportSymbolExceptions in\n  // base_test.html for an example.\n  if (!(parts[0] in cur) && typeof cur.execScript != 'undefined') {\n    cur.execScript('var ' + parts[0]);\n  }\n\n  for (var part; parts.length && (part = parts.shift());) {\n    if (!parts.length && object !== undefined) {\n      if (!overwriteImplicit && goog.isObject(object) &&\n          goog.isObject(cur[part])) {\n        // Merge properties on object (the input parameter) with the existing\n        // implicitly defined namespace, so as to not clobber previously\n        // defined child namespaces.\n        for (var prop in object) {\n          if (object.hasOwnProperty(prop)) {\n            cur[part][prop] = object[prop];\n          }\n        }\n      } else {\n        // Either there is no existing implicit namespace, or overwriteImplicit\n        // is set to true, so directly assign object (the input parameter) to\n        // the namespace.\n        cur[part] = object;\n      }\n    } else if (cur[part] && cur[part] !== Object.prototype[part]) {\n      cur = cur[part];\n    } else {\n      cur = cur[part] = {};\n    }\n  }\n};\n\n\n/**\n * Defines a named value. In uncompiled mode, the value is retrieved from\n * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and\n * has the property specified, and otherwise used the defined defaultValue.\n * When compiled the default can be overridden using the compiler options or the\n * value set in the CLOSURE_DEFINES object. Returns the defined value so that it\n * can be used safely in modules. Note that the value type MUST be either\n * boolean, number, or string.\n *\n * @param {string} name The distinguished name to provide.\n * @param {T} defaultValue\n * @return {T} The defined value.\n * @template T\n */\ngoog.define = function(name, defaultValue) {\n  var value = defaultValue;\n  if (!COMPILED) {\n    var uncompiledDefines = goog.global.CLOSURE_UNCOMPILED_DEFINES;\n    var defines = goog.global.CLOSURE_DEFINES;\n    if (uncompiledDefines &&\n        // Anti DOM-clobbering runtime check (b/37736576).\n        /** @type {?} */ (uncompiledDefines).nodeType === undefined &&\n        Object.prototype.hasOwnProperty.call(uncompiledDefines, name)) {\n      value = uncompiledDefines[name];\n    } else if (\n        defines &&\n        // Anti DOM-clobbering runtime check (b/37736576).\n        /** @type {?} */ (defines).nodeType === undefined &&\n        Object.prototype.hasOwnProperty.call(defines, name)) {\n      value = defines[name];\n    }\n  }\n  return value;\n};\n\n\n/**\n * @define {number} Integer year indicating the set of browser features that are\n * guaranteed to be present.  This is defined to include exactly features that\n * work correctly on all \"modern\" browsers that are stable on January 1 of the\n * specified year.  For example,\n * ```js\n * if (goog.FEATURESET_YEAR >= 2019) {\n *   // use APIs known to be available on all major stable browsers Jan 1, 2019\n * } else {\n *   // polyfill for older browsers\n * }\n * ```\n * This is intended to be the primary define for removing\n * unnecessary browser compatibility code (such as ponyfills and workarounds),\n * and should inform the default value for most other defines:\n * ```js\n * const ASSUME_NATIVE_PROMISE =\n *     goog.define('ASSUME_NATIVE_PROMISE', goog.FEATURESET_YEAR >= 2016);\n * ```\n *\n * The default assumption is that IE9 is the lowest supported browser, which was\n * first available Jan 1, 2012.\n *\n * TODO(user): Reference more thorough documentation when it's available.\n */\ngoog.FEATURESET_YEAR = goog.define('goog.FEATURESET_YEAR', 2012);\n\n\n/**\n * @define {boolean} DEBUG is provided as a convenience so that debugging code\n * that should not be included in a production. It can be easily stripped\n * by specifying --define goog.DEBUG=false to the Closure Compiler aka\n * JSCompiler. For example, most toString() methods should be declared inside an\n * \"if (goog.DEBUG)\" conditional because they are generally used for debugging\n * purposes and it is difficult for the JSCompiler to statically determine\n * whether they are used.\n */\ngoog.DEBUG = goog.define('goog.DEBUG', true);\n\n\n/**\n * @define {string} LOCALE defines the locale being used for compilation. It is\n * used to select locale specific data to be compiled in js binary. BUILD rule\n * can specify this value by \"--define goog.LOCALE=<locale_name>\" as a compiler\n * option.\n *\n * Take into account that the locale code format is important. You should use\n * the canonical Unicode format with hyphen as a delimiter. Language must be\n * lowercase, Language Script - Capitalized, Region - UPPERCASE.\n * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.\n *\n * See more info about locale codes here:\n * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers\n *\n * For language codes you should use values defined by ISO 693-1. See it here\n * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from\n * this rule: the Hebrew language. For legacy reasons the old code (iw) should\n * be used instead of the new code (he).\n *\n */\ngoog.LOCALE = goog.define('goog.LOCALE', 'en');  // default to en\n\n\n/**\n * This method is intended to be used for bookkeeping purposes.  We would\n * like to distinguish uses of goog.LOCALE used for code stripping purposes\n * and uses of goog.LOCALE for other uses (such as URL parameters).\n *\n * This allows us to ban direct uses of goog.LOCALE and to ensure that all\n * code has been transformed to our new localization build scheme.\n *\n * @return {string}\n *\n */\ngoog.getLocale = function() {\n  return goog.LOCALE;\n};\n\n\n/**\n * @define {boolean} Whether this code is running on trusted sites.\n *\n * On untrusted sites, several native functions can be defined or overridden by\n * external libraries like Prototype, Datejs, and JQuery and setting this flag\n * to false forces closure to use its own implementations when possible.\n *\n * If your JavaScript can be loaded by a third party site and you are wary about\n * relying on non-standard implementations, specify\n * \"--define goog.TRUSTED_SITE=false\" to the compiler.\n */\ngoog.TRUSTED_SITE = goog.define('goog.TRUSTED_SITE', true);\n\n\n/**\n * @define {boolean} Whether code that calls {@link goog.setTestOnly} should\n *     be disallowed in the compilation unit.\n */\ngoog.DISALLOW_TEST_ONLY_CODE =\n    goog.define('goog.DISALLOW_TEST_ONLY_CODE', COMPILED && !goog.DEBUG);\n\n\n/**\n * @define {boolean} Whether to use a Chrome app CSP-compliant method for\n *     loading scripts via goog.require. @see appendScriptSrcNode_.\n */\ngoog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING =\n    goog.define('goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING', false);\n\n\n/**\n * Defines a namespace in Closure.\n *\n * A namespace may only be defined once in a codebase. It may be defined using\n * goog.provide() or goog.module().\n *\n * The presence of one or more goog.provide() calls in a file indicates\n * that the file defines the given objects/namespaces.\n * Provided symbols must not be null or undefined.\n *\n * In addition, goog.provide() creates the object stubs for a namespace\n * (for example, goog.provide(\"goog.foo.bar\") will create the object\n * goog.foo.bar if it does not already exist).\n *\n * Build tools also scan for provide/require/module statements\n * to discern dependencies, build dependency files (see deps.js), etc.\n *\n * @see goog.require\n * @see goog.module\n * @param {string} name Namespace provided by this file in the form\n *     \"goog.package.part\".\n * deprecated Use goog.module (see b/159289405)\n */\ngoog.provide = function(name) {\n  if (goog.isInModuleLoader_()) {\n    throw new Error('goog.provide cannot be used within a module.');\n  }\n  if (!COMPILED) {\n    // Ensure that the same namespace isn't provided twice.\n    // A goog.module/goog.provide maps a goog.require to a specific file\n    if (goog.isProvided_(name)) {\n      throw new Error('Namespace \"' + name + '\" already declared.');\n    }\n  }\n\n  goog.constructNamespace_(name);\n};\n\n\n/**\n * @param {string} name Namespace provided by this file in the form\n *     \"goog.package.part\".\n * @param {?Object=} object The object to embed in the namespace.\n * @param {boolean=} overwriteImplicit If object is set and a previous call\n *     implicitly constructed the namespace given by name, this parameter\n *     controls whether opt_obj should overwrite the implicitly constructed\n *     namespace or be merged into it. Defaults to false.\n * @private\n */\ngoog.constructNamespace_ = function(name, object, overwriteImplicit) {\n  if (!COMPILED) {\n    delete goog.implicitNamespaces_[name];\n\n    var namespace = name;\n    while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {\n      if (goog.getObjectByName(namespace)) {\n        break;\n      }\n      goog.implicitNamespaces_[namespace] = true;\n    }\n  }\n\n  goog.exportPath_(name, object, overwriteImplicit);\n};\n\n\n/**\n * According to the CSP3 spec a nonce must be a valid base64 string.\n * @see https://www.w3.org/TR/CSP3/#grammardef-base64-value\n * @private @const\n */\ngoog.NONCE_PATTERN_ = /^[\\w+/_-]+[=]{0,2}$/;\n\n\n/**\n * Returns CSP nonce, if set for any script tag.\n * @param {?Window=} opt_window The window context used to retrieve the nonce.\n *     Defaults to global context.\n * @return {string} CSP nonce or empty string if no nonce is present.\n * @private\n */\ngoog.getScriptNonce_ = function(opt_window) {\n  var doc = (opt_window || goog.global).document;\n  var script = doc.querySelector && doc.querySelector('script[nonce]');\n  if (script) {\n    // Try to get the nonce from the IDL property first, because browsers that\n    // implement additional nonce protection features (currently only Chrome) to\n    // prevent nonce stealing via CSS do not expose the nonce via attributes.\n    // See https://github.com/whatwg/html/issues/2369\n    var nonce = script['nonce'] || script.getAttribute('nonce');\n    if (nonce && goog.NONCE_PATTERN_.test(nonce)) {\n      return nonce;\n    }\n  }\n  return '';\n};\n\n\n/**\n * Module identifier validation regexp.\n * Note: This is a conservative check, it is very possible to be more lenient,\n *   the primary exclusion here is \"/\" and \"\\\" and a leading \".\", these\n *   restrictions are intended to leave the door open for using goog.require\n *   with relative file paths rather than module identifiers.\n * @private\n */\ngoog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;\n\n\n/**\n * Defines a module in Closure.\n *\n * Marks that this file must be loaded as a module and claims the namespace.\n *\n * A namespace may only be defined once in a codebase. It may be defined using\n * goog.provide() or goog.module().\n *\n * goog.module() has three requirements:\n * - goog.module may not be used in the same file as goog.provide.\n * - goog.module must be the first statement in the file.\n * - only one goog.module is allowed per file.\n *\n * When a goog.module annotated file is loaded, it is enclosed in\n * a strict function closure. This means that:\n * - any variables declared in a goog.module file are private to the file\n * (not global), though the compiler is expected to inline the module.\n * - The code must obey all the rules of \"strict\" JavaScript.\n * - the file will be marked as \"use strict\"\n *\n * NOTE: unlike goog.provide, goog.module does not declare any symbols by\n * itself. If declared symbols are desired, use\n * goog.module.declareLegacyNamespace().\n *\n *\n * See the public goog.module proposal: http://goo.gl/Va1hin\n *\n * @param {string} name Namespace provided by this file in the form\n *     \"goog.package.part\", is expected but not required.\n * @return {void}\n */\ngoog.module = function(name) {\n  if (typeof name !== 'string' || !name ||\n      name.search(goog.VALID_MODULE_RE_) == -1) {\n    throw new Error('Invalid module identifier');\n  }\n  if (!goog.isInGoogModuleLoader_()) {\n    throw new Error(\n        'Module ' + name + ' has been loaded incorrectly. Note, ' +\n        'modules cannot be loaded as normal scripts. They require some kind of ' +\n        'pre-processing step. You\\'re likely trying to load a module via a ' +\n        'script tag or as a part of a concatenated bundle without rewriting the ' +\n        'module. For more info see: ' +\n        'https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.');\n  }\n  if (goog.moduleLoaderState_.moduleName) {\n    throw new Error('goog.module may only be called once per module.');\n  }\n\n  // Store the module name for the loader.\n  goog.moduleLoaderState_.moduleName = name;\n  if (!COMPILED) {\n    // Ensure that the same namespace isn't provided twice.\n    // A goog.module/goog.provide maps a goog.require to a specific file\n    if (goog.isProvided_(name)) {\n      throw new Error('Namespace \"' + name + '\" already declared.');\n    }\n    delete goog.implicitNamespaces_[name];\n  }\n};\n\n\n/**\n * @param {string} name The module identifier.\n * @return {?} The module exports for an already loaded module or null.\n *\n * Note: This is not an alternative to goog.require, it does not\n * indicate a hard dependency, instead it is used to indicate\n * an optional dependency or to access the exports of a module\n * that has already been loaded.\n * @suppress {missingProvide}\n */\ngoog.module.get = function(name) {\n  return goog.module.getInternal_(name);\n};\n\n\n/**\n * @param {string} name The module identifier.\n * @return {?} The module exports for an already loaded module or null.\n * @private\n */\ngoog.module.getInternal_ = function(name) {\n  if (!COMPILED) {\n    if (name in goog.loadedModules_) {\n      return goog.loadedModules_[name].exports;\n    } else if (!goog.implicitNamespaces_[name]) {\n      var ns = goog.getObjectByName(name);\n      return ns != null ? ns : null;\n    }\n  }\n  return null;\n};\n\n\n/**\n * Types of modules the debug loader can load.\n * @enum {string}\n */\ngoog.ModuleType = {\n  ES6: 'es6',\n  GOOG: 'goog'\n};\n\n\n/**\n * @private {?{\n *   moduleName: (string|undefined),\n *   declareLegacyNamespace:boolean,\n *   type: ?goog.ModuleType\n * }}\n */\ngoog.moduleLoaderState_ = null;\n\n\n/**\n * @private\n * @return {boolean} Whether a goog.module or an es6 module is currently being\n *     initialized.\n */\ngoog.isInModuleLoader_ = function() {\n  return goog.isInGoogModuleLoader_() || goog.isInEs6ModuleLoader_();\n};\n\n\n/**\n * @private\n * @return {boolean} Whether a goog.module is currently being initialized.\n */\ngoog.isInGoogModuleLoader_ = function() {\n  return !!goog.moduleLoaderState_ &&\n      goog.moduleLoaderState_.type == goog.ModuleType.GOOG;\n};\n\n\n/**\n * @private\n * @return {boolean} Whether an es6 module is currently being initialized.\n */\ngoog.isInEs6ModuleLoader_ = function() {\n  var inLoader = !!goog.moduleLoaderState_ &&\n      goog.moduleLoaderState_.type == goog.ModuleType.ES6;\n\n  if (inLoader) {\n    return true;\n  }\n\n  var jscomp = goog.global['$jscomp'];\n\n  if (jscomp) {\n    // jscomp may not have getCurrentModulePath if this is a compiled bundle\n    // that has some of the runtime, but not all of it. This can happen if\n    // optimizations are turned on so the unused runtime is removed but renaming\n    // and Closure pass are off (so $jscomp is still named $jscomp and the\n    // goog.provide/require calls still exist).\n    if (typeof jscomp.getCurrentModulePath != 'function') {\n      return false;\n    }\n\n    // Bundled ES6 module.\n    return !!jscomp.getCurrentModulePath();\n  }\n\n  return false;\n};\n\n\n/**\n * Provide the module's exports as a globally accessible object under the\n * module's declared name.  This is intended to ease migration to goog.module\n * for files that have existing usages.\n * @suppress {missingProvide}\n */\ngoog.module.declareLegacyNamespace = function() {\n  if (!COMPILED && !goog.isInGoogModuleLoader_()) {\n    throw new Error(\n        'goog.module.declareLegacyNamespace must be called from ' +\n        'within a goog.module');\n  }\n  if (!COMPILED && !goog.moduleLoaderState_.moduleName) {\n    throw new Error(\n        'goog.module must be called prior to ' +\n        'goog.module.declareLegacyNamespace.');\n  }\n  goog.moduleLoaderState_.declareLegacyNamespace = true;\n};\n\n\n/**\n * Associates an ES6 module with a Closure module ID so that is available via\n * goog.require. The associated ID  acts like a goog.module ID - it does not\n * create any global names, it is merely available via goog.require /\n * goog.module.get / goog.forwardDeclare / goog.requireType. goog.require and\n * goog.module.get will return the entire module as if it was import *'d. This\n * allows Closure files to reference ES6 modules for the sake of migration.\n *\n * @param {string} namespace\n * @suppress {missingProvide}\n */\ngoog.declareModuleId = function(namespace) {\n  if (!COMPILED) {\n    if (!goog.isInEs6ModuleLoader_()) {\n      throw new Error(\n          'goog.declareModuleId may only be called from ' +\n          'within an ES6 module');\n    }\n    if (goog.moduleLoaderState_ && goog.moduleLoaderState_.moduleName) {\n      throw new Error(\n          'goog.declareModuleId may only be called once per module.');\n    }\n    if (namespace in goog.loadedModules_) {\n      throw new Error(\n          'Module with namespace \"' + namespace + '\" already exists.');\n    }\n  }\n  if (goog.moduleLoaderState_) {\n    // Not bundled - debug loading.\n    goog.moduleLoaderState_.moduleName = namespace;\n  } else {\n    // Bundled - not debug loading, no module loader state.\n    var jscomp = goog.global['$jscomp'];\n    if (!jscomp || typeof jscomp.getCurrentModulePath != 'function') {\n      throw new Error(\n          'Module with namespace \"' + namespace +\n          '\" has been loaded incorrectly.');\n    }\n    var exports = jscomp.require(jscomp.getCurrentModulePath());\n    goog.loadedModules_[namespace] = {\n      exports: exports,\n      type: goog.ModuleType.ES6,\n      moduleId: namespace\n    };\n  }\n};\n\n\n/**\n * Marks that the current file should only be used for testing, and never for\n * live code in production.\n *\n * In the case of unit tests, the message may optionally be an exact namespace\n * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra\n * provide (if not explicitly defined in the code).\n *\n * @param {string=} opt_message Optional message to add to the error that's\n *     raised when used in production code.\n */\ngoog.setTestOnly = function(opt_message) {\n  if (goog.DISALLOW_TEST_ONLY_CODE) {\n    opt_message = opt_message || '';\n    throw new Error(\n        'Importing test-only code into non-debug environment' +\n        (opt_message ? ': ' + opt_message : '.'));\n  }\n};\n\n\n/**\n * Forward declares a symbol. This is an indication to the compiler that the\n * symbol may be used in the source yet is not required and may not be provided\n * in compilation.\n *\n * The most common usage of forward declaration is code that takes a type as a\n * function parameter but does not need to require it. By forward declaring\n * instead of requiring, no hard dependency is made, and (if not required\n * elsewhere) the namespace may never be required and thus, not be pulled\n * into the JavaScript binary. If it is required elsewhere, it will be type\n * checked as normal.\n *\n * Before using goog.forwardDeclare, please read the documentation at\n * https://github.com/google/closure-compiler/wiki/Bad-Type-Annotation to\n * understand the options and tradeoffs when working with forward declarations.\n *\n * @param {string} name The namespace to forward declare in the form of\n *     \"goog.package.part\".\n * @deprecated See go/noforwarddeclaration, Use `goog.requireType` instead.\n */\ngoog.forwardDeclare = function(name) {};\n\n\n/**\n * Forward declare type information. Used to assign types to goog.global\n * referenced object that would otherwise result in unknown type references\n * and thus block property disambiguation.\n */\ngoog.forwardDeclare('Document');\ngoog.forwardDeclare('HTMLScriptElement');\ngoog.forwardDeclare('XMLHttpRequest');\n\n\nif (!COMPILED) {\n  /**\n   * Check if the given name has been goog.provided. This will return false for\n   * names that are available only as implicit namespaces.\n   * @param {string} name name of the object to look for.\n   * @return {boolean} Whether the name has been provided.\n   * @private\n   */\n  goog.isProvided_ = function(name) {\n    return (name in goog.loadedModules_) ||\n        (!goog.implicitNamespaces_[name] && goog.getObjectByName(name) != null);\n  };\n\n  /**\n   * Namespaces implicitly defined by goog.provide. For example,\n   * goog.provide('goog.events.Event') implicitly declares that 'goog' and\n   * 'goog.events' must be namespaces.\n   *\n   * @type {!Object<string, (boolean|undefined)>}\n   * @private\n   */\n  goog.implicitNamespaces_ = {'goog.module': true};\n\n  // NOTE: We add goog.module as an implicit namespace as goog.module is defined\n  // here and because the existing module package has not been moved yet out of\n  // the goog.module namespace. This satisifies both the debug loader and\n  // ahead-of-time dependency management.\n}\n\n\n/**\n * Returns an object based on its fully qualified external name.  The object\n * is not found if null or undefined.  If you are using a compilation pass that\n * renames property names beware that using this function will not find renamed\n * properties.\n *\n * @param {string} name The fully qualified name.\n * @param {Object=} opt_obj The object within which to look; default is\n *     |goog.global|.\n * @return {?} The value (object or primitive) or, if not found, null.\n */\ngoog.getObjectByName = function(name, opt_obj) {\n  var parts = name.split('.');\n  var cur = opt_obj || goog.global;\n  for (var i = 0; i < parts.length; i++) {\n    cur = cur[parts[i]];\n    if (cur == null) {\n      return null;\n    }\n  }\n  return cur;\n};\n\n\n/**\n * Adds a dependency from a file to the files it requires.\n * @param {string} relPath The path to the js file.\n * @param {!Array<string>} provides An array of strings with\n *     the names of the objects this file provides.\n * @param {!Array<string>} requires An array of strings with\n *     the names of the objects this file requires.\n * @param {boolean|!Object<string>=} opt_loadFlags Parameters indicating\n *     how the file must be loaded.  The boolean 'true' is equivalent\n *     to {'module': 'goog'} for backwards-compatibility.  Valid properties\n *     and values include {'module': 'goog'} and {'lang': 'es6'}.\n */\ngoog.addDependency = function(relPath, provides, requires, opt_loadFlags) {\n  if (!COMPILED && goog.DEPENDENCIES_ENABLED) {\n    goog.debugLoader_.addDependency(relPath, provides, requires, opt_loadFlags);\n  }\n};\n\n\n// NOTE(nnaze): The debug DOM loader was included in base.js as an original way\n// to do \"debug-mode\" development.  The dependency system can sometimes be\n// confusing, as can the debug DOM loader's asynchronous nature.\n//\n// With the DOM loader, a call to goog.require() is not blocking -- the script\n// will not load until some point after the current script.  If a namespace is\n// needed at runtime, it needs to be defined in a previous script, or loaded via\n// require() with its registered dependencies.\n//\n// User-defined namespaces may need their own deps file. For a reference on\n// creating a deps file, see:\n// Externally: https://developers.google.com/closure/library/docs/depswriter\n//\n// Because of legacy clients, the DOM loader can't be easily removed from\n// base.js.  Work was done to make it disableable or replaceable for\n// different environments (DOM-less JavaScript interpreters like Rhino or V8,\n// for example). See bootstrap/ for more information.\n\n\n/**\n * @define {boolean} Whether to enable the debug loader.\n *\n * If enabled, a call to goog.require() will attempt to load the namespace by\n * appending a script tag to the DOM (if the namespace has been registered).\n *\n * If disabled, goog.require() will simply assert that the namespace has been\n * provided (and depend on the fact that some outside tool correctly ordered\n * the script).\n */\ngoog.ENABLE_DEBUG_LOADER = goog.define('goog.ENABLE_DEBUG_LOADER', true);\n\n\n/**\n * @param {string} msg\n * @private\n */\ngoog.logToConsole_ = function(msg) {\n  if (goog.global.console) {\n    goog.global.console['error'](msg);\n  }\n};\n\n\n/**\n * Implements a system for the dynamic resolution of dependencies that works in\n * parallel with the BUILD system.\n *\n * Note that all calls to goog.require will be stripped by the compiler.\n *\n * @see goog.provide\n * @param {string} namespace Namespace (as was given in goog.provide,\n *     goog.module, or goog.declareModuleId) in the form\n *     \"goog.package.part\".\n * @return {?} If called within a goog.module or ES6 module file, the associated\n *     namespace or module otherwise null.\n */\ngoog.require = function(namespace) {\n  if (!COMPILED) {\n    // Might need to lazy load on old IE.\n    if (goog.ENABLE_DEBUG_LOADER) {\n      goog.debugLoader_.requested(namespace);\n    }\n\n    // If the object already exists we do not need to do anything.\n    if (goog.isProvided_(namespace)) {\n      if (goog.isInModuleLoader_()) {\n        return goog.module.getInternal_(namespace);\n      }\n    } else if (goog.ENABLE_DEBUG_LOADER) {\n      var moduleLoaderState = goog.moduleLoaderState_;\n      goog.moduleLoaderState_ = null;\n      try {\n        goog.debugLoader_.load_(namespace);\n      } finally {\n        goog.moduleLoaderState_ = moduleLoaderState;\n      }\n    }\n\n    return null;\n  }\n};\n\n\n/**\n * Requires a symbol for its type information. This is an indication to the\n * compiler that the symbol may appear in type annotations, yet it is not\n * referenced at runtime.\n *\n * When called within a goog.module or ES6 module file, the return value may be\n * assigned to or destructured into a variable, but it may not be otherwise used\n * in code outside of a type annotation.\n *\n * Note that all calls to goog.requireType will be stripped by the compiler.\n *\n * @param {string} namespace Namespace (as was given in goog.provide,\n *     goog.module, or goog.declareModuleId) in the form\n *     \"goog.package.part\".\n * @return {?}\n */\ngoog.requireType = function(namespace) {\n  // Return an empty object so that single-level destructuring of the return\n  // value doesn't crash at runtime when using the debug loader. Multi-level\n  // destructuring isn't supported.\n  return {};\n};\n\n\n/**\n * Path for included scripts.\n * @type {string}\n */\ngoog.basePath = '';\n\n\n/**\n * A hook for overriding the base path.\n * @type {string|undefined}\n */\ngoog.global.CLOSURE_BASE_PATH;\n\n\n/**\n * Whether to attempt to load Closure's deps file. By default, when uncompiled,\n * deps files will attempt to be loaded.\n * @type {boolean|undefined}\n */\ngoog.global.CLOSURE_NO_DEPS;\n\n\n/**\n * A function to import a single script. This is meant to be overridden when\n * Closure is being run in non-HTML contexts, such as web workers. It's defined\n * in the global scope so that it can be set before base.js is loaded, which\n * allows deps.js to be imported properly.\n *\n * The first parameter the script source, which is a relative URI. The second,\n * optional parameter is the script contents, in the event the script needed\n * transformation. It should return true if the script was imported, false\n * otherwise.\n * @type {(function(string, string=): boolean)|undefined}\n */\ngoog.global.CLOSURE_IMPORT_SCRIPT;\n\n\n/**\n * Null function used for default values of callbacks, etc.\n * @return {void} Nothing.\n * @deprecated use '()=>{}' or 'function(){}' instead.\n */\ngoog.nullFunction = function() {};\n\n\n/**\n * When defining a class Foo with an abstract method bar(), you can do:\n * Foo.prototype.bar = goog.abstractMethod\n *\n * Now if a subclass of Foo fails to override bar(), an error will be thrown\n * when bar() is invoked.\n *\n * @type {!Function}\n * @throws {Error} when invoked to indicate the method should be overridden.\n * @deprecated Use \"@abstract\" annotation instead of goog.abstractMethod in new\n *     code. See\n *     https://github.com/google/closure-compiler/wiki/@abstract-classes-and-methods\n */\ngoog.abstractMethod = function() {\n  throw new Error('unimplemented abstract method');\n};\n\n\n/**\n * Adds a `getInstance` static method that always returns the same\n * instance object.\n * @param {!Function} ctor The constructor for the class to add the static\n *     method to.\n * @suppress {missingProperties} 'instance_' isn't a property on 'Function'\n *     but we don't have a better type to use here.\n */\ngoog.addSingletonGetter = function(ctor) {\n  // instance_ is immediately set to prevent issues with sealed constructors\n  // such as are encountered when a constructor is returned as the export object\n  // of a goog.module in unoptimized code.\n  // Delcare type to avoid conformance violations that ctor.instance_ is unknown\n  /** @type {undefined|!Object} @suppress {underscore} */\n  ctor.instance_ = undefined;\n  ctor.getInstance = function() {\n    if (ctor.instance_) {\n      return ctor.instance_;\n    }\n    if (goog.DEBUG) {\n      // NOTE: JSCompiler can't optimize away Array#push.\n      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;\n    }\n    // Cast to avoid conformance violations that ctor.instance_ is unknown\n    return /** @type {!Object|undefined} */ (ctor.instance_) = new ctor;\n  };\n};\n\n\n/**\n * All singleton classes that have been instantiated, for testing. Don't read\n * it directly, use the `goog.testing.singleton` module. The compiler\n * removes this variable if unused.\n * @type {!Array<!Function>}\n * @private\n */\ngoog.instantiatedSingletons_ = [];\n\n\n/**\n * @define {boolean} Whether to load goog.modules using `eval` when using\n * the debug loader.  This provides a better debugging experience as the\n * source is unmodified and can be edited using Chrome Workspaces or similar.\n * However in some environments the use of `eval` is banned\n * so we provide an alternative.\n */\ngoog.LOAD_MODULE_USING_EVAL = goog.define('goog.LOAD_MODULE_USING_EVAL', true);\n\n\n/**\n * @define {boolean} Whether the exports of goog.modules should be sealed when\n * possible.\n */\ngoog.SEAL_MODULE_EXPORTS = goog.define('goog.SEAL_MODULE_EXPORTS', goog.DEBUG);\n\n\n/**\n * The registry of initialized modules:\n * The module identifier or path to module exports map.\n * @private @const {!Object<string, {exports:?,type:string,moduleId:string}>}\n */\ngoog.loadedModules_ = {};\n\n\n/**\n * True if the debug loader enabled and used.\n * @const {boolean}\n */\ngoog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;\n\n\n/**\n * @define {string} How to decide whether to transpile.  Valid values\n * are 'always', 'never', and 'detect'.  The default ('detect') is to\n * use feature detection to determine which language levels need\n * transpilation.\n */\n// NOTE(sdh): we could expand this to accept a language level to bypass\n// detection: e.g. goog.TRANSPILE == 'es5' would transpile ES6 files but\n// would leave ES3 and ES5 files alone.\ngoog.TRANSPILE = goog.define('goog.TRANSPILE', 'detect');\n\n/**\n * @define {boolean} If true assume that ES modules have already been\n * transpiled by the jscompiler (in the same way that transpile.js would\n * transpile them - to jscomp modules). Useful only for servers that wish to use\n * the debug loader and transpile server side. Thus this is only respected if\n * goog.TRANSPILE is \"never\".\n */\ngoog.ASSUME_ES_MODULES_TRANSPILED =\n    goog.define('goog.ASSUME_ES_MODULES_TRANSPILED', false);\n\n\n/**\n * @define {string} If a file needs to be transpiled what the output language\n * should be. By default this is the highest language level this file detects\n * the current environment supports. Generally this flag should not be set, but\n * it could be useful to override. Example: If the current environment supports\n * ES6 then by default ES7+ files will be transpiled to ES6, unless this is\n * overridden.\n *\n * Valid values include: es3, es5, es6, es7, and es8. Anything not recognized\n * is treated as es3.\n *\n * Note that setting this value does not force transpilation. Just if\n * transpilation occurs this will be the output. So this is most useful when\n * goog.TRANSPILE is set to 'always' and then forcing the language level to be\n * something lower than what the environment detects.\n */\ngoog.TRANSPILE_TO_LANGUAGE = goog.define('goog.TRANSPILE_TO_LANGUAGE', '');\n\n\n/**\n * @define {string} Path to the transpiler.  Executing the script at this\n * path (relative to base.js) should define a function $jscomp.transpile.\n */\ngoog.TRANSPILER = goog.define('goog.TRANSPILER', 'transpile.js');\n\n\n/**\n * @define {string} Trusted Types policy name. If non-empty then Closure will\n * use Trusted Types.\n */\ngoog.TRUSTED_TYPES_POLICY_NAME =\n    goog.define('goog.TRUSTED_TYPES_POLICY_NAME', 'goog');\n\n\n/**\n * @package {?boolean}\n * Visible for testing.\n */\ngoog.hasBadLetScoping = null;\n\n\n/**\n * @param {function(?):?|string} moduleDef The module definition.\n */\ngoog.loadModule = function(moduleDef) {\n  // NOTE: we allow function definitions to be either in the from\n  // of a string to eval (which keeps the original source intact) or\n  // in a eval forbidden environment (CSP) we allow a function definition\n  // which in its body must call `goog.module`, and return the exports\n  // of the module.\n  var previousState = goog.moduleLoaderState_;\n  try {\n    goog.moduleLoaderState_ = {\n      moduleName: '',\n      declareLegacyNamespace: false,\n      type: goog.ModuleType.GOOG\n    };\n    var origExports = {};\n    var exports = origExports;\n    if (typeof moduleDef === 'function') {\n      exports = moduleDef.call(undefined, exports);\n    } else if (typeof moduleDef === 'string') {\n      exports = goog.loadModuleFromSource_.call(undefined, exports, moduleDef);\n    } else {\n      throw new Error('Invalid module definition');\n    }\n\n    var moduleName = goog.moduleLoaderState_.moduleName;\n    if (typeof moduleName === 'string' && moduleName) {\n      // Don't seal legacy namespaces as they may be used as a parent of\n      // another namespace\n      if (goog.moduleLoaderState_.declareLegacyNamespace) {\n        // Whether exports was overwritten via default export assignment.\n        // This is important for legacy namespaces as it dictates whether\n        // previously a previously loaded implicit namespace should be clobbered\n        // or not.\n        var isDefaultExport = origExports !== exports;\n        goog.constructNamespace_(moduleName, exports, isDefaultExport);\n      } else if (\n          goog.SEAL_MODULE_EXPORTS && Object.seal &&\n          typeof exports == 'object' && exports != null) {\n        Object.seal(exports);\n      }\n\n      var data = {\n        exports: exports,\n        type: goog.ModuleType.GOOG,\n        moduleId: goog.moduleLoaderState_.moduleName\n      };\n      goog.loadedModules_[moduleName] = data;\n    } else {\n      throw new Error('Invalid module name \\\"' + moduleName + '\\\"');\n    }\n  } finally {\n    goog.moduleLoaderState_ = previousState;\n  }\n};\n\n\n/**\n * @private @const\n */\ngoog.loadModuleFromSource_ =\n    /** @type {function(!Object, string):?} */ (function(exports) {\n      // NOTE: we avoid declaring parameters or local variables here to avoid\n      // masking globals or leaking values into the module definition.\n      'use strict';\n      eval(goog.CLOSURE_EVAL_PREFILTER_.createScript(arguments[1]));\n      return exports;\n    });\n\n\n/**\n * Normalize a file path by removing redundant \"..\" and extraneous \".\" file\n * path components.\n * @param {string} path\n * @return {string}\n * @private\n */\ngoog.normalizePath_ = function(path) {\n  var components = path.split('/');\n  var i = 0;\n  while (i < components.length) {\n    if (components[i] == '.') {\n      components.splice(i, 1);\n    } else if (\n        i && components[i] == '..' && components[i - 1] &&\n        components[i - 1] != '..') {\n      components.splice(--i, 2);\n    } else {\n      i++;\n    }\n  }\n  return components.join('/');\n};\n\n\n/**\n * Provides a hook for loading a file when using Closure's goog.require() API\n * with goog.modules.  In particular this hook is provided to support Node.js.\n *\n * @type {(function(string):string)|undefined}\n */\ngoog.global.CLOSURE_LOAD_FILE_SYNC;\n\n\n/**\n * Loads file by synchronous XHR. Should not be used in production environments.\n * @param {string} src Source URL.\n * @return {?string} File contents, or null if load failed.\n * @private\n */\ngoog.loadFileSync_ = function(src) {\n  if (goog.global.CLOSURE_LOAD_FILE_SYNC) {\n    return goog.global.CLOSURE_LOAD_FILE_SYNC(src);\n  } else {\n    try {\n      /** @type {XMLHttpRequest} */\n      var xhr = new goog.global['XMLHttpRequest']();\n      xhr.open('get', src, false);\n      xhr.send();\n      // NOTE: Successful http: requests have a status of 200, but successful\n      // file: requests may have a status of zero.  Any other status, or a\n      // thrown exception (particularly in case of file: requests) indicates\n      // some sort of error, which we treat as a missing or unavailable file.\n      return xhr.status == 0 || xhr.status == 200 ? xhr.responseText : null;\n    } catch (err) {\n      // No need to rethrow or log, since errors should show up on their own.\n      return null;\n    }\n  }\n};\n\n\n/**\n * Lazily retrieves the transpiler and applies it to the source.\n * @param {string} code JS code.\n * @param {string} path Path to the code.\n * @param {string} target Language level output.\n * @return {string} The transpiled code.\n * @private\n */\ngoog.transpile_ = function(code, path, target) {\n  var jscomp = goog.global['$jscomp'];\n  if (!jscomp) {\n    goog.global['$jscomp'] = jscomp = {};\n  }\n  var transpile = jscomp.transpile;\n  if (!transpile) {\n    var transpilerPath = goog.basePath + goog.TRANSPILER;\n    var transpilerCode = goog.loadFileSync_(transpilerPath);\n    if (transpilerCode) {\n      // This must be executed synchronously, since by the time we know we\n      // need it, we're about to load and write the ES6 code synchronously,\n      // so a normal script-tag load will be too slow. Wrapped in a function\n      // so that code is eval'd in the global scope.\n      (function() {\n        (0, eval)(transpilerCode + '\\n//# sourceURL=' + transpilerPath);\n      }).call(goog.global);\n      // Even though the transpiler is optional, if $gwtExport is found, it's\n      // a sign the transpiler was loaded and the $jscomp.transpile *should*\n      // be there.\n      if (goog.global['$gwtExport'] && goog.global['$gwtExport']['$jscomp'] &&\n          !goog.global['$gwtExport']['$jscomp']['transpile']) {\n        throw new Error(\n            'The transpiler did not properly export the \"transpile\" ' +\n            'method. $gwtExport: ' + JSON.stringify(goog.global['$gwtExport']));\n      }\n      // transpile.js only exports a single $jscomp function, transpile. We\n      // grab just that and add it to the existing definition of $jscomp which\n      // contains the polyfills.\n      goog.global['$jscomp'].transpile =\n          goog.global['$gwtExport']['$jscomp']['transpile'];\n      jscomp = goog.global['$jscomp'];\n      transpile = jscomp.transpile;\n    }\n  }\n  if (!transpile) {\n    // The transpiler is an optional component.  If it's not available then\n    // replace it with a pass-through function that simply logs.\n    var suffix = ' requires transpilation but no transpiler was found.';\n    transpile = jscomp.transpile = function(code, path) {\n      // TODO(sdh): figure out some way to get this error to show up\n      // in test results, noting that the failure may occur in many\n      // different ways, including in loadModule() before the test\n      // runner even comes up.\n      goog.logToConsole_(path + suffix);\n      return code;\n    };\n  }\n  // Note: any transpilation errors/warnings will be logged to the console.\n  return transpile(code, path, target);\n};\n\n//==============================================================================\n// Language Enhancements\n//==============================================================================\n\n\n/**\n * This is a \"fixed\" version of the typeof operator.  It differs from the typeof\n * operator in such a way that null returns 'null' and arrays return 'array'.\n * @param {?} value The value to get the type of.\n * @return {string} The name of the type.\n */\ngoog.typeOf = function(value) {\n  var s = typeof value;\n\n  if (s != 'object') {\n    return s;\n  }\n\n  if (!value) {\n    return 'null';\n  }\n\n  if (Array.isArray(value)) {\n    return 'array';\n  }\n  return s;\n};\n\n\n/**\n * Returns true if the object looks like an array. To qualify as array like\n * the value needs to be either a NodeList or an object with a Number length\n * property. Note that for this function neither strings nor functions are\n * considered \"array-like\".\n *\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is an array.\n */\ngoog.isArrayLike = function(val) {\n  var type = goog.typeOf(val);\n  // We do not use goog.isObject here in order to exclude function values.\n  return type == 'array' || type == 'object' && typeof val.length == 'number';\n};\n\n\n/**\n * Returns true if the object looks like a Date. To qualify as Date-like the\n * value needs to be an object and have a getFullYear() function.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is a like a Date.\n */\ngoog.isDateLike = function(val) {\n  return goog.isObject(val) && typeof val.getFullYear == 'function';\n};\n\n\n/**\n * Returns true if the specified value is an object.  This includes arrays and\n * functions.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is an object.\n */\ngoog.isObject = function(val) {\n  var type = typeof val;\n  return type == 'object' && val != null || type == 'function';\n  // return Object(val) === val also works, but is slower, especially if val is\n  // not an object.\n};\n\n\n/**\n * Gets a unique ID for an object. This mutates the object so that further calls\n * with the same object as a parameter returns the same value. The unique ID is\n * guaranteed to be unique across the current session amongst objects that are\n * passed into `getUid`. There is no guarantee that the ID is unique or\n * consistent across sessions. It is unsafe to generate unique ID for function\n * prototypes.\n *\n * @param {Object} obj The object to get the unique ID for.\n * @return {number} The unique ID for the object.\n */\ngoog.getUid = function(obj) {\n  // TODO(arv): Make the type stricter, do not accept null.\n  return Object.prototype.hasOwnProperty.call(obj, goog.UID_PROPERTY_) &&\n      obj[goog.UID_PROPERTY_] ||\n      (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);\n};\n\n\n/**\n * Whether the given object is already assigned a unique ID.\n *\n * This does not modify the object.\n *\n * @param {!Object} obj The object to check.\n * @return {boolean} Whether there is an assigned unique id for the object.\n */\ngoog.hasUid = function(obj) {\n  return !!obj[goog.UID_PROPERTY_];\n};\n\n\n/**\n * Removes the unique ID from an object. This is useful if the object was\n * previously mutated using `goog.getUid` in which case the mutation is\n * undone.\n * @param {Object} obj The object to remove the unique ID field from.\n */\ngoog.removeUid = function(obj) {\n  // TODO(arv): Make the type stricter, do not accept null.\n\n  // In IE, DOM nodes are not instances of Object and throw an exception if we\n  // try to delete.  Instead we try to use removeAttribute.\n  if (obj !== null && 'removeAttribute' in obj) {\n    obj.removeAttribute(goog.UID_PROPERTY_);\n  }\n\n  try {\n    delete obj[goog.UID_PROPERTY_];\n  } catch (ex) {\n  }\n};\n\n\n/**\n * Name for unique ID property. Initialized in a way to help avoid collisions\n * with other closure JavaScript on the same page.\n * @type {string}\n * @private\n */\ngoog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) >>> 0);\n\n\n/**\n * Counter for UID.\n * @type {number}\n * @private\n */\ngoog.uidCounter_ = 0;\n\n\n/**\n * Clones a value. The input may be an Object, Array, or basic type. Objects and\n * arrays will be cloned recursively.\n *\n * WARNINGS:\n * <code>goog.cloneObject</code> does not detect reference loops. Objects that\n * refer to themselves will cause infinite recursion.\n *\n * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies\n * UIDs created by <code>getUid</code> into cloned results.\n *\n * @param {*} obj The value to clone.\n * @return {*} A clone of the input value.\n * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.\n */\ngoog.cloneObject = function(obj) {\n  var type = goog.typeOf(obj);\n  if (type == 'object' || type == 'array') {\n    if (typeof obj.clone === 'function') {\n      return obj.clone();\n    }\n    if (typeof Map !== 'undefined' && obj instanceof Map) {\n      return new Map(obj);\n    } else if (typeof Set !== 'undefined' && obj instanceof Set) {\n      return new Set(obj);\n    }\n    var clone = type == 'array' ? [] : {};\n    for (var key in obj) {\n      clone[key] = goog.cloneObject(obj[key]);\n    }\n    return clone;\n  }\n\n  return obj;\n};\n\n\n/**\n * A native implementation of goog.bind.\n * @param {?function(this:T, ...)} fn A function to partially apply.\n * @param {T} selfObj Specifies the object which this should point to when the\n *     function is run.\n * @param {...*} var_args Additional arguments that are partially applied to the\n *     function.\n * @return {!Function} A partially-applied form of the function goog.bind() was\n *     invoked as a method of.\n * @template T\n * @private\n */\ngoog.bindNative_ = function(fn, selfObj, var_args) {\n  return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));\n};\n\n\n/**\n * A pure-JS implementation of goog.bind.\n * @param {?function(this:T, ...)} fn A function to partially apply.\n * @param {T} selfObj Specifies the object which this should point to when the\n *     function is run.\n * @param {...*} var_args Additional arguments that are partially applied to the\n *     function.\n * @return {!Function} A partially-applied form of the function goog.bind() was\n *     invoked as a method of.\n * @template T\n * @private\n */\ngoog.bindJs_ = function(fn, selfObj, var_args) {\n  if (!fn) {\n    throw new Error();\n  }\n\n  if (arguments.length > 2) {\n    var boundArgs = Array.prototype.slice.call(arguments, 2);\n    return function() {\n      // Prepend the bound arguments to the current arguments.\n      var newArgs = Array.prototype.slice.call(arguments);\n      Array.prototype.unshift.apply(newArgs, boundArgs);\n      return fn.apply(selfObj, newArgs);\n    };\n\n  } else {\n    return function() {\n      return fn.apply(selfObj, arguments);\n    };\n  }\n};\n\n\n/**\n * Partially applies this function to a particular 'this object' and zero or\n * more arguments. The result is a new function with some arguments of the first\n * function pre-filled and the value of this 'pre-specified'.\n *\n * Remaining arguments specified at call-time are appended to the pre-specified\n * ones.\n *\n * Also see: {@link #partial}.\n *\n * Usage:\n * <pre>var barMethBound = goog.bind(myFunction, myObj, 'arg1', 'arg2');\n * barMethBound('arg3', 'arg4');</pre>\n *\n * @param {?function(this:T, ...)} fn A function to partially apply.\n * @param {T} selfObj Specifies the object which this should point to when the\n *     function is run.\n * @param {...*} var_args Additional arguments that are partially applied to the\n *     function.\n * @return {!Function} A partially-applied form of the function goog.bind() was\n *     invoked as a method of.\n * @template T\n * @suppress {deprecated} See above.\n * @deprecated use `=> {}` or Function.prototype.bind instead.\n */\ngoog.bind = function(fn, selfObj, var_args) {\n  // TODO(nicksantos): narrow the type signature.\n  if (Function.prototype.bind &&\n      // NOTE(nicksantos): Somebody pulled base.js into the default Chrome\n      // extension environment. This means that for Chrome extensions, they get\n      // the implementation of Function.prototype.bind that calls goog.bind\n      // instead of the native one. Even worse, we don't want to introduce a\n      // circular dependency between goog.bind and Function.prototype.bind, so\n      // we have to hack this to make sure it works correctly.\n      Function.prototype.bind.toString().indexOf('native code') != -1) {\n    goog.bind = goog.bindNative_;\n  } else {\n    goog.bind = goog.bindJs_;\n  }\n  return goog.bind.apply(null, arguments);\n};\n\n\n/**\n * Like goog.bind(), except that a 'this object' is not required. Useful when\n * the target function is already bound.\n *\n * Usage:\n * var g = goog.partial(f, arg1, arg2);\n * g(arg3, arg4);\n *\n * @param {Function} fn A function to partially apply.\n * @param {...*} var_args Additional arguments that are partially applied to fn.\n * @return {!Function} A partially-applied form of the function goog.partial()\n *     was invoked as a method of.\n */\ngoog.partial = function(fn, var_args) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function() {\n    // Clone the array (with slice()) and append additional arguments\n    // to the existing arguments.\n    var newArgs = args.slice();\n    newArgs.push.apply(newArgs, arguments);\n    return fn.apply(/** @type {?} */ (this), newArgs);\n  };\n};\n\n\n/**\n * Copies all the members of a source object to a target object. This method\n * does not work on all browsers for all objects that contain keys such as\n * toString or hasOwnProperty. Use goog.object.extend for this purpose.\n *\n * NOTE: Some have advocated for the use of goog.mixin to setup classes\n * with multiple inheritence (traits, mixins, etc).  However, as it simply\n * uses \"for in\", this is not compatible with ES6 classes whose methods are\n * non-enumerable.  Changing this, would break cases where non-enumerable\n * properties are not expected.\n *\n * @param {Object} target Target.\n * @param {Object} source Source.\n * @deprecated Prefer Object.assign\n */\ngoog.mixin = function(target, source) {\n  for (var x in source) {\n    target[x] = source[x];\n  }\n\n  // For IE7 or lower, the for-in-loop does not contain any properties that are\n  // not enumerable on the prototype object (for example, isPrototypeOf from\n  // Object.prototype) but also it will not include 'replace' on objects that\n  // extend String and change 'replace' (not that it is common for anyone to\n  // extend anything except Object).\n};\n\n\n/**\n * @return {number} An integer value representing the number of milliseconds\n *     between midnight, January 1, 1970 and the current time.\n * @deprecated Use Date.now\n */\ngoog.now = function() {\n  return Date.now();\n};\n\n\n/**\n * Evals JavaScript in the global scope.\n *\n * Throws an exception if neither execScript or eval is defined.\n * @param {string|!TrustedScript} script JavaScript string.\n */\ngoog.globalEval = function(script) {\n  (0, eval)(script);\n};\n\n\n/**\n * Optional map of CSS class names to obfuscated names used with\n * goog.getCssName().\n * @private {!Object<string, string>|undefined}\n * @see goog.setCssNameMapping\n */\ngoog.cssNameMapping_;\n\n\n/**\n * Optional obfuscation style for CSS class names. Should be set to either\n * 'BY_WHOLE' or 'BY_PART' if defined.\n * @type {string|undefined}\n * @private\n * @see goog.setCssNameMapping\n */\ngoog.cssNameMappingStyle_;\n\n\n\n/**\n * A hook for modifying the default behavior goog.getCssName. The function\n * if present, will receive the standard output of the goog.getCssName as\n * its input.\n *\n * @type {(function(string):string)|undefined}\n */\ngoog.global.CLOSURE_CSS_NAME_MAP_FN;\n\n\n/**\n * Handles strings that are intended to be used as CSS class names.\n *\n * This function works in tandem with @see goog.setCssNameMapping.\n *\n * Without any mapping set, the arguments are simple joined with a hyphen and\n * passed through unaltered.\n *\n * When there is a mapping, there are two possible styles in which these\n * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)\n * of the passed in css name is rewritten according to the map. In the BY_WHOLE\n * style, the full css name is looked up in the map directly. If a rewrite is\n * not specified by the map, the compiler will output a warning.\n *\n * When the mapping is passed to the compiler, it will replace calls to\n * goog.getCssName with the strings from the mapping, e.g.\n *     var x = goog.getCssName('foo');\n *     var y = goog.getCssName(this.baseClass, 'active');\n *  becomes:\n *     var x = 'foo';\n *     var y = this.baseClass + '-active';\n *\n * If one argument is passed it will be processed, if two are passed only the\n * modifier will be processed, as it is assumed the first argument was generated\n * as a result of calling goog.getCssName.\n *\n * @param {string} className The class name.\n * @param {string=} opt_modifier A modifier to be appended to the class name.\n * @return {string} The class name or the concatenation of the class name and\n *     the modifier.\n */\ngoog.getCssName = function(className, opt_modifier) {\n  // String() is used for compatibility with compiled soy where the passed\n  // className can be non-string objects.\n  if (String(className).charAt(0) == '.') {\n    throw new Error(\n        'className passed in goog.getCssName must not start with \".\".' +\n        ' You passed: ' + className);\n  }\n\n  var getMapping = function(cssName) {\n    return goog.cssNameMapping_[cssName] || cssName;\n  };\n\n  var renameByParts = function(cssName) {\n    // Remap all the parts individually.\n    var parts = cssName.split('-');\n    var mapped = [];\n    for (var i = 0; i < parts.length; i++) {\n      mapped.push(getMapping(parts[i]));\n    }\n    return mapped.join('-');\n  };\n\n  var rename;\n  if (goog.cssNameMapping_) {\n    rename =\n        goog.cssNameMappingStyle_ == 'BY_WHOLE' ? getMapping : renameByParts;\n  } else {\n    rename = function(a) {\n      return a;\n    };\n  }\n\n  var result =\n      opt_modifier ? className + '-' + rename(opt_modifier) : rename(className);\n\n  // The special CLOSURE_CSS_NAME_MAP_FN allows users to specify further\n  // processing of the class name.\n  if (goog.global.CLOSURE_CSS_NAME_MAP_FN) {\n    return goog.global.CLOSURE_CSS_NAME_MAP_FN(result);\n  }\n\n  return result;\n};\n\n\n/**\n * Sets the map to check when returning a value from goog.getCssName(). Example:\n * <pre>\n * goog.setCssNameMapping({\n *   \"goog\": \"a\",\n *   \"disabled\": \"b\",\n * });\n *\n * var x = goog.getCssName('goog');\n * // The following evaluates to: \"a a-b\".\n * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')\n * </pre>\n * When declared as a map of string literals to string literals, the JSCompiler\n * will replace all calls to goog.getCssName() using the supplied map if the\n * --process_closure_primitives flag is set.\n *\n * @param {!Object} mapping A map of strings to strings where keys are possible\n *     arguments to goog.getCssName() and values are the corresponding values\n *     that should be returned.\n * @param {string=} opt_style The style of css name mapping. There are two valid\n *     options: 'BY_PART', and 'BY_WHOLE'.\n * @see goog.getCssName for a description.\n */\ngoog.setCssNameMapping = function(mapping, opt_style) {\n  goog.cssNameMapping_ = mapping;\n  goog.cssNameMappingStyle_ = opt_style;\n};\n\n\n/**\n * To use CSS renaming in compiled mode, one of the input files should have a\n * call to goog.setCssNameMapping() with an object literal that the JSCompiler\n * can extract and use to replace all calls to goog.getCssName(). In uncompiled\n * mode, JavaScript code should be loaded before this base.js file that declares\n * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is\n * to ensure that the mapping is loaded before any calls to goog.getCssName()\n * are made in uncompiled mode.\n *\n * A hook for overriding the CSS name mapping.\n * @type {!Object<string, string>|undefined}\n */\ngoog.global.CLOSURE_CSS_NAME_MAPPING;\n\n\nif (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {\n  // This does not call goog.setCssNameMapping() because the JSCompiler\n  // requires that goog.setCssNameMapping() be called with an object literal.\n  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;\n}\n\n\n/**\n * Gets a localized message.\n *\n * This function is a compiler primitive. If you give the compiler a localized\n * message bundle, it will replace the string at compile-time with a localized\n * version, and expand goog.getMsg call to a concatenated string.\n *\n * Messages must be initialized in the form:\n * <code>\n * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});\n * </code>\n *\n * This function produces a string which should be treated as plain text. Use\n * {@link goog.html.SafeHtmlFormatter} in conjunction with goog.getMsg to\n * produce SafeHtml.\n *\n * @param {string} str Translatable string, places holders in the form {$foo}.\n * @param {Object<string, string>=} opt_values Maps place holder name to value.\n * @param {{html: (boolean|undefined),\n *         unescapeHtmlEntities: (boolean|undefined)}=} opt_options Options:\n *     html: Escape '<' in str to '&lt;'. Used by Closure Templates where the\n *     generated code size and performance is critical which is why {@link\n *     goog.html.SafeHtmlFormatter} is not used. The value must be literal true\n *     or false.\n *     unescapeHtmlEntities: Unescape common html entities: &gt;, &lt;, &apos;,\n *     &quot; and &amp;. Used for messages not in HTML context, such as with\n *     `textContent` property.\n * @return {string} message with placeholders filled.\n */\ngoog.getMsg = function(str, opt_values, opt_options) {\n  if (opt_options && opt_options.html) {\n    // Note that '&' is not replaced because the translation can contain HTML\n    // entities.\n    str = str.replace(/</g, '&lt;');\n  }\n  if (opt_options && opt_options.unescapeHtmlEntities) {\n    // Note that \"&amp;\" must be the last to avoid \"creating\" new entities.\n    str = str.replace(/&lt;/g, '<')\n              .replace(/&gt;/g, '>')\n              .replace(/&apos;/g, '\\'')\n              .replace(/&quot;/g, '\"')\n              .replace(/&amp;/g, '&');\n  }\n  if (opt_values) {\n    str = str.replace(/\\{\\$([^}]+)}/g, function(match, key) {\n      return (opt_values != null && key in opt_values) ? opt_values[key] :\n                                                         match;\n    });\n  }\n  return str;\n};\n\n\n/**\n * Gets a localized message. If the message does not have a translation, gives a\n * fallback message.\n *\n * This is useful when introducing a new message that has not yet been\n * translated into all languages.\n *\n * This function is a compiler primitive. Must be used in the form:\n * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>\n * where MSG_A and MSG_B were initialized with goog.getMsg.\n *\n * @param {string} a The preferred message.\n * @param {string} b The fallback message.\n * @return {string} The best translated message.\n */\ngoog.getMsgWithFallback = function(a, b) {\n  return a;\n};\n\n\n/**\n * Exposes an unobfuscated global namespace path for the given object.\n * Note that fields of the exported object *will* be obfuscated, unless they are\n * exported in turn via this function or goog.exportProperty.\n *\n * Also handy for making public items that are defined in anonymous closures.\n *\n * ex. goog.exportSymbol('public.path.Foo', Foo);\n *\n * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);\n *     public.path.Foo.staticFunction();\n *\n * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',\n *                       Foo.prototype.myMethod);\n *     new public.path.Foo().myMethod();\n *\n * @param {string} publicPath Unobfuscated name to export.\n * @param {*} object Object the name should point to.\n * @param {?Object=} objectToExportTo The object to add the path to; default\n *     is goog.global.\n */\ngoog.exportSymbol = function(publicPath, object, objectToExportTo) {\n  goog.exportPath_(\n      publicPath, object, /* overwriteImplicit= */ true, objectToExportTo);\n};\n\n\n/**\n * Exports a property unobfuscated into the object's namespace.\n * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);\n * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);\n * @param {Object} object Object whose static property is being exported.\n * @param {string} publicName Unobfuscated name to export.\n * @param {*} symbol Object the name should point to.\n */\ngoog.exportProperty = function(object, publicName, symbol) {\n  object[publicName] = symbol;\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * Usage:\n * <pre>\n * function ParentClass(a, b) { }\n * ParentClass.prototype.foo = function(a) { };\n *\n * function ChildClass(a, b, c) {\n *   ChildClass.base(this, 'constructor', a, b);\n * }\n * goog.inherits(ChildClass, ParentClass);\n *\n * var child = new ChildClass('a', 'b', 'see');\n * child.foo(); // This works.\n * </pre>\n *\n * @param {!Function} childCtor Child class.\n * @param {!Function} parentCtor Parent class.\n * @suppress {strictMissingProperties} superClass_ and base is not defined on\n *    Function.\n * @deprecated Use ECMAScript class syntax instead.\n */\ngoog.inherits = function(childCtor, parentCtor) {\n  /** @constructor */\n  function tempCtor() {}\n  tempCtor.prototype = parentCtor.prototype;\n  childCtor.superClass_ = parentCtor.prototype;\n  childCtor.prototype = new tempCtor();\n  /** @override */\n  childCtor.prototype.constructor = childCtor;\n\n  /**\n   * Calls superclass constructor/method.\n   *\n   * This function is only available if you use goog.inherits to\n   * express inheritance relationships between classes.\n   *\n   * NOTE: This is a replacement for goog.base and for superClass_\n   * property defined in childCtor.\n   *\n   * @param {!Object} me Should always be \"this\".\n   * @param {string} methodName The method name to call. Calling\n   *     superclass constructor can be done with the special string\n   *     'constructor'.\n   * @param {...*} var_args The arguments to pass to superclass\n   *     method/constructor.\n   * @return {*} The return value of the superclass method/constructor.\n   */\n  childCtor.base = function(me, methodName, var_args) {\n    // Copying using loop to avoid deop due to passing arguments object to\n    // function. This is faster in many JS engines as of late 2014.\n    var args = new Array(arguments.length - 2);\n    for (var i = 2; i < arguments.length; i++) {\n      args[i - 2] = arguments[i];\n    }\n    return parentCtor.prototype[methodName].apply(me, args);\n  };\n};\n\n\n/**\n * Allow for aliasing within scope functions.  This function exists for\n * uncompiled code - in compiled code the calls will be inlined and the aliases\n * applied.  In uncompiled code the function is simply run since the aliases as\n * written are valid JavaScript.\n *\n *\n * @param {function()} fn Function to call.  This function can contain aliases\n *     to namespaces (e.g. \"var dom = goog.dom\") or classes\n *     (e.g. \"var Timer = goog.Timer\").\n * @deprecated Use goog.module instead.\n */\ngoog.scope = function(fn) {\n  if (goog.isInModuleLoader_()) {\n    throw new Error('goog.scope is not supported within a module.');\n  }\n  fn.call(goog.global);\n};\n\n\n/*\n * To support uncompiled, strict mode bundles that use eval to divide source\n * like so:\n *    eval('someSource;//# sourceUrl sourcefile.js');\n * We need to export the globally defined symbols \"goog\" and \"COMPILED\".\n * Exporting \"goog\" breaks the compiler optimizations, so we required that\n * be defined externally.\n * NOTE: We don't use goog.exportSymbol here because we don't want to trigger\n * extern generation when that compiler option is enabled.\n */\nif (!COMPILED) {\n  goog.global['COMPILED'] = COMPILED;\n}\n\n\n//==============================================================================\n// goog.defineClass implementation\n//==============================================================================\n\n\n/**\n * Creates a restricted form of a Closure \"class\":\n *   - from the compiler's perspective, the instance returned from the\n *     constructor is sealed (no new properties may be added).  This enables\n *     better checks.\n *   - the compiler will rewrite this definition to a form that is optimal\n *     for type checking and optimization (initially this will be a more\n *     traditional form).\n *\n * @param {Function} superClass The superclass, Object or null.\n * @param {goog.defineClass.ClassDescriptor} def\n *     An object literal describing\n *     the class.  It may have the following properties:\n *     \"constructor\": the constructor function\n *     \"statics\": an object literal containing methods to add to the constructor\n *        as \"static\" methods or a function that will receive the constructor\n *        function as its only parameter to which static properties can\n *        be added.\n *     all other properties are added to the prototype.\n * @return {!Function} The class constructor.\n * @deprecated Use ECMAScript class syntax instead.\n */\ngoog.defineClass = function(superClass, def) {\n  // TODO(johnlenz): consider making the superClass an optional parameter.\n  var constructor = def.constructor;\n  var statics = def.statics;\n  // Wrap the constructor prior to setting up the prototype and static methods.\n  if (!constructor || constructor == Object.prototype.constructor) {\n    constructor = function() {\n      throw new Error(\n          'cannot instantiate an interface (no constructor defined).');\n    };\n  }\n\n  var cls = goog.defineClass.createSealingConstructor_(constructor, superClass);\n  if (superClass) {\n    goog.inherits(cls, superClass);\n  }\n\n  // Remove all the properties that should not be copied to the prototype.\n  delete def.constructor;\n  delete def.statics;\n\n  goog.defineClass.applyProperties_(cls.prototype, def);\n  if (statics != null) {\n    if (statics instanceof Function) {\n      statics(cls);\n    } else {\n      goog.defineClass.applyProperties_(cls, statics);\n    }\n  }\n\n  return cls;\n};\n\n\n/**\n * @typedef {{\n *   constructor: (!Function|undefined),\n *   statics: (Object|undefined|function(Function):void)\n * }}\n */\ngoog.defineClass.ClassDescriptor;\n\n\n/**\n * @define {boolean} Whether the instances returned by goog.defineClass should\n *     be sealed when possible.\n *\n * When sealing is disabled the constructor function will not be wrapped by\n * goog.defineClass, making it incompatible with ES6 class methods.\n */\ngoog.defineClass.SEAL_CLASS_INSTANCES =\n    goog.define('goog.defineClass.SEAL_CLASS_INSTANCES', goog.DEBUG);\n\n\n/**\n * If goog.defineClass.SEAL_CLASS_INSTANCES is enabled and Object.seal is\n * defined, this function will wrap the constructor in a function that seals the\n * results of the provided constructor function.\n *\n * @param {!Function} ctr The constructor whose results maybe be sealed.\n * @param {Function} superClass The superclass constructor.\n * @return {!Function} The replacement constructor.\n * @private\n */\ngoog.defineClass.createSealingConstructor_ = function(ctr, superClass) {\n  if (!goog.defineClass.SEAL_CLASS_INSTANCES) {\n    // Do now wrap the constructor when sealing is disabled. Angular code\n    // depends on this for injection to work properly.\n    return ctr;\n  }\n\n  // NOTE: The sealing behavior has been removed\n\n  /**\n   * @this {Object}\n   * @return {?}\n   */\n  var wrappedCtr = function() {\n    // Don't seal an instance of a subclass when it calls the constructor of\n    // its super class as there is most likely still setup to do.\n    var instance = ctr.apply(this, arguments) || this;\n    instance[goog.UID_PROPERTY_] = instance[goog.UID_PROPERTY_];\n\n    return instance;\n  };\n\n  return wrappedCtr;\n};\n\n\n\n// TODO(johnlenz): share these values with the goog.object\n/**\n * The names of the fields that are defined on Object.prototype.\n * @type {!Array<string>}\n * @private\n * @const\n */\ngoog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = [\n  'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',\n  'toLocaleString', 'toString', 'valueOf'\n];\n\n\n// TODO(johnlenz): share this function with the goog.object\n/**\n * @param {!Object} target The object to add properties to.\n * @param {!Object} source The object to copy properties from.\n * @private\n */\ngoog.defineClass.applyProperties_ = function(target, source) {\n  // TODO(johnlenz): update this to support ES5 getters/setters\n\n  var key;\n  for (key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      target[key] = source[key];\n    }\n  }\n\n  // For IE the for-in-loop does not contain any properties that are not\n  // enumerable on the prototype object (for example isPrototypeOf from\n  // Object.prototype) and it will also not include 'replace' on objects that\n  // extend String and change 'replace' (not that it is common for anyone to\n  // extend anything except Object).\n  for (var i = 0; i < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; i++) {\n    key = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[i];\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      target[key] = source[key];\n    }\n  }\n};\n\n/**\n * Returns the parameter.\n * @param {string} s\n * @return {string}\n * @private\n */\ngoog.identity_ = function(s) {\n  return s;\n};\n\n\n/**\n * Creates Trusted Types policy if Trusted Types are supported by the browser.\n * The policy just blesses any string as a Trusted Type. It is not visibility\n * restricted because anyone can also call trustedTypes.createPolicy directly.\n * However, the allowed names should be restricted by a HTTP header and the\n * reference to the created policy should be visibility restricted.\n * @param {string} name\n * @return {?TrustedTypePolicy}\n */\ngoog.createTrustedTypesPolicy = function(name) {\n  var policy = null;\n  var policyFactory = goog.global.trustedTypes;\n  if (!policyFactory || !policyFactory.createPolicy) {\n    return policy;\n  }\n  // trustedTypes.createPolicy throws if called with a name that is already\n  // registered, even in report-only mode. Until the API changes, catch the\n  // error not to break the applications functionally. In such case, the code\n  // will fall back to using regular Safe Types.\n  // TODO(koto): Remove catching once createPolicy API stops throwing.\n  try {\n    policy = policyFactory.createPolicy(name, {\n      createHTML: goog.identity_,\n      createScript: goog.identity_,\n      createScriptURL: goog.identity_\n    });\n  } catch (e) {\n    goog.logToConsole_(e.message);\n  }\n  return policy;\n};\n\n// There's a bug in the compiler where without collapse properties the\n// Closure namespace defines do not guard code correctly. To help reduce code\n// size also check for !COMPILED even though it redundant until this is fixed.\nif (!COMPILED && goog.DEPENDENCIES_ENABLED) {\n\n\n  /**\n   * Tries to detect whether the current browser is Edge, based on the user\n   * agent. This matches only pre-Chromium Edge.\n   * @see https://docs.microsoft.com/en-us/microsoft-edge/web-platform/user-agent-string\n   * @return {boolean} True if the current browser is Edge.\n   * @private\n   */\n  goog.isEdge_ = function() {\n    var userAgent = goog.global.navigator && goog.global.navigator.userAgent ?\n        goog.global.navigator.userAgent :\n        '';\n    var edgeRe = /Edge\\/(\\d+)(\\.\\d)*/i;\n    return !!userAgent.match(edgeRe);\n  };\n\n\n  /**\n   * Tries to detect whether is in the context of an HTML document.\n   * @return {boolean} True if it looks like HTML document.\n   * @private\n   */\n  goog.inHtmlDocument_ = function() {\n    /** @type {!Document} */\n    var doc = goog.global.document;\n    return doc != null && 'write' in doc;  // XULDocument misses write.\n  };\n\n\n  /**\n   * We'd like to check for if the document readyState is 'loading'; however\n   * there are bugs on IE 10 and below where the readyState being anything other\n   * than 'complete' is not reliable.\n   * @return {boolean}\n   * @private\n   */\n  goog.isDocumentLoading_ = function() {\n    // attachEvent is available on IE 6 thru 10 only, and thus can be used to\n    // detect those browsers.\n    /** @type {!HTMLDocument} */\n    var doc = goog.global.document;\n    return doc.attachEvent ? doc.readyState != 'complete' :\n                             doc.readyState == 'loading';\n  };\n\n\n  /**\n   * Tries to detect the base path of base.js script that bootstraps Closure.\n   * @private\n   */\n  goog.findBasePath_ = function() {\n    if (goog.global.CLOSURE_BASE_PATH != undefined &&\n        // Anti DOM-clobbering runtime check (b/37736576).\n        typeof goog.global.CLOSURE_BASE_PATH === 'string') {\n      goog.basePath = goog.global.CLOSURE_BASE_PATH;\n      return;\n    } else if (!goog.inHtmlDocument_()) {\n      return;\n    }\n    /** @type {!Document} */\n    var doc = goog.global.document;\n    // If we have a currentScript available, use it exclusively.\n    var currentScript = doc.currentScript;\n    if (currentScript) {\n      var scripts = [currentScript];\n    } else {\n      var scripts = doc.getElementsByTagName('SCRIPT');\n    }\n    // Search backwards since the current script is in almost all cases the one\n    // that has base.js.\n    for (var i = scripts.length - 1; i >= 0; --i) {\n      var script = /** @type {!HTMLScriptElement} */ (scripts[i]);\n      var src = script.src;\n      var qmark = src.lastIndexOf('?');\n      var l = qmark == -1 ? src.length : qmark;\n      if (src.substr(l - 7, 7) == 'base.js') {\n        goog.basePath = src.substr(0, l - 7);\n        return;\n      }\n    }\n  };\n\n  goog.findBasePath_();\n\n  /** @struct @constructor @final */\n  goog.Transpiler = function() {\n    /** @private {?Object<string, boolean>} */\n    this.requiresTranspilation_ = null;\n    /** @private {string} */\n    this.transpilationTarget_ = goog.TRANSPILE_TO_LANGUAGE;\n  };\n  /**\n   * Returns a newly created map from language mode string to a boolean\n   * indicating whether transpilation should be done for that mode as well as\n   * the highest level language that this environment supports.\n   *\n   * Guaranteed invariant:\n   * For any two modes, l1 and l2 where l2 is a newer mode than l1,\n   * `map[l1] == true` implies that `map[l2] == true`.\n   *\n   * Note this method is extracted and used elsewhere, so it cannot rely on\n   * anything external (it should easily be able to be transformed into a\n   * standalone, top level function).\n   *\n   * @private\n   * @return {{\n   *   target: string,\n   *   map: !Object<string, boolean>\n   * }}\n   */\n  goog.Transpiler.prototype.createRequiresTranspilation_ = function() {\n    var transpilationTarget = 'es3';\n    var /** !Object<string, boolean> */ requiresTranspilation = {'es3': false};\n    var transpilationRequiredForAllLaterModes = false;\n\n    /**\n     * Adds an entry to requiresTranspliation for the given language mode.\n     *\n     * IMPORTANT: Calls must be made in order from oldest to newest language\n     * mode.\n     * @param {string} modeName\n     * @param {function(): boolean} isSupported Returns true if the JS engine\n     *     supports the given mode.\n     */\n    function addNewerLanguageTranspilationCheck(modeName, isSupported) {\n      if (transpilationRequiredForAllLaterModes) {\n        requiresTranspilation[modeName] = true;\n      } else if (isSupported()) {\n        transpilationTarget = modeName;\n        requiresTranspilation[modeName] = false;\n      } else {\n        requiresTranspilation[modeName] = true;\n        transpilationRequiredForAllLaterModes = true;\n      }\n    }\n\n    /**\n     * Does the given code evaluate without syntax errors and return a truthy\n     * result?\n     */\n    function /** boolean */ evalCheck(/** string */ code) {\n      try {\n        return !!eval(goog.CLOSURE_EVAL_PREFILTER_.createScript(code));\n      } catch (ignored) {\n        return false;\n      }\n    }\n\n    // Identify ES3-only browsers by their incorrect treatment of commas.\n    addNewerLanguageTranspilationCheck('es5', function() {\n      return evalCheck('[1,].length==1');\n    });\n    addNewerLanguageTranspilationCheck('es6', function() {\n      // Edge has a non-deterministic (i.e., not reproducible) bug with ES6:\n      // https://github.com/Microsoft/ChakraCore/issues/1496.\n      if (goog.isEdge_()) {\n        // The Reflect.construct test below is flaky on Edge. It can sometimes\n        // pass or fail on 40 15.15063, so just exit early for Edge and treat\n        // it as ES5. Until we're on a more up to date version just always use\n        // ES5. See https://github.com/Microsoft/ChakraCore/issues/3217.\n        return false;\n      }\n      // Test es6: [FF50 (?), Edge 14 (?), Chrome 50]\n      //   (a) default params (specifically shadowing locals),\n      //   (b) destructuring, (c) block-scoped functions,\n      //   (d) for-of (const), (e) new.target/Reflect.construct\n      var es6fullTest =\n          'class X{constructor(){if(new.target!=String)throw 1;this.x=42}}' +\n          'let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof ' +\n          'String))throw 1;for(const a of[2,3]){if(a==2)continue;function ' +\n          'f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()' +\n          '==3}';\n\n      return evalCheck('(()=>{\"use strict\";' + es6fullTest + '})()');\n    });\n    // ** and **= are the only new features in 'es7'\n    addNewerLanguageTranspilationCheck('es7', function() {\n      return evalCheck('2**3==8');\n    });\n    // async functions are the only new features in 'es8'\n    addNewerLanguageTranspilationCheck('es8', function() {\n      return evalCheck('async()=>1,1');\n    });\n    addNewerLanguageTranspilationCheck('es9', function() {\n      return evalCheck('({...rest}={}),1');\n    });\n    // optional catch binding, unescaped unicode paragraph separator in strings\n    addNewerLanguageTranspilationCheck('es_2019', function() {\n      return evalCheck('let r;try{r=\"\\u2029\"}catch{};r');\n    });\n    // optional chaining, nullish coalescing\n    // untested/unsupported: bigint, import meta\n    addNewerLanguageTranspilationCheck('es_2020', function() {\n      return evalCheck('null?.x??1');\n    });\n    addNewerLanguageTranspilationCheck('es_next', function() {\n      return false;  // assume it always need to transpile\n    });\n    return {target: transpilationTarget, map: requiresTranspilation};\n  };\n\n\n  /**\n   * Determines whether the given language needs to be transpiled.\n   * @param {string} lang\n   * @param {string|undefined} module\n   * @return {boolean}\n   */\n  goog.Transpiler.prototype.needsTranspile = function(lang, module) {\n    if (goog.TRANSPILE == 'always') {\n      return true;\n    } else if (goog.TRANSPILE == 'never') {\n      return false;\n    } else if (!this.requiresTranspilation_) {\n      var obj = this.createRequiresTranspilation_();\n      this.requiresTranspilation_ = obj.map;\n      this.transpilationTarget_ = this.transpilationTarget_ || obj.target;\n    }\n    if (lang in this.requiresTranspilation_) {\n      if (this.requiresTranspilation_[lang]) {\n        return true;\n      } else if (\n          goog.inHtmlDocument_() && module == 'es6' &&\n          !('noModule' in goog.global.document.createElement('script'))) {\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      throw new Error('Unknown language mode: ' + lang);\n    }\n  };\n\n\n  /**\n   * Lazily retrieves the transpiler and applies it to the source.\n   * @param {string} code JS code.\n   * @param {string} path Path to the code.\n   * @return {string} The transpiled code.\n   */\n  goog.Transpiler.prototype.transpile = function(code, path) {\n    // TODO(johnplaisted): We should delete goog.transpile_ and just have this\n    // function. But there's some compile error atm where goog.global is being\n    // stripped incorrectly without this.\n    return goog.transpile_(code, path, this.transpilationTarget_);\n  };\n\n\n  /** @private @final {!goog.Transpiler} */\n  goog.transpiler_ = new goog.Transpiler();\n\n  /**\n   * Rewrites closing script tags in input to avoid ending an enclosing script\n   * tag.\n   *\n   * @param {string} str\n   * @return {string}\n   * @private\n   */\n  goog.protectScriptTag_ = function(str) {\n    return str.replace(/<\\/(SCRIPT)/ig, '\\\\x3c/$1');\n  };\n\n\n  /**\n   * A debug loader is responsible for downloading and executing javascript\n   * files in an unbundled, uncompiled environment.\n   *\n   * This can be custimized via the setDependencyFactory method, or by\n   * CLOSURE_IMPORT_SCRIPT/CLOSURE_LOAD_FILE_SYNC.\n   *\n   * @struct @constructor @final @private\n   */\n  goog.DebugLoader_ = function() {\n    /** @private @const {!Object<string, !goog.Dependency>} */\n    this.dependencies_ = {};\n    /** @private @const {!Object<string, string>} */\n    this.idToPath_ = {};\n    /** @private @const {!Object<string, boolean>} */\n    this.written_ = {};\n    /** @private @const {!Array<!goog.Dependency>} */\n    this.loadingDeps_ = [];\n    /** @private {!Array<!goog.Dependency>} */\n    this.depsToLoad_ = [];\n    /** @private {boolean} */\n    this.paused_ = false;\n    /** @private {!goog.DependencyFactory} */\n    this.factory_ = new goog.DependencyFactory(goog.transpiler_);\n    /** @private @const {!Object<string, !Function>} */\n    this.deferredCallbacks_ = {};\n    /** @private @const {!Array<string>} */\n    this.deferredQueue_ = [];\n  };\n\n  /**\n   * @param {!Array<string>} namespaces\n   * @param {function(): undefined} callback Function to call once all the\n   *     namespaces have loaded.\n   */\n  goog.DebugLoader_.prototype.bootstrap = function(namespaces, callback) {\n    var cb = callback;\n    function resolve() {\n      if (cb) {\n        goog.global.setTimeout(cb, 0);\n        cb = null;\n      }\n    }\n\n    if (!namespaces.length) {\n      resolve();\n      return;\n    }\n\n    var deps = [];\n    for (var i = 0; i < namespaces.length; i++) {\n      var path = this.getPathFromDeps_(namespaces[i]);\n      if (!path) {\n        throw new Error('Unregonized namespace: ' + namespaces[i]);\n      }\n      deps.push(this.dependencies_[path]);\n    }\n\n    var require = goog.require;\n    var loaded = 0;\n    for (var i = 0; i < namespaces.length; i++) {\n      require(namespaces[i]);\n      deps[i].onLoad(function() {\n        if (++loaded == namespaces.length) {\n          resolve();\n        }\n      });\n    }\n  };\n\n\n  /**\n   * Loads the Closure Dependency file.\n   *\n   * Exposed a public function so CLOSURE_NO_DEPS can be set to false, base\n   * loaded, setDependencyFactory called, and then this called. i.e. allows\n   * custom loading of the deps file.\n   */\n  goog.DebugLoader_.prototype.loadClosureDeps = function() {\n    // Circumvent addDependency, which would try to transpile deps.js if\n    // transpile is set to always.\n    var relPath = 'deps.js';\n    this.depsToLoad_.push(this.factory_.createDependency(\n        goog.normalizePath_(goog.basePath + relPath), relPath, [], [], {},\n        false));\n    this.loadDeps_();\n  };\n\n\n  /**\n   * Notifies the debug loader when a dependency has been requested.\n   *\n   * @param {string} absPathOrId Path of the dependency or goog id.\n   * @param {boolean=} opt_force\n   */\n  goog.DebugLoader_.prototype.requested = function(absPathOrId, opt_force) {\n    var path = this.getPathFromDeps_(absPathOrId);\n    if (path &&\n        (opt_force || this.areDepsLoaded_(this.dependencies_[path].requires))) {\n      var callback = this.deferredCallbacks_[path];\n      if (callback) {\n        delete this.deferredCallbacks_[path];\n        callback();\n      }\n    }\n  };\n\n\n  /**\n   * Sets the dependency factory, which can be used to create custom\n   * goog.Dependency implementations to control how dependencies are loaded.\n   *\n   * @param {!goog.DependencyFactory} factory\n   */\n  goog.DebugLoader_.prototype.setDependencyFactory = function(factory) {\n    this.factory_ = factory;\n  };\n\n\n  /**\n   * Travserses the dependency graph and queues the given dependency, and all of\n   * its transitive dependencies, for loading and then starts loading if not\n   * paused.\n   *\n   * @param {string} namespace\n   * @private\n   */\n  goog.DebugLoader_.prototype.load_ = function(namespace) {\n    if (!this.getPathFromDeps_(namespace)) {\n      var errorMessage = 'goog.require could not find: ' + namespace;\n      goog.logToConsole_(errorMessage);\n    } else {\n      var loader = this;\n\n      var deps = [];\n\n      /** @param {string} namespace */\n      var visit = function(namespace) {\n        var path = loader.getPathFromDeps_(namespace);\n\n        if (!path) {\n          throw new Error('Bad dependency path or symbol: ' + namespace);\n        }\n\n        if (loader.written_[path]) {\n          return;\n        }\n\n        loader.written_[path] = true;\n\n        var dep = loader.dependencies_[path];\n        for (var i = 0; i < dep.requires.length; i++) {\n          if (!goog.isProvided_(dep.requires[i])) {\n            visit(dep.requires[i]);\n          }\n        }\n\n        deps.push(dep);\n      };\n\n      visit(namespace);\n\n      var wasLoading = !!this.depsToLoad_.length;\n      this.depsToLoad_ = this.depsToLoad_.concat(deps);\n\n      if (!this.paused_ && !wasLoading) {\n        this.loadDeps_();\n      }\n    }\n  };\n\n\n  /**\n   * Loads any queued dependencies until they are all loaded or paused.\n   *\n   * @private\n   */\n  goog.DebugLoader_.prototype.loadDeps_ = function() {\n    var loader = this;\n    var paused = this.paused_;\n\n    while (this.depsToLoad_.length && !paused) {\n      (function() {\n        var loadCallDone = false;\n        var dep = loader.depsToLoad_.shift();\n\n        var loaded = false;\n        loader.loading_(dep);\n\n        var controller = {\n          pause: function() {\n            if (loadCallDone) {\n              throw new Error('Cannot call pause after the call to load.');\n            } else {\n              paused = true;\n            }\n          },\n          resume: function() {\n            if (loadCallDone) {\n              loader.resume_();\n            } else {\n              // Some dep called pause and then resume in the same load call.\n              // Just keep running this same loop.\n              paused = false;\n            }\n          },\n          loaded: function() {\n            if (loaded) {\n              throw new Error('Double call to loaded.');\n            }\n\n            loaded = true;\n            loader.loaded_(dep);\n          },\n          pending: function() {\n            // Defensive copy.\n            var pending = [];\n            for (var i = 0; i < loader.loadingDeps_.length; i++) {\n              pending.push(loader.loadingDeps_[i]);\n            }\n            return pending;\n          },\n          /**\n           * @param {goog.ModuleType} type\n           */\n          setModuleState: function(type) {\n            goog.moduleLoaderState_ = {\n              type: type,\n              moduleName: '',\n              declareLegacyNamespace: false\n            };\n          },\n          /** @type {function(string, string, string=)} */\n          registerEs6ModuleExports: function(\n              path, exports, opt_closureNamespace) {\n            if (opt_closureNamespace) {\n              goog.loadedModules_[opt_closureNamespace] = {\n                exports: exports,\n                type: goog.ModuleType.ES6,\n                moduleId: opt_closureNamespace || ''\n              };\n            }\n          },\n          /** @type {function(string, ?)} */\n          registerGoogModuleExports: function(moduleId, exports) {\n            goog.loadedModules_[moduleId] = {\n              exports: exports,\n              type: goog.ModuleType.GOOG,\n              moduleId: moduleId\n            };\n          },\n          clearModuleState: function() {\n            goog.moduleLoaderState_ = null;\n          },\n          defer: function(callback) {\n            if (loadCallDone) {\n              throw new Error(\n                  'Cannot register with defer after the call to load.');\n            }\n            loader.defer_(dep, callback);\n          },\n          areDepsLoaded: function() {\n            return loader.areDepsLoaded_(dep.requires);\n          }\n        };\n\n        try {\n          dep.load(controller);\n        } finally {\n          loadCallDone = true;\n        }\n      })();\n    }\n\n    if (paused) {\n      this.pause_();\n    }\n  };\n\n\n  /** @private */\n  goog.DebugLoader_.prototype.pause_ = function() {\n    this.paused_ = true;\n  };\n\n\n  /** @private */\n  goog.DebugLoader_.prototype.resume_ = function() {\n    if (this.paused_) {\n      this.paused_ = false;\n      this.loadDeps_();\n    }\n  };\n\n\n  /**\n   * Marks the given dependency as loading (load has been called but it has not\n   * yet marked itself as finished). Useful for dependencies that want to know\n   * what else is loading. Example: goog.modules cannot eval if there are\n   * loading dependencies.\n   *\n   * @param {!goog.Dependency} dep\n   * @private\n   */\n  goog.DebugLoader_.prototype.loading_ = function(dep) {\n    this.loadingDeps_.push(dep);\n  };\n\n\n  /**\n   * Marks the given dependency as having finished loading and being available\n   * for require.\n   *\n   * @param {!goog.Dependency} dep\n   * @private\n   */\n  goog.DebugLoader_.prototype.loaded_ = function(dep) {\n    for (var i = 0; i < this.loadingDeps_.length; i++) {\n      if (this.loadingDeps_[i] == dep) {\n        this.loadingDeps_.splice(i, 1);\n        break;\n      }\n    }\n\n    for (var i = 0; i < this.deferredQueue_.length; i++) {\n      if (this.deferredQueue_[i] == dep.path) {\n        this.deferredQueue_.splice(i, 1);\n        break;\n      }\n    }\n\n    if (this.loadingDeps_.length == this.deferredQueue_.length &&\n        !this.depsToLoad_.length) {\n      // Something has asked to load these, but they may not be directly\n      // required again later, so load them now that we know we're done loading\n      // everything else. e.g. a goog module entry point.\n      while (this.deferredQueue_.length) {\n        this.requested(this.deferredQueue_.shift(), true);\n      }\n    }\n\n    dep.loaded();\n  };\n\n\n  /**\n   * @param {!Array<string>} pathsOrIds\n   * @return {boolean}\n   * @private\n   */\n  goog.DebugLoader_.prototype.areDepsLoaded_ = function(pathsOrIds) {\n    for (var i = 0; i < pathsOrIds.length; i++) {\n      var path = this.getPathFromDeps_(pathsOrIds[i]);\n      if (!path ||\n          (!(path in this.deferredCallbacks_) &&\n           !goog.isProvided_(pathsOrIds[i]))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n\n  /**\n   * @param {string} absPathOrId\n   * @return {?string}\n   * @private\n   */\n  goog.DebugLoader_.prototype.getPathFromDeps_ = function(absPathOrId) {\n    if (absPathOrId in this.idToPath_) {\n      return this.idToPath_[absPathOrId];\n    } else if (absPathOrId in this.dependencies_) {\n      return absPathOrId;\n    } else {\n      return null;\n    }\n  };\n\n\n  /**\n   * @param {!goog.Dependency} dependency\n   * @param {!Function} callback\n   * @private\n   */\n  goog.DebugLoader_.prototype.defer_ = function(dependency, callback) {\n    this.deferredCallbacks_[dependency.path] = callback;\n    this.deferredQueue_.push(dependency.path);\n  };\n\n\n  /**\n   * Interface for goog.Dependency implementations to have some control over\n   * loading of dependencies.\n   *\n   * @record\n   */\n  goog.LoadController = function() {};\n\n\n  /**\n   * Tells the controller to halt loading of more dependencies.\n   */\n  goog.LoadController.prototype.pause = function() {};\n\n\n  /**\n   * Tells the controller to resume loading of more dependencies if paused.\n   */\n  goog.LoadController.prototype.resume = function() {};\n\n\n  /**\n   * Tells the controller that this dependency has finished loading.\n   *\n   * This causes this to be removed from pending() and any load callbacks to\n   * fire.\n   */\n  goog.LoadController.prototype.loaded = function() {};\n\n\n  /**\n   * List of dependencies on which load has been called but which have not\n   * called loaded on their controller. This includes the current dependency.\n   *\n   * @return {!Array<!goog.Dependency>}\n   */\n  goog.LoadController.prototype.pending = function() {};\n\n\n  /**\n   * Registers an object as an ES6 module's exports so that goog.modules may\n   * require it by path.\n   *\n   * @param {string} path Full path of the module.\n   * @param {?} exports\n   * @param {string=} opt_closureNamespace Closure namespace to associate with\n   *     this module.\n   */\n  goog.LoadController.prototype.registerEs6ModuleExports = function(\n      path, exports, opt_closureNamespace) {};\n\n\n  /**\n   * Sets the current module state.\n   *\n   * @param {goog.ModuleType} type Type of module.\n   */\n  goog.LoadController.prototype.setModuleState = function(type) {};\n\n\n  /**\n   * Clears the current module state.\n   */\n  goog.LoadController.prototype.clearModuleState = function() {};\n\n\n  /**\n   * Registers a callback to call once the dependency is actually requested\n   * via goog.require + all of the immediate dependencies have been loaded or\n   * all other files have been loaded. Allows for lazy loading until\n   * require'd without pausing dependency loading, which is needed on old IE.\n   *\n   * @param {!Function} callback\n   */\n  goog.LoadController.prototype.defer = function(callback) {};\n\n\n  /**\n   * @return {boolean}\n   */\n  goog.LoadController.prototype.areDepsLoaded = function() {};\n\n\n  /**\n   * Basic super class for all dependencies Closure Library can load.\n   *\n   * This default implementation is designed to load untranspiled, non-module\n   * scripts in a web broswer.\n   *\n   * For transpiled non-goog.module files {@see goog.TranspiledDependency}.\n   * For goog.modules see {@see goog.GoogModuleDependency}.\n   * For untranspiled ES6 modules {@see goog.Es6ModuleDependency}.\n   *\n   * @param {string} path Absolute path of this script.\n   * @param {string} relativePath Path of this script relative to goog.basePath.\n   * @param {!Array<string>} provides goog.provided or goog.module symbols\n   *     in this file.\n   * @param {!Array<string>} requires goog symbols or relative paths to Closure\n   *     this depends on.\n   * @param {!Object<string, string>} loadFlags\n   * @struct @constructor\n   */\n  goog.Dependency = function(\n      path, relativePath, provides, requires, loadFlags) {\n    /** @const */\n    this.path = path;\n    /** @const */\n    this.relativePath = relativePath;\n    /** @const */\n    this.provides = provides;\n    /** @const */\n    this.requires = requires;\n    /** @const */\n    this.loadFlags = loadFlags;\n    /** @private {boolean} */\n    this.loaded_ = false;\n    /** @private {!Array<function()>} */\n    this.loadCallbacks_ = [];\n  };\n\n\n  /**\n   * @return {string} The pathname part of this dependency's path if it is a\n   *     URI.\n   */\n  goog.Dependency.prototype.getPathName = function() {\n    var pathName = this.path;\n    var protocolIndex = pathName.indexOf('://');\n    if (protocolIndex >= 0) {\n      pathName = pathName.substring(protocolIndex + 3);\n      var slashIndex = pathName.indexOf('/');\n      if (slashIndex >= 0) {\n        pathName = pathName.substring(slashIndex + 1);\n      }\n    }\n    return pathName;\n  };\n\n\n  /**\n   * @param {function()} callback Callback to fire as soon as this has loaded.\n   * @final\n   */\n  goog.Dependency.prototype.onLoad = function(callback) {\n    if (this.loaded_) {\n      callback();\n    } else {\n      this.loadCallbacks_.push(callback);\n    }\n  };\n\n\n  /**\n   * Marks this dependency as loaded and fires any callbacks registered with\n   * onLoad.\n   * @final\n   */\n  goog.Dependency.prototype.loaded = function() {\n    this.loaded_ = true;\n    var callbacks = this.loadCallbacks_;\n    this.loadCallbacks_ = [];\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i]();\n    }\n  };\n\n\n  /**\n   * Whether or not document.written / appended script tags should be deferred.\n   *\n   * @private {boolean}\n   */\n  goog.Dependency.defer_ = false;\n\n\n  /**\n   * Map of script ready / state change callbacks. Old IE cannot handle putting\n   * these properties on goog.global.\n   *\n   * @private @const {!Object<string, function(?):undefined>}\n   */\n  goog.Dependency.callbackMap_ = {};\n\n\n  /**\n   * @param {function(...?):?} callback\n   * @return {string}\n   * @private\n   */\n  goog.Dependency.registerCallback_ = function(callback) {\n    var key = Math.random().toString(32);\n    goog.Dependency.callbackMap_[key] = callback;\n    return key;\n  };\n\n\n  /**\n   * @param {string} key\n   * @private\n   */\n  goog.Dependency.unregisterCallback_ = function(key) {\n    delete goog.Dependency.callbackMap_[key];\n  };\n\n\n  /**\n   * @param {string} key\n   * @param {...?} var_args\n   * @private\n   * @suppress {unusedPrivateMembers}\n   */\n  goog.Dependency.callback_ = function(key, var_args) {\n    if (key in goog.Dependency.callbackMap_) {\n      var callback = goog.Dependency.callbackMap_[key];\n      var args = [];\n      for (var i = 1; i < arguments.length; i++) {\n        args.push(arguments[i]);\n      }\n      callback.apply(undefined, args);\n    } else {\n      var errorMessage = 'Callback key ' + key +\n          ' does not exist (was base.js loaded more than once?).';\n      throw Error(errorMessage);\n    }\n  };\n\n\n  /**\n   * Starts loading this dependency. This dependency can pause loading if it\n   * needs to and resume it later via the controller interface.\n   *\n   * When this is loaded it should call controller.loaded(). Note that this will\n   * end up calling the loaded method of this dependency; there is no need to\n   * call it explicitly.\n   *\n   * @param {!goog.LoadController} controller\n   */\n  goog.Dependency.prototype.load = function(controller) {\n    if (goog.global.CLOSURE_IMPORT_SCRIPT) {\n      if (goog.global.CLOSURE_IMPORT_SCRIPT(this.path)) {\n        controller.loaded();\n      } else {\n        controller.pause();\n      }\n      return;\n    }\n\n    if (!goog.inHtmlDocument_()) {\n      goog.logToConsole_(\n          'Cannot use default debug loader outside of HTML documents.');\n      if (this.relativePath == 'deps.js') {\n        // Some old code is relying on base.js auto loading deps.js failing with\n        // no error before later setting CLOSURE_IMPORT_SCRIPT.\n        // CLOSURE_IMPORT_SCRIPT should be set *before* base.js is loaded, or\n        // CLOSURE_NO_DEPS set to true.\n        goog.logToConsole_(\n            'Consider setting CLOSURE_IMPORT_SCRIPT before loading base.js, ' +\n            'or setting CLOSURE_NO_DEPS to true.');\n        controller.loaded();\n      } else {\n        controller.pause();\n      }\n      return;\n    }\n\n    /** @type {!HTMLDocument} */\n    var doc = goog.global.document;\n\n    // If the user tries to require a new symbol after document load,\n    // something has gone terribly wrong. Doing a document.write would\n    // wipe out the page. This does not apply to the CSP-compliant method\n    // of writing script tags.\n    if (doc.readyState == 'complete' &&\n        !goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING) {\n      // Certain test frameworks load base.js multiple times, which tries\n      // to write deps.js each time. If that happens, just fail silently.\n      // These frameworks wipe the page between each load of base.js, so this\n      // is OK.\n      var isDeps = /\\bdeps.js$/.test(this.path);\n      if (isDeps) {\n        controller.loaded();\n        return;\n      } else {\n        throw Error('Cannot write \"' + this.path + '\" after document load');\n      }\n    }\n\n    var nonce = goog.getScriptNonce_();\n    if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING &&\n        goog.isDocumentLoading_()) {\n      var key;\n      var callback = function(script) {\n        if (script.readyState && script.readyState != 'complete') {\n          script.onload = callback;\n          return;\n        }\n        goog.Dependency.unregisterCallback_(key);\n        controller.loaded();\n      };\n      key = goog.Dependency.registerCallback_(callback);\n\n      var defer = goog.Dependency.defer_ ? ' defer' : '';\n      var nonceAttr = nonce ? ' nonce=\"' + nonce + '\"' : '';\n      var script = '<script src=\"' + this.path + '\"' + nonceAttr + defer +\n          ' id=\"script-' + key + '\"><\\/script>';\n\n      script += '<script' + nonceAttr + '>';\n\n      if (goog.Dependency.defer_) {\n        script += 'document.getElementById(\\'script-' + key +\n            '\\').onload = function() {\\n' +\n            '  goog.Dependency.callback_(\\'' + key + '\\', this);\\n' +\n            '};\\n';\n      } else {\n        script += 'goog.Dependency.callback_(\\'' + key +\n            '\\', document.getElementById(\\'script-' + key + '\\'));';\n      }\n\n      script += '<\\/script>';\n\n      doc.write(\n          goog.TRUSTED_TYPES_POLICY_ ?\n              goog.TRUSTED_TYPES_POLICY_.createHTML(script) :\n              script);\n    } else {\n      var scriptEl =\n          /** @type {!HTMLScriptElement} */ (doc.createElement('script'));\n      scriptEl.defer = goog.Dependency.defer_;\n      scriptEl.async = false;\n\n      // If CSP nonces are used, propagate them to dynamically created scripts.\n      // This is necessary to allow nonce-based CSPs without 'strict-dynamic'.\n      if (nonce) {\n        scriptEl.nonce = nonce;\n      }\n\n      scriptEl.onload = function() {\n        scriptEl.onload = null;\n        controller.loaded();\n      };\n\n      scriptEl.src = goog.TRUSTED_TYPES_POLICY_ ?\n          goog.TRUSTED_TYPES_POLICY_.createScriptURL(this.path) :\n          this.path;\n      doc.head.appendChild(scriptEl);\n    }\n  };\n\n\n  /**\n   * @param {string} path Absolute path of this script.\n   * @param {string} relativePath Path of this script relative to goog.basePath.\n   * @param {!Array<string>} provides Should be an empty array.\n   *     TODO(johnplaisted) add support for adding closure namespaces to ES6\n   *     modules for interop purposes.\n   * @param {!Array<string>} requires goog symbols or relative paths to Closure\n   *     this depends on.\n   * @param {!Object<string, string>} loadFlags\n   * @struct @constructor\n   * @extends {goog.Dependency}\n   */\n  goog.Es6ModuleDependency = function(\n      path, relativePath, provides, requires, loadFlags) {\n    goog.Es6ModuleDependency.base(\n        this, 'constructor', path, relativePath, provides, requires, loadFlags);\n  };\n  goog.inherits(goog.Es6ModuleDependency, goog.Dependency);\n\n\n  /**\n   * @override\n   * @param {!goog.LoadController} controller\n   */\n  goog.Es6ModuleDependency.prototype.load = function(controller) {\n    if (goog.global.CLOSURE_IMPORT_SCRIPT) {\n      if (goog.global.CLOSURE_IMPORT_SCRIPT(this.path)) {\n        controller.loaded();\n      } else {\n        controller.pause();\n      }\n      return;\n    }\n\n    if (!goog.inHtmlDocument_()) {\n      goog.logToConsole_(\n          'Cannot use default debug loader outside of HTML documents.');\n      controller.pause();\n      return;\n    }\n\n    /** @type {!HTMLDocument} */\n    var doc = goog.global.document;\n\n    var dep = this;\n\n    // TODO(johnplaisted): Does document.writing really speed up anything? Any\n    // difference between this and just waiting for interactive mode and then\n    // appending?\n    function write(src, contents) {\n      var nonceAttr = '';\n      var nonce = goog.getScriptNonce_();\n      if (nonce) {\n        nonceAttr = ' nonce=\"' + nonce + '\"';\n      }\n\n      if (contents) {\n        var script = '<script type=\"module\" crossorigin' + nonceAttr + '>' +\n            contents + '</' +\n            'script>';\n        doc.write(\n            goog.TRUSTED_TYPES_POLICY_ ?\n                goog.TRUSTED_TYPES_POLICY_.createHTML(script) :\n                script);\n      } else {\n        var script = '<script type=\"module\" crossorigin src=\"' + src + '\"' +\n            nonceAttr + '></' +\n            'script>';\n        doc.write(\n            goog.TRUSTED_TYPES_POLICY_ ?\n                goog.TRUSTED_TYPES_POLICY_.createHTML(script) :\n                script);\n      }\n    }\n\n    function append(src, contents) {\n      var scriptEl =\n          /** @type {!HTMLScriptElement} */ (doc.createElement('script'));\n      scriptEl.defer = true;\n      scriptEl.async = false;\n      scriptEl.type = 'module';\n      scriptEl.setAttribute('crossorigin', true);\n\n      // If CSP nonces are used, propagate them to dynamically created scripts.\n      // This is necessary to allow nonce-based CSPs without 'strict-dynamic'.\n      var nonce = goog.getScriptNonce_();\n      if (nonce) {\n        scriptEl.nonce = nonce;\n      }\n\n      if (contents) {\n        scriptEl.text = goog.TRUSTED_TYPES_POLICY_ ?\n            goog.TRUSTED_TYPES_POLICY_.createScript(contents) :\n            contents;\n      } else {\n        scriptEl.src = goog.TRUSTED_TYPES_POLICY_ ?\n            goog.TRUSTED_TYPES_POLICY_.createScriptURL(src) :\n            src;\n      }\n\n      doc.head.appendChild(scriptEl);\n    }\n\n    var create;\n\n    if (goog.isDocumentLoading_()) {\n      create = write;\n      // We can ONLY call document.write if we are guaranteed that any\n      // non-module script tags document.written after this are deferred.\n      // Small optimization, in theory document.writing is faster.\n      goog.Dependency.defer_ = true;\n    } else {\n      create = append;\n    }\n\n    // Write 4 separate tags here:\n    // 1) Sets the module state at the correct time (just before execution).\n    // 2) A src node for this, which just hopefully lets the browser load it a\n    //    little early (no need to parse #3).\n    // 3) Import the module and register it.\n    // 4) Clear the module state at the correct time. Guaranteed to run even\n    //    if there is an error in the module (#3 will not run if there is an\n    //    error in the module).\n    var beforeKey = goog.Dependency.registerCallback_(function() {\n      goog.Dependency.unregisterCallback_(beforeKey);\n      controller.setModuleState(goog.ModuleType.ES6);\n    });\n    create(undefined, 'goog.Dependency.callback_(\"' + beforeKey + '\")');\n\n    // TODO(johnplaisted): Does this really speed up anything?\n    create(this.path, undefined);\n\n    var registerKey = goog.Dependency.registerCallback_(function(exports) {\n      goog.Dependency.unregisterCallback_(registerKey);\n      controller.registerEs6ModuleExports(\n          dep.path, exports, goog.moduleLoaderState_.moduleName);\n    });\n    create(\n        undefined,\n        'import * as m from \"' + this.path + '\"; goog.Dependency.callback_(\"' +\n            registerKey + '\", m)');\n\n    var afterKey = goog.Dependency.registerCallback_(function() {\n      goog.Dependency.unregisterCallback_(afterKey);\n      controller.clearModuleState();\n      controller.loaded();\n    });\n    create(undefined, 'goog.Dependency.callback_(\"' + afterKey + '\")');\n  };\n\n\n  /**\n   * Superclass of any dependency that needs to be loaded into memory,\n   * transformed, and then eval'd (goog.modules and transpiled files).\n   *\n   * @param {string} path Absolute path of this script.\n   * @param {string} relativePath Path of this script relative to goog.basePath.\n   * @param {!Array<string>} provides goog.provided or goog.module symbols\n   *     in this file.\n   * @param {!Array<string>} requires goog symbols or relative paths to Closure\n   *     this depends on.\n   * @param {!Object<string, string>} loadFlags\n   * @struct @constructor @abstract\n   * @extends {goog.Dependency}\n   */\n  goog.TransformedDependency = function(\n      path, relativePath, provides, requires, loadFlags) {\n    goog.TransformedDependency.base(\n        this, 'constructor', path, relativePath, provides, requires, loadFlags);\n    /** @private {?string} */\n    this.contents_ = null;\n\n    /**\n     * Whether to lazily make the synchronous XHR (when goog.require'd) or make\n     * the synchronous XHR when initially loading. On FireFox 61 there is a bug\n     * where an ES6 module cannot make a synchronous XHR (rather, it can, but if\n     * it does then no other ES6 modules will load after).\n     *\n     * tl;dr we lazy load due to bugs on older browsers and eager load due to\n     * bugs on newer ones.\n     *\n     * https://bugzilla.mozilla.org/show_bug.cgi?id=1477090\n     *\n     * @private @const {boolean}\n     */\n    this.lazyFetch_ = !goog.inHtmlDocument_() ||\n        !('noModule' in goog.global.document.createElement('script'));\n  };\n  goog.inherits(goog.TransformedDependency, goog.Dependency);\n\n\n  /**\n   * @override\n   * @param {!goog.LoadController} controller\n   */\n  goog.TransformedDependency.prototype.load = function(controller) {\n    var dep = this;\n\n    function fetch() {\n      dep.contents_ = goog.loadFileSync_(dep.path);\n\n      if (dep.contents_) {\n        dep.contents_ = dep.transform(dep.contents_);\n        if (dep.contents_) {\n          dep.contents_ += '\\n//# sourceURL=' + dep.path;\n        }\n      }\n    }\n\n    if (goog.global.CLOSURE_IMPORT_SCRIPT) {\n      fetch();\n      if (this.contents_ &&\n          goog.global.CLOSURE_IMPORT_SCRIPT('', this.contents_)) {\n        this.contents_ = null;\n        controller.loaded();\n      } else {\n        controller.pause();\n      }\n      return;\n    }\n\n\n    var isEs6 = this.loadFlags['module'] == goog.ModuleType.ES6;\n\n    if (!this.lazyFetch_) {\n      fetch();\n    }\n\n    function load() {\n      if (dep.lazyFetch_) {\n        fetch();\n      }\n\n      if (!dep.contents_) {\n        // loadFileSync_ or transform are responsible. Assume they logged an\n        // error.\n        return;\n      }\n\n      if (isEs6) {\n        controller.setModuleState(goog.ModuleType.ES6);\n      }\n\n      var namespace;\n\n      try {\n        var contents = dep.contents_;\n        dep.contents_ = null;\n        goog.globalEval(goog.CLOSURE_EVAL_PREFILTER_.createScript(contents));\n        if (isEs6) {\n          namespace = goog.moduleLoaderState_.moduleName;\n        }\n      } finally {\n        if (isEs6) {\n          controller.clearModuleState();\n        }\n      }\n\n      if (isEs6) {\n        // Due to circular dependencies this may not be available for require\n        // right now.\n        goog.global['$jscomp']['require']['ensure'](\n            [dep.getPathName()], function() {\n              controller.registerEs6ModuleExports(\n                  dep.path,\n                  goog.global['$jscomp']['require'](dep.getPathName()),\n                  namespace);\n            });\n      }\n\n      controller.loaded();\n    }\n\n    // Do not fetch now; in FireFox 47 the synchronous XHR doesn't block all\n    // events. If we fetched now and then document.write'd the contents the\n    // document.write would be an eval and would execute too soon! Instead write\n    // a script tag to fetch and eval synchronously at the correct time.\n    function fetchInOwnScriptThenLoad() {\n      /** @type {!HTMLDocument} */\n      var doc = goog.global.document;\n\n      var key = goog.Dependency.registerCallback_(function() {\n        goog.Dependency.unregisterCallback_(key);\n        load();\n      });\n\n      var nonce = goog.getScriptNonce_();\n      var nonceAttr = nonce ? ' nonce=\"' + nonce + '\"' : '';\n      var script = '<script' + nonceAttr + '>' +\n          goog.protectScriptTag_('goog.Dependency.callback_(\"' + key + '\");') +\n          '</' +\n          'script>';\n      doc.write(\n          goog.TRUSTED_TYPES_POLICY_ ?\n              goog.TRUSTED_TYPES_POLICY_.createHTML(script) :\n              script);\n    }\n\n    // If one thing is pending it is this.\n    var anythingElsePending = controller.pending().length > 1;\n\n    // Additionally if we are meant to defer scripts but the page is still\n    // loading (e.g. an ES6 module is loading) then also defer. Or if we are\n    // meant to defer and anything else is pending then defer (those may be\n    // scripts that did not need transformation and are just script tags with\n    // defer set to true, and we need to evaluate after that deferred script).\n    var needsAsyncLoading = goog.Dependency.defer_ &&\n        (anythingElsePending || goog.isDocumentLoading_());\n\n    if (needsAsyncLoading) {\n      // Note that we only defer when we have to rather than 100% of the time.\n      // Always defering would work, but then in theory the order of\n      // goog.require calls would then matter. We want to enforce that most of\n      // the time the order of the require calls does not matter.\n      controller.defer(function() {\n        load();\n      });\n      return;\n    }\n    // TODO(johnplaisted): Externs are missing onreadystatechange for\n    // HTMLDocument.\n    /** @type {?} */\n    var doc = goog.global.document;\n\n    var isInternetExplorerOrEdge = goog.inHtmlDocument_() &&\n        ('ActiveXObject' in goog.global || goog.isEdge_());\n\n    // Don't delay in any version of IE or pre-Chromium Edge. There's a bug\n    // around this that will cause out of order script execution. This means\n    // that on older IE ES6 modules will load too early (while the document is\n    // still loading + the dom is not available). The other option is to load\n    // too late (when the document is complete and the onload even will never\n    // fire). This seems to be the lesser of two evils as scripts already act\n    // like the former.\n    if (isEs6 && goog.inHtmlDocument_() && goog.isDocumentLoading_() &&\n        !isInternetExplorerOrEdge) {\n      goog.Dependency.defer_ = true;\n      // Transpiled ES6 modules still need to load like regular ES6 modules,\n      // aka only after the document is interactive.\n      controller.pause();\n      var oldCallback = doc.onreadystatechange;\n      doc.onreadystatechange = function() {\n        if (doc.readyState == 'interactive') {\n          doc.onreadystatechange = oldCallback;\n          load();\n          controller.resume();\n        }\n        if (typeof oldCallback === 'function') {\n          oldCallback.apply(undefined, arguments);\n        }\n      };\n    } else {\n      // Always eval on old IE.\n      if (!goog.inHtmlDocument_() || !goog.isDocumentLoading_()) {\n        load();\n      } else {\n        fetchInOwnScriptThenLoad();\n      }\n    }\n  };\n\n\n  /**\n   * @param {string} contents\n   * @return {string}\n   * @abstract\n   */\n  goog.TransformedDependency.prototype.transform = function(contents) {};\n\n\n  /**\n   * Any non-goog.module dependency which needs to be transpiled before eval.\n   *\n   * @param {string} path Absolute path of this script.\n   * @param {string} relativePath Path of this script relative to goog.basePath.\n   * @param {!Array<string>} provides goog.provided or goog.module symbols\n   *     in this file.\n   * @param {!Array<string>} requires goog symbols or relative paths to Closure\n   *     this depends on.\n   * @param {!Object<string, string>} loadFlags\n   * @param {!goog.Transpiler} transpiler\n   * @struct @constructor\n   * @extends {goog.TransformedDependency}\n   */\n  goog.TranspiledDependency = function(\n      path, relativePath, provides, requires, loadFlags, transpiler) {\n    goog.TranspiledDependency.base(\n        this, 'constructor', path, relativePath, provides, requires, loadFlags);\n    /** @protected @const*/\n    this.transpiler = transpiler;\n  };\n  goog.inherits(goog.TranspiledDependency, goog.TransformedDependency);\n\n\n  /**\n   * @override\n   * @param {string} contents\n   * @return {string}\n   */\n  goog.TranspiledDependency.prototype.transform = function(contents) {\n    // Transpile with the pathname so that ES6 modules are domain agnostic.\n    return this.transpiler.transpile(contents, this.getPathName());\n  };\n\n\n  /**\n   * An ES6 module dependency that was transpiled to a jscomp module outside\n   * of the debug loader, e.g. server side.\n   *\n   * @param {string} path Absolute path of this script.\n   * @param {string} relativePath Path of this script relative to goog.basePath.\n   * @param {!Array<string>} provides goog.provided or goog.module symbols\n   *     in this file.\n   * @param {!Array<string>} requires goog symbols or relative paths to Closure\n   *     this depends on.\n   * @param {!Object<string, string>} loadFlags\n   * @struct @constructor\n   * @extends {goog.TransformedDependency}\n   */\n  goog.PreTranspiledEs6ModuleDependency = function(\n      path, relativePath, provides, requires, loadFlags) {\n    goog.PreTranspiledEs6ModuleDependency.base(\n        this, 'constructor', path, relativePath, provides, requires, loadFlags);\n  };\n  goog.inherits(\n      goog.PreTranspiledEs6ModuleDependency, goog.TransformedDependency);\n\n\n  /**\n   * @override\n   * @param {string} contents\n   * @return {string}\n   */\n  goog.PreTranspiledEs6ModuleDependency.prototype.transform = function(\n      contents) {\n    return contents;\n  };\n\n\n  /**\n   * A goog.module, transpiled or not. Will always perform some minimal\n   * transformation even when not transpiled to wrap in a goog.loadModule\n   * statement.\n   *\n   * @param {string} path Absolute path of this script.\n   * @param {string} relativePath Path of this script relative to goog.basePath.\n   * @param {!Array<string>} provides goog.provided or goog.module symbols\n   *     in this file.\n   * @param {!Array<string>} requires goog symbols or relative paths to Closure\n   *     this depends on.\n   * @param {!Object<string, string>} loadFlags\n   * @param {boolean} needsTranspile\n   * @param {!goog.Transpiler} transpiler\n   * @struct @constructor\n   * @extends {goog.TransformedDependency}\n   */\n  goog.GoogModuleDependency = function(\n      path, relativePath, provides, requires, loadFlags, needsTranspile,\n      transpiler) {\n    goog.GoogModuleDependency.base(\n        this, 'constructor', path, relativePath, provides, requires, loadFlags);\n    /** @private @const */\n    this.needsTranspile_ = needsTranspile;\n    /** @private @const */\n    this.transpiler_ = transpiler;\n  };\n  goog.inherits(goog.GoogModuleDependency, goog.TransformedDependency);\n\n\n  /**\n   * @override\n   * @param {string} contents\n   * @return {string}\n   */\n  goog.GoogModuleDependency.prototype.transform = function(contents) {\n    if (this.needsTranspile_) {\n      contents = this.transpiler_.transpile(contents, this.getPathName());\n    }\n\n    if (!goog.LOAD_MODULE_USING_EVAL || goog.global.JSON === undefined) {\n      return '' +\n          'goog.loadModule(function(exports) {' +\n          '\"use strict\";' + contents +\n          '\\n' +  // terminate any trailing single line comment.\n          ';return exports' +\n          '});' +\n          '\\n//# sourceURL=' + this.path + '\\n';\n    } else {\n      return '' +\n          'goog.loadModule(' +\n          goog.global.JSON.stringify(\n              contents + '\\n//# sourceURL=' + this.path + '\\n') +\n          ');';\n    }\n  };\n\n\n  /**\n   * @param {string} relPath\n   * @param {!Array<string>|undefined} provides\n   * @param {!Array<string>} requires\n   * @param {boolean|!Object<string>=} opt_loadFlags\n   * @see goog.addDependency\n   */\n  goog.DebugLoader_.prototype.addDependency = function(\n      relPath, provides, requires, opt_loadFlags) {\n    provides = provides || [];\n    relPath = relPath.replace(/\\\\/g, '/');\n    var path = goog.normalizePath_(goog.basePath + relPath);\n    if (!opt_loadFlags || typeof opt_loadFlags === 'boolean') {\n      opt_loadFlags = opt_loadFlags ? {'module': goog.ModuleType.GOOG} : {};\n    }\n    var dep = this.factory_.createDependency(\n        path, relPath, provides, requires, opt_loadFlags,\n        goog.transpiler_.needsTranspile(\n            opt_loadFlags['lang'] || 'es3', opt_loadFlags['module']));\n    this.dependencies_[path] = dep;\n    for (var i = 0; i < provides.length; i++) {\n      this.idToPath_[provides[i]] = path;\n    }\n    this.idToPath_[relPath] = path;\n  };\n\n\n  /**\n   * Creates goog.Dependency instances for the debug loader to load.\n   *\n   * Should be overridden to have the debug loader use custom subclasses of\n   * goog.Dependency.\n   *\n   * @param {!goog.Transpiler} transpiler\n   * @struct @constructor\n   */\n  goog.DependencyFactory = function(transpiler) {\n    /** @protected @const */\n    this.transpiler = transpiler;\n  };\n\n\n  /**\n   * @param {string} path Absolute path of the file.\n   * @param {string} relativePath Path relative to closure\u2019s base.js.\n   * @param {!Array<string>} provides Array of provided goog.provide/module ids.\n   * @param {!Array<string>} requires Array of required goog.provide/module /\n   *     relative ES6 module paths.\n   * @param {!Object<string, string>} loadFlags\n   * @param {boolean} needsTranspile True if the file needs to be transpiled\n   *     per the goog.Transpiler.\n   * @return {!goog.Dependency}\n   */\n  goog.DependencyFactory.prototype.createDependency = function(\n      path, relativePath, provides, requires, loadFlags, needsTranspile) {\n\n    if (loadFlags['module'] == goog.ModuleType.GOOG) {\n      return new goog.GoogModuleDependency(\n          path, relativePath, provides, requires, loadFlags, needsTranspile,\n          this.transpiler);\n    } else if (needsTranspile) {\n      return new goog.TranspiledDependency(\n          path, relativePath, provides, requires, loadFlags, this.transpiler);\n    } else {\n      if (loadFlags['module'] == goog.ModuleType.ES6) {\n        if (goog.TRANSPILE == 'never' && goog.ASSUME_ES_MODULES_TRANSPILED) {\n          return new goog.PreTranspiledEs6ModuleDependency(\n              path, relativePath, provides, requires, loadFlags);\n        } else {\n          return new goog.Es6ModuleDependency(\n              path, relativePath, provides, requires, loadFlags);\n        }\n      } else {\n        return new goog.Dependency(\n            path, relativePath, provides, requires, loadFlags);\n      }\n    }\n  };\n\n\n  /** @private @const */\n  goog.debugLoader_ = new goog.DebugLoader_();\n\n\n  /**\n   * Loads the Closure Dependency file.\n   *\n   * Exposed a public function so CLOSURE_NO_DEPS can be set to false, base\n   * loaded, setDependencyFactory called, and then this called. i.e. allows\n   * custom loading of the deps file.\n   */\n  goog.loadClosureDeps = function() {\n    goog.debugLoader_.loadClosureDeps();\n  };\n\n\n  /**\n   * Sets the dependency factory, which can be used to create custom\n   * goog.Dependency implementations to control how dependencies are loaded.\n   *\n   * Note: if you wish to call this function and provide your own implemnetation\n   * it is a wise idea to set CLOSURE_NO_DEPS to true, otherwise the dependency\n   * file and all of its goog.addDependency calls will use the default factory.\n   * You can call goog.loadClosureDeps to load the Closure dependency file\n   * later, after your factory is injected.\n   *\n   * @param {!goog.DependencyFactory} factory\n   */\n  goog.setDependencyFactory = function(factory) {\n    goog.debugLoader_.setDependencyFactory(factory);\n  };\n\n\n  /**\n   * Trusted Types policy for the debug loader.\n   * @private @const {?TrustedTypePolicy}\n   */\n  goog.TRUSTED_TYPES_POLICY_ = goog.TRUSTED_TYPES_POLICY_NAME ?\n      goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME + '#base') :\n      null;\n\n  if (!goog.global.CLOSURE_NO_DEPS) {\n    goog.debugLoader_.loadClosureDeps();\n  }\n\n\n  /**\n   * Bootstraps the given namespaces and calls the callback once they are\n   * available either via goog.require. This is a replacement for using\n   * `goog.require` to bootstrap Closure JavaScript. Previously a `goog.require`\n   * in an HTML file would guarantee that the require'd namespace was available\n   * in the next immediate script tag. With ES6 modules this no longer a\n   * guarantee.\n   *\n   * @param {!Array<string>} namespaces\n   * @param {function(): ?} callback Function to call once all the namespaces\n   *     have loaded. Always called asynchronously.\n   */\n  goog.bootstrap = function(namespaces, callback) {\n    goog.debugLoader_.bootstrap(namespaces, callback);\n  };\n}\n\n\nif (!COMPILED) {\n  var isChrome87 = false;\n  // Cannot run check for Chrome <87 bug in case of strict CSP environments.\n  // TODO(user): Remove once Chrome <87 bug is no longer a problem.\n  try {\n    isChrome87 = eval(goog.global.trustedTypes.emptyScript) !==\n        goog.global.trustedTypes.emptyScript;\n  } catch (err) {\n  }\n\n  /**\n   * Trusted Types for running dev servers.\n   *\n   * @private @const\n   */\n  goog.CLOSURE_EVAL_PREFILTER_ =\n      // Detect Chrome <87 bug with TT and eval.\n      goog.global.trustedTypes && isChrome87 &&\n          goog.createTrustedTypesPolicy('goog#base#devonly#eval') ||\n      {createScript: goog.identity_};\n}\ngoog.ENABLE_DEBUG_LOADER = false;\nmodule.exports = goog;\n/* WEBPACK VAR INJECTION */}.call(this, window.goog = window.goog || {}))\n\n//# sourceURL=webpack:///./closure/goog/base.js?")},
"./core/block.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/extensions.js\");\n__webpack_require__(\"./core/tooltip.js\");\n__webpack_require__(\"./core/utils/array.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/constants.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/field_registry.js\");\n__webpack_require__(\"./core/utils/idgenerator.js\");\n__webpack_require__(\"./core/utils/object.js\");\n__webpack_require__(\"./core/utils/parsing.js\");\n__webpack_require__(\"./core/input.js\");\n__webpack_require__(\"./core/keyboard_nav/ast_node.js\");\n__webpack_require__(\"./core/blocks.js\");\n__webpack_require__(\"./core/connection_type.js\");\n__webpack_require__(\"./core/connection.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/interfaces/i_ast_node_location.js\");\n__webpack_require__(\"./core/interfaces/i_deletable.js\");\n__webpack_require__(\"./core/utils/size.js\");\n__webpack_require__(\"./core/input_types.js\");\n__webpack_require__(\"./core/events/events_block_change.js\");\n__webpack_require__(\"./core/events/events_block_create.js\");\n__webpack_require__(\"./core/events/events_block_delete.js\");\n__webpack_require__(\"./core/events/events_block_move.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2011 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing one block.\n */\n\n\n/**\n * The class representing one block.\n * @class\n */\ngoog.module('Blockly.Block');\n\nconst Extensions = goog.require('Blockly.Extensions');\nconst Tooltip = goog.require('Blockly.Tooltip');\nconst arrayUtils = goog.require('Blockly.utils.array');\nconst common = goog.require('Blockly.common');\nconst constants = goog.require('Blockly.constants');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst fieldRegistry = goog.require('Blockly.fieldRegistry');\nconst idGenerator = goog.require('Blockly.utils.idGenerator');\nconst object = goog.require('Blockly.utils.object');\nconst parsing = goog.require('Blockly.utils.parsing');\n/* eslint-disable-next-line no-unused-vars */\nconst {Abstract} = goog.requireType('Blockly.Events.Abstract');\nconst {Align, Input} = goog.require('Blockly.Input');\nconst {ASTNode} = goog.require('Blockly.ASTNode');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockMove} = goog.requireType('Blockly.Events.BlockMove');\nconst {Blocks} = goog.require('Blockly.blocks');\n/* eslint-disable-next-line no-unused-vars */\nconst {Comment} = goog.requireType('Blockly.Comment');\nconst {ConnectionType} = goog.require('Blockly.ConnectionType');\nconst {Connection} = goog.require('Blockly.Connection');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\n/* eslint-disable-next-line no-unused-vars */\nconst {Field} = goog.requireType('Blockly.Field');\n/* eslint-disable-next-line no-unused-vars */\nconst {IASTNodeLocation} = goog.require('Blockly.IASTNodeLocation');\n/* eslint-disable-next-line no-unused-vars */\nconst {IDeletable} = goog.require('Blockly.IDeletable');\n/* eslint-disable-next-line no-unused-vars */\nconst {Mutator} = goog.requireType('Blockly.Mutator');\nconst {Size} = goog.require('Blockly.utils.Size');\n/* eslint-disable-next-line no-unused-vars */\nconst {VariableModel} = goog.requireType('Blockly.VariableModel');\n/* eslint-disable-next-line no-unused-vars */\nconst {Workspace} = goog.requireType('Blockly.Workspace');\nconst {inputTypes} = goog.require('Blockly.inputTypes');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockChange');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockCreate');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockDelete');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockMove');\n\n\n/**\n * Class for one block.\n * Not normally called directly, workspace.newBlock() is preferred.\n * @implements {IASTNodeLocation}\n * @implements {IDeletable}\n * @unrestricted\n * @alias Blockly.Block\n */\nclass Block {\n  /**\n   * @param {!Workspace} workspace The block's workspace.\n   * @param {!string} prototypeName Name of the language object containing\n   *     type-specific functions for this block.\n   * @param {string=} opt_id Optional ID.  Use this ID if provided, otherwise\n   *     create a new ID.\n   * @throws When the prototypeName is not valid or not allowed.\n   */\n  constructor(workspace, prototypeName, opt_id) {\n    const {Generator} = goog.module.get('Blockly.Generator');\n    if (Generator &&\n        typeof Generator.prototype[prototypeName] !== 'undefined') {\n      // Occluding Generator class members is not allowed.\n      throw Error(\n          'Block prototypeName \"' + prototypeName +\n          '\" conflicts with Blockly.Generator members.');\n    }\n\n    /**\n     * Optional text data that round-trips between blocks and XML.\n     * Has no effect. May be used by 3rd parties for meta information.\n     * @type {?string}\n     */\n    this.data = null;\n\n    /**\n     * Has this block been disposed of?\n     * @type {boolean}\n     * @package\n     */\n    this.disposed = false;\n\n    /**\n     * Colour of the block as HSV hue value (0-360)\n     * This may be null if the block colour was not set via a hue number.\n     * @type {?number}\n     * @private\n     */\n    this.hue_ = null;\n\n    /**\n     * Colour of the block in '#RRGGBB' format.\n     * @type {string}\n     * @protected\n     */\n    this.colour_ = '#000000';\n\n    /**\n     * Name of the block style.\n     * @type {string}\n     * @protected\n     */\n    this.styleName_ = '';\n\n    /**\n     * An optional method called during initialization.\n     * @type {undefined|?function()}\n     */\n    this.init = undefined;\n\n    /**\n     * An optional serialization method for defining how to serialize the\n     * mutation state to XML. This must be coupled with defining\n     * `domToMutation`.\n     * @type {undefined|?function(...):!Element}\n     */\n    this.mutationToDom = undefined;\n\n    /**\n     * An optional deserialization method for defining how to deserialize the\n     * mutation state from XML. This must be coupled with defining\n     * `mutationToDom`.\n     * @type {undefined|?function(!Element)}\n     */\n    this.domToMutation = undefined;\n\n    /**\n     * An optional serialization method for defining how to serialize the\n     * block's extra state (eg mutation state) to something JSON compatible.\n     * This must be coupled with defining `loadExtraState`.\n     * @type {undefined|?function(): *}\n     */\n    this.saveExtraState = undefined;\n\n    /**\n     * An optional serialization method for defining how to deserialize the\n     * block's extra state (eg mutation state) from something JSON compatible.\n     * This must be coupled with defining `saveExtraState`.\n     * @type {undefined|?function(*)}\n     */\n    this.loadExtraState = undefined;\n\n\n    /**\n     * An optional property for suppressing adding STATEMENT_PREFIX and\n     * STATEMENT_SUFFIX to generated code.\n     * @type {?boolean}\n     */\n    this.suppressPrefixSuffix = false;\n\n    /**\n     * An optional property for declaring developer variables.  Return a list of\n     * variable names for use by generators.  Developer variables are never\n     * shown to the user, but are declared as global variables in the generated\n     * code.\n     * @type {undefined|?function():!Array<string>}\n     */\n    this.getDeveloperVariables = undefined;\n\n    /** @type {string} */\n    this.id = (opt_id && !workspace.getBlockById(opt_id)) ?\n        opt_id :\n        idGenerator.genUid();\n    workspace.setBlockById(this.id, this);\n    /** @type {Connection} */\n    this.outputConnection = null;\n    /** @type {Connection} */\n    this.nextConnection = null;\n    /** @type {Connection} */\n    this.previousConnection = null;\n    /** @type {!Array<!Input>} */\n    this.inputList = [];\n    /** @type {boolean|undefined} */\n    this.inputsInline = undefined;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.disabled = false;\n    /** @type {!Tooltip.TipInfo} */\n    this.tooltip = '';\n    /** @type {boolean} */\n    this.contextMenu = true;\n\n    /**\n     * @type {Block}\n     * @protected\n     */\n    this.parentBlock_ = null;\n\n    /**\n     * @type {!Array<!Block>}\n     * @protected\n     */\n    this.childBlocks_ = [];\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.deletable_ = true;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.movable_ = true;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.editable_ = true;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.isShadow_ = false;\n\n    /**\n     * @type {boolean}\n     * @protected\n     */\n    this.collapsed_ = false;\n\n    /**\n     * @type {?number}\n     * @protected\n     */\n    this.outputShape_ = null;\n\n    /**\n     * A string representing the comment attached to this block.\n     * @type {string|Comment}\n     * @deprecated August 2019. Use getCommentText instead.\n     */\n    this.comment = null;\n\n    /**\n     * A model of the comment attached to this block.\n     * @type {!Block.CommentModel}\n     * @package\n     */\n    this.commentModel = {text: null, pinned: false, size: new Size(160, 80)};\n\n    /**\n     * The block's position in workspace units.  (0, 0) is at the workspace's\n     * origin; scale does not change this value.\n     * @type {!Coordinate}\n     * @private\n     */\n    this.xy_ = new Coordinate(0, 0);\n\n    /** @type {!Workspace} */\n    this.workspace = workspace;\n    /** @type {boolean} */\n    this.isInFlyout = workspace.isFlyout;\n    /** @type {boolean} */\n    this.isInMutator = workspace.isMutator;\n\n    /** @type {boolean} */\n    this.RTL = workspace.RTL;\n\n    /**\n     * True if this block is an insertion marker.\n     * @type {boolean}\n     * @protected\n     */\n    this.isInsertionMarker_ = false;\n\n    /**\n     * Name of the type of hat.\n     * @type {string|undefined}\n     */\n    this.hat = undefined;\n\n    /** @type {?boolean} */\n    this.rendered = null;\n\n    /**\n     * String for block help, or function that returns a URL. Null for no help.\n     * @type {string|Function}\n     */\n    this.helpUrl = null;\n\n    /**\n     * A bound callback function to use when the parent workspace changes.\n     * @type {?function(Abstract)}\n     * @private\n     */\n    this.onchangeWrapper_ = null;\n\n    /**\n     * A count of statement inputs on the block.\n     * @type {number}\n     * @package\n     */\n    this.statementInputCount = 0;\n\n    // Copy the type-specific functions and data from the prototype.\n    if (prototypeName) {\n      /** @type {string} */\n      this.type = prototypeName;\n      const prototype = Blocks[prototypeName];\n      if (!prototype || typeof prototype !== 'object') {\n        throw TypeError('Invalid block definition for type: ' + prototypeName);\n      }\n      object.mixin(this, prototype);\n    }\n\n    workspace.addTopBlock(this);\n    workspace.addTypedBlock(this);\n\n    if (new.target === Block) this.doInit_();\n  }\n\n  /**\n   * Calls the init() function and handles associated event firing, etc.\n   * @protected\n   */\n  doInit_() {\n    // All events fired should be part of the same group.\n    // Any events fired during init should not be undoable,\n    // so that block creation is atomic.\n    const existingGroup = eventUtils.getGroup();\n    if (!existingGroup) {\n      eventUtils.setGroup(true);\n    }\n    const initialUndoFlag = eventUtils.getRecordUndo();\n\n    try {\n      // Call an initialization function, if it exists.\n      if (typeof this.init === 'function') {\n        eventUtils.setRecordUndo(false);\n        this.init();\n        eventUtils.setRecordUndo(initialUndoFlag);\n      }\n\n      // Fire a create event.\n      if (eventUtils.isEnabled()) {\n        eventUtils.fire(new (eventUtils.get(eventUtils.BLOCK_CREATE))(this));\n      }\n    } finally {\n      if (!existingGroup) {\n        eventUtils.setGroup(false);\n      }\n      // In case init threw, recordUndo flag should still be reset.\n      eventUtils.setRecordUndo(initialUndoFlag);\n    }\n\n    // Record initial inline state.\n    /** @type {boolean|undefined} */\n    this.inputsInlineDefault = this.inputsInline;\n\n    // Bind an onchange function, if it exists.\n    if (typeof this.onchange === 'function') {\n      this.setOnChange(this.onchange);\n    }\n  }\n\n  /**\n   * Dispose of this block.\n   * @param {boolean} healStack If true, then try to heal any gap by connecting\n   *     the next statement with the previous statement.  Otherwise, dispose of\n   *     all children of this block.\n   * @suppress {checkTypes}\n   */\n  dispose(healStack) {\n    if (!this.workspace) {\n      // Already deleted.\n      return;\n    }\n    // Terminate onchange event calls.\n    if (this.onchangeWrapper_) {\n      this.workspace.removeChangeListener(this.onchangeWrapper_);\n    }\n\n    this.unplug(healStack);\n    if (eventUtils.isEnabled()) {\n      eventUtils.fire(new (eventUtils.get(eventUtils.BLOCK_DELETE))(this));\n    }\n    eventUtils.disable();\n\n    try {\n      // This block is now at the top of the workspace.\n      // Remove this block from the workspace's list of top-most blocks.\n      if (this.workspace) {\n        this.workspace.removeTopBlock(this);\n        this.workspace.removeTypedBlock(this);\n        // Remove from block database.\n        this.workspace.removeBlockById(this.id);\n        this.workspace = null;\n      }\n\n      // Just deleting this block from the DOM would result in a memory leak as\n      // well as corruption of the connection database.  Therefore we must\n      // methodically step through the blocks and carefully disassemble them.\n\n      if (common.getSelected() === this) {\n        common.setSelected(null);\n      }\n\n      // First, dispose of all my children.\n      for (let i = this.childBlocks_.length - 1; i >= 0; i--) {\n        this.childBlocks_[i].dispose(false);\n      }\n      // Then dispose of myself.\n      // Dispose of all inputs and their fields.\n      for (let i = 0, input; (input = this.inputList[i]); i++) {\n        input.dispose();\n      }\n      this.inputList.length = 0;\n      // Dispose of any remaining connections (next/previous/output).\n      const connections = this.getConnections_(true);\n      for (let i = 0, connection; (connection = connections[i]); i++) {\n        connection.dispose();\n      }\n    } finally {\n      eventUtils.enable();\n      this.disposed = true;\n    }\n  }\n\n  /**\n   * Call initModel on all fields on the block.\n   * May be called more than once.\n   * Either initModel or initSvg must be called after creating a block and\n   * before the first interaction with it.  Interactions include UI actions\n   * (e.g. clicking and dragging) and firing events (e.g. create, delete, and\n   * change).\n   * @public\n   */\n  initModel() {\n    for (let i = 0, input; (input = this.inputList[i]); i++) {\n      for (let j = 0, field; (field = input.fieldRow[j]); j++) {\n        if (field.initModel) {\n          field.initModel();\n        }\n      }\n    }\n  }\n\n  /**\n   * Unplug this block from its superior block.  If this block is a statement,\n   * optionally reconnect the block underneath with the block on top.\n   * @param {boolean=} opt_healStack Disconnect child statement and reconnect\n   *   stack.  Defaults to false.\n   */\n  unplug(opt_healStack) {\n    if (this.outputConnection) {\n      this.unplugFromRow_(opt_healStack);\n    }\n    if (this.previousConnection) {\n      this.unplugFromStack_(opt_healStack);\n    }\n  }\n\n  /**\n   * Unplug this block's output from an input on another block.  Optionally\n   * reconnect the block's parent to the only child block, if possible.\n   * @param {boolean=} opt_healStack Disconnect right-side block and connect to\n   *     left-side block.  Defaults to false.\n   * @private\n   */\n  unplugFromRow_(opt_healStack) {\n    let parentConnection = null;\n    if (this.outputConnection.isConnected()) {\n      parentConnection = this.outputConnection.targetConnection;\n      // Disconnect from any superior block.\n      this.outputConnection.disconnect();\n    }\n\n    // Return early in obvious cases.\n    if (!parentConnection || !opt_healStack) {\n      return;\n    }\n\n    const thisConnection = this.getOnlyValueConnection_();\n    if (!thisConnection || !thisConnection.isConnected() ||\n        thisConnection.targetBlock().isShadow()) {\n      // Too many or too few possible connections on this block, or there's\n      // nothing on the other side of this connection.\n      return;\n    }\n\n    const childConnection = thisConnection.targetConnection;\n    // Disconnect the child block.\n    childConnection.disconnect();\n    // Connect child to the parent if possible, otherwise bump away.\n    if (this.workspace.connectionChecker.canConnect(\n            childConnection, parentConnection, false)) {\n      parentConnection.connect(childConnection);\n    } else {\n      childConnection.onFailedConnect(parentConnection);\n    }\n  }\n\n  /**\n   * Returns the connection on the value input that is connected to another\n   * block. When an insertion marker is connected to a connection with a block\n   * already attached, the connected block is attached to the insertion marker.\n   * Since only one block can be displaced and attached to the insertion marker\n   * this should only ever return one connection.\n   *\n   * @return {?Connection} The connection on the value input, or null.\n   * @private\n   */\n  getOnlyValueConnection_() {\n    let connection = null;\n    for (let i = 0; i < this.inputList.length; i++) {\n      const thisConnection = this.inputList[i].connection;\n      if (thisConnection &&\n          thisConnection.type === ConnectionType.INPUT_VALUE &&\n          thisConnection.targetConnection) {\n        if (connection) {\n          return null;  // More than one value input found.\n        }\n        connection = thisConnection;\n      }\n    }\n    return connection;\n  }\n\n  /**\n   * Unplug this statement block from its superior block.  Optionally reconnect\n   * the block underneath with the block on top.\n   * @param {boolean=} opt_healStack Disconnect child statement and reconnect\n   *   stack.  Defaults to false.\n   * @private\n   */\n  unplugFromStack_(opt_healStack) {\n    let previousTarget = null;\n    if (this.previousConnection.isConnected()) {\n      // Remember the connection that any next statements need to connect to.\n      previousTarget = this.previousConnection.targetConnection;\n      // Detach this block from the parent's tree.\n      this.previousConnection.disconnect();\n    }\n    const nextBlock = this.getNextBlock();\n    if (opt_healStack && nextBlock && !nextBlock.isShadow()) {\n      // Disconnect the next statement.\n      const nextTarget = this.nextConnection.targetConnection;\n      nextTarget.disconnect();\n      if (previousTarget &&\n          this.workspace.connectionChecker.canConnect(\n              previousTarget, nextTarget, false)) {\n        // Attach the next statement to the previous statement.\n        previousTarget.connect(nextTarget);\n      }\n    }\n  }\n\n  /**\n   * Returns all connections originating from this block.\n   * @param {boolean} _all If true, return all connections even hidden ones.\n   * @return {!Array<!Connection>} Array of connections.\n   * @package\n   */\n  getConnections_(_all) {\n    const myConnections = [];\n    if (this.outputConnection) {\n      myConnections.push(this.outputConnection);\n    }\n    if (this.previousConnection) {\n      myConnections.push(this.previousConnection);\n    }\n    if (this.nextConnection) {\n      myConnections.push(this.nextConnection);\n    }\n    for (let i = 0, input; (input = this.inputList[i]); i++) {\n      if (input.connection) {\n        myConnections.push(input.connection);\n      }\n    }\n    return myConnections;\n  }\n\n  /**\n   * Walks down a stack of blocks and finds the last next connection on the\n   * stack.\n   * @param {boolean} ignoreShadows If true,the last connection on a non-shadow\n   *     block will be returned. If false, this will follow shadows to find the\n   *     last connection.\n   * @return {?Connection} The last next connection on the stack, or null.\n   * @package\n   */\n  lastConnectionInStack(ignoreShadows) {\n    let nextConnection = this.nextConnection;\n    while (nextConnection) {\n      const nextBlock = nextConnection.targetBlock();\n      if (!nextBlock || (ignoreShadows && nextBlock.isShadow())) {\n        return nextConnection;\n      }\n      nextConnection = nextBlock.nextConnection;\n    }\n    return null;\n  }\n\n  /**\n   * Bump unconnected blocks out of alignment.  Two blocks which aren't actually\n   * connected should not coincidentally line up on screen.\n   */\n  bumpNeighbours() {\n    // noop.\n  }\n\n  /**\n   * Return the parent block or null if this block is at the top level. The\n   * parent block is either the block connected to the previous connection (for\n   * a statement block) or the block connected to the output connection (for a\n   * value block).\n   * @return {?Block} The block (if any) that holds the current block.\n   */\n  getParent() {\n    return this.parentBlock_;\n  }\n\n  /**\n   * Return the input that connects to the specified block.\n   * @param {!Block} block A block connected to an input on this block.\n   * @return {?Input} The input (if any) that connects to the specified\n   *     block.\n   */\n  getInputWithBlock(block) {\n    for (let i = 0, input; (input = this.inputList[i]); i++) {\n      if (input.connection && input.connection.targetBlock() === block) {\n        return input;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Return the parent block that surrounds the current block, or null if this\n   * block has no surrounding block.  A parent block might just be the previous\n   * statement, whereas the surrounding block is an if statement, while loop,\n   * etc.\n   * @return {?Block} The block (if any) that surrounds the current block.\n   */\n  getSurroundParent() {\n    let block = this;\n    let prevBlock;\n    do {\n      prevBlock = block;\n      block = block.getParent();\n      if (!block) {\n        // Ran off the top.\n        return null;\n      }\n    } while (block.getNextBlock() === prevBlock);\n    // This block is an enclosing parent, not just a statement in a stack.\n    return block;\n  }\n\n  /**\n   * Return the next statement block directly connected to this block.\n   * @return {?Block} The next statement block or null.\n   */\n  getNextBlock() {\n    return this.nextConnection && this.nextConnection.targetBlock();\n  }\n\n  /**\n   * Returns the block connected to the previous connection.\n   * @return {?Block} The previous statement block or null.\n   */\n  getPreviousBlock() {\n    return this.previousConnection && this.previousConnection.targetBlock();\n  }\n\n  /**\n   * Return the connection on the first statement input on this block, or null\n   * if there are none.\n   * @return {?Connection} The first statement connection or null.\n   * @package\n   */\n  getFirstStatementConnection() {\n    for (let i = 0, input; (input = this.inputList[i]); i++) {\n      if (input.connection &&\n          input.connection.type === ConnectionType.NEXT_STATEMENT) {\n        return input.connection;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Return the top-most block in this block's tree.\n   * This will return itself if this block is at the top level.\n   * @return {!Block} The root block.\n   */\n  getRootBlock() {\n    let rootBlock;\n    let block = this;\n    do {\n      rootBlock = block;\n      block = rootBlock.parentBlock_;\n    } while (block);\n    return rootBlock;\n  }\n\n  /**\n   * Walk up from the given block up through the stack of blocks to find\n   * the top block of the sub stack. If we are nested in a statement input only\n   * find the top-most nested block. Do not go all the way to the root block.\n   * @return {!Block} The top block in a stack.\n   * @package\n   */\n  getTopStackBlock() {\n    let block = this;\n    let previous;\n    do {\n      previous = block.getPreviousBlock();\n    } while (previous && previous.getNextBlock() === block &&\n             (block = previous));\n    return block;\n  }\n\n  /**\n   * Find all the blocks that are directly nested inside this one.\n   * Includes value and statement inputs, as well as any following statement.\n   * Excludes any connection on an output tab or any preceding statement.\n   * Blocks are optionally sorted by position; top to bottom.\n   * @param {boolean} ordered Sort the list if true.\n   * @return {!Array<!Block>} Array of blocks.\n   */\n  getChildren(ordered) {\n    if (!ordered) {\n      return this.childBlocks_;\n    }\n    const blocks = [];\n    for (let i = 0, input; (input = this.inputList[i]); i++) {\n      if (input.connection) {\n        const child = input.connection.targetBlock();\n        if (child) {\n          blocks.push(child);\n        }\n      }\n    }\n    const next = this.getNextBlock();\n    if (next) {\n      blocks.push(next);\n    }\n    return blocks;\n  }\n\n  /**\n   * Set parent of this block to be a new block or null.\n   * @param {Block} newParent New parent block.\n   * @package\n   */\n  setParent(newParent) {\n    if (newParent === this.parentBlock_) {\n      return;\n    }\n\n    // Check that block is connected to new parent if new parent is not null and\n    //    that block is not connected to superior one if new parent is null.\n    const targetBlock =\n        (this.previousConnection && this.previousConnection.targetBlock()) ||\n        (this.outputConnection && this.outputConnection.targetBlock());\n    const isConnected = !!targetBlock;\n\n    if (isConnected && newParent && targetBlock !== newParent) {\n      throw Error('Block connected to superior one that is not new parent.');\n    } else if (!isConnected && newParent) {\n      throw Error('Block not connected to new parent.');\n    } else if (isConnected && !newParent) {\n      throw Error(\n          'Cannot set parent to null while block is still connected to' +\n          ' superior block.');\n    }\n\n    if (this.parentBlock_) {\n      // Remove this block from the old parent's child list.\n      arrayUtils.removeElem(this.parentBlock_.childBlocks_, this);\n\n      // This block hasn't actually moved on-screen, so there's no need to\n      // update\n      //     its connection locations.\n    } else {\n      // New parent must be non-null so remove this block from the workspace's\n      //     list of top-most blocks.\n      this.workspace.removeTopBlock(this);\n    }\n\n    this.parentBlock_ = newParent;\n    if (newParent) {\n      // Add this block to the new parent's child list.\n      newParent.childBlocks_.push(this);\n    } else {\n      this.workspace.addTopBlock(this);\n    }\n  }\n\n  /**\n   * Find all the blocks that are directly or indirectly nested inside this one.\n   * Includes this block in the list.\n   * Includes value and statement inputs, as well as any following statements.\n   * Excludes any connection on an output tab or any preceding statements.\n   * Blocks are optionally sorted by position; top to bottom.\n   * @param {boolean} ordered Sort the list if true.\n   * @return {!Array<!Block>} Flattened array of blocks.\n   */\n  getDescendants(ordered) {\n    const blocks = [this];\n    const childBlocks = this.getChildren(ordered);\n    for (let child, i = 0; (child = childBlocks[i]); i++) {\n      blocks.push.apply(blocks, child.getDescendants(ordered));\n    }\n    return blocks;\n  }\n\n  /**\n   * Get whether this block is deletable or not.\n   * @return {boolean} True if deletable.\n   */\n  isDeletable() {\n    return this.deletable_ && !this.isShadow_ &&\n        !(this.workspace && this.workspace.options.readOnly);\n  }\n\n  /**\n   * Set whether this block is deletable or not.\n   * @param {boolean} deletable True if deletable.\n   */\n  setDeletable(deletable) {\n    this.deletable_ = deletable;\n  }\n\n  /**\n   * Get whether this block is movable or not.\n   * @return {boolean} True if movable.\n   */\n  isMovable() {\n    return this.movable_ && !this.isShadow_ &&\n        !(this.workspace && this.workspace.options.readOnly);\n  }\n\n  /**\n   * Set whether this block is movable or not.\n   * @param {boolean} movable True if movable.\n   */\n  setMovable(movable) {\n    this.movable_ = movable;\n  }\n\n  /**\n   * Get whether is block is duplicatable or not. If duplicating this block and\n   * descendants will put this block over the workspace's capacity this block is\n   * not duplicatable. If duplicating this block and descendants will put any\n   * type over their maxInstances this block is not duplicatable.\n   * @return {boolean} True if duplicatable.\n   */\n  isDuplicatable() {\n    if (!this.workspace.hasBlockLimits()) {\n      return true;\n    }\n    return this.workspace.isCapacityAvailable(\n        common.getBlockTypeCounts(this, true));\n  }\n\n  /**\n   * Get whether this block is a shadow block or not.\n   * @return {boolean} True if a shadow.\n   */\n  isShadow() {\n    return this.isShadow_;\n  }\n\n  /**\n   * Set whether this block is a shadow block or not.\n   * @param {boolean} shadow True if a shadow.\n   * @package\n   */\n  setShadow(shadow) {\n    this.isShadow_ = shadow;\n  }\n\n  /**\n   * Get whether this block is an insertion marker block or not.\n   * @return {boolean} True if an insertion marker.\n   */\n  isInsertionMarker() {\n    return this.isInsertionMarker_;\n  }\n\n  /**\n   * Set whether this block is an insertion marker block or not.\n   * Once set this cannot be unset.\n   * @param {boolean} insertionMarker True if an insertion marker.\n   * @package\n   */\n  setInsertionMarker(insertionMarker) {\n    this.isInsertionMarker_ = insertionMarker;\n  }\n\n  /**\n   * Get whether this block is editable or not.\n   * @return {boolean} True if editable.\n   */\n  isEditable() {\n    return this.editable_ &&\n        !(this.workspace && this.workspace.options.readOnly);\n  }\n\n  /**\n   * Set whether this block is editable or not.\n   * @param {boolean} editable True if editable.\n   */\n  setEditable(editable) {\n    this.editable_ = editable;\n    for (let i = 0, input; (input = this.inputList[i]); i++) {\n      for (let j = 0, field; (field = input.fieldRow[j]); j++) {\n        field.updateEditable();\n      }\n    }\n  }\n\n  /**\n   * Returns if this block has been disposed of / deleted.\n   * @return {boolean} True if this block has been disposed of / deleted.\n   */\n  isDisposed() {\n    return this.disposed;\n  }\n\n  /**\n   * Find the connection on this block that corresponds to the given connection\n   * on the other block.\n   * Used to match connections between a block and its insertion marker.\n   * @param {!Block} otherBlock The other block to match against.\n   * @param {!Connection} conn The other connection to match.\n   * @return {?Connection} The matching connection on this block, or null.\n   * @package\n   */\n  getMatchingConnection(otherBlock, conn) {\n    const connections = this.getConnections_(true);\n    const otherConnections = otherBlock.getConnections_(true);\n    if (connections.length !== otherConnections.length) {\n      throw Error('Connection lists did not match in length.');\n    }\n    for (let i = 0; i < otherConnections.length; i++) {\n      if (otherConnections[i] === conn) {\n        return connections[i];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Set the URL of this block's help page.\n   * @param {string|Function} url URL string for block help, or function that\n   *     returns a URL.  Null for no help.\n   */\n  setHelpUrl(url) {\n    this.helpUrl = url;\n  }\n\n  /**\n   * Sets the tooltip for this block.\n   * @param {!Tooltip.TipInfo} newTip The text for the tooltip, a function\n   *     that returns the text for the tooltip, or a parent object whose tooltip\n   *     will be used. To not display a tooltip pass the empty string.\n   */\n  setTooltip(newTip) {\n    this.tooltip = newTip;\n  }\n\n  /**\n   * Returns the tooltip text for this block.\n   * @return {!string} The tooltip text for this block.\n   */\n  getTooltip() {\n    return Tooltip.getTooltipOfObject(this);\n  }\n\n  /**\n   * Get the colour of a block.\n   * @return {string} #RRGGBB string.\n   */\n  getColour() {\n    return this.colour_;\n  }\n\n  /**\n   * Get the name of the block style.\n   * @return {string} Name of the block style.\n   */\n  getStyleName() {\n    return this.styleName_;\n  }\n\n  /**\n   * Get the HSV hue value of a block.  Null if hue not set.\n   * @return {?number} Hue value (0-360).\n   */\n  getHue() {\n    return this.hue_;\n  }\n\n  /**\n   * Change the colour of a block.\n   * @param {number|string} colour HSV hue value (0 to 360), #RRGGBB string,\n   *     or a message reference string pointing to one of those two values.\n   */\n  setColour(colour) {\n    const parsed = parsing.parseBlockColour(colour);\n    this.hue_ = parsed.hue;\n    this.colour_ = parsed.hex;\n  }\n\n  /**\n   * Set the style and colour values of a block.\n   * @param {string} blockStyleName Name of the block style.\n   */\n  setStyle(blockStyleName) {\n    this.styleName_ = blockStyleName;\n  }\n\n  /**\n   * Sets a callback function to use whenever the block's parent workspace\n   * changes, replacing any prior onchange handler. This is usually only called\n   * from the constructor, the block type initializer function, or an extension\n   * initializer function.\n   * @param {function(Abstract)} onchangeFn The callback to call\n   *     when the block's workspace changes.\n   * @throws {Error} if onchangeFn is not falsey and not a function.\n   */\n  setOnChange(onchangeFn) {\n    if (onchangeFn && typeof onchangeFn !== 'function') {\n      throw Error('onchange must be a function.');\n    }\n    if (this.onchangeWrapper_) {\n      this.workspace.removeChangeListener(this.onchangeWrapper_);\n    }\n    this.onchange = onchangeFn;\n    if (this.onchange) {\n      this.onchangeWrapper_ = onchangeFn.bind(this);\n      this.workspace.addChangeListener(this.onchangeWrapper_);\n    }\n  }\n\n  /**\n   * Returns the named field from a block.\n   * @param {string} name The name of the field.\n   * @return {?Field} Named field, or null if field does not exist.\n   */\n  getField(name) {\n    if (typeof name !== 'string') {\n      throw TypeError(\n          'Block.prototype.getField expects a string ' +\n          'with the field name but received ' +\n          (name === undefined ? 'nothing' : name + ' of type ' + typeof name) +\n          ' instead');\n    }\n    for (let i = 0, input; (input = this.inputList[i]); i++) {\n      for (let j = 0, field; (field = input.fieldRow[j]); j++) {\n        if (field.name === name) {\n          return field;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Return all variables referenced by this block.\n   * @return {!Array<string>} List of variable ids.\n   */\n  getVars() {\n    const vars = [];\n    for (let i = 0, input; (input = this.inputList[i]); i++) {\n      for (let j = 0, field; (field = input.fieldRow[j]); j++) {\n        if (field.referencesVariables()) {\n          vars.push(field.getValue());\n        }\n      }\n    }\n    return vars;\n  }\n\n  /**\n   * Return all variables referenced by this block.\n   * @return {!Array<!VariableModel>} List of variable models.\n   * @package\n   */\n  getVarModels() {\n    const vars = [];\n    for (let i = 0, input; (input = this.inputList[i]); i++) {\n      for (let j = 0, field; (field = input.fieldRow[j]); j++) {\n        if (field.referencesVariables()) {\n          const model = this.workspace.getVariableById(\n              /** @type {string} */ (field.getValue()));\n          // Check if the variable actually exists (and isn't just a potential\n          // variable).\n          if (model) {\n            vars.push(model);\n          }\n        }\n      }\n    }\n    return vars;\n  }\n\n  /**\n   * Notification that a variable is renaming but keeping the same ID.  If the\n   * variable is in use on this block, rerender to show the new name.\n   * @param {!VariableModel} variable The variable being renamed.\n   * @package\n   */\n  updateVarName(variable) {\n    for (let i = 0, input; (input = this.inputList[i]); i++) {\n      for (let j = 0, field; (field = input.fieldRow[j]); j++) {\n        if (field.referencesVariables() &&\n            variable.getId() === field.getValue()) {\n          field.refreshVariableName();\n        }\n      }\n    }\n  }\n\n  /**\n   * Notification that a variable is renaming.\n   * If the ID matches one of this block's variables, rename it.\n   * @param {string} oldId ID of variable to rename.\n   * @param {string} newId ID of new variable.  May be the same as oldId, but\n   *     with an updated name.\n   */\n  renameVarById(oldId, newId) {\n    for (let i = 0, input; (input = this.inputList[i]); i++) {\n      for (let j = 0, field; (field = input.fieldRow[j]); j++) {\n        if (field.referencesVariables() && oldId === field.getValue()) {\n          field.setValue(newId);\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns the language-neutral value of the given field.\n   * @param {string} name The name of the field.\n   * @return {*} Value of the field or null if field does not exist.\n   */\n  getFieldValue(name) {\n    const field = this.getField(name);\n    if (field) {\n      return field.getValue();\n    }\n    return null;\n  }\n\n  /**\n   * Sets the value of the given field for this block.\n   * @param {*} newValue The value to set.\n   * @param {string} name The name of the field to set the value of.\n   */\n  setFieldValue(newValue, name) {\n    const field = this.getField(name);\n    if (!field) {\n      throw Error('Field \"' + name + '\" not found.');\n    }\n    field.setValue(newValue);\n  }\n\n  /**\n   * Set whether this block can chain onto the bottom of another block.\n   * @param {boolean} newBoolean True if there can be a previous statement.\n   * @param {(string|Array<string>|null)=} opt_check Statement type or\n   *     list of statement types.  Null/undefined if any type could be\n   * connected.\n   */\n  setPreviousStatement(newBoolean, opt_check) {\n    if (newBoolean) {\n      if (opt_check === undefined) {\n        opt_check = null;\n      }\n      if (!this.previousConnection) {\n        this.previousConnection =\n            this.makeConnection_(ConnectionType.PREVIOUS_STATEMENT);\n      }\n      this.previousConnection.setCheck(opt_check);\n    } else {\n      if (this.previousConnection) {\n        if (this.previousConnection.isConnected()) {\n          throw Error(\n              'Must disconnect previous statement before removing ' +\n              'connection.');\n        }\n        this.previousConnection.dispose();\n        this.previousConnection = null;\n      }\n    }\n  }\n\n  /**\n   * Set whether another block can chain onto the bottom of this block.\n   * @param {boolean} newBoolean True if there can be a next statement.\n   * @param {(string|Array<string>|null)=} opt_check Statement type or\n   *     list of statement types.  Null/undefined if any type could be\n   * connected.\n   */\n  setNextStatement(newBoolean, opt_check) {\n    if (newBoolean) {\n      if (opt_check === undefined) {\n        opt_check = null;\n      }\n      if (!this.nextConnection) {\n        this.nextConnection =\n            this.makeConnection_(ConnectionType.NEXT_STATEMENT);\n      }\n      this.nextConnection.setCheck(opt_check);\n    } else {\n      if (this.nextConnection) {\n        if (this.nextConnection.isConnected()) {\n          throw Error(\n              'Must disconnect next statement before removing ' +\n              'connection.');\n        }\n        this.nextConnection.dispose();\n        this.nextConnection = null;\n      }\n    }\n  }\n\n  /**\n   * Set whether this block returns a value.\n   * @param {boolean} newBoolean True if there is an output.\n   * @param {(string|Array<string>|null)=} opt_check Returned type or list\n   *     of returned types.  Null or undefined if any type could be returned\n   *     (e.g. variable get).\n   */\n  setOutput(newBoolean, opt_check) {\n    if (newBoolean) {\n      if (opt_check === undefined) {\n        opt_check = null;\n      }\n      if (!this.outputConnection) {\n        this.outputConnection =\n            this.makeConnection_(ConnectionType.OUTPUT_VALUE);\n      }\n      this.outputConnection.setCheck(opt_check);\n    } else {\n      if (this.outputConnection) {\n        if (this.outputConnection.isConnected()) {\n          throw Error(\n              'Must disconnect output value before removing connection.');\n        }\n        this.outputConnection.dispose();\n        this.outputConnection = null;\n      }\n    }\n  }\n\n  /**\n   * Set whether value inputs are arranged horizontally or vertically.\n   * @param {boolean} newBoolean True if inputs are horizontal.\n   */\n  setInputsInline(newBoolean) {\n    if (this.inputsInline !== newBoolean) {\n      eventUtils.fire(new (eventUtils.get(eventUtils.BLOCK_CHANGE))(\n          this, 'inline', null, this.inputsInline, newBoolean));\n      this.inputsInline = newBoolean;\n    }\n  }\n\n  /**\n   * Get whether value inputs are arranged horizontally or vertically.\n   * @return {boolean} True if inputs are horizontal.\n   */\n  getInputsInline() {\n    if (this.inputsInline !== undefined) {\n      // Set explicitly.\n      return this.inputsInline;\n    }\n    // Not defined explicitly.  Figure out what would look best.\n    for (let i = 1; i < this.inputList.length; i++) {\n      if (this.inputList[i - 1].type === inputTypes.DUMMY &&\n          this.inputList[i].type === inputTypes.DUMMY) {\n        // Two dummy inputs in a row.  Don't inline them.\n        return false;\n      }\n    }\n    for (let i = 1; i < this.inputList.length; i++) {\n      if (this.inputList[i - 1].type === inputTypes.VALUE &&\n          this.inputList[i].type === inputTypes.DUMMY) {\n        // Dummy input after a value input.  Inline them.\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Set the block's output shape.\n   * @param {?number} outputShape Value representing an output shape.\n   */\n  setOutputShape(outputShape) {\n    this.outputShape_ = outputShape;\n  }\n\n  /**\n   * Get the block's output shape.\n   * @return {?number} Value representing output shape if one exists.\n   */\n  getOutputShape() {\n    return this.outputShape_;\n  }\n\n  /**\n   * Get whether this block is enabled or not.\n   * @return {boolean} True if enabled.\n   */\n  isEnabled() {\n    return !this.disabled;\n  }\n\n  /**\n   * Set whether the block is enabled or not.\n   * @param {boolean} enabled True if enabled.\n   */\n  setEnabled(enabled) {\n    if (this.isEnabled() !== enabled) {\n      const oldValue = this.disabled;\n      this.disabled = !enabled;\n      eventUtils.fire(new (eventUtils.get(eventUtils.BLOCK_CHANGE))(\n          this, 'disabled', null, oldValue, !enabled));\n    }\n  }\n\n  /**\n   * Get whether the block is disabled or not due to parents.\n   * The block's own disabled property is not considered.\n   * @return {boolean} True if disabled.\n   */\n  getInheritedDisabled() {\n    let ancestor = this.getSurroundParent();\n    while (ancestor) {\n      if (ancestor.disabled) {\n        return true;\n      }\n      ancestor = ancestor.getSurroundParent();\n    }\n    // Ran off the top.\n    return false;\n  }\n\n  /**\n   * Get whether the block is collapsed or not.\n   * @return {boolean} True if collapsed.\n   */\n  isCollapsed() {\n    return this.collapsed_;\n  }\n\n  /**\n   * Set whether the block is collapsed or not.\n   * @param {boolean} collapsed True if collapsed.\n   */\n  setCollapsed(collapsed) {\n    if (this.collapsed_ !== collapsed) {\n      eventUtils.fire(new (eventUtils.get(eventUtils.BLOCK_CHANGE))(\n          this, 'collapsed', null, this.collapsed_, collapsed));\n      this.collapsed_ = collapsed;\n    }\n  }\n\n  /**\n   * Create a human-readable text representation of this block and any children.\n   * @param {number=} opt_maxLength Truncate the string to this length.\n   * @param {string=} opt_emptyToken The placeholder string used to denote an\n   *     empty field. If not specified, '?' is used.\n   * @return {string} Text of block.\n   */\n  toString(opt_maxLength, opt_emptyToken) {\n    let text = [];\n    const emptyFieldPlaceholder = opt_emptyToken || '?';\n\n    // Temporarily set flag to navigate to all fields.\n    const prevNavigateFields = ASTNode.NAVIGATE_ALL_FIELDS;\n    ASTNode.NAVIGATE_ALL_FIELDS = true;\n\n    let node = ASTNode.createBlockNode(this);\n    const rootNode = node;\n\n    /**\n     * Whether or not to add parentheses around an input.\n     * @param {!Connection} connection The connection.\n     * @return {boolean} True if we should add parentheses around the input.\n     */\n    function shouldAddParentheses(connection) {\n      let checks = connection.getCheck();\n      if (!checks && connection.targetConnection) {\n        checks = connection.targetConnection.getCheck();\n      }\n      return !!checks &&\n          (checks.indexOf('Boolean') !== -1 || checks.indexOf('Number') !== -1);\n    }\n\n    /**\n     * Check that we haven't circled back to the original root node.\n     */\n    function checkRoot() {\n      if (node && node.getType() === rootNode.getType() &&\n          node.getLocation() === rootNode.getLocation()) {\n        node = null;\n      }\n    }\n\n    // Traverse the AST building up our text string.\n    while (node) {\n      switch (node.getType()) {\n        case ASTNode.types.INPUT: {\n          const connection = /** @type {!Connection} */ (node.getLocation());\n          if (!node.in()) {\n            text.push(emptyFieldPlaceholder);\n          } else if (shouldAddParentheses(connection)) {\n            text.push('(');\n          }\n          break;\n        }\n        case ASTNode.types.FIELD: {\n          const field = /** @type {Field} */ (node.getLocation());\n          if (field.name !== constants.COLLAPSED_FIELD_NAME) {\n            text.push(field.getText());\n          }\n          break;\n        }\n      }\n\n      const current = node;\n      node = current.in() || current.next();\n      if (!node) {\n        // Can't go in or next, keep going out until we can go next.\n        node = current.out();\n        checkRoot();\n        while (node && !node.next()) {\n          node = node.out();\n          checkRoot();\n          // If we hit an input on the way up, possibly close out parentheses.\n          if (node && node.getType() === ASTNode.types.INPUT &&\n              shouldAddParentheses(\n                  /** @type {!Connection} */ (node.getLocation()))) {\n            text.push(')');\n          }\n        }\n        if (node) {\n          node = node.next();\n        }\n      }\n    }\n\n    // Restore state of NAVIGATE_ALL_FIELDS.\n    ASTNode.NAVIGATE_ALL_FIELDS = prevNavigateFields;\n\n    // Run through our text array and simplify expression to remove parentheses\n    // around single field blocks.\n    // E.g. ['repeat', '(', '10', ')', 'times', 'do', '?']\n    for (let i = 2; i < text.length; i++) {\n      if (text[i - 2] === '(' && text[i] === ')') {\n        text[i - 2] = text[i - 1];\n        text.splice(i - 1, 2);\n      }\n    }\n\n    // Join the text array, removing spaces around added parentheses.\n    text = text.reduce(function(acc, value) {\n      return acc + ((acc.substr(-1) === '(' || value === ')') ? '' : ' ') +\n          value;\n    }, '');\n    text = text.trim() || '???';\n    if (opt_maxLength) {\n      // TODO: Improve truncation so that text from this block is given\n      // priority. E.g. \"1+2+3+4+5+6+7+8+9=0\" should be \"...6+7+8+9=0\", not\n      // \"1+2+3+4+5...\". E.g. \"1+2+3+4+5=6+7+8+9+0\" should be \"...4+5=6+7...\".\n      if (text.length > opt_maxLength) {\n        text = text.substring(0, opt_maxLength - 3) + '...';\n      }\n    }\n    return text;\n  }\n\n  /**\n   * Shortcut for appending a value input row.\n   * @param {string} name Language-neutral identifier which may used to find\n   *     this input again.  Should be unique to this block.\n   * @return {!Input} The input object created.\n   */\n  appendValueInput(name) {\n    return this.appendInput_(inputTypes.VALUE, name);\n  }\n\n  /**\n   * Shortcut for appending a statement input row.\n   * @param {string} name Language-neutral identifier which may used to find\n   *     this input again.  Should be unique to this block.\n   * @return {!Input} The input object created.\n   */\n  appendStatementInput(name) {\n    return this.appendInput_(inputTypes.STATEMENT, name);\n  }\n\n  /**\n   * Shortcut for appending a dummy input row.\n   * @param {string=} opt_name Language-neutral identifier which may used to\n   *     find this input again.  Should be unique to this block.\n   * @return {!Input} The input object created.\n   */\n  appendDummyInput(opt_name) {\n    return this.appendInput_(inputTypes.DUMMY, opt_name || '');\n  }\n\n  /**\n   * Initialize this block using a cross-platform, internationalization-friendly\n   * JSON description.\n   * @param {!Object} json Structured data describing the block.\n   */\n  jsonInit(json) {\n    const warningPrefix = json['type'] ? 'Block \"' + json['type'] + '\": ' : '';\n\n    // Validate inputs.\n    if (json['output'] && json['previousStatement']) {\n      throw Error(\n          warningPrefix +\n          'Must not have both an output and a previousStatement.');\n    }\n\n    // Set basic properties of block.\n    // Makes styles backward compatible with old way of defining hat style.\n    if (json['style'] && json['style'].hat) {\n      this.hat = json['style'].hat;\n      // Must set to null so it doesn't error when checking for style and\n      // colour.\n      json['style'] = null;\n    }\n\n    if (json['style'] && json['colour']) {\n      throw Error(warningPrefix + 'Must not have both a colour and a style.');\n    } else if (json['style']) {\n      this.jsonInitStyle_(json, warningPrefix);\n    } else {\n      this.jsonInitColour_(json, warningPrefix);\n    }\n\n    // Interpolate the message blocks.\n    let i = 0;\n    while (json['message' + i] !== undefined) {\n      this.interpolate_(\n          json['message' + i], json['args' + i] || [],\n          json['lastDummyAlign' + i], warningPrefix);\n      i++;\n    }\n\n    if (json['inputsInline'] !== undefined) {\n      this.setInputsInline(json['inputsInline']);\n    }\n    // Set output and previous/next connections.\n    if (json['output'] !== undefined) {\n      this.setOutput(true, json['output']);\n    }\n    if (json['outputShape'] !== undefined) {\n      this.setOutputShape(json['outputShape']);\n    }\n    if (json['previousStatement'] !== undefined) {\n      this.setPreviousStatement(true, json['previousStatement']);\n    }\n    if (json['nextStatement'] !== undefined) {\n      this.setNextStatement(true, json['nextStatement']);\n    }\n    if (json['tooltip'] !== undefined) {\n      const rawValue = json['tooltip'];\n      const localizedText = parsing.replaceMessageReferences(rawValue);\n      this.setTooltip(localizedText);\n    }\n    if (json['enableContextMenu'] !== undefined) {\n      this.contextMenu = !!json['enableContextMenu'];\n    }\n    if (json['suppressPrefixSuffix'] !== undefined) {\n      this.suppressPrefixSuffix = !!json['suppressPrefixSuffix'];\n    }\n    if (json['helpUrl'] !== undefined) {\n      const rawValue = json['helpUrl'];\n      const localizedValue = parsing.replaceMessageReferences(rawValue);\n      this.setHelpUrl(localizedValue);\n    }\n    if (typeof json['extensions'] === 'string') {\n      console.warn(\n          warningPrefix +\n          'JSON attribute \\'extensions\\' should be an array of' +\n          ' strings. Found raw string in JSON for \\'' + json['type'] +\n          '\\' block.');\n      json['extensions'] = [json['extensions']];  // Correct and continue.\n    }\n\n    // Add the mutator to the block.\n    if (json['mutator'] !== undefined) {\n      Extensions.apply(json['mutator'], this, true);\n    }\n\n    const extensionNames = json['extensions'];\n    if (Array.isArray(extensionNames)) {\n      for (let j = 0; j < extensionNames.length; j++) {\n        Extensions.apply(extensionNames[j], this, false);\n      }\n    }\n  }\n\n  /**\n   * Initialize the colour of this block from the JSON description.\n   * @param {!Object} json Structured data describing the block.\n   * @param {string} warningPrefix Warning prefix string identifying block.\n   * @private\n   */\n  jsonInitColour_(json, warningPrefix) {\n    if ('colour' in json) {\n      if (json['colour'] === undefined) {\n        console.warn(warningPrefix + 'Undefined colour value.');\n      } else {\n        const rawValue = json['colour'];\n        try {\n          this.setColour(rawValue);\n        } catch (e) {\n          console.warn(warningPrefix + 'Illegal colour value: ', rawValue);\n        }\n      }\n    }\n  }\n\n  /**\n   * Initialize the style of this block from the JSON description.\n   * @param {!Object} json Structured data describing the block.\n   * @param {string} warningPrefix Warning prefix string identifying block.\n   * @private\n   */\n  jsonInitStyle_(json, warningPrefix) {\n    const blockStyleName = json['style'];\n    try {\n      this.setStyle(blockStyleName);\n    } catch (styleError) {\n      console.warn(warningPrefix + 'Style does not exist: ', blockStyleName);\n    }\n  }\n\n  /**\n   * Add key/values from mixinObj to this block object. By default, this method\n   * will check that the keys in mixinObj will not overwrite existing values in\n   * the block, including prototype values. This provides some insurance against\n   * mixin / extension incompatibilities with future block features. This check\n   * can be disabled by passing true as the second argument.\n   * @param {!Object} mixinObj The key/values pairs to add to this block object.\n   * @param {boolean=} opt_disableCheck Option flag to disable overwrite checks.\n   */\n  mixin(mixinObj, opt_disableCheck) {\n    if (opt_disableCheck !== undefined &&\n        typeof opt_disableCheck !== 'boolean') {\n      throw Error('opt_disableCheck must be a boolean if provided');\n    }\n    if (!opt_disableCheck) {\n      const overwrites = [];\n      for (const key in mixinObj) {\n        if (this[key] !== undefined) {\n          overwrites.push(key);\n        }\n      }\n      if (overwrites.length) {\n        throw Error(\n            'Mixin will overwrite block members: ' +\n            JSON.stringify(overwrites));\n      }\n    }\n    object.mixin(this, mixinObj);\n  }\n\n  /**\n   * Interpolate a message description onto the block.\n   * @param {string} message Text contains interpolation tokens (%1, %2, ...)\n   *     that match with fields or inputs defined in the args array.\n   * @param {!Array} args Array of arguments to be interpolated.\n   * @param {string|undefined} lastDummyAlign If a dummy input is added at the\n   *     end, how should it be aligned?\n   * @param {string} warningPrefix Warning prefix string identifying block.\n   * @private\n   */\n  interpolate_(message, args, lastDummyAlign, warningPrefix) {\n    const tokens = parsing.tokenizeInterpolation(message);\n    this.validateTokens_(tokens, args.length);\n    const elements = this.interpolateArguments_(tokens, args, lastDummyAlign);\n\n    // An array of [field, fieldName] tuples.\n    const fieldStack = [];\n    for (let i = 0, element; (element = elements[i]); i++) {\n      if (this.isInputKeyword_(element['type'])) {\n        const input = this.inputFromJson_(element, warningPrefix);\n        // Should never be null, but just in case.\n        if (input) {\n          for (let j = 0, tuple; (tuple = fieldStack[j]); j++) {\n            input.appendField(tuple[0], tuple[1]);\n          }\n          fieldStack.length = 0;\n        }\n      } else {\n        // All other types, including ones starting with 'input_' get routed\n        // here.\n        const field = this.fieldFromJson_(element);\n        if (field) {\n          fieldStack.push([field, element['name']]);\n        }\n      }\n    }\n  }\n\n  /**\n   * Validates that the tokens are within the correct bounds, with no\n   * duplicates, and that all of the arguments are referred to. Throws errors if\n   * any of these things are not true.\n   * @param {!Array<string|number>} tokens An array of tokens to validate\n   * @param {number} argsCount The number of args that need to be referred to.\n   * @private\n   */\n  validateTokens_(tokens, argsCount) {\n    const visitedArgsHash = [];\n    let visitedArgsCount = 0;\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      if (typeof token !== 'number') {\n        continue;\n      }\n      if (token < 1 || token > argsCount) {\n        throw Error(\n            'Block \"' + this.type + '\": ' +\n            'Message index %' + token + ' out of range.');\n      }\n      if (visitedArgsHash[token]) {\n        throw Error(\n            'Block \"' + this.type + '\": ' +\n            'Message index %' + token + ' duplicated.');\n      }\n      visitedArgsHash[token] = true;\n      visitedArgsCount++;\n    }\n    if (visitedArgsCount !== argsCount) {\n      throw Error(\n          'Block \"' + this.type + '\": ' +\n          'Message does not reference all ' + argsCount + ' arg(s).');\n    }\n  }\n\n  /**\n   * Inserts args in place of numerical tokens. String args are converted to\n   * JSON that defines a label field. If necessary an extra dummy input is added\n   * to the end of the elements.\n   * @param {!Array<!string|number>} tokens The tokens to interpolate\n   * @param {!Array<!Object|string>} args The arguments to insert.\n   * @param {string|undefined} lastDummyAlign The alignment the added dummy\n   *     input should have, if we are required to add one.\n   * @return {!Array<!Object>} The JSON definitions of field and inputs to add\n   *     to the block.\n   * @private\n   */\n  interpolateArguments_(tokens, args, lastDummyAlign) {\n    const elements = [];\n    for (let i = 0; i < tokens.length; i++) {\n      let element = tokens[i];\n      if (typeof element === 'number') {\n        element = args[element - 1];\n      }\n      // Args can be strings, which is why this isn't elseif.\n      if (typeof element === 'string') {\n        element = this.stringToFieldJson_(element);\n        if (!element) {\n          continue;\n        }\n      }\n      elements.push(element);\n    }\n\n    const length = elements.length;\n    if (length && !this.isInputKeyword_(elements[length - 1]['type'])) {\n      const dummyInput = {'type': 'input_dummy'};\n      if (lastDummyAlign) {\n        dummyInput['align'] = lastDummyAlign;\n      }\n      elements.push(dummyInput);\n    }\n\n    return elements;\n  }\n\n  /**\n   * Creates a field from the JSON definition of a field. If a field with the\n   * given type cannot be found, this attempts to create a different field using\n   * the 'alt' property of the JSON definition (if it exists).\n   * @param {{alt:(string|undefined)}} element The element to try to turn into a\n   *     field.\n   * @return {?Field} The field defined by the JSON, or null if one\n   *     couldn't be created.\n   * @private\n   */\n  fieldFromJson_(element) {\n    const field = fieldRegistry.fromJson(element);\n    if (!field && element['alt']) {\n      if (typeof element['alt'] === 'string') {\n        const json = this.stringToFieldJson_(element['alt']);\n        return json ? this.fieldFromJson_(json) : null;\n      }\n      return this.fieldFromJson_(element['alt']);\n    }\n    return field;\n  }\n\n  /**\n   * Creates an input from the JSON definition of an input. Sets the input's\n   * check and alignment if they are provided.\n   * @param {!Object} element The JSON to turn into an input.\n   * @param {string} warningPrefix The prefix to add to warnings to help the\n   *     developer debug.\n   * @return {?Input} The input that has been created, or null if one\n   *     could not be created for some reason (should never happen).\n   * @private\n   */\n  inputFromJson_(element, warningPrefix) {\n    const alignmentLookup = {\n      'LEFT': Align.LEFT,\n      'RIGHT': Align.RIGHT,\n      'CENTRE': Align.CENTRE,\n      'CENTER': Align.CENTRE,\n    };\n\n    let input = null;\n    switch (element['type']) {\n      case 'input_value':\n        input = this.appendValueInput(element['name']);\n        break;\n      case 'input_statement':\n        input = this.appendStatementInput(element['name']);\n        break;\n      case 'input_dummy':\n        input = this.appendDummyInput(element['name']);\n        break;\n    }\n    // Should never be hit because of interpolate_'s checks, but just in case.\n    if (!input) {\n      return null;\n    }\n\n    if (element['check']) {\n      input.setCheck(element['check']);\n    }\n    if (element['align']) {\n      const alignment = alignmentLookup[element['align'].toUpperCase()];\n      if (alignment === undefined) {\n        console.warn(warningPrefix + 'Illegal align value: ', element['align']);\n      } else {\n        input.setAlign(alignment);\n      }\n    }\n    return input;\n  }\n\n  /**\n   * Returns true if the given string matches one of the input keywords.\n   * @param {string} str The string to check.\n   * @return {boolean} True if the given string matches one of the input\n   *     keywords, false otherwise.\n   * @private\n   */\n  isInputKeyword_(str) {\n    return str === 'input_value' || str === 'input_statement' ||\n        str === 'input_dummy';\n  }\n\n  /**\n   * Turns a string into the JSON definition of a label field. If the string\n   * becomes an empty string when trimmed, this returns null.\n   * @param {string} str String to turn into the JSON definition of a label\n   *     field.\n   * @return {?{text: string, type: string}} The JSON definition or null.\n   * @private\n   */\n  stringToFieldJson_(str) {\n    str = str.trim();\n    if (str) {\n      return {\n        'type': 'field_label',\n        'text': str,\n      };\n    }\n    return null;\n  }\n\n  /**\n   * Add a value input, statement input or local variable to this block.\n   * @param {number} type One of Blockly.inputTypes.\n   * @param {string} name Language-neutral identifier which may used to find\n   *     this input again.  Should be unique to this block.\n   * @return {!Input} The input object created.\n   * @protected\n   */\n  appendInput_(type, name) {\n    let connection = null;\n    if (type === inputTypes.VALUE || type === inputTypes.STATEMENT) {\n      connection = this.makeConnection_(type);\n    }\n    if (type === inputTypes.STATEMENT) {\n      this.statementInputCount++;\n    }\n    const input = new Input(type, name, this, connection);\n    // Append input to list.\n    this.inputList.push(input);\n    return input;\n  }\n\n  /**\n   * Move a named input to a different location on this block.\n   * @param {string} name The name of the input to move.\n   * @param {?string} refName Name of input that should be after the moved\n   *     input,\n   *   or null to be the input at the end.\n   */\n  moveInputBefore(name, refName) {\n    if (name === refName) {\n      return;\n    }\n    // Find both inputs.\n    let inputIndex = -1;\n    let refIndex = refName ? -1 : this.inputList.length;\n    for (let i = 0, input; (input = this.inputList[i]); i++) {\n      if (input.name === name) {\n        inputIndex = i;\n        if (refIndex !== -1) {\n          break;\n        }\n      } else if (refName && input.name === refName) {\n        refIndex = i;\n        if (inputIndex !== -1) {\n          break;\n        }\n      }\n    }\n    if (inputIndex === -1) {\n      throw Error('Named input \"' + name + '\" not found.');\n    }\n    if (refIndex === -1) {\n      throw Error('Reference input \"' + refName + '\" not found.');\n    }\n    this.moveNumberedInputBefore(inputIndex, refIndex);\n  }\n\n  /**\n   * Move a numbered input to a different location on this block.\n   * @param {number} inputIndex Index of the input to move.\n   * @param {number} refIndex Index of input that should be after the moved\n   *     input.\n   */\n  moveNumberedInputBefore(inputIndex, refIndex) {\n    // Validate arguments.\n    if (inputIndex === refIndex) {\n      throw Error('Can\\'t move input to itself.');\n    }\n    if (inputIndex >= this.inputList.length) {\n      throw RangeError('Input index ' + inputIndex + ' out of bounds.');\n    }\n    if (refIndex > this.inputList.length) {\n      throw RangeError('Reference input ' + refIndex + ' out of bounds.');\n    }\n    // Remove input.\n    const input = this.inputList[inputIndex];\n    this.inputList.splice(inputIndex, 1);\n    if (inputIndex < refIndex) {\n      refIndex--;\n    }\n    // Reinsert input.\n    this.inputList.splice(refIndex, 0, input);\n  }\n\n  /**\n   * Remove an input from this block.\n   * @param {string} name The name of the input.\n   * @param {boolean=} opt_quiet True to prevent an error if input is not\n   *     present.\n   * @return {boolean} True if operation succeeds, false if input is not present\n   *     and opt_quiet is true.\n   * @throws {Error} if the input is not present and opt_quiet is not true.\n   */\n  removeInput(name, opt_quiet) {\n    for (let i = 0, input; (input = this.inputList[i]); i++) {\n      if (input.name === name) {\n        if (input.type === inputTypes.STATEMENT) {\n          this.statementInputCount--;\n        }\n        input.dispose();\n        this.inputList.splice(i, 1);\n        return true;\n      }\n    }\n    if (opt_quiet) {\n      return false;\n    }\n    throw Error('Input not found: ' + name);\n  }\n\n  /**\n   * Fetches the named input object.\n   * @param {string} name The name of the input.\n   * @return {?Input} The input object, or null if input does not exist.\n   */\n  getInput(name) {\n    for (let i = 0, input; (input = this.inputList[i]); i++) {\n      if (input.name === name) {\n        return input;\n      }\n    }\n    // This input does not exist.\n    return null;\n  }\n\n  /**\n   * Fetches the block attached to the named input.\n   * @param {string} name The name of the input.\n   * @return {?Block} The attached value block, or null if the input is\n   *     either disconnected or if the input does not exist.\n   */\n  getInputTargetBlock(name) {\n    const input = this.getInput(name);\n    return input && input.connection && input.connection.targetBlock();\n  }\n\n  /**\n   * Returns the comment on this block (or null if there is no comment).\n   * @return {?string} Block's comment.\n   */\n  getCommentText() {\n    return this.commentModel.text;\n  }\n\n  /**\n   * Set this block's comment text.\n   * @param {?string} text The text, or null to delete.\n   */\n  setCommentText(text) {\n    if (this.commentModel.text === text) {\n      return;\n    }\n    eventUtils.fire(new (eventUtils.get(eventUtils.BLOCK_CHANGE))(\n        this, 'comment', null, this.commentModel.text, text));\n    this.commentModel.text = text;\n    this.comment = text;  // For backwards compatibility.\n  }\n\n  /**\n   * Set this block's warning text.\n   * @param {?string} _text The text, or null to delete.\n   * @param {string=} _opt_id An optional ID for the warning text to be able to\n   *     maintain multiple warnings.\n   */\n  setWarningText(_text, _opt_id) {\n    // NOP.\n  }\n\n  /**\n   * Give this block a mutator dialog.\n   * @param {Mutator} _mutator A mutator dialog instance or null to\n   *     remove.\n   */\n  setMutator(_mutator) {\n    // NOP.\n  }\n\n  /**\n   * Return the coordinates of the top-left corner of this block relative to the\n   * drawing surface's origin (0,0), in workspace units.\n   * @return {!Coordinate} Object with .x and .y properties.\n   */\n  getRelativeToSurfaceXY() {\n    return this.xy_;\n  }\n\n  /**\n   * Move a block by a relative offset.\n   * @param {number} dx Horizontal offset, in workspace units.\n   * @param {number} dy Vertical offset, in workspace units.\n   */\n  moveBy(dx, dy) {\n    if (this.parentBlock_) {\n      throw Error('Block has parent.');\n    }\n    const event = /** @type {!BlockMove} */ (\n        new (eventUtils.get(eventUtils.BLOCK_MOVE))(this));\n    this.xy_.translate(dx, dy);\n    event.recordNew();\n    eventUtils.fire(event);\n  }\n\n  /**\n   * Create a connection of the specified type.\n   * @param {number} type The type of the connection to create.\n   * @return {!Connection} A new connection of the specified type.\n   * @protected\n   */\n  makeConnection_(type) {\n    return new Connection(this, type);\n  }\n\n  /**\n   * Recursively checks whether all statement and value inputs are filled with\n   * blocks. Also checks all following statement blocks in this stack.\n   * @param {boolean=} opt_shadowBlocksAreFilled An optional argument\n   *     controlling whether shadow blocks are counted as filled. Defaults to\n   *     true.\n   * @return {boolean} True if all inputs are filled, false otherwise.\n   */\n  allInputsFilled(opt_shadowBlocksAreFilled) {\n    // Account for the shadow block filledness toggle.\n    if (opt_shadowBlocksAreFilled === undefined) {\n      opt_shadowBlocksAreFilled = true;\n    }\n    if (!opt_shadowBlocksAreFilled && this.isShadow()) {\n      return false;\n    }\n\n    // Recursively check each input block of the current block.\n    for (let i = 0, input; (input = this.inputList[i]); i++) {\n      if (!input.connection) {\n        continue;\n      }\n      const target = input.connection.targetBlock();\n      if (!target || !target.allInputsFilled(opt_shadowBlocksAreFilled)) {\n        return false;\n      }\n    }\n\n    // Recursively check the next block after the current block.\n    const next = this.getNextBlock();\n    if (next) {\n      return next.allInputsFilled(opt_shadowBlocksAreFilled);\n    }\n\n    return true;\n  }\n\n  /**\n   * This method returns a string describing this Block in developer terms (type\n   * name and ID; English only).\n   *\n   * Intended to on be used in console logs and errors. If you need a string\n   * that uses the user's native language (including block text, field values,\n   * and child blocks), use [toString()]{@link Block#toString}.\n   * @return {string} The description.\n   */\n  toDevString() {\n    let msg = this.type ? '\"' + this.type + '\" block' : 'Block';\n    if (this.id) {\n      msg += ' (id=\"' + this.id + '\")';\n    }\n    return msg;\n  }\n}\n\n/**\n * @typedef {{\n *            text:?string,\n *            pinned:boolean,\n *            size:Size\n *          }}\n */\nBlock.CommentModel;\n\n/**\n * An optional callback method to use whenever the block's parent workspace\n * changes. This is usually only called from the constructor, the block type\n * initializer function, or an extension initializer function.\n * @type {undefined|?function(Abstract)}\n */\nBlock.prototype.onchange;\n\n/**\n * The language-neutral ID given to the collapsed input.\n * @const {string}\n */\nBlock.COLLAPSED_INPUT_NAME = constants.COLLAPSED_INPUT_NAME;\n\n/**\n * The language-neutral ID given to the collapsed field.\n * @const {string}\n */\nBlock.COLLAPSED_FIELD_NAME = constants.COLLAPSED_FIELD_NAME;\n\nexports.Block = Block;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/block.js?")},
"./core/block_animations.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Methods animating a block on connection and disconnection.\n */\n\n\n/**\n * Methods animating a block on connection and disconnection.\n * @namespace Blockly.blockAnimations\n */\ngoog.module('Blockly.blockAnimations');\n\nconst dom = goog.require('Blockly.utils.dom');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n\n\n/**\n * PID of disconnect UI animation.  There can only be one at a time.\n * @type {number}\n */\nlet disconnectPid = 0;\n\n/**\n * SVG group of wobbling block.  There can only be one at a time.\n * @type {Element}\n */\nlet disconnectGroup = null;\n\n/**\n * Play some UI effects (sound, animation) when disposing of a block.\n * @param {!BlockSvg} block The block being disposed of.\n * @alias Blockly.blockAnimations.disposeUiEffect\n * @package\n */\nconst disposeUiEffect = function(block) {\n  const workspace = block.workspace;\n  const svgGroup = block.getSvgRoot();\n  workspace.getAudioManager().play('delete');\n\n  const xy = workspace.getSvgXY(svgGroup);\n  // Deeply clone the current block.\n  const clone = svgGroup.cloneNode(true);\n  clone.translateX_ = xy.x;\n  clone.translateY_ = xy.y;\n  clone.setAttribute('transform', 'translate(' + xy.x + ',' + xy.y + ')');\n  workspace.getParentSvg().appendChild(clone);\n  clone.bBox_ = clone.getBBox();\n  // Start the animation.\n  disposeUiStep(clone, workspace.RTL, new Date, workspace.scale);\n};\nexports.disposeUiEffect = disposeUiEffect;\n\n/**\n * Animate a cloned block and eventually dispose of it.\n * This is a class method, not an instance method since the original block has\n * been destroyed and is no longer accessible.\n * @param {!Element} clone SVG element to animate and dispose of.\n * @param {boolean} rtl True if RTL, false if LTR.\n * @param {!Date} start Date of animation's start.\n * @param {number} workspaceScale Scale of workspace.\n */\nconst disposeUiStep = function(clone, rtl, start, workspaceScale) {\n  const ms = new Date - start;\n  const percent = ms / 150;\n  if (percent > 1) {\n    dom.removeNode(clone);\n  } else {\n    const x = clone.translateX_ +\n        (rtl ? -1 : 1) * clone.bBox_.width * workspaceScale / 2 * percent;\n    const y = clone.translateY_ + clone.bBox_.height * workspaceScale * percent;\n    const scale = (1 - percent) * workspaceScale;\n    clone.setAttribute(\n        'transform',\n        'translate(' + x + ',' + y + ')' +\n            ' scale(' + scale + ')');\n    setTimeout(disposeUiStep, 10, clone, rtl, start, workspaceScale);\n  }\n};\n\n/**\n * Play some UI effects (sound, ripple) after a connection has been established.\n * @param {!BlockSvg} block The block being connected.\n * @alias Blockly.blockAnimations.connectionUiEffect\n * @package\n */\nconst connectionUiEffect = function(block) {\n  const workspace = block.workspace;\n  const scale = workspace.scale;\n  workspace.getAudioManager().play('click');\n  if (scale < 1) {\n    return;  // Too small to care about visual effects.\n  }\n  // Determine the absolute coordinates of the inferior block.\n  const xy = workspace.getSvgXY(block.getSvgRoot());\n  // Offset the coordinates based on the two connection types, fix scale.\n  if (block.outputConnection) {\n    xy.x += (block.RTL ? 3 : -3) * scale;\n    xy.y += 13 * scale;\n  } else if (block.previousConnection) {\n    xy.x += (block.RTL ? -23 : 23) * scale;\n    xy.y += 3 * scale;\n  }\n  const ripple = dom.createSvgElement(\n      Svg.CIRCLE, {\n        'cx': xy.x,\n        'cy': xy.y,\n        'r': 0,\n        'fill': 'none',\n        'stroke': '#888',\n        'stroke-width': 10,\n      },\n      workspace.getParentSvg());\n  // Start the animation.\n  connectionUiStep(ripple, new Date, scale);\n};\nexports.connectionUiEffect = connectionUiEffect;\n\n/**\n * Expand a ripple around a connection.\n * @param {!SVGElement} ripple Element to animate.\n * @param {!Date} start Date of animation's start.\n * @param {number} scale Scale of workspace.\n */\nconst connectionUiStep = function(ripple, start, scale) {\n  const ms = new Date - start;\n  const percent = ms / 150;\n  if (percent > 1) {\n    dom.removeNode(ripple);\n  } else {\n    ripple.setAttribute('r', percent * 25 * scale);\n    ripple.style.opacity = 1 - percent;\n    disconnectPid = setTimeout(connectionUiStep, 10, ripple, start, scale);\n  }\n};\n\n/**\n * Play some UI effects (sound, animation) when disconnecting a block.\n * @param {!BlockSvg} block The block being disconnected.\n * @alias Blockly.blockAnimations.disconnectUiEffect\n * @package\n */\nconst disconnectUiEffect = function(block) {\n  block.workspace.getAudioManager().play('disconnect');\n  if (block.workspace.scale < 1) {\n    return;  // Too small to care about visual effects.\n  }\n  // Horizontal distance for bottom of block to wiggle.\n  const DISPLACEMENT = 10;\n  // Scale magnitude of skew to height of block.\n  const height = block.getHeightWidth().height;\n  let magnitude = Math.atan(DISPLACEMENT / height) / Math.PI * 180;\n  if (!block.RTL) {\n    magnitude *= -1;\n  }\n  // Start the animation.\n  disconnectUiStep(block.getSvgRoot(), magnitude, new Date);\n};\nexports.disconnectUiEffect = disconnectUiEffect;\n\n/**\n * Animate a brief wiggle of a disconnected block.\n * @param {!SVGElement} group SVG element to animate.\n * @param {number} magnitude Maximum degrees skew (reversed for RTL).\n * @param {!Date} start Date of animation's start.\n */\nconst disconnectUiStep = function(group, magnitude, start) {\n  const DURATION = 200;  // Milliseconds.\n  const WIGGLES = 3;     // Half oscillations.\n\n  const ms = new Date - start;\n  const percent = ms / DURATION;\n\n  if (percent > 1) {\n    group.skew_ = '';\n  } else {\n    const skew = Math.round(\n        Math.sin(percent * Math.PI * WIGGLES) * (1 - percent) * magnitude);\n    group.skew_ = 'skewX(' + skew + ')';\n    disconnectGroup = group;\n    disconnectPid = setTimeout(disconnectUiStep, 10, group, magnitude, start);\n  }\n  group.setAttribute('transform', group.translate_ + group.skew_);\n};\n\n/**\n * Stop the disconnect UI animation immediately.\n * @alias Blockly.blockAnimations.disconnectUiStop\n * @package\n */\nconst disconnectUiStop = function() {\n  if (disconnectGroup) {\n    clearTimeout(disconnectPid);\n    const group = disconnectGroup;\n    group.skew_ = '';\n    group.setAttribute('transform', group.translate_);\n    disconnectGroup = null;\n  }\n};\nexports.disconnectUiStop = disconnectUiStop;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/block_animations.js?")},
"./core/block_drag_surface.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/utils/svg_math.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A class that manages a surface for dragging blocks.  When a\n * block drag is started, we move the block (and children) to a separate DOM\n * element that we move around using translate3d. At the end of the drag, the\n * blocks are put back in into the SVG they came from. This helps\n * performance by avoiding repainting the entire SVG on every mouse move\n * while dragging blocks.\n */\n\n\n\n/**\n * A class that manages a surface for dragging blocks.  When a\n * block drag is started, we move the block (and children) to a separate DOM\n * element that we move around using translate3d. At the end of the drag, the\n * blocks are put back in into the SVG they came from. This helps\n * performance by avoiding repainting the entire SVG on every mouse move\n * while dragging blocks.\n * @class\n */\ngoog.module('Blockly.BlockDragSurfaceSvg');\n\nconst dom = goog.require('Blockly.utils.dom');\nconst svgMath = goog.require('Blockly.utils.svgMath');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n\n\n/**\n * Class for a drag surface for the currently dragged block. This is a separate\n * SVG that contains only the currently moving block, or nothing.\n * @alias Blockly.BlockDragSurfaceSvg\n */\nconst BlockDragSurfaceSvg = class {\n  /**\n   * @param {!Element} container Containing element.\n   */\n  constructor(container) {\n    /**\n     * The SVG drag surface. Set once by BlockDragSurfaceSvg.createDom.\n     * @type {?SVGElement}\n     * @private\n     */\n    this.SVG_ = null;\n\n    /**\n     * This is where blocks live while they are being dragged if the drag\n     * surface is enabled.\n     * @type {?SVGElement}\n     * @private\n     */\n    this.dragGroup_ = null;\n\n    /**\n     * Containing HTML element; parent of the workspace and the drag surface.\n     * @type {!Element}\n     * @private\n     */\n    this.container_ = container;\n\n    /**\n     * Cached value for the scale of the drag surface.\n     * Used to set/get the correct translation during and after a drag.\n     * @type {number}\n     * @private\n     */\n    this.scale_ = 1;\n\n    /**\n     * Cached value for the translation of the drag surface.\n     * This translation is in pixel units, because the scale is applied to the\n     * drag group rather than the top-level SVG.\n     * @type {?Coordinate}\n     * @private\n     */\n    this.surfaceXY_ = null;\n\n    /**\n     * Cached value for the translation of the child drag surface in pixel\n     * units. Since the child drag surface tracks the translation of the\n     * workspace this is ultimately the translation of the workspace.\n     * @type {!Coordinate}\n     * @private\n     */\n    this.childSurfaceXY_ = new Coordinate(0, 0);\n\n    this.createDom();\n  }\n\n  /**\n   * Create the drag surface and inject it into the container.\n   */\n  createDom() {\n    if (this.SVG_) {\n      return;  // Already created.\n    }\n    this.SVG_ = dom.createSvgElement(\n        Svg.SVG, {\n          'xmlns': dom.SVG_NS,\n          'xmlns:html': dom.HTML_NS,\n          'xmlns:xlink': dom.XLINK_NS,\n          'version': '1.1',\n          'class': 'blocklyBlockDragSurface',\n        },\n        this.container_);\n    this.dragGroup_ = dom.createSvgElement(Svg.G, {}, this.SVG_);\n  }\n\n  /**\n   * Set the SVG blocks on the drag surface's group and show the surface.\n   * Only one block group should be on the drag surface at a time.\n   * @param {!SVGElement} blocks Block or group of blocks to place on the drag\n   * surface.\n   */\n  setBlocksAndShow(blocks) {\n    if (this.dragGroup_.childNodes.length) {\n      throw Error('Already dragging a block.');\n    }\n    // appendChild removes the blocks from the previous parent\n    this.dragGroup_.appendChild(blocks);\n    this.SVG_.style.display = 'block';\n    this.surfaceXY_ = new Coordinate(0, 0);\n  }\n\n  /**\n   * Translate and scale the entire drag surface group to the given position, to\n   * keep in sync with the workspace.\n   * @param {number} x X translation in pixel coordinates.\n   * @param {number} y Y translation in pixel coordinates.\n   * @param {number} scale Scale of the group.\n   */\n  translateAndScaleGroup(x, y, scale) {\n    this.scale_ = scale;\n    // This is a work-around to prevent a the blocks from rendering\n    // fuzzy while they are being dragged on the drag surface.\n    const fixedX = x.toFixed(0);\n    const fixedY = y.toFixed(0);\n\n    this.childSurfaceXY_.x = parseInt(fixedX, 10);\n    this.childSurfaceXY_.y = parseInt(fixedY, 10);\n\n    this.dragGroup_.setAttribute(\n        'transform',\n        'translate(' + fixedX + ',' + fixedY + ') scale(' + scale + ')');\n  }\n\n  /**\n   * Translate the drag surface's SVG based on its internal state.\n   * @private\n   */\n  translateSurfaceInternal_() {\n    let x = this.surfaceXY_.x;\n    let y = this.surfaceXY_.y;\n    // This is a work-around to prevent a the blocks from rendering\n    // fuzzy while they are being dragged on the drag surface.\n    x = x.toFixed(0);\n    y = y.toFixed(0);\n    this.SVG_.style.display = 'block';\n\n    dom.setCssTransform(this.SVG_, 'translate3d(' + x + 'px, ' + y + 'px, 0)');\n  }\n\n  /**\n   * Translates the entire surface by a relative offset.\n   * @param {number} deltaX Horizontal offset in pixel units.\n   * @param {number} deltaY Vertical offset in pixel units.\n   */\n  translateBy(deltaX, deltaY) {\n    const x = this.surfaceXY_.x + deltaX;\n    const y = this.surfaceXY_.y + deltaY;\n    this.surfaceXY_ = new Coordinate(x, y);\n    this.translateSurfaceInternal_();\n  }\n\n  /**\n   * Translate the entire drag surface during a drag.\n   * We translate the drag surface instead of the blocks inside the surface\n   * so that the browser avoids repainting the SVG.\n   * Because of this, the drag coordinates must be adjusted by scale.\n   * @param {number} x X translation for the entire surface.\n   * @param {number} y Y translation for the entire surface.\n   */\n  translateSurface(x, y) {\n    this.surfaceXY_ = new Coordinate(x * this.scale_, y * this.scale_);\n    this.translateSurfaceInternal_();\n  }\n\n  /**\n   * Reports the surface translation in scaled workspace coordinates.\n   * Use this when finishing a drag to return blocks to the correct position.\n   * @return {!Coordinate} Current translation of the surface.\n   */\n  getSurfaceTranslation() {\n    const xy = svgMath.getRelativeXY(/** @type {!SVGElement} */ (this.SVG_));\n    return new Coordinate(xy.x / this.scale_, xy.y / this.scale_);\n  }\n\n  /**\n   * Provide a reference to the drag group (primarily for\n   * BlockSvg.getRelativeToSurfaceXY).\n   * @return {?SVGElement} Drag surface group element.\n   */\n  getGroup() {\n    return this.dragGroup_;\n  }\n\n  /**\n   * Returns the SVG drag surface.\n   * @returns {?SVGElement} The SVG drag surface.\n   */\n  getSvgRoot() {\n    return this.SVG_;\n  }\n\n  /**\n   * Get the current blocks on the drag surface, if any (primarily\n   * for BlockSvg.getRelativeToSurfaceXY).\n   * @return {?Element} Drag surface block DOM element, or null if no blocks\n   *     exist.\n   */\n  getCurrentBlock() {\n    return /** @type {Element} */ (this.dragGroup_.firstChild);\n  }\n\n  /**\n   * Gets the translation of the child block surface\n   * This surface is in charge of keeping track of how much the workspace has\n   * moved.\n   * @return {!Coordinate} The amount the workspace has been moved.\n   */\n  getWsTranslation() {\n    // Returning a copy so the coordinate can not be changed outside this class.\n    return this.childSurfaceXY_.clone();\n  }\n\n  /**\n   * Clear the group and hide the surface; move the blocks off onto the provided\n   * element.\n   * If the block is being deleted it doesn't need to go back to the original\n   * surface, since it would be removed immediately during dispose.\n   * @param {Element=} opt_newSurface Surface the dragging blocks should be\n   *     moved to, or null if the blocks should be removed from this surface\n   *     without being moved to a different surface.\n   */\n  clearAndHide(opt_newSurface) {\n    const currentBlockElement = this.getCurrentBlock();\n    if (currentBlockElement) {\n      if (opt_newSurface) {\n        // appendChild removes the node from this.dragGroup_\n        opt_newSurface.appendChild(currentBlockElement);\n      } else {\n        this.dragGroup_.removeChild(currentBlockElement);\n      }\n    }\n    this.SVG_.style.display = 'none';\n    if (this.dragGroup_.childNodes.length) {\n      throw Error('Drag group was not cleared.');\n    }\n    this.surfaceXY_ = null;\n  }\n};\n\nexports.BlockDragSurfaceSvg = BlockDragSurfaceSvg;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/block_drag_surface.js?")},
"./core/block_dragger.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/block_animations.js\");\n__webpack_require__(\"./core/bump_objects.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/interfaces/i_block_dragger.js\");\n__webpack_require__(\"./core/insertion_marker_manager.js\");\n__webpack_require__(\"./core/events/events_block_drag.js\");\n__webpack_require__(\"./core/events/events_block_move.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Methods for dragging a block visually.\n */\n\n\n/**\n * Methods for dragging a block visually.\n * @class\n */\ngoog.module('Blockly.BlockDragger');\n\nconst blockAnimation = goog.require('Blockly.blockAnimations');\nconst bumpObjects = goog.require('Blockly.bumpObjects');\nconst common = goog.require('Blockly.common');\nconst dom = goog.require('Blockly.utils.dom');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockMove} = goog.requireType('Blockly.Events.BlockMove');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\n/* eslint-disable-next-line no-unused-vars */\nconst {IBlockDragger} = goog.require('Blockly.IBlockDragger');\n/* eslint-disable-next-line no-unused-vars */\nconst {IDragTarget} = goog.requireType('Blockly.IDragTarget');\nconst {InsertionMarkerManager} = goog.require('Blockly.InsertionMarkerManager');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockDrag');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockMove');\n\n\n/**\n * Class for a block dragger.  It moves blocks around the workspace when they\n * are being dragged by a mouse or touch.\n * @implements {IBlockDragger}\n * @alias Blockly.BlockDragger\n */\nconst BlockDragger = class {\n  /**\n   * @param {!BlockSvg} block The block to drag.\n   * @param {!WorkspaceSvg} workspace The workspace to drag on.\n   */\n  constructor(block, workspace) {\n    /**\n     * The top block in the stack that is being dragged.\n     * @type {!BlockSvg}\n     * @protected\n     */\n    this.draggingBlock_ = block;\n\n    /**\n     * The workspace on which the block is being dragged.\n     * @type {!WorkspaceSvg}\n     * @protected\n     */\n    this.workspace_ = workspace;\n\n    /**\n     * Object that keeps track of connections on dragged blocks.\n     * @type {!InsertionMarkerManager}\n     * @protected\n     */\n    this.draggedConnectionManager_ =\n        new InsertionMarkerManager(this.draggingBlock_);\n\n    /**\n     * Which drag area the mouse pointer is over, if any.\n     * @type {?IDragTarget}\n     * @private\n     */\n    this.dragTarget_ = null;\n\n    /**\n     * Whether the block would be deleted if dropped immediately.\n     * @type {boolean}\n     * @protected\n     */\n    this.wouldDeleteBlock_ = false;\n\n    /**\n     * The location of the top left corner of the dragging block at the\n     * beginning of the drag in workspace coordinates.\n     * @type {!Coordinate}\n     * @protected\n     */\n    this.startXY_ = this.draggingBlock_.getRelativeToSurfaceXY();\n\n    /**\n     * A list of all of the icons (comment, warning, and mutator) that are\n     * on this block and its descendants.  Moving an icon moves the bubble that\n     * extends from it if that bubble is open.\n     * @type {Array<!Object>}\n     * @protected\n     */\n    this.dragIconData_ = initIconData(block);\n  }\n\n  /**\n   * Sever all links from this object.\n   * @package\n   */\n  dispose() {\n    this.dragIconData_.length = 0;\n\n    if (this.draggedConnectionManager_) {\n      this.draggedConnectionManager_.dispose();\n    }\n  }\n\n  /**\n   * Start dragging a block.  This includes moving it to the drag surface.\n   * @param {!Coordinate} currentDragDeltaXY How far the pointer has\n   *     moved from the position at mouse down, in pixel units.\n   * @param {boolean} healStack Whether or not to heal the stack after\n   *     disconnecting.\n   * @public\n   */\n  startDrag(currentDragDeltaXY, healStack) {\n    if (!eventUtils.getGroup()) {\n      eventUtils.setGroup(true);\n    }\n    this.fireDragStartEvent_();\n\n    // Mutators don't have the same type of z-ordering as the normal workspace\n    // during a drag.  They have to rely on the order of the blocks in the SVG.\n    // For performance reasons that usually happens at the end of a drag,\n    // but do it at the beginning for mutators.\n    if (this.workspace_.isMutator) {\n      this.draggingBlock_.bringToFront();\n    }\n\n    // During a drag there may be a lot of rerenders, but not field changes.\n    // Turn the cache on so we don't do spurious remeasures during the drag.\n    dom.startTextWidthCache();\n    this.workspace_.setResizesEnabled(false);\n    blockAnimation.disconnectUiStop();\n\n    if (this.shouldDisconnect_(healStack)) {\n      this.disconnectBlock_(healStack, currentDragDeltaXY);\n    }\n    this.draggingBlock_.setDragging(true);\n    // For future consideration: we may be able to put moveToDragSurface inside\n    // the block dragger, which would also let the block not track the block\n    // drag surface.\n    this.draggingBlock_.moveToDragSurface();\n  }\n\n  /**\n   * Whether or not we should disconnect the block when a drag is started.\n   * @param {boolean} healStack Whether or not to heal the stack after\n   *     disconnecting.\n   * @return {boolean} True to disconnect the block, false otherwise.\n   * @protected\n   */\n  shouldDisconnect_(healStack) {\n    return !!(\n        this.draggingBlock_.getParent() ||\n        (healStack && this.draggingBlock_.nextConnection &&\n         this.draggingBlock_.nextConnection.targetBlock()));\n  }\n\n  /**\n   * Disconnects the block and moves it to a new location.\n   * @param {boolean} healStack Whether or not to heal the stack after\n   *     disconnecting.\n   * @param {!Coordinate} currentDragDeltaXY How far the pointer has\n   *     moved from the position at mouse down, in pixel units.\n   * @protected\n   */\n  disconnectBlock_(healStack, currentDragDeltaXY) {\n    this.draggingBlock_.unplug(healStack);\n    const delta = this.pixelsToWorkspaceUnits_(currentDragDeltaXY);\n    const newLoc = Coordinate.sum(this.startXY_, delta);\n\n    this.draggingBlock_.translate(newLoc.x, newLoc.y);\n    blockAnimation.disconnectUiEffect(this.draggingBlock_);\n    this.draggedConnectionManager_.updateAvailableConnections();\n  }\n\n  /**\n   * Fire a UI event at the start of a block drag.\n   * @protected\n   */\n  fireDragStartEvent_() {\n    const event = new (eventUtils.get(eventUtils.BLOCK_DRAG))(\n        this.draggingBlock_, true, this.draggingBlock_.getDescendants(false));\n    eventUtils.fire(event);\n  }\n\n  /**\n   * Execute a step of block dragging, based on the given event.  Update the\n   * display accordingly.\n   * @param {!Event} e The most recent move event.\n   * @param {!Coordinate} currentDragDeltaXY How far the pointer has\n   *     moved from the position at the start of the drag, in pixel units.\n   * @public\n   */\n  drag(e, currentDragDeltaXY) {\n    const delta = this.pixelsToWorkspaceUnits_(currentDragDeltaXY);\n    const newLoc = Coordinate.sum(this.startXY_, delta);\n    this.draggingBlock_.moveDuringDrag(newLoc);\n    this.dragIcons_(delta);\n\n    const oldDragTarget = this.dragTarget_;\n    this.dragTarget_ = this.workspace_.getDragTarget(e);\n\n    this.draggedConnectionManager_.update(delta, this.dragTarget_);\n    const oldWouldDeleteBlock = this.wouldDeleteBlock_;\n    this.wouldDeleteBlock_ = this.draggedConnectionManager_.wouldDeleteBlock();\n    if (oldWouldDeleteBlock !== this.wouldDeleteBlock_) {\n      // Prevent unnecessary add/remove class calls.\n      this.updateCursorDuringBlockDrag_();\n    }\n\n    // Call drag enter/exit/over after wouldDeleteBlock is called in\n    // InsertionMarkerManager.update.\n    if (this.dragTarget_ !== oldDragTarget) {\n      oldDragTarget && oldDragTarget.onDragExit(this.draggingBlock_);\n      this.dragTarget_ && this.dragTarget_.onDragEnter(this.draggingBlock_);\n    }\n    this.dragTarget_ && this.dragTarget_.onDragOver(this.draggingBlock_);\n  }\n\n  /**\n   * Finish a block drag and put the block back on the workspace.\n   * @param {!Event} e The mouseup/touchend event.\n   * @param {!Coordinate} currentDragDeltaXY How far the pointer has\n   *     moved from the position at the start of the drag, in pixel units.\n   * @public\n   */\n  endDrag(e, currentDragDeltaXY) {\n    // Make sure internal state is fresh.\n    this.drag(e, currentDragDeltaXY);\n    this.dragIconData_ = [];\n    this.fireDragEndEvent_();\n\n    dom.stopTextWidthCache();\n\n    blockAnimation.disconnectUiStop();\n\n    const preventMove = !!this.dragTarget_ &&\n        this.dragTarget_.shouldPreventMove(this.draggingBlock_);\n    /** @type {Coordinate} */\n    let newLoc;\n    /** @type {Coordinate} */\n    let delta;\n    if (preventMove) {\n      newLoc = this.startXY_;\n    } else {\n      const newValues = this.getNewLocationAfterDrag_(currentDragDeltaXY);\n      delta = newValues.delta;\n      newLoc = newValues.newLocation;\n    }\n    this.draggingBlock_.moveOffDragSurface(newLoc);\n\n    if (this.dragTarget_) {\n      this.dragTarget_.onDrop(this.draggingBlock_);\n    }\n\n    const deleted = this.maybeDeleteBlock_();\n    if (!deleted) {\n      // These are expensive and don't need to be done if we're deleting.\n      this.draggingBlock_.setDragging(false);\n      if (delta) {  // !preventMove\n        this.updateBlockAfterMove_(delta);\n      } else {\n        // Blocks dragged directly from a flyout may need to be bumped into\n        // bounds.\n        bumpObjects.bumpIntoBounds(\n            this.draggingBlock_.workspace,\n            this.workspace_.getMetricsManager().getScrollMetrics(true),\n            this.draggingBlock_);\n      }\n    }\n    this.workspace_.setResizesEnabled(true);\n\n    eventUtils.setGroup(false);\n  }\n\n  /**\n   * Calculates the drag delta and new location values after a block is dragged.\n   * @param {!Coordinate} currentDragDeltaXY How far the pointer has\n   *     moved from the start of the drag, in pixel units.\n   * @return {{delta: !Coordinate, newLocation:\n   *     !Coordinate}} New location after drag. delta is in\n   *     workspace units. newLocation is the new coordinate where the block\n   * should end up.\n   * @protected\n   */\n  getNewLocationAfterDrag_(currentDragDeltaXY) {\n    const newValues = {};\n    newValues.delta = this.pixelsToWorkspaceUnits_(currentDragDeltaXY);\n    newValues.newLocation = Coordinate.sum(this.startXY_, newValues.delta);\n    return newValues;\n  }\n\n  /**\n   * May delete the dragging block, if allowed. If `this.wouldDeleteBlock_` is\n   * not true, the block will not be deleted. This should be called at the end\n   * of a block drag.\n   * @return {boolean} True if the block was deleted.\n   * @protected\n   */\n  maybeDeleteBlock_() {\n    if (this.wouldDeleteBlock_) {\n      // Fire a move event, so we know where to go back to for an undo.\n      this.fireMoveEvent_();\n      this.draggingBlock_.dispose(false, true);\n      common.draggingConnections.length = 0;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Updates the necessary information to place a block at a certain location.\n   * @param {!Coordinate} delta The change in location from where\n   *     the block started the drag to where it ended the drag.\n   * @protected\n   */\n  updateBlockAfterMove_(delta) {\n    this.draggingBlock_.moveConnections(delta.x, delta.y);\n    this.fireMoveEvent_();\n    if (this.draggedConnectionManager_.wouldConnectBlock()) {\n      // Applying connections also rerenders the relevant blocks.\n      this.draggedConnectionManager_.applyConnections();\n    } else {\n      this.draggingBlock_.render();\n    }\n    this.draggingBlock_.scheduleSnapAndBump();\n  }\n\n  /**\n   * Fire a UI event at the end of a block drag.\n   * @protected\n   */\n  fireDragEndEvent_() {\n    const event = new (eventUtils.get(eventUtils.BLOCK_DRAG))(\n        this.draggingBlock_, false, this.draggingBlock_.getDescendants(false));\n    eventUtils.fire(event);\n  }\n\n  /**\n   * Adds or removes the style of the cursor for the toolbox.\n   * This is what changes the cursor to display an x when a deletable block is\n   * held over the toolbox.\n   * @param {boolean} isEnd True if we are at the end of a drag, false\n   *     otherwise.\n   * @protected\n   */\n  updateToolboxStyle_(isEnd) {\n    const toolbox = this.workspace_.getToolbox();\n\n    if (toolbox) {\n      const style = this.draggingBlock_.isDeletable() ? 'blocklyToolboxDelete' :\n                                                        'blocklyToolboxGrab';\n\n      if (isEnd && typeof toolbox.removeStyle === 'function') {\n        toolbox.removeStyle(style);\n      } else if (!isEnd && typeof toolbox.addStyle === 'function') {\n        toolbox.addStyle(style);\n      }\n    }\n  }\n\n  /**\n   * Fire a move event at the end of a block drag.\n   * @protected\n   */\n  fireMoveEvent_() {\n    const event = /** @type {!BlockMove} */\n        (new (eventUtils.get(eventUtils.BLOCK_MOVE))(this.draggingBlock_));\n    event.oldCoordinate = this.startXY_;\n    event.recordNew();\n    eventUtils.fire(event);\n  }\n\n  /**\n   * Update the cursor (and possibly the trash can lid) to reflect whether the\n   * dragging block would be deleted if released immediately.\n   * @protected\n   */\n  updateCursorDuringBlockDrag_() {\n    this.draggingBlock_.setDeleteStyle(this.wouldDeleteBlock_);\n  }\n\n  /**\n   * Convert a coordinate object from pixels to workspace units, including a\n   * correction for mutator workspaces.\n   * This function does not consider differing origins.  It simply scales the\n   * input's x and y values.\n   * @param {!Coordinate} pixelCoord A coordinate with x and y\n   *     values in CSS pixel units.\n   * @return {!Coordinate} The input coordinate divided by the\n   *     workspace scale.\n   * @protected\n   */\n  pixelsToWorkspaceUnits_(pixelCoord) {\n    const result = new Coordinate(\n        pixelCoord.x / this.workspace_.scale,\n        pixelCoord.y / this.workspace_.scale);\n    if (this.workspace_.isMutator) {\n      // If we're in a mutator, its scale is always 1, purely because of some\n      // oddities in our rendering optimizations.  The actual scale is the same\n      // as the scale on the parent workspace. Fix that for dragging.\n      const mainScale = this.workspace_.options.parentWorkspace.scale;\n      result.scale(1 / mainScale);\n    }\n    return result;\n  }\n\n  /**\n   * Move all of the icons connected to this drag.\n   * @param {!Coordinate} dxy How far to move the icons from their\n   *     original positions, in workspace units.\n   * @protected\n   */\n  dragIcons_(dxy) {\n    // Moving icons moves their associated bubbles.\n    for (let i = 0; i < this.dragIconData_.length; i++) {\n      const data = this.dragIconData_[i];\n      data.icon.setIconLocation(Coordinate.sum(data.location, dxy));\n    }\n  }\n\n  /**\n   * Get a list of the insertion markers that currently exist.  Drags have 0, 1,\n   * or 2 insertion markers.\n   * @return {!Array<!BlockSvg>} A possibly empty list of insertion\n   *     marker blocks.\n   * @public\n   */\n  getInsertionMarkers() {\n    // No insertion markers with the old style of dragged connection managers.\n    if (this.draggedConnectionManager_ &&\n        this.draggedConnectionManager_.getInsertionMarkers) {\n      return this.draggedConnectionManager_.getInsertionMarkers();\n    }\n    return [];\n  }\n};\n\n/**\n * Make a list of all of the icons (comment, warning, and mutator) that are\n * on this block and its descendants.  Moving an icon moves the bubble that\n * extends from it if that bubble is open.\n * @param {!BlockSvg} block The root block that is being dragged.\n * @return {!Array<!Object>} The list of all icons and their locations.\n */\nconst initIconData = function(block) {\n  // Build a list of icons that need to be moved and where they started.\n  const dragIconData = [];\n  const descendants =\n      /** @type {!Array<!BlockSvg>} */ (block.getDescendants(false));\n\n  for (let i = 0, descendant; (descendant = descendants[i]); i++) {\n    const icons = descendant.getIcons();\n    for (let j = 0; j < icons.length; j++) {\n      const data = {\n        // Coordinate with x and y properties (workspace\n        // coordinates).\n        location: icons[j].getIconLocation(),\n        // Blockly.Icon\n        icon: icons[j],\n      };\n      dragIconData.push(data);\n    }\n  }\n  return dragIconData;\n};\n\nregistry.register(registry.Type.BLOCK_DRAGGER, registry.DEFAULT, BlockDragger);\n\nexports.BlockDragger = BlockDragger;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/block_dragger.js?")},
"./core/block_svg.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/contextmenu.js\");\n__webpack_require__(\"./core/tooltip.js\");\n__webpack_require__(\"./core/block_animations.js\");\n__webpack_require__(\"./core/serialization/blocks.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/constants.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/internal_constants.js\");\n__webpack_require__(\"./core/utils/svg_math.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\n__webpack_require__(\"./core/keyboard_nav/ast_node.js\");\n__webpack_require__(\"./core/block.js\");\n__webpack_require__(\"./core/config.js\");\n__webpack_require__(\"./core/connection_type.js\");\n__webpack_require__(\"./core/contextmenu_registry.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/field_label.js\");\n__webpack_require__(\"./core/interfaces/i_ast_node_location_svg.js\");\n__webpack_require__(\"./core/interfaces/i_bounded_element.js\");\n__webpack_require__(\"./core/interfaces/i_copyable.js\");\n__webpack_require__(\"./core/interfaces/i_draggable.js\");\n__webpack_require__(\"./core/marker_manager.js\");\n__webpack_require__(\"./core/msg.js\");\n__webpack_require__(\"./core/utils/rect.js\");\n__webpack_require__(\"./core/rendered_connection.js\");\n__webpack_require__(\"./core/utils/svg.js\");\n__webpack_require__(\"./core/keyboard_nav/tab_navigate_cursor.js\");\n__webpack_require__(\"./core/events/events_block_move.js\");\n__webpack_require__(\"./core/events/events_selected.js\");\n__webpack_require__(\"./core/touch.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Methods for graphically rendering a block as SVG.\n */\n\n\n/**\n * Methods for graphically rendering a block as SVG.\n * @class\n */\ngoog.module('Blockly.BlockSvg');\n\nconst ContextMenu = goog.require('Blockly.ContextMenu');\nconst Tooltip = goog.require('Blockly.Tooltip');\nconst blockAnimations = goog.require('Blockly.blockAnimations');\nconst blocks = goog.require('Blockly.serialization.blocks');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst common = goog.require('Blockly.common');\nconst constants = goog.require('Blockly.constants');\nconst dom = goog.require('Blockly.utils.dom');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst internalConstants = goog.require('Blockly.internalConstants');\nconst svgMath = goog.require('Blockly.utils.svgMath');\nconst userAgent = goog.require('Blockly.utils.userAgent');\nconst {ASTNode} = goog.require('Blockly.ASTNode');\nconst {Block} = goog.require('Blockly.Block');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockMove} = goog.requireType('Blockly.Events.BlockMove');\n/* eslint-disable-next-line no-unused-vars */\nconst {Comment} = goog.requireType('Blockly.Comment');\nconst {config} = goog.require('Blockly.config');\nconst {ConnectionType} = goog.require('Blockly.ConnectionType');\n/* eslint-disable-next-line no-unused-vars */\nconst {Connection} = goog.requireType('Blockly.Connection');\nconst {ContextMenuRegistry} = goog.require('Blockly.ContextMenuRegistry');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\n/* eslint-disable-next-line no-unused-vars */\nconst {Debug: BlockRenderingDebug} = goog.requireType('Blockly.blockRendering.Debug');\nconst {FieldLabel} = goog.require('Blockly.FieldLabel');\n/* eslint-disable-next-line no-unused-vars */\nconst {Field} = goog.requireType('Blockly.Field');\n/* eslint-disable-next-line no-unused-vars */\nconst {IASTNodeLocationSvg} = goog.require('Blockly.IASTNodeLocationSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {IBoundedElement} = goog.require('Blockly.IBoundedElement');\n/* eslint-disable-next-line no-unused-vars */\nconst {ICopyable} = goog.require('Blockly.ICopyable');\n/* eslint-disable-next-line no-unused-vars */\nconst {IDraggable} = goog.require('Blockly.IDraggable');\n/* eslint-disable-next-line no-unused-vars */\nconst {IPathObject} = goog.requireType('Blockly.blockRendering.IPathObject');\n/* eslint-disable-next-line no-unused-vars */\nconst {Icon} = goog.requireType('Blockly.Icon');\n/* eslint-disable-next-line no-unused-vars */\nconst {Input} = goog.requireType('Blockly.Input');\nconst {MarkerManager} = goog.require('Blockly.MarkerManager');\nconst {Msg} = goog.require('Blockly.Msg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Mutator} = goog.requireType('Blockly.Mutator');\nconst {Rect} = goog.require('Blockly.utils.Rect');\nconst {RenderedConnection} = goog.require('Blockly.RenderedConnection');\nconst {Svg} = goog.require('Blockly.utils.Svg');\nconst {TabNavigateCursor} = goog.require('Blockly.TabNavigateCursor');\n/* eslint-disable-next-line no-unused-vars */\nconst {Theme} = goog.requireType('Blockly.Theme');\n/* eslint-disable-next-line no-unused-vars */\nconst {Warning} = goog.requireType('Blockly.Warning');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockMove');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.Selected');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Touch');\n\n\n/**\n * Class for a block's SVG representation.\n * Not normally called directly, workspace.newBlock() is preferred.\n * @extends {Block}\n * @implements {IASTNodeLocationSvg}\n * @implements {IBoundedElement}\n * @implements {ICopyable}\n * @implements {IDraggable}\n * @alias Blockly.BlockSvg\n */\nclass BlockSvg extends Block {\n  /**\n   * @param {!WorkspaceSvg} workspace The block's workspace.\n   * @param {string} prototypeName Name of the language object containing\n   *     type-specific functions for this block.\n   * @param {string=} opt_id Optional ID.  Use this ID if provided, otherwise\n   *     create a new ID.\n   */\n  constructor(workspace, prototypeName, opt_id) {\n    super(workspace, prototypeName, opt_id);\n\n    /**\n     * An optional method called when a mutator dialog is first opened.\n     * This function must create and initialize a top-level block for the\n     * mutator dialog, and return it. This function should also populate this\n     * top-level block with any sub-blocks which are appropriate. This method\n     * must also be coupled with defining a `compose` method for the default\n     * mutation dialog button and UI to appear.\n     * @type {undefined|?function(WorkspaceSvg):!BlockSvg}\n     */\n    this.decompose = this.decompose;\n\n    /**\n     * An optional method called when a mutator dialog saves its content.\n     * This function is called to modify the original block according to new\n     * settings. This method must also be coupled with defining a `decompose`\n     * method for the default mutation dialog button and UI to appear.\n     * @type {undefined|?function(!BlockSvg)}\n     */\n    this.compose = this.compose;\n\n    /**\n     * An optional method called by the default mutator UI which gives the block\n     * a chance to save information about what child blocks are connected to\n     * what mutated connections.\n     * @type {undefined|?function(!BlockSvg)}\n     */\n    this.saveConnections = this.saveConnections;\n\n    /**\n     * An optional method for defining custom block context menu items.\n     * @type {undefined|?function(!Array<!Object>)}\n     */\n    this.customContextMenu = this.customContextMenu;\n\n    /**\n     * An property used internally to reference the block's rendering debugger.\n     * @type {?BlockRenderingDebug}\n     * @package\n     */\n    this.renderingDebugger = null;\n\n    /**\n     * Height of this block, not including any statement blocks above or below.\n     * Height is in workspace units.\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * Width of this block, including any connected value blocks.\n     * Width is in workspace units.\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     * Map from IDs for warnings text to PIDs of functions to apply them.\n     * Used to be able to maintain multiple warnings.\n     * @type {Object<string, number>}\n     * @private\n     */\n    this.warningTextDb_ = null;\n\n    /**\n     * Block's mutator icon (if any).\n     * @type {?Mutator}\n     */\n    this.mutator = null;\n\n    /**\n     * Block's comment icon (if any).\n     * @type {?Comment}\n     * @deprecated August 2019. Use getCommentIcon instead.\n     */\n    this.comment = null;\n\n    /**\n     * Block's comment icon (if any).\n     * @type {?Comment}\n     * @private\n     */\n    this.commentIcon_ = null;\n\n    /**\n     * Block's warning icon (if any).\n     * @type {?Warning}\n     */\n    this.warning = null;\n\n    // Create core elements for the block.\n    /**\n     * @type {!SVGGElement}\n     * @private\n     */\n    this.svgGroup_ = dom.createSvgElement(Svg.G, {}, null);\n    this.svgGroup_.translate_ = '';\n\n    /**\n     * A block style object.\n     * @type {!Theme.BlockStyle}\n     */\n    this.style = workspace.getRenderer().getConstants().getBlockStyle(null);\n\n    /**\n     * The renderer's path object.\n     * @type {IPathObject}\n     * @package\n     */\n    this.pathObject =\n        workspace.getRenderer().makePathObject(this.svgGroup_, this.style);\n\n    /** @type {boolean} */\n    this.rendered = false;\n    /**\n     * Is this block currently rendering? Used to stop recursive render calls\n     * from actually triggering a re-render.\n     * @type {boolean}\n     * @private\n     */\n    this.renderIsInProgress_ = false;\n\n    /**\n     * Whether mousedown events have been bound yet.\n     * @type {boolean}\n     * @private\n     */\n    this.eventsInit_ = false;\n\n    /** @type {!WorkspaceSvg} */\n    this.workspace;\n    /** @type {RenderedConnection} */\n    this.outputConnection;\n    /** @type {RenderedConnection} */\n    this.nextConnection;\n    /** @type {RenderedConnection} */\n    this.previousConnection;\n\n    /**\n     * Whether to move the block to the drag surface when it is dragged.\n     * True if it should move, false if it should be translated directly.\n     * @type {boolean}\n     * @private\n     */\n    this.useDragSurface_ =\n        svgMath.is3dSupported() && !!workspace.getBlockDragSurface();\n\n    const svgPath = this.pathObject.svgPath;\n    svgPath.tooltip = this;\n    Tooltip.bindMouseEvents(svgPath);\n\n    // Expose this block's ID on its top-level SVG group.\n    if (this.svgGroup_.dataset) {\n      this.svgGroup_.dataset['id'] = this.id;\n    } else if (userAgent.IE) {\n      // SVGElement.dataset is not available on IE11, but data-* properties\n      // can be set with setAttribute().\n      this.svgGroup_.setAttribute('data-id', this.id);\n    }\n\n    this.doInit_();\n  }\n\n  /**\n   * Create and initialize the SVG representation of the block.\n   * May be called more than once.\n   */\n  initSvg() {\n    if (!this.workspace.rendered) {\n      throw TypeError('Workspace is headless.');\n    }\n    for (let i = 0, input; (input = this.inputList[i]); i++) {\n      input.init();\n    }\n    const icons = this.getIcons();\n    for (let i = 0; i < icons.length; i++) {\n      icons[i].createIcon();\n    }\n    this.applyColour();\n    this.pathObject.updateMovable(this.isMovable());\n    const svg = this.getSvgRoot();\n    if (!this.workspace.options.readOnly && !this.eventsInit_ && svg) {\n      browserEvents.conditionalBind(svg, 'mousedown', this, this.onMouseDown_);\n    }\n    this.eventsInit_ = true;\n\n    if (!svg.parentNode) {\n      this.workspace.getCanvas().appendChild(svg);\n    }\n  }\n\n  /**\n   * Get the secondary colour of a block.\n   * @return {?string} #RRGGBB string.\n   */\n  getColourSecondary() {\n    return this.style.colourSecondary;\n  }\n\n  /**\n   * Get the tertiary colour of a block.\n   * @return {?string} #RRGGBB string.\n   */\n  getColourTertiary() {\n    return this.style.colourTertiary;\n  }\n\n  /**\n   * Selects this block. Highlights the block visually and fires a select event\n   * if the block is not already selected.\n   */\n  select() {\n    if (this.isShadow() && this.getParent()) {\n      // Shadow blocks should not be selected.\n      this.getParent().select();\n      return;\n    }\n    if (common.getSelected() === this) {\n      return;\n    }\n    let oldId = null;\n    if (common.getSelected()) {\n      oldId = common.getSelected().id;\n      // Unselect any previously selected block.\n      eventUtils.disable();\n      try {\n        common.getSelected().unselect();\n      } finally {\n        eventUtils.enable();\n      }\n    }\n    const event = new (eventUtils.get(eventUtils.SELECTED))(\n        oldId, this.id, this.workspace.id);\n    eventUtils.fire(event);\n    common.setSelected(this);\n    this.addSelect();\n  }\n\n  /**\n   * Unselects this block. Unhighlights the block and fires a select (false)\n   * event if the block is currently selected.\n   */\n  unselect() {\n    if (common.getSelected() !== this) {\n      return;\n    }\n    const event = new (eventUtils.get(eventUtils.SELECTED))(\n        this.id, null, this.workspace.id);\n    event.workspaceId = this.workspace.id;\n    eventUtils.fire(event);\n    common.setSelected(null);\n    this.removeSelect();\n  }\n\n  /**\n   * Returns a list of mutator, comment, and warning icons.\n   * @return {!Array<!Icon>} List of icons.\n   */\n  getIcons() {\n    const icons = [];\n    if (this.mutator) {\n      icons.push(this.mutator);\n    }\n    if (this.commentIcon_) {\n      icons.push(this.commentIcon_);\n    }\n    if (this.warning) {\n      icons.push(this.warning);\n    }\n    return icons;\n  }\n\n  /**\n   * Sets the parent of this block to be a new block or null.\n   * @param {?Block} newParent New parent block.\n   * @package\n   * @override\n   */\n  setParent(newParent) {\n    const oldParent = this.parentBlock_;\n    if (newParent === oldParent) {\n      return;\n    }\n\n    dom.startTextWidthCache();\n    super.setParent(newParent);\n    dom.stopTextWidthCache();\n\n    const svgRoot = this.getSvgRoot();\n\n    // Bail early if workspace is clearing, or we aren't rendered.\n    // We won't need to reattach ourselves anywhere.\n    if (this.workspace.isClearing || !svgRoot) {\n      return;\n    }\n\n    const oldXY = this.getRelativeToSurfaceXY();\n    if (newParent) {\n      (/** @type {!BlockSvg} */ (newParent)).getSvgRoot().appendChild(svgRoot);\n      const newXY = this.getRelativeToSurfaceXY();\n      // Move the connections to match the child's new position.\n      this.moveConnections(newXY.x - oldXY.x, newXY.y - oldXY.y);\n    } else if (oldParent) {\n      // If we are losing a parent, we want to move our DOM element to the\n      // root of the workspace.\n      this.workspace.getCanvas().appendChild(svgRoot);\n      this.translate(oldXY.x, oldXY.y);\n    }\n\n    this.applyColour();\n  }\n\n  /**\n   * Return the coordinates of the top-left corner of this block relative to the\n   * drawing surface's origin (0,0), in workspace units.\n   * If the block is on the workspace, (0, 0) is the origin of the workspace\n   * coordinate system.\n   * This does not change with workspace scale.\n   * @return {!Coordinate} Object with .x and .y properties in\n   *     workspace coordinates.\n   */\n  getRelativeToSurfaceXY() {\n    let x = 0;\n    let y = 0;\n\n    const dragSurfaceGroup = this.useDragSurface_ ?\n        this.workspace.getBlockDragSurface().getGroup() :\n        null;\n\n    let element = this.getSvgRoot();\n    if (element) {\n      do {\n        // Loop through this block and every parent.\n        const xy = svgMath.getRelativeXY(element);\n        x += xy.x;\n        y += xy.y;\n        // If this element is the current element on the drag surface, include\n        // the translation of the drag surface itself.\n        if (this.useDragSurface_ &&\n            this.workspace.getBlockDragSurface().getCurrentBlock() ===\n                element) {\n          const surfaceTranslation =\n              this.workspace.getBlockDragSurface().getSurfaceTranslation();\n          x += surfaceTranslation.x;\n          y += surfaceTranslation.y;\n        }\n        element = /** @type {!SVGElement} */ (element.parentNode);\n      } while (element && element !== this.workspace.getCanvas() &&\n               element !== dragSurfaceGroup);\n    }\n    return new Coordinate(x, y);\n  }\n\n  /**\n   * Move a block by a relative offset.\n   * @param {number} dx Horizontal offset in workspace units.\n   * @param {number} dy Vertical offset in workspace units.\n   */\n  moveBy(dx, dy) {\n    if (this.parentBlock_) {\n      throw Error('Block has parent.');\n    }\n    const eventsEnabled = eventUtils.isEnabled();\n    let event;\n    if (eventsEnabled) {\n      event = /** @type {!BlockMove} */\n          (new (eventUtils.get(eventUtils.BLOCK_MOVE))(this));\n    }\n    const xy = this.getRelativeToSurfaceXY();\n    this.translate(xy.x + dx, xy.y + dy);\n    this.moveConnections(dx, dy);\n    if (eventsEnabled) {\n      event.recordNew();\n      eventUtils.fire(event);\n    }\n    this.workspace.resizeContents();\n  }\n\n  /**\n   * Transforms a block by setting the translation on the transform attribute\n   * of the block's SVG.\n   * @param {number} x The x coordinate of the translation in workspace units.\n   * @param {number} y The y coordinate of the translation in workspace units.\n   */\n  translate(x, y) {\n    this.getSvgRoot().setAttribute(\n        'transform', 'translate(' + x + ',' + y + ')');\n  }\n\n  /**\n   * Move this block to its workspace's drag surface, accounting for\n   * positioning. Generally should be called at the same time as\n   * setDragging_(true). Does nothing if useDragSurface_ is false.\n   * @package\n   */\n  moveToDragSurface() {\n    if (!this.useDragSurface_) {\n      return;\n    }\n    // The translation for drag surface blocks,\n    // is equal to the current relative-to-surface position,\n    // to keep the position in sync as it move on/off the surface.\n    // This is in workspace coordinates.\n    const xy = this.getRelativeToSurfaceXY();\n    this.clearTransformAttributes_();\n    this.workspace.getBlockDragSurface().translateSurface(xy.x, xy.y);\n    // Execute the move on the top-level SVG component\n    const svg = this.getSvgRoot();\n    if (svg) {\n      this.workspace.getBlockDragSurface().setBlocksAndShow(svg);\n    }\n  }\n\n  /**\n   * Move a block to a position.\n   * @param {Coordinate} xy The position to move to in workspace units.\n   */\n  moveTo(xy) {\n    const curXY = this.getRelativeToSurfaceXY();\n    this.moveBy(xy.x - curXY.x, xy.y - curXY.y);\n  }\n\n  /**\n   * Move this block back to the workspace block canvas.\n   * Generally should be called at the same time as setDragging_(false).\n   * Does nothing if useDragSurface_ is false.\n   * @param {!Coordinate} newXY The position the block should take on\n   *     on the workspace canvas, in workspace coordinates.\n   * @package\n   */\n  moveOffDragSurface(newXY) {\n    if (!this.useDragSurface_) {\n      return;\n    }\n    // Translate to current position, turning off 3d.\n    this.translate(newXY.x, newXY.y);\n    this.workspace.getBlockDragSurface().clearAndHide(\n        this.workspace.getCanvas());\n  }\n\n  /**\n   * Move this block during a drag, taking into account whether we are using a\n   * drag surface to translate blocks.\n   * This block must be a top-level block.\n   * @param {!Coordinate} newLoc The location to translate to, in\n   *     workspace coordinates.\n   * @package\n   */\n  moveDuringDrag(newLoc) {\n    if (this.useDragSurface_) {\n      this.workspace.getBlockDragSurface().translateSurface(newLoc.x, newLoc.y);\n    } else {\n      this.svgGroup_.translate_ =\n          'translate(' + newLoc.x + ',' + newLoc.y + ')';\n      this.svgGroup_.setAttribute(\n          'transform', this.svgGroup_.translate_ + this.svgGroup_.skew_);\n    }\n  }\n\n  /**\n   * Clear the block of transform=\"...\" attributes.\n   * Used when the block is switching from 3d to 2d transform or vice versa.\n   * @private\n   */\n  clearTransformAttributes_() {\n    this.getSvgRoot().removeAttribute('transform');\n  }\n\n  /**\n   * Snap this block to the nearest grid point.\n   */\n  snapToGrid() {\n    if (!this.workspace) {\n      return;  // Deleted block.\n    }\n    if (this.workspace.isDragging()) {\n      return;  // Don't bump blocks during a drag.\n    }\n    if (this.getParent()) {\n      return;  // Only snap top-level blocks.\n    }\n    if (this.isInFlyout) {\n      return;  // Don't move blocks around in a flyout.\n    }\n    const grid = this.workspace.getGrid();\n    if (!grid || !grid.shouldSnap()) {\n      return;  // Config says no snapping.\n    }\n    const spacing = grid.getSpacing();\n    const half = spacing / 2;\n    const xy = this.getRelativeToSurfaceXY();\n    const dx =\n        Math.round(Math.round((xy.x - half) / spacing) * spacing + half - xy.x);\n    const dy =\n        Math.round(Math.round((xy.y - half) / spacing) * spacing + half - xy.y);\n    if (dx || dy) {\n      this.moveBy(dx, dy);\n    }\n  }\n\n  /**\n   * Returns the coordinates of a bounding box describing the dimensions of this\n   * block and any blocks stacked below it.\n   * Coordinate system: workspace coordinates.\n   * @return {!Rect} Object with coordinates of the bounding box.\n   */\n  getBoundingRectangle() {\n    const blockXY = this.getRelativeToSurfaceXY();\n    const blockBounds = this.getHeightWidth();\n    let left;\n    let right;\n    if (this.RTL) {\n      left = blockXY.x - blockBounds.width;\n      right = blockXY.x;\n    } else {\n      left = blockXY.x;\n      right = blockXY.x + blockBounds.width;\n    }\n    return new Rect(blockXY.y, blockXY.y + blockBounds.height, left, right);\n  }\n\n  /**\n   * Notify every input on this block to mark its fields as dirty.\n   * A dirty field is a field that needs to be re-rendered.\n   */\n  markDirty() {\n    this.pathObject.constants = (/** @type {!WorkspaceSvg} */ (this.workspace))\n                                    .getRenderer()\n                                    .getConstants();\n    for (let i = 0, input; (input = this.inputList[i]); i++) {\n      input.markDirty();\n    }\n  }\n\n  /**\n   * Set whether the block is collapsed or not.\n   * @param {boolean} collapsed True if collapsed.\n   */\n  setCollapsed(collapsed) {\n    if (this.collapsed_ === collapsed) {\n      return;\n    }\n    super.setCollapsed(collapsed);\n    if (!collapsed) {\n      this.updateCollapsed_();\n    } else if (this.rendered) {\n      this.render();\n      // Don't bump neighbours. Users like to store collapsed functions together\n      // and bumping makes them go out of alignment.\n    }\n  }\n\n  /**\n   * Makes sure that when the block is collapsed, it is rendered correctly\n   * for that state.\n   * @private\n   */\n  updateCollapsed_() {\n    const collapsed = this.isCollapsed();\n    const collapsedInputName = constants.COLLAPSED_INPUT_NAME;\n    const collapsedFieldName = constants.COLLAPSED_FIELD_NAME;\n\n    for (let i = 0, input; (input = this.inputList[i]); i++) {\n      if (input.name !== collapsedInputName) {\n        input.setVisible(!collapsed);\n      }\n    }\n\n    if (!collapsed) {\n      this.updateDisabled();\n      this.removeInput(collapsedInputName);\n      return;\n    }\n\n    const icons = this.getIcons();\n    for (let i = 0, icon; (icon = icons[i]); i++) {\n      icon.setVisible(false);\n    }\n\n    const text = this.toString(internalConstants.COLLAPSE_CHARS);\n    const field = this.getField(collapsedFieldName);\n    if (field) {\n      field.setValue(text);\n      return;\n    }\n    const input = this.getInput(collapsedInputName) ||\n        this.appendDummyInput(collapsedInputName);\n    input.appendField(new FieldLabel(text), collapsedFieldName);\n  }\n\n  /**\n   * Open the next (or previous) FieldTextInput.\n   * @param {!Field} start Current field.\n   * @param {boolean} forward If true go forward, otherwise backward.\n   */\n  tab(start, forward) {\n    const tabCursor = new TabNavigateCursor();\n    tabCursor.setCurNode(ASTNode.createFieldNode(start));\n    const currentNode = tabCursor.getCurNode();\n\n    if (forward) {\n      tabCursor.next();\n    } else {\n      tabCursor.prev();\n    }\n\n    const nextNode = tabCursor.getCurNode();\n    if (nextNode && nextNode !== currentNode) {\n      const nextField = /** @type {!Field} */ (nextNode.getLocation());\n      nextField.showEditor();\n\n      // Also move the cursor if we're in keyboard nav mode.\n      if (this.workspace.keyboardAccessibilityMode) {\n        this.workspace.getCursor().setCurNode(nextNode);\n      }\n    }\n  }\n\n  /**\n   * Handle a mouse-down on an SVG block.\n   * @param {!Event} e Mouse down event or touch start event.\n   * @private\n   */\n  onMouseDown_(e) {\n    const gesture = this.workspace && this.workspace.getGesture(e);\n    if (gesture) {\n      gesture.handleBlockStart(e, this);\n    }\n  }\n\n  /**\n   * Load the block's help page in a new window.\n   * @package\n   */\n  showHelp() {\n    const url =\n        (typeof this.helpUrl === 'function') ? this.helpUrl() : this.helpUrl;\n    if (url) {\n      window.open(url);\n    }\n  }\n\n  /**\n   * Generate the context menu for this block.\n   * @return {?Array<!Object>} Context menu options or null if no menu.\n   * @protected\n   */\n  generateContextMenu() {\n    if (this.workspace.options.readOnly || !this.contextMenu) {\n      return null;\n    }\n    const menuOptions = ContextMenuRegistry.registry.getContextMenuOptions(\n        ContextMenuRegistry.ScopeType.BLOCK, {block: this});\n\n    // Allow the block to add or modify menuOptions.\n    if (this.customContextMenu) {\n      this.customContextMenu(menuOptions);\n    }\n\n    return menuOptions;\n  }\n\n  /**\n   * Show the context menu for this block.\n   * @param {!Event} e Mouse event.\n   * @package\n   */\n  showContextMenu(e) {\n    const menuOptions = this.generateContextMenu();\n\n    if (menuOptions && menuOptions.length) {\n      ContextMenu.show(e, menuOptions, this.RTL);\n      ContextMenu.setCurrentBlock(this);\n    }\n  }\n\n  /**\n   * Move the connections for this block and all blocks attached under it.\n   * Also update any attached bubbles.\n   * @param {number} dx Horizontal offset from current location, in workspace\n   *     units.\n   * @param {number} dy Vertical offset from current location, in workspace\n   *     units.\n   * @package\n   */\n  moveConnections(dx, dy) {\n    if (!this.rendered) {\n      // Rendering is required to lay out the blocks.\n      // This is probably an invisible block attached to a collapsed block.\n      return;\n    }\n    const myConnections = this.getConnections_(false);\n    for (let i = 0; i < myConnections.length; i++) {\n      myConnections[i].moveBy(dx, dy);\n    }\n    const icons = this.getIcons();\n    for (let i = 0; i < icons.length; i++) {\n      icons[i].computeIconLocation();\n    }\n\n    // Recurse through all blocks attached under this one.\n    for (let i = 0; i < this.childBlocks_.length; i++) {\n      (/** @type {!BlockSvg} */ (this.childBlocks_[i])).moveConnections(dx, dy);\n    }\n  }\n\n  /**\n   * Recursively adds or removes the dragging class to this node and its\n   * children.\n   * @param {boolean} adding True if adding, false if removing.\n   * @package\n   */\n  setDragging(adding) {\n    if (adding) {\n      const group = this.getSvgRoot();\n      group.translate_ = '';\n      group.skew_ = '';\n      common.draggingConnections.push(...this.getConnections_(true));\n      dom.addClass(\n          /** @type {!Element} */ (this.svgGroup_), 'blocklyDragging');\n    } else {\n      common.draggingConnections.length = 0;\n      dom.removeClass(\n          /** @type {!Element} */ (this.svgGroup_), 'blocklyDragging');\n    }\n    // Recurse through all blocks attached under this one.\n    for (let i = 0; i < this.childBlocks_.length; i++) {\n      (/** @type {!BlockSvg} */ (this.childBlocks_[i])).setDragging(adding);\n    }\n  }\n\n  /**\n   * Set whether this block is movable or not.\n   * @param {boolean} movable True if movable.\n   */\n  setMovable(movable) {\n    super.setMovable(movable);\n    this.pathObject.updateMovable(movable);\n  }\n\n  /**\n   * Set whether this block is editable or not.\n   * @param {boolean} editable True if editable.\n   */\n  setEditable(editable) {\n    super.setEditable(editable);\n    const icons = this.getIcons();\n    for (let i = 0; i < icons.length; i++) {\n      icons[i].updateEditable();\n    }\n  }\n\n  /**\n   * Sets whether this block is a shadow block or not.\n   * @param {boolean} shadow True if a shadow.\n   * @package\n   */\n  setShadow(shadow) {\n    super.setShadow(shadow);\n    this.applyColour();\n  }\n\n  /**\n   * Set whether this block is an insertion marker block or not.\n   * Once set this cannot be unset.\n   * @param {boolean} insertionMarker True if an insertion marker.\n   * @package\n   */\n  setInsertionMarker(insertionMarker) {\n    if (this.isInsertionMarker_ === insertionMarker) {\n      return;  // No change.\n    }\n    this.isInsertionMarker_ = insertionMarker;\n    if (this.isInsertionMarker_) {\n      this.setColour(\n          this.workspace.getRenderer().getConstants().INSERTION_MARKER_COLOUR);\n      this.pathObject.updateInsertionMarker(true);\n    }\n  }\n\n  /**\n   * Return the root node of the SVG or null if none exists.\n   * @return {!SVGGElement} The root SVG node (probably a group).\n   */\n  getSvgRoot() {\n    return this.svgGroup_;\n  }\n\n  /**\n   * Dispose of this block.\n   * @param {boolean=} healStack If true, then try to heal any gap by connecting\n   *     the next statement with the previous statement.  Otherwise, dispose of\n   *     all children of this block.\n   * @param {boolean=} animate If true, show a disposal animation and sound.\n   * @suppress {checkTypes}\n   */\n  dispose(healStack, animate) {\n    if (!this.workspace) {\n      // The block has already been deleted.\n      return;\n    }\n    Tooltip.dispose();\n    Tooltip.unbindMouseEvents(this.pathObject.svgPath);\n    dom.startTextWidthCache();\n    // Save the block's workspace temporarily so we can resize the\n    // contents once the block is disposed.\n    const blockWorkspace = this.workspace;\n    // If this block is being dragged, unlink the mouse events.\n    if (common.getSelected() === this) {\n      this.unselect();\n      this.workspace.cancelCurrentGesture();\n    }\n    // If this block has a context menu open, close it.\n    if (ContextMenu.getCurrentBlock() === this) {\n      ContextMenu.hide();\n    }\n\n    if (animate && this.rendered) {\n      this.unplug(healStack);\n      blockAnimations.disposeUiEffect(this);\n    }\n    // Stop rerendering.\n    this.rendered = false;\n\n    // Clear pending warnings.\n    if (this.warningTextDb_) {\n      for (const n in this.warningTextDb_) {\n        clearTimeout(this.warningTextDb_[n]);\n      }\n      this.warningTextDb_ = null;\n    }\n\n    const icons = this.getIcons();\n    for (let i = 0; i < icons.length; i++) {\n      icons[i].dispose();\n    }\n    super.dispose(!!healStack);\n\n    dom.removeNode(this.svgGroup_);\n    blockWorkspace.resizeContents();\n    // Sever JavaScript to DOM connections.\n    this.svgGroup_ = null;\n    dom.stopTextWidthCache();\n  }\n\n  /**\n   * Delete a block and hide chaff when doing so. The block will not be deleted\n   * if it's in a flyout. This is called from the context menu and keyboard\n   * shortcuts as the full delete action. If you are disposing of a block from\n   * the workspace and don't need to perform flyout checks, handle event\n   * grouping, or hide chaff, then use `block.dispose()` directly.\n   */\n  checkAndDelete() {\n    if (this.workspace.isFlyout) {\n      return;\n    }\n    eventUtils.setGroup(true);\n    this.workspace.hideChaff();\n    if (this.outputConnection) {\n      // Do not attempt to heal rows\n      // (https://github.com/google/blockly/issues/4832)\n      this.dispose(false, true);\n    } else {\n      this.dispose(/* heal */ true, true);\n    }\n    eventUtils.setGroup(false);\n  }\n\n  /**\n   * Encode a block for copying.\n   * @return {?ICopyable.CopyData} Copy metadata, or null if the block is\n   *     an insertion marker.\n   * @package\n   */\n  toCopyData() {\n    if (this.isInsertionMarker_) {\n      return null;\n    }\n    return {\n      saveInfo: /** @type {!blocks.State} */ (\n          blocks.save(this, {addCoordinates: true, addNextBlocks: false})),\n      source: this.workspace,\n      typeCounts: common.getBlockTypeCounts(this, true),\n    };\n  }\n\n  /**\n   * Updates the colour of the block to match the block's state.\n   * @package\n   */\n  applyColour() {\n    this.pathObject.applyColour(this);\n\n    const icons = this.getIcons();\n    for (let i = 0; i < icons.length; i++) {\n      icons[i].applyColour();\n    }\n\n    for (let x = 0, input; (input = this.inputList[x]); x++) {\n      for (let y = 0, field; (field = input.fieldRow[y]); y++) {\n        field.applyColour();\n      }\n    }\n  }\n\n  /**\n   * Updates the color of the block (and children) to match the current disabled\n   * state.\n   * @package\n   */\n  updateDisabled() {\n    const children =\n        /** @type {!Array<!BlockSvg>} */ (this.getChildren(false));\n    this.applyColour();\n    if (this.isCollapsed()) {\n      return;\n    }\n    for (let i = 0, child; (child = children[i]); i++) {\n      if (child.rendered) {\n        child.updateDisabled();\n      }\n    }\n  }\n\n  /**\n   * Get the comment icon attached to this block, or null if the block has no\n   * comment.\n   * @return {?Comment} The comment icon attached to this block, or null.\n   */\n  getCommentIcon() {\n    return this.commentIcon_;\n  }\n\n  /**\n   * Set this block's comment text.\n   * @param {?string} text The text, or null to delete.\n   */\n  setCommentText(text) {\n    const {Comment} = goog.module.get('Blockly.Comment');\n    if (!Comment) {\n      throw Error('Missing require for Blockly.Comment');\n    }\n    if (this.commentModel.text === text) {\n      return;\n    }\n    super.setCommentText(text);\n\n    const shouldHaveComment = text !== null;\n    if (!!this.commentIcon_ === shouldHaveComment) {\n      // If the comment's state of existence is correct, but the text is new\n      // that means we're just updating a comment.\n      this.commentIcon_.updateText();\n      return;\n    }\n    if (shouldHaveComment) {\n      this.commentIcon_ = new Comment(this);\n      this.comment = this.commentIcon_;  // For backwards compatibility.\n    } else {\n      this.commentIcon_.dispose();\n      this.commentIcon_ = null;\n      this.comment = null;  // For backwards compatibility.\n    }\n    if (this.rendered) {\n      this.render();\n      // Adding or removing a comment icon will cause the block to change shape.\n      this.bumpNeighbours();\n    }\n  }\n\n  /**\n   * Set this block's warning text.\n   * @param {?string} text The text, or null to delete.\n   * @param {string=} opt_id An optional ID for the warning text to be able to\n   *     maintain multiple warnings.\n   */\n  setWarningText(text, opt_id) {\n    const {Warning} = goog.module.get('Blockly.Warning');\n    if (!Warning) {\n      throw Error('Missing require for Blockly.Warning');\n    }\n    if (!this.warningTextDb_) {\n      // Create a database of warning PIDs.\n      // Only runs once per block (and only those with warnings).\n      this.warningTextDb_ = Object.create(null);\n    }\n    const id = opt_id || '';\n    if (!id) {\n      // Kill all previous pending processes, this edit supersedes them all.\n      for (const n of Object.keys(this.warningTextDb_)) {\n        clearTimeout(this.warningTextDb_[n]);\n        delete this.warningTextDb_[n];\n      }\n    } else if (this.warningTextDb_[id]) {\n      // Only queue up the latest change.  Kill any earlier pending process.\n      clearTimeout(this.warningTextDb_[id]);\n      delete this.warningTextDb_[id];\n    }\n    if (this.workspace.isDragging()) {\n      // Don't change the warning text during a drag.\n      // Wait until the drag finishes.\n      const thisBlock = this;\n      this.warningTextDb_[id] = setTimeout(function() {\n        if (thisBlock.workspace) {  // Check block wasn't deleted.\n          delete thisBlock.warningTextDb_[id];\n          thisBlock.setWarningText(text, id);\n        }\n      }, 100);\n      return;\n    }\n    if (this.isInFlyout) {\n      text = null;\n    }\n\n    let changedState = false;\n    if (typeof text === 'string') {\n      // Bubble up to add a warning on top-most collapsed block.\n      let parent = this.getSurroundParent();\n      let collapsedParent = null;\n      while (parent) {\n        if (parent.isCollapsed()) {\n          collapsedParent = parent;\n        }\n        parent = parent.getSurroundParent();\n      }\n      if (collapsedParent) {\n        collapsedParent.setWarningText(\n            Msg['COLLAPSED_WARNINGS_WARNING'], BlockSvg.COLLAPSED_WARNING_ID);\n      }\n\n      if (!this.warning) {\n        this.warning = new Warning(this);\n        changedState = true;\n      }\n      this.warning.setText(/** @type {string} */ (text), id);\n    } else {\n      // Dispose all warnings if no ID is given.\n      if (this.warning && !id) {\n        this.warning.dispose();\n        changedState = true;\n      } else if (this.warning) {\n        const oldText = this.warning.getText();\n        this.warning.setText('', id);\n        const newText = this.warning.getText();\n        if (!newText) {\n          this.warning.dispose();\n        }\n        changedState = oldText !== newText;\n      }\n    }\n    if (changedState && this.rendered) {\n      this.render();\n      // Adding or removing a warning icon will cause the block to change shape.\n      this.bumpNeighbours();\n    }\n  }\n\n  /**\n   * Give this block a mutator dialog.\n   * @param {?Mutator} mutator A mutator dialog instance or null to remove.\n   */\n  setMutator(mutator) {\n    if (this.mutator && this.mutator !== mutator) {\n      this.mutator.dispose();\n    }\n    if (mutator) {\n      mutator.setBlock(this);\n      this.mutator = mutator;\n      mutator.createIcon();\n    }\n    if (this.rendered) {\n      this.render();\n      // Adding or removing a mutator icon will cause the block to change shape.\n      this.bumpNeighbours();\n    }\n  }\n\n  /**\n   * Set whether the block is enabled or not.\n   * @param {boolean} enabled True if enabled.\n   */\n  setEnabled(enabled) {\n    if (this.isEnabled() !== enabled) {\n      super.setEnabled(enabled);\n      if (this.rendered && !this.getInheritedDisabled()) {\n        this.updateDisabled();\n      }\n    }\n  }\n\n  /**\n   * Set whether the block is highlighted or not.  Block highlighting is\n   * often used to visually mark blocks currently being executed.\n   * @param {boolean} highlighted True if highlighted.\n   */\n  setHighlighted(highlighted) {\n    if (!this.rendered) {\n      return;\n    }\n    this.pathObject.updateHighlighted(highlighted);\n  }\n\n  /**\n   * Adds the visual \"select\" effect to the block, but does not actually select\n   * it or fire an event.\n   * @see BlockSvg#select\n   */\n  addSelect() {\n    this.pathObject.updateSelected(true);\n  }\n\n  /**\n   * Removes the visual \"select\" effect from the block, but does not actually\n   * unselect it or fire an event.\n   * @see BlockSvg#unselect\n   */\n  removeSelect() {\n    this.pathObject.updateSelected(false);\n  }\n\n  /**\n   * Update the cursor over this block by adding or removing a class.\n   * @param {boolean} enable True if the delete cursor should be shown, false\n   *     otherwise.\n   * @package\n   */\n  setDeleteStyle(enable) {\n    this.pathObject.updateDraggingDelete(enable);\n  }\n\n  // Overrides of functions on Blockly.Block that take into account whether the\n\n  // block has been rendered.\n\n  /**\n   * Get the colour of a block.\n   * @return {string} #RRGGBB string.\n   */\n  getColour() {\n    return this.style.colourPrimary;\n  }\n\n  /**\n   * Change the colour of a block.\n   * @param {number|string} colour HSV hue value, or #RRGGBB string.\n   */\n  setColour(colour) {\n    super.setColour(colour);\n    const styleObj =\n        this.workspace.getRenderer().getConstants().getBlockStyleForColour(\n            this.colour_);\n\n    this.pathObject.setStyle(styleObj.style);\n    this.style = styleObj.style;\n    this.styleName_ = styleObj.name;\n\n    this.applyColour();\n  }\n\n  /**\n   * Set the style and colour values of a block.\n   * @param {string} blockStyleName Name of the block style.\n   * @throws {Error} if the block style does not exist.\n   */\n  setStyle(blockStyleName) {\n    const blockStyle =\n        this.workspace.getRenderer().getConstants().getBlockStyle(\n            blockStyleName);\n    this.styleName_ = blockStyleName;\n\n    if (blockStyle) {\n      this.hat = blockStyle.hat;\n      this.pathObject.setStyle(blockStyle);\n      // Set colour to match Block.\n      this.colour_ = blockStyle.colourPrimary;\n      this.style = blockStyle;\n\n      this.applyColour();\n    } else {\n      throw Error('Invalid style name: ' + blockStyleName);\n    }\n  }\n\n  /**\n   * Move this block to the front of the visible workspace.\n   * <g> tags do not respect z-index so SVG renders them in the\n   * order that they are in the DOM.  By placing this block first within the\n   * block group's <g>, it will render on top of any other blocks.\n   * @package\n   */\n  bringToFront() {\n    let block = this;\n    do {\n      const root = block.getSvgRoot();\n      const parent = root.parentNode;\n      const childNodes = parent.childNodes;\n      // Avoid moving the block if it's already at the bottom.\n      if (childNodes[childNodes.length - 1] !== root) {\n        parent.appendChild(root);\n      }\n      block = block.getParent();\n    } while (block);\n  }\n\n  /**\n   * Set whether this block can chain onto the bottom of another block.\n   * @param {boolean} newBoolean True if there can be a previous statement.\n   * @param {(string|Array<string>|null)=} opt_check Statement type or\n   *     list of statement types.  Null/undefined if any type could be\n   * connected.\n   */\n  setPreviousStatement(newBoolean, opt_check) {\n    super.setPreviousStatement(newBoolean, opt_check);\n\n    if (this.rendered) {\n      this.render();\n      this.bumpNeighbours();\n    }\n  }\n\n  /**\n   * Set whether another block can chain onto the bottom of this block.\n   * @param {boolean} newBoolean True if there can be a next statement.\n   * @param {(string|Array<string>|null)=} opt_check Statement type or\n   *     list of statement types.  Null/undefined if any type could be\n   * connected.\n   */\n  setNextStatement(newBoolean, opt_check) {\n    super.setNextStatement(newBoolean, opt_check);\n\n    if (this.rendered) {\n      this.render();\n      this.bumpNeighbours();\n    }\n  }\n\n  /**\n   * Set whether this block returns a value.\n   * @param {boolean} newBoolean True if there is an output.\n   * @param {(string|Array<string>|null)=} opt_check Returned type or list\n   *     of returned types.  Null or undefined if any type could be returned\n   *     (e.g. variable get).\n   */\n  setOutput(newBoolean, opt_check) {\n    super.setOutput(newBoolean, opt_check);\n\n    if (this.rendered) {\n      this.render();\n      this.bumpNeighbours();\n    }\n  }\n\n  /**\n   * Set whether value inputs are arranged horizontally or vertically.\n   * @param {boolean} newBoolean True if inputs are horizontal.\n   */\n  setInputsInline(newBoolean) {\n    super.setInputsInline(newBoolean);\n\n    if (this.rendered) {\n      this.render();\n      this.bumpNeighbours();\n    }\n  }\n\n  /**\n   * Remove an input from this block.\n   * @param {string} name The name of the input.\n   * @param {boolean=} opt_quiet True to prevent error if input is not present.\n   * @return {boolean} True if operation succeeds, false if input is not present\n   *     and opt_quiet is true\n   * @throws {Error} if the input is not present and opt_quiet is not true.\n   */\n  removeInput(name, opt_quiet) {\n    const removed = super.removeInput(name, opt_quiet);\n\n    if (this.rendered) {\n      this.render();\n      // Removing an input will cause the block to change shape.\n      this.bumpNeighbours();\n    }\n\n    return removed;\n  }\n\n  /**\n   * Move a numbered input to a different location on this block.\n   * @param {number} inputIndex Index of the input to move.\n   * @param {number} refIndex Index of input that should be after the moved\n   *     input.\n   */\n  moveNumberedInputBefore(inputIndex, refIndex) {\n    super.moveNumberedInputBefore(inputIndex, refIndex);\n\n    if (this.rendered) {\n      this.render();\n      // Moving an input will cause the block to change shape.\n      this.bumpNeighbours();\n    }\n  }\n\n  /**\n   * Add a value input, statement input or local variable to this block.\n   * @param {number} type One of Blockly.inputTypes.\n   * @param {string} name Language-neutral identifier which may used to find\n   *     this input again.  Should be unique to this block.\n   * @return {!Input} The input object created.\n   * @protected\n   * @override\n   */\n  appendInput_(type, name) {\n    const input = super.appendInput_(type, name);\n\n    if (this.rendered) {\n      this.render();\n      // Adding an input will cause the block to change shape.\n      this.bumpNeighbours();\n    }\n    return input;\n  }\n\n  /**\n   * Sets whether this block's connections are tracked in the database or not.\n   *\n   * Used by the deserializer to be more efficient. Setting a connection's\n   * tracked_ value to false keeps it from adding itself to the db when it\n   * gets its first moveTo call, saving expensive ops for later.\n   * @param {boolean} track If true, start tracking. If false, stop tracking.\n   * @package\n   */\n  setConnectionTracking(track) {\n    if (this.previousConnection) {\n      /** @type {!RenderedConnection} */ (this.previousConnection)\n          .setTracking(track);\n    }\n    if (this.outputConnection) {\n      /** @type {!RenderedConnection} */ (this.outputConnection)\n          .setTracking(track);\n    }\n    if (this.nextConnection) {\n      /** @type {!RenderedConnection} */ (this.nextConnection)\n          .setTracking(track);\n      const child =\n          /** @type {!RenderedConnection} */ (this.nextConnection)\n              .targetBlock();\n      if (child) {\n        child.setConnectionTracking(track);\n      }\n    }\n\n    if (this.collapsed_) {\n      // When track is true, we don't want to start tracking collapsed\n      // connections. When track is false, we're already not tracking\n      // collapsed connections, so no need to update.\n      return;\n    }\n\n    for (let i = 0; i < this.inputList.length; i++) {\n      const conn =\n          /** @type {!RenderedConnection} */ (this.inputList[i].connection);\n      if (conn) {\n        conn.setTracking(track);\n\n        // Pass tracking on down the chain.\n        const block = conn.targetBlock();\n        if (block) {\n          block.setConnectionTracking(track);\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns connections originating from this block.\n   * @param {boolean} all If true, return all connections even hidden ones.\n   *     Otherwise, for a non-rendered block return an empty list, and for a\n   *     collapsed block don't return inputs connections.\n   * @return {!Array<!RenderedConnection>} Array of connections.\n   * @package\n   */\n  getConnections_(all) {\n    const myConnections = [];\n    if (all || this.rendered) {\n      if (this.outputConnection) {\n        myConnections.push(this.outputConnection);\n      }\n      if (this.previousConnection) {\n        myConnections.push(this.previousConnection);\n      }\n      if (this.nextConnection) {\n        myConnections.push(this.nextConnection);\n      }\n      if (all || !this.collapsed_) {\n        for (let i = 0, input; (input = this.inputList[i]); i++) {\n          if (input.connection) {\n            myConnections.push(input.connection);\n          }\n        }\n      }\n    }\n    return myConnections;\n  }\n\n  /**\n   * Walks down a stack of blocks and finds the last next connection on the\n   * stack.\n   * @param {boolean} ignoreShadows If true,the last connection on a non-shadow\n   *     block will be returned. If false, this will follow shadows to find the\n   *     last connection.\n   * @return {?RenderedConnection} The last next connection on the stack,\n   *     or null.\n   * @package\n   * @override\n   */\n  lastConnectionInStack(ignoreShadows) {\n    return /** @type {RenderedConnection} */ (\n        super.lastConnectionInStack(ignoreShadows));\n  }\n\n  /**\n   * Find the connection on this block that corresponds to the given connection\n   * on the other block.\n   * Used to match connections between a block and its insertion marker.\n   * @param {!Block} otherBlock The other block to match against.\n   * @param {!Connection} conn The other connection to match.\n   * @return {?RenderedConnection} The matching connection on this block,\n   *     or null.\n   * @package\n   * @override\n   */\n  getMatchingConnection(otherBlock, conn) {\n    return /** @type {RenderedConnection} */ (\n        super.getMatchingConnection(otherBlock, conn));\n  }\n\n  /**\n   * Create a connection of the specified type.\n   * @param {number} type The type of the connection to create.\n   * @return {!RenderedConnection} A new connection of the specified type.\n   * @protected\n   */\n  makeConnection_(type) {\n    return new RenderedConnection(this, type);\n  }\n\n  /**\n   * Bump unconnected blocks out of alignment.  Two blocks which aren't actually\n   * connected should not coincidentally line up on screen.\n   */\n  bumpNeighbours() {\n    if (!this.workspace) {\n      return;  // Deleted block.\n    }\n    if (this.workspace.isDragging()) {\n      return;  // Don't bump blocks during a drag.\n    }\n    const rootBlock = this.getRootBlock();\n    if (rootBlock.isInFlyout) {\n      return;  // Don't move blocks around in a flyout.\n    }\n    // Loop through every connection on this block.\n    const myConnections = this.getConnections_(false);\n    for (let i = 0, connection; (connection = myConnections[i]); i++) {\n      const renderedConn = /** @type {!RenderedConnection} */ (connection);\n      // Spider down from this block bumping all sub-blocks.\n      if (renderedConn.isConnected() && renderedConn.isSuperior()) {\n        renderedConn.targetBlock().bumpNeighbours();\n      }\n\n      const neighbours = connection.neighbours(config.snapRadius);\n      for (let j = 0, otherConnection; (otherConnection = neighbours[j]); j++) {\n        const renderedOther =\n            /** @type {!RenderedConnection} */ (otherConnection);\n        // If both connections are connected, that's probably fine.  But if\n        // either one of them is unconnected, then there could be confusion.\n        if (!renderedConn.isConnected() || !renderedOther.isConnected()) {\n          // Only bump blocks if they are from different tree structures.\n          if (renderedOther.getSourceBlock().getRootBlock() !== rootBlock) {\n            // Always bump the inferior block.\n            if (renderedConn.isSuperior()) {\n              renderedOther.bumpAwayFrom(renderedConn);\n            } else {\n              renderedConn.bumpAwayFrom(renderedOther);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Schedule snapping to grid and bumping neighbours to occur after a brief\n   * delay.\n   * @package\n   */\n  scheduleSnapAndBump() {\n    const block = this;\n    // Ensure that any snap and bump are part of this move's event group.\n    const group = eventUtils.getGroup();\n\n    setTimeout(function() {\n      eventUtils.setGroup(group);\n      block.snapToGrid();\n      eventUtils.setGroup(false);\n    }, config.bumpDelay / 2);\n\n    setTimeout(function() {\n      eventUtils.setGroup(group);\n      block.bumpNeighbours();\n      eventUtils.setGroup(false);\n    }, config.bumpDelay);\n  }\n\n  /**\n   * Position a block so that it doesn't move the target block when connected.\n   * The block to position is usually either the first block in a dragged stack\n   * or an insertion marker.\n   * @param {!RenderedConnection} sourceConnection The connection on the\n   *     moving block's stack.\n   * @param {!RenderedConnection} targetConnection The connection that\n   *     should stay stationary as this block is positioned.\n   * @package\n   */\n  positionNearConnection(sourceConnection, targetConnection) {\n    // We only need to position the new block if it's before the existing one,\n    // otherwise its position is set by the previous block.\n    if (sourceConnection.type === ConnectionType.NEXT_STATEMENT ||\n        sourceConnection.type === ConnectionType.INPUT_VALUE) {\n      const dx = targetConnection.x - sourceConnection.x;\n      const dy = targetConnection.y - sourceConnection.y;\n\n      this.moveBy(dx, dy);\n    }\n  }\n\n  /**\n   * Return the parent block or null if this block is at the top level.\n   * @return {?BlockSvg} The block (if any) that holds the current block.\n   * @override\n   */\n  getParent() {\n    return /** @type {?BlockSvg} */ (super.getParent());\n  }\n\n  /**\n   * @return {?BlockSvg} The block (if any) that surrounds the current block.\n   * @override\n   */\n  getSurroundParent() {\n    return /** @type {?BlockSvg} */ (super.getSurroundParent());\n  }\n\n  /**\n   * @return {?BlockSvg} The next statement block or null.\n   * @override\n   */\n  getNextBlock() {\n    return /** @type {?BlockSvg} */ (super.getNextBlock());\n  }\n\n  /**\n   * @return {?BlockSvg} The previou statement block or null.\n   * @override\n   */\n  getPreviousBlock() {\n    return /** @type {?BlockSvg} */ (super.getPreviousBlock());\n  }\n\n  /**\n   * @return {?RenderedConnection} The first statement connection or null.\n   * @package\n   * @override\n   */\n  getFirstStatementConnection() {\n    return /** @type {?RenderedConnection} */ (\n        super.getFirstStatementConnection());\n  }\n\n  /**\n   * @return {!BlockSvg} The top block in a stack.\n   * @override\n   */\n  getTopStackBlock() {\n    return /** @type {!BlockSvg} */ (super.getTopStackBlock());\n  }\n\n  /**\n   * @param {boolean} ordered Sort the list if true.\n   * @return {!Array<!BlockSvg>} Children of this block.\n   * @override\n   */\n  getChildren(ordered) {\n    return /** @type {!Array<!BlockSvg>} */ (super.getChildren(ordered));\n  }\n\n  /**\n   * @param {boolean} ordered Sort the list if true.\n   * @return {!Array<!BlockSvg>} Descendants of this block.\n   * @override\n   */\n  getDescendants(ordered) {\n    return /** @type {!Array<!BlockSvg>} */ (super.getDescendants(ordered));\n  }\n\n  /**\n   * @param {string} name The name of the input.\n   * @return {?BlockSvg} The attached value block, or null if the input is\n   *     either disconnected or if the input does not exist.\n   * @override\n   */\n  getInputTargetBlock(name) {\n    return /** @type {?BlockSvg} */ (super.getInputTargetBlock(name));\n  }\n\n  /**\n   * Return the top-most block in this block's tree.\n   * This will return itself if this block is at the top level.\n   * @return {!BlockSvg} The root block.\n   * @override\n   */\n  getRootBlock() {\n    return /** @type {!BlockSvg} */ (super.getRootBlock());\n  }\n\n  /**\n   * Lays out and reflows a block based on its contents and settings.\n   * @param {boolean=} opt_bubble If false, just render this block.\n   *   If true, also render block's parent, grandparent, etc.  Defaults to true.\n   */\n  render(opt_bubble) {\n    if (this.renderIsInProgress_) {\n      return;  // Don't allow recursive renders.\n    }\n    this.renderIsInProgress_ = true;\n    try {\n      this.rendered = true;\n      dom.startTextWidthCache();\n\n      if (this.isCollapsed()) {\n        this.updateCollapsed_();\n      }\n      this.workspace.getRenderer().render(this);\n      this.updateConnectionLocations_();\n\n      if (opt_bubble !== false) {\n        const parentBlock = this.getParent();\n        if (parentBlock) {\n          parentBlock.render(true);\n        } else {\n          // Top-most block. Fire an event to allow scrollbars to resize.\n          this.workspace.resizeContents();\n        }\n      }\n\n      dom.stopTextWidthCache();\n      this.updateMarkers_();\n    } finally {\n      this.renderIsInProgress_ = false;\n    }\n  }\n\n  /**\n   * Redraw any attached marker or cursor svgs if needed.\n   * @protected\n   */\n  updateMarkers_() {\n    if (this.workspace.keyboardAccessibilityMode && this.pathObject.cursorSvg) {\n      this.workspace.getCursor().draw();\n    }\n    if (this.workspace.keyboardAccessibilityMode && this.pathObject.markerSvg) {\n      // TODO(#4592): Update all markers on the block.\n      this.workspace.getMarker(MarkerManager.LOCAL_MARKER).draw();\n    }\n  }\n\n  /**\n   * Update all of the connections on this block with the new locations\n   * calculated during rendering.  Also move all of the connected blocks based\n   * on the new connection locations.\n   * @private\n   */\n  updateConnectionLocations_() {\n    const blockTL = this.getRelativeToSurfaceXY();\n    // Don't tighten previous or output connections because they are inferior\n    // connections.\n    if (this.previousConnection) {\n      this.previousConnection.moveToOffset(blockTL);\n    }\n    if (this.outputConnection) {\n      this.outputConnection.moveToOffset(blockTL);\n    }\n\n    for (let i = 0; i < this.inputList.length; i++) {\n      const conn =\n          /** @type {!RenderedConnection} */ (this.inputList[i].connection);\n      if (conn) {\n        conn.moveToOffset(blockTL);\n        if (conn.isConnected()) {\n          conn.tighten();\n        }\n      }\n    }\n\n    if (this.nextConnection) {\n      this.nextConnection.moveToOffset(blockTL);\n      if (this.nextConnection.isConnected()) {\n        this.nextConnection.tighten();\n      }\n    }\n  }\n\n  /**\n   * Add the cursor SVG to this block's SVG group.\n   * @param {SVGElement} cursorSvg The SVG root of the cursor to be added to the\n   *     block SVG group.\n   * @package\n   */\n  setCursorSvg(cursorSvg) {\n    this.pathObject.setCursorSvg(cursorSvg);\n  }\n\n  /**\n   * Add the marker SVG to this block's SVG group.\n   * @param {SVGElement} markerSvg The SVG root of the marker to be added to the\n   *     block SVG group.\n   * @package\n   */\n  setMarkerSvg(markerSvg) {\n    this.pathObject.setMarkerSvg(markerSvg);\n  }\n\n  /**\n   * Returns a bounding box describing the dimensions of this block\n   * and any blocks stacked below it.\n   * @return {!{height: number, width: number}} Object with height and width\n   *    properties in workspace units.\n   * @package\n   */\n  getHeightWidth() {\n    let height = this.height;\n    let width = this.width;\n    // Recursively add size of subsequent blocks.\n    const nextBlock = this.getNextBlock();\n    if (nextBlock) {\n      const nextHeightWidth = nextBlock.getHeightWidth();\n      const workspace = /** @type {!WorkspaceSvg} */ (this.workspace);\n      const tabHeight = workspace.getRenderer().getConstants().NOTCH_HEIGHT;\n      height += nextHeightWidth.height - tabHeight;\n      width = Math.max(width, nextHeightWidth.width);\n    }\n    return {height: height, width: width};\n  }\n\n  /**\n   * Visual effect to show that if the dragging block is dropped, this block\n   * will be replaced.  If a shadow block, it will disappear.  Otherwise it will\n   * bump.\n   * @param {boolean} add True if highlighting should be added.\n   * @package\n   */\n  fadeForReplacement(add) {\n    this.pathObject.updateReplacementFade(add);\n  }\n\n  /**\n   * Visual effect to show that if the dragging block is dropped it will connect\n   * to this input.\n   * @param {Connection} conn The connection on the input to highlight.\n   * @param {boolean} add True if highlighting should be added.\n   * @package\n   */\n  highlightShapeForInput(conn, add) {\n    this.pathObject.updateShapeForInputHighlight(conn, add);\n  }\n}\n\n/**\n * Constant for identifying rows that are to be rendered inline.\n * Don't collide with Blockly.inputTypes.\n * @const\n */\nBlockSvg.INLINE = -1;\n\n/**\n * ID to give the \"collapsed warnings\" warning. Allows us to remove the\n * \"collapsed warnings\" warning without removing any warnings that belong to\n * the block.\n * @type {string}\n * @const\n */\nBlockSvg.COLLAPSED_WARNING_ID = 'TEMP_COLLAPSED_WARNING_';\n\nexports.BlockSvg = BlockSvg;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/block_svg.js?")},
"./core/blockly.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/contextmenu.js\");\n__webpack_require__(\"./core/contextmenu_items.js\");\n__webpack_require__(\"./core/css.js\");\n__webpack_require__(\"./core/events/events.js\");\n__webpack_require__(\"./core/extensions.js\");\n__webpack_require__(\"./core/procedures.js\");\n__webpack_require__(\"./core/shortcut_items.js\");\n__webpack_require__(\"./core/theme/themes.js\");\n__webpack_require__(\"./core/tooltip.js\");\n__webpack_require__(\"./core/touch.js\");\n__webpack_require__(\"./core/variables.js\");\n__webpack_require__(\"./core/variables_dynamic.js\");\n__webpack_require__(\"./core/widgetdiv.js\");\n__webpack_require__(\"./core/xml.js\");\n__webpack_require__(\"./core/block_animations.js\");\n__webpack_require__(\"./core/renderers/common/block_rendering.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/bump_objects.js\");\n__webpack_require__(\"./core/clipboard.js\");\n__webpack_require__(\"./core/utils/colour.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/constants.js\");\n__webpack_require__(\"./core/utils/deprecation.js\");\n__webpack_require__(\"./core/dialog.js\");\n__webpack_require__(\"./core/dropdowndiv.js\");\n__webpack_require__(\"./core/field_registry.js\");\n__webpack_require__(\"./core/renderers/geras/geras.js\");\n__webpack_require__(\"./core/internal_constants.js\");\n__webpack_require__(\"./core/renderers/minimalist/minimalist.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/serialization/blocks.js\");\n__webpack_require__(\"./core/serialization/exceptions.js\");\n__webpack_require__(\"./core/serialization/priorities.js\");\n__webpack_require__(\"./core/serialization/registry.js\");\n__webpack_require__(\"./core/serialization/variables.js\");\n__webpack_require__(\"./core/serialization/workspaces.js\");\n__webpack_require__(\"./core/utils/svg_math.js\");\n__webpack_require__(\"./core/renderers/thrasos/thrasos.js\");\n__webpack_require__(\"./core/utils/toolbox.js\");\n__webpack_require__(\"./core/positionable_helpers.js\");\n__webpack_require__(\"./core/utils.js\");\n__webpack_require__(\"./core/renderers/zelos/zelos.js\");\n__webpack_require__(\"./core/input.js\");\n__webpack_require__(\"./core/keyboard_nav/ast_node.js\");\n__webpack_require__(\"./core/keyboard_nav/basic_cursor.js\");\n__webpack_require__(\"./core/block_drag_surface.js\");\n__webpack_require__(\"./core/block_dragger.js\");\n__webpack_require__(\"./core/block_svg.js\");\n__webpack_require__(\"./core/blockly_options.js\");\n__webpack_require__(\"./core/blocks.js\");\n__webpack_require__(\"./core/block.js\");\n__webpack_require__(\"./core/bubble_dragger.js\");\n__webpack_require__(\"./core/bubble.js\");\n__webpack_require__(\"./core/toolbox/collapsible_category.js\");\n__webpack_require__(\"./core/comment.js\");\n__webpack_require__(\"./core/component_manager.js\");\n__webpack_require__(\"./core/config.js\");\n__webpack_require__(\"./core/connection_checker.js\");\n__webpack_require__(\"./core/connection_db.js\");\n__webpack_require__(\"./core/connection_type.js\");\n__webpack_require__(\"./core/connection.js\");\n__webpack_require__(\"./core/contextmenu_registry.js\");\n__webpack_require__(\"./core/keyboard_nav/cursor.js\");\n__webpack_require__(\"./core/delete_area.js\");\n__webpack_require__(\"./core/drag_target.js\");\n__webpack_require__(\"./core/field_angle.js\");\n__webpack_require__(\"./core/field_checkbox.js\");\n__webpack_require__(\"./core/field_colour.js\");\n__webpack_require__(\"./core/field_dropdown.js\");\n__webpack_require__(\"./core/field_image.js\");\n__webpack_require__(\"./core/field_label_serializable.js\");\n__webpack_require__(\"./core/field_label.js\");\n__webpack_require__(\"./core/field_multilineinput.js\");\n__webpack_require__(\"./core/field_number.js\");\n__webpack_require__(\"./core/field_textinput.js\");\n__webpack_require__(\"./core/field_variable.js\");\n__webpack_require__(\"./core/field.js\");\n__webpack_require__(\"./core/flyout_button.js\");\n__webpack_require__(\"./core/flyout_metrics_manager.js\");\n__webpack_require__(\"./core/flyout_base.js\");\n__webpack_require__(\"./core/generator.js\");\n__webpack_require__(\"./core/gesture.js\");\n__webpack_require__(\"./core/grid.js\");\n__webpack_require__(\"./core/flyout_horizontal.js\");\n__webpack_require__(\"./core/interfaces/i_ast_node_location_svg.js\");\n__webpack_require__(\"./core/interfaces/i_ast_node_location_with_block.js\");\n__webpack_require__(\"./core/interfaces/i_ast_node_location.js\");\n__webpack_require__(\"./core/interfaces/i_autohideable.js\");\n__webpack_require__(\"./core/interfaces/i_block_dragger.js\");\n__webpack_require__(\"./core/interfaces/i_bounded_element.js\");\n__webpack_require__(\"./core/interfaces/i_bubble.js\");\n__webpack_require__(\"./core/interfaces/i_collapsible_toolbox_item.js\");\n__webpack_require__(\"./core/interfaces/i_component.js\");\n__webpack_require__(\"./core/interfaces/i_connection_checker.js\");\n__webpack_require__(\"./core/interfaces/i_contextmenu.js\");\n__webpack_require__(\"./core/interfaces/i_copyable.js\");\n__webpack_require__(\"./core/interfaces/i_deletable.js\");\n__webpack_require__(\"./core/interfaces/i_delete_area.js\");\n__webpack_require__(\"./core/interfaces/i_drag_target.js\");\n__webpack_require__(\"./core/interfaces/i_draggable.js\");\n__webpack_require__(\"./core/interfaces/i_flyout.js\");\n__webpack_require__(\"./core/interfaces/i_keyboard_accessible.js\");\n__webpack_require__(\"./core/interfaces/i_metrics_manager.js\");\n__webpack_require__(\"./core/interfaces/i_movable.js\");\n__webpack_require__(\"./core/interfaces/i_positionable.js\");\n__webpack_require__(\"./core/interfaces/i_registrable_field.js\");\n__webpack_require__(\"./core/interfaces/i_registrable.js\");\n__webpack_require__(\"./core/interfaces/i_selectable_toolbox_item.js\");\n__webpack_require__(\"./core/interfaces/i_selectable.js\");\n__webpack_require__(\"./core/interfaces/i_serializer.js\");\n__webpack_require__(\"./core/interfaces/i_styleable.js\");\n__webpack_require__(\"./core/interfaces/i_toolbox_item.js\");\n__webpack_require__(\"./core/interfaces/i_toolbox.js\");\n__webpack_require__(\"./core/icon.js\");\n__webpack_require__(\"./core/insertion_marker_manager.js\");\n__webpack_require__(\"./core/keyboard_nav/marker.js\");\n__webpack_require__(\"./core/marker_manager.js\");\n__webpack_require__(\"./core/menuitem.js\");\n__webpack_require__(\"./core/menu.js\");\n__webpack_require__(\"./core/metrics_manager.js\");\n__webpack_require__(\"./core/mutator.js\");\n__webpack_require__(\"./core/msg.js\");\n__webpack_require__(\"./core/names.js\");\n__webpack_require__(\"./core/options.js\");\n__webpack_require__(\"./core/rendered_connection.js\");\n__webpack_require__(\"./core/scrollbar_pair.js\");\n__webpack_require__(\"./core/scrollbar.js\");\n__webpack_require__(\"./core/shortcut_registry.js\");\n__webpack_require__(\"./core/keyboard_nav/tab_navigate_cursor.js\");\n__webpack_require__(\"./core/theme_manager.js\");\n__webpack_require__(\"./core/theme.js\");\n__webpack_require__(\"./core/toolbox/category.js\");\n__webpack_require__(\"./core/toolbox/toolbox_item.js\");\n__webpack_require__(\"./core/toolbox/separator.js\");\n__webpack_require__(\"./core/toolbox/toolbox.js\");\n__webpack_require__(\"./core/touch_gesture.js\");\n__webpack_require__(\"./core/trashcan.js\");\n__webpack_require__(\"./core/variable_map.js\");\n__webpack_require__(\"./core/variable_model.js\");\n__webpack_require__(\"./core/flyout_vertical.js\");\n__webpack_require__(\"./core/warning.js\");\n__webpack_require__(\"./core/workspace_audio.js\");\n__webpack_require__(\"./core/workspace_comment_svg.js\");\n__webpack_require__(\"./core/workspace_comment.js\");\n__webpack_require__(\"./core/workspace_drag_surface_svg.js\");\n__webpack_require__(\"./core/workspace_dragger.js\");\n__webpack_require__(\"./core/workspace_svg.js\");\n__webpack_require__(\"./core/workspace.js\");\n__webpack_require__(\"./core/zoom_controls.js\");\n__webpack_require__(\"./core/utils/global.js\");\n__webpack_require__(\"./core/inject.js\");\n__webpack_require__(\"./core/input_types.js\");\n__webpack_require__(\"./core/events/events_block_create.js\");\n__webpack_require__(\"./core/events/workspace_events.js\");\n__webpack_require__(\"./core/events/events_ui.js\");\n__webpack_require__(\"./core/events/events_ui_base.js\");\n__webpack_require__(\"./core/events/events_var_create.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2011 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The top level namespace used to access the Blockly library.\n */\n\n\n/**\n * The top level namespace used to access the Blockly library.\n * @namespace Blockly\n */\ngoog.module('Blockly');\ngoog.module.declareLegacyNamespace();\n\nconst ContextMenu = goog.require('Blockly.ContextMenu');\nconst ContextMenuItems = goog.require('Blockly.ContextMenuItems');\nconst Css = goog.require('Blockly.Css');\nconst Events = goog.require('Blockly.Events');\nconst Extensions = goog.require('Blockly.Extensions');\nconst Procedures = goog.require('Blockly.Procedures');\nconst ShortcutItems = goog.require('Blockly.ShortcutItems');\nconst Themes = goog.require('Blockly.Themes');\nconst Tooltip = goog.require('Blockly.Tooltip');\nconst Touch = goog.require('Blockly.Touch');\nconst Variables = goog.require('Blockly.Variables');\nconst VariablesDynamic = goog.require('Blockly.VariablesDynamic');\nconst WidgetDiv = goog.require('Blockly.WidgetDiv');\nconst Xml = goog.require('Blockly.Xml');\nconst blockAnimations = goog.require('Blockly.blockAnimations');\nconst blockRendering = goog.require('Blockly.blockRendering');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst bumpObjects = goog.require('Blockly.bumpObjects');\nconst clipboard = goog.require('Blockly.clipboard');\nconst colour = goog.require('Blockly.utils.colour');\nconst common = goog.require('Blockly.common');\nconst constants = goog.require('Blockly.constants');\nconst deprecation = goog.require('Blockly.utils.deprecation');\nconst dialog = goog.require('Blockly.dialog');\nconst dropDownDiv = goog.require('Blockly.dropDownDiv');\nconst fieldRegistry = goog.require('Blockly.fieldRegistry');\nconst geras = goog.require('Blockly.geras');\nconst internalConstants = goog.require('Blockly.internalConstants');\nconst minimalist = goog.require('Blockly.minimalist');\nconst registry = goog.require('Blockly.registry');\nconst serializationBlocks = goog.require('Blockly.serialization.blocks');\nconst serializationExceptions = goog.require('Blockly.serialization.exceptions');\nconst serializationPriorities = goog.require('Blockly.serialization.priorities');\nconst serializationRegistry = goog.require('Blockly.serialization.registry');\nconst serializationVariables = goog.require('Blockly.serialization.variables');\nconst serializationWorkspaces = goog.require('Blockly.serialization.workspaces');\nconst svgMath = goog.require('Blockly.utils.svgMath');\nconst thrasos = goog.require('Blockly.thrasos');\nconst toolbox = goog.require('Blockly.utils.toolbox');\nconst uiPosition = goog.require('Blockly.uiPosition');\nconst utils = goog.require('Blockly.utils');\nconst zelos = goog.require('Blockly.zelos');\nconst {Align, Input} = goog.require('Blockly.Input');\nconst {ASTNode} = goog.require('Blockly.ASTNode');\nconst {BasicCursor} = goog.require('Blockly.BasicCursor');\nconst {BlockDragSurfaceSvg} = goog.require('Blockly.BlockDragSurfaceSvg');\nconst {BlockDragger} = goog.require('Blockly.BlockDragger');\nconst {BlockSvg} = goog.require('Blockly.BlockSvg');\nconst {BlocklyOptions} = goog.require('Blockly.BlocklyOptions');\nconst {Blocks} = goog.require('Blockly.blocks');\nconst {Block} = goog.require('Blockly.Block');\nconst {BubbleDragger} = goog.require('Blockly.BubbleDragger');\nconst {Bubble} = goog.require('Blockly.Bubble');\nconst {CollapsibleToolboxCategory} = goog.require('Blockly.CollapsibleToolboxCategory');\nconst {Comment} = goog.require('Blockly.Comment');\nconst {ComponentManager} = goog.require('Blockly.ComponentManager');\nconst {config} = goog.require('Blockly.config');\nconst {ConnectionChecker} = goog.require('Blockly.ConnectionChecker');\nconst {ConnectionDB} = goog.require('Blockly.ConnectionDB');\nconst {ConnectionType} = goog.require('Blockly.ConnectionType');\nconst {Connection} = goog.require('Blockly.Connection');\nconst {ContextMenuRegistry} = goog.require('Blockly.ContextMenuRegistry');\nconst {Cursor} = goog.require('Blockly.Cursor');\nconst {DeleteArea} = goog.require('Blockly.DeleteArea');\nconst {DragTarget} = goog.require('Blockly.DragTarget');\nconst {FieldAngle} = goog.require('Blockly.FieldAngle');\nconst {FieldCheckbox} = goog.require('Blockly.FieldCheckbox');\nconst {FieldColour} = goog.require('Blockly.FieldColour');\nconst {FieldDropdown} = goog.require('Blockly.FieldDropdown');\nconst {FieldImage} = goog.require('Blockly.FieldImage');\nconst {FieldLabelSerializable} = goog.require('Blockly.FieldLabelSerializable');\nconst {FieldLabel} = goog.require('Blockly.FieldLabel');\nconst {FieldMultilineInput} = goog.require('Blockly.FieldMultilineInput');\nconst {FieldNumber} = goog.require('Blockly.FieldNumber');\nconst {FieldTextInput} = goog.require('Blockly.FieldTextInput');\nconst {FieldVariable} = goog.require('Blockly.FieldVariable');\nconst {Field} = goog.require('Blockly.Field');\nconst {FlyoutButton} = goog.require('Blockly.FlyoutButton');\nconst {FlyoutMetricsManager} = goog.require('Blockly.FlyoutMetricsManager');\nconst {Flyout} = goog.require('Blockly.Flyout');\nconst {Generator} = goog.require('Blockly.Generator');\nconst {Gesture} = goog.require('Blockly.Gesture');\nconst {Grid} = goog.require('Blockly.Grid');\nconst {HorizontalFlyout} = goog.require('Blockly.HorizontalFlyout');\nconst {IASTNodeLocationSvg} = goog.require('Blockly.IASTNodeLocationSvg');\nconst {IASTNodeLocationWithBlock} = goog.require('Blockly.IASTNodeLocationWithBlock');\nconst {IASTNodeLocation} = goog.require('Blockly.IASTNodeLocation');\nconst {IAutoHideable} = goog.require('Blockly.IAutoHideable');\nconst {IBlockDragger} = goog.require('Blockly.IBlockDragger');\nconst {IBoundedElement} = goog.require('Blockly.IBoundedElement');\nconst {IBubble} = goog.require('Blockly.IBubble');\nconst {ICollapsibleToolboxItem} = goog.require('Blockly.ICollapsibleToolboxItem');\nconst {IComponent} = goog.require('Blockly.IComponent');\nconst {IConnectionChecker} = goog.require('Blockly.IConnectionChecker');\nconst {IContextMenu} = goog.require('Blockly.IContextMenu');\nconst {ICopyable} = goog.require('Blockly.ICopyable');\nconst {IDeletable} = goog.require('Blockly.IDeletable');\nconst {IDeleteArea} = goog.require('Blockly.IDeleteArea');\nconst {IDragTarget} = goog.require('Blockly.IDragTarget');\nconst {IDraggable} = goog.require('Blockly.IDraggable');\nconst {IFlyout} = goog.require('Blockly.IFlyout');\nconst {IKeyboardAccessible} = goog.require('Blockly.IKeyboardAccessible');\nconst {IMetricsManager} = goog.require('Blockly.IMetricsManager');\nconst {IMovable} = goog.require('Blockly.IMovable');\nconst {IPositionable} = goog.require('Blockly.IPositionable');\nconst {IRegistrableField} = goog.require('Blockly.IRegistrableField');\nconst {IRegistrable} = goog.require('Blockly.IRegistrable');\nconst {ISelectableToolboxItem} = goog.require('Blockly.ISelectableToolboxItem');\nconst {ISelectable} = goog.require('Blockly.ISelectable');\nconst {ISerializer} = goog.require('Blockly.serialization.ISerializer');\nconst {IStyleable} = goog.require('Blockly.IStyleable');\nconst {IToolboxItem} = goog.require('Blockly.IToolboxItem');\nconst {IToolbox} = goog.require('Blockly.IToolbox');\nconst {Icon} = goog.require('Blockly.Icon');\nconst {InsertionMarkerManager} = goog.require('Blockly.InsertionMarkerManager');\nconst {Marker} = goog.require('Blockly.Marker');\nconst {MarkerManager} = goog.require('Blockly.MarkerManager');\nconst {MenuItem} = goog.require('Blockly.MenuItem');\nconst {Menu} = goog.require('Blockly.Menu');\nconst {MetricsManager} = goog.require('Blockly.MetricsManager');\nconst {Mutator} = goog.require('Blockly.Mutator');\nconst {Msg} = goog.require('Blockly.Msg');\nconst {Names} = goog.require('Blockly.Names');\nconst {Options} = goog.require('Blockly.Options');\nconst {RenderedConnection} = goog.require('Blockly.RenderedConnection');\nconst {ScrollbarPair} = goog.require('Blockly.ScrollbarPair');\nconst {Scrollbar} = goog.require('Blockly.Scrollbar');\nconst {ShortcutRegistry} = goog.require('Blockly.ShortcutRegistry');\nconst {TabNavigateCursor} = goog.require('Blockly.TabNavigateCursor');\nconst {ThemeManager} = goog.require('Blockly.ThemeManager');\nconst {Theme} = goog.require('Blockly.Theme');\nconst {ToolboxCategory} = goog.require('Blockly.ToolboxCategory');\nconst {ToolboxItem} = goog.require('Blockly.ToolboxItem');\nconst {ToolboxSeparator} = goog.require('Blockly.ToolboxSeparator');\nconst {Toolbox} = goog.require('Blockly.Toolbox');\nconst {TouchGesture} = goog.require('Blockly.TouchGesture');\nconst {Trashcan} = goog.require('Blockly.Trashcan');\nconst {VariableMap} = goog.require('Blockly.VariableMap');\nconst {VariableModel} = goog.require('Blockly.VariableModel');\nconst {VerticalFlyout} = goog.require('Blockly.VerticalFlyout');\nconst {Warning} = goog.require('Blockly.Warning');\nconst {WorkspaceAudio} = goog.require('Blockly.WorkspaceAudio');\nconst {WorkspaceCommentSvg} = goog.require('Blockly.WorkspaceCommentSvg');\nconst {WorkspaceComment} = goog.require('Blockly.WorkspaceComment');\nconst {WorkspaceDragSurfaceSvg} = goog.require('Blockly.WorkspaceDragSurfaceSvg');\nconst {WorkspaceDragger} = goog.require('Blockly.WorkspaceDragger');\nconst {WorkspaceSvg, resizeSvgContents} = goog.require('Blockly.WorkspaceSvg');\nconst {Workspace} = goog.require('Blockly.Workspace');\nconst {ZoomControls} = goog.require('Blockly.ZoomControls');\nconst {globalThis} = goog.require('Blockly.utils.global');\nconst {inject} = goog.require('Blockly.inject');\nconst {inputTypes} = goog.require('Blockly.inputTypes');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockCreate');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.FinishedLoading');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.Ui');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.UiBase');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.VarCreate');\n\n\n/**\n * Blockly core version.\n * This constant is overridden by the build script (npm run build) to the value\n * of the version in package.json. This is done by the Closure Compiler in the\n * buildCompressed gulp task.\n * For local builds, you can pass --define='Blockly.VERSION=X.Y.Z' to the\n * compiler to override this constant.\n * @define {string}\n * @alias Blockly.VERSION\n */\nexports.VERSION = 'uncompiled';\n\n/*\n * Top-level functions and properties on the Blockly namespace.\n * These are used only in external code. Do not reference these\n * from internal code as importing from this file can cause circular\n * dependencies. Do not add new functions here. There is probably a better\n * namespace to put new functions on.\n */\n\n/*\n * Aliases for input alignments used in block defintions.\n */\n\n/**\n * @see Blockly.Input.Align.LEFT\n * @alias Blockly.ALIGN_LEFT\n */\nexports.ALIGN_LEFT = Align.LEFT;\n\n/**\n * @see Blockly.Input.Align.CENTRE\n * @alias Blockly.ALIGN_CENTRE\n */\nexports.ALIGN_CENTRE = Align.CENTRE;\n\n/**\n * @see Blockly.Input.Align.RIGHT\n * @alias Blockly.ALIGN_RIGHT\n */\nexports.ALIGN_RIGHT = Align.RIGHT;\n\n/*\n * Aliases for constants used for connection and input types.\n */\n\n/**\n * @see ConnectionType.INPUT_VALUE\n * @alias Blockly.INPUT_VALUE\n */\nexports.INPUT_VALUE = ConnectionType.INPUT_VALUE;\n\n/**\n * @see ConnectionType.OUTPUT_VALUE\n * @alias Blockly.OUTPUT_VALUE\n */\nexports.OUTPUT_VALUE = ConnectionType.OUTPUT_VALUE;\n\n/**\n * @see ConnectionType.NEXT_STATEMENT\n * @alias Blockly.NEXT_STATEMENT\n */\nexports.NEXT_STATEMENT = ConnectionType.NEXT_STATEMENT;\n\n/**\n * @see ConnectionType.PREVIOUS_STATEMENT\n * @alias Blockly.PREVIOUS_STATEMENT\n */\nexports.PREVIOUS_STATEMENT = ConnectionType.PREVIOUS_STATEMENT;\n\n/**\n * @see inputTypes.DUMMY_INPUT\n * @alias Blockly.DUMMY_INPUT\n */\nexports.DUMMY_INPUT = inputTypes.DUMMY;\n\n/**\n * Aliases for toolbox positions.\n */\n\n/**\n * @see toolbox.Position.TOP\n * @alias Blockly.TOOLBOX_AT_TOP\n */\nexports.TOOLBOX_AT_TOP = toolbox.Position.TOP;\n\n/**\n * @see toolbox.Position.BOTTOM\n * @alias Blockly.TOOLBOX_AT_BOTTOM\n */\nexports.TOOLBOX_AT_BOTTOM = toolbox.Position.BOTTOM;\n\n/**\n * @see toolbox.Position.LEFT\n * @alias Blockly.TOOLBOX_AT_LEFT\n */\nexports.TOOLBOX_AT_LEFT = toolbox.Position.LEFT;\n\n/**\n * @see toolbox.Position.RIGHT\n * @alias Blockly.TOOLBOX_AT_RIGHT\n */\nexports.TOOLBOX_AT_RIGHT = toolbox.Position.RIGHT;\n\n/*\n * Other aliased functions.\n */\n\n/**\n * Size the SVG image to completely fill its container. Call this when the view\n * actually changes sizes (e.g. on a window resize/device orientation change).\n * See workspace.resizeContents to resize the workspace when the contents\n * change (e.g. when a block is added or removed).\n * Record the height/width of the SVG image.\n * @param {!WorkspaceSvg} workspace Any workspace in the SVG.\n * @see Blockly.common.svgResize\n * @alias Blockly.svgResize\n */\nexports.svgResize = common.svgResize;\n\n/**\n * Close tooltips, context menus, dropdown selections, etc.\n * @param {boolean=} opt_onlyClosePopups Whether only popups should be closed.\n * @see Blockly.WorkspaceSvg.hideChaff\n * @alias Blockly.hideChaff\n */\nconst hideChaff = function(opt_onlyClosePopups) {\n  /** @type {!WorkspaceSvg} */ (common.getMainWorkspace())\n      .hideChaff(opt_onlyClosePopups);\n};\nexports.hideChaff = hideChaff;\n\n/**\n * Returns the main workspace.  Returns the last used main workspace (based on\n * focus).  Try not to use this function, particularly if there are multiple\n * Blockly instances on a page.\n * @return {!Workspace} The main workspace.\n * @see Blockly.common.getMainWorkspace\n * @alias Blockly.getMainWorkspace\n */\nexports.getMainWorkspace = common.getMainWorkspace;\n\n/**\n * Define blocks from an array of JSON block definitions, as might be generated\n * by the Blockly Developer Tools.\n * @param {!Array<!Object>} jsonArray An array of JSON block definitions.\n * @see Blockly.common.defineBlocksWithJsonArray\n * @alias Blockly.defineBlocksWithJsonArray\n */\nexports.defineBlocksWithJsonArray = common.defineBlocksWithJsonArray;\n\n/**\n * Set the parent container.  This is the container element that the WidgetDiv,\n * dropDownDiv, and Tooltip are rendered into the first time `Blockly.inject`\n * is called.\n * This method is a NOP if called after the first ``Blockly.inject``.\n * @param {!Element} container The container element.\n * @see Blockly.common.setParentContainer\n * @alias Blockly.setParentContainer\n */\nexports.setParentContainer = common.setParentContainer;\n\n/*\n * Aliased functions and properties that used to be on the Blockly namespace.\n * Everything in this section is deprecated. Both external and internal code\n * should avoid using these functions and use the designated replacements.\n * Anything in this section may be removed in a future version of Blockly.\n */\n\n// Add accessors for properties on Blockly that have now been deprecated.\nObject.defineProperties(exports, {\n  /**\n   * Wrapper to window.alert() that app developers may override to\n   * provide alternatives to the modal browser window.\n   * @name Blockly.alert\n   * @type {!function(string, function()=)}\n   * @deprecated Use Blockly.dialog.alert / .setAlert() instead.\n   *     (December 2021)\n   * @suppress {checkTypes}\n   */\n  alert: {\n    set: function(newAlert) {\n      deprecation.warn('Blockly.alert', 'December 2021', 'December 2022');\n      dialog.setAlert(newAlert);\n    },\n    get: function() {\n      deprecation.warn(\n          'Blockly.alert', 'December 2021', 'December 2022',\n          'Blockly.dialog.alert()');\n      return dialog.alert;\n    },\n  },\n  /**\n   * Wrapper to window.confirm() that app developers may override to\n   * provide alternatives to the modal browser window.\n   * @name Blockly.confirm\n   * @type {!function(string, function()=)}\n   * @deprecated Use Blockly.dialog.confirm / .setConfirm() instead.\n   *     (December 2021)\n   * @suppress {checkTypes}\n   */\n  confirm: {\n    set: function(newConfirm) {\n      deprecation.warn('Blockly.confirm', 'December 2021', 'December 2022');\n      dialog.setConfirm(newConfirm);\n    },\n    get: function() {\n      deprecation.warn(\n          'Blockly.confirm', 'December 2021', 'December 2022',\n          'Blockly.dialog.confirm()');\n      return dialog.confirm;\n    },\n  },\n  /**\n   * The main workspace most recently used.\n   * Set by Blockly.WorkspaceSvg.prototype.markFocused\n   * @name Blockly.mainWorkspace\n   * @type {Workspace}\n   * @suppress {checkTypes}\n   */\n  mainWorkspace: {\n    set: function(x) {\n      common.setMainWorkspace(x);\n    },\n    get: function() {\n      return common.getMainWorkspace();\n    },\n  },\n  /**\n   * Wrapper to window.prompt() that app developers may override to\n   * provide alternatives to the modal browser window. Built-in\n   * browser prompts are often used for better text input experience\n   * on mobile device. We strongly recommend testing mobile when\n   * overriding this.\n   * @name Blockly.prompt\n   * @type {!function(string, string, function()=)}\n   * @deprecated Use Blockly.dialog.prompt / .setPrompt() instead.\n   *     (December 2021)\n   * @suppress {checkTypes}\n   */\n  prompt: {\n    set: function(newPrompt) {\n      deprecation.warn('Blockly.prompt', 'December 2021', 'December 2022');\n      dialog.setPrompt(newPrompt);\n    },\n    get: function() {\n      deprecation.warn(\n          'Blockly.prompt', 'December 2021', 'December 2022',\n          'Blockly.dialog.prompt()');\n      return dialog.prompt;\n    },\n  },\n  /**\n   * Currently selected block.\n   * @name Blockly.selected\n   * @type {?ICopyable}\n   * @suppress {checkTypes}\n   */\n  selected: {\n    get: function() {\n      return common.getSelected();\n    },\n    set: function(newSelection) {\n      common.setSelected(newSelection);\n    },\n  },\n  /**\n   * The richness of block colours, regardless of the hue.\n   * Must be in the range of 0 (inclusive) to 1 (exclusive).\n   * @name Blockly.HSV_SATURATION\n   * @type {number}\n   * @suppress {checkTypes}\n   */\n  HSV_SATURATION: {\n    get: function() {\n      return utils.colour.getHsvSaturation();\n    },\n    set: function(newValue) {\n      utils.colour.setHsvSaturation(newValue);\n    },\n  },\n  /**\n   * The intensity of block colours, regardless of the hue.\n   * Must be in the range of 0 (inclusive) to 1 (exclusive).\n   * @name Blockly.HSV_VALUE\n   * @type {number}\n   * @suppress {checkTypes}\n   */\n  HSV_VALUE: {\n    get: function() {\n      return utils.colour.getHsvValue();\n    },\n    set: function(newValue) {\n      utils.colour.setHsvValue(newValue);\n    },\n  },\n});\n\n/**\n * Returns the dimensions of the specified SVG image.\n * @param {!SVGElement} svg SVG image.\n * @return {!Size} Contains width and height properties.\n * @deprecated Use workspace.setCachedParentSvgSize. (2021 March 5)\n * @see Blockly.WorkspaceSvg.setCachedParentSvgSize\n * @alias Blockly.svgSize\n */\nexports.svgSize = svgMath.svgSize;\n\n/**\n * Size the workspace when the contents change.  This also updates\n * scrollbars accordingly.\n * @param {!WorkspaceSvg} workspace The workspace to resize.\n * @deprecated Use workspace.resizeContents. (2021 December)\n * @see Blockly.WorkspaceSvg.resizeContents\n * @alias Blockly.resizeSvgContents\n */\nconst resizeSvgContentsLocal = function(workspace) {\n  deprecation.warn(\n      'Blockly.resizeSvgContents', 'December 2021', 'December 2022',\n      'Blockly.WorkspaceSvg.resizeSvgContents');\n  resizeSvgContents(workspace);\n};\nexports.resizeSvgContents = resizeSvgContentsLocal;\n\n/**\n * Copy a block or workspace comment onto the local clipboard.\n * @param {!ICopyable} toCopy Block or Workspace Comment to be copied.\n * @deprecated Use Blockly.clipboard.copy(). (2021 December)\n * @see Blockly.clipboard.copy\n * @alias Blockly.copy\n */\nconst copy = function(toCopy) {\n  deprecation.warn(\n      'Blockly.copy', 'December 2021', 'December 2022',\n      'Blockly.clipboard.copy');\n  clipboard.copy(toCopy);\n};\nexports.copy = copy;\n\n/**\n * Paste a block or workspace comment on to the main workspace.\n * @return {boolean} True if the paste was successful, false otherwise.\n * @deprecated Use Blockly.clipboard.paste(). (2021 December)\n * @see Blockly.clipboard.paste\n * @alias Blockly.paste\n */\nconst paste = function() {\n  deprecation.warn(\n      'Blockly.paste', 'December 2021', 'December 2022',\n      'Blockly.clipboard.paste');\n  return !!clipboard.paste();\n};\nexports.paste = paste;\n\n/**\n * Duplicate this block and its children, or a workspace comment.\n * @param {!ICopyable} toDuplicate Block or Workspace Comment to be\n *     copied.\n * @deprecated Use Blockly.clipboard.duplicate(). (2021 December)\n * @see Blockly.clipboard.duplicate\n * @alias Blockly.duplicate\n */\nconst duplicate = function(toDuplicate) {\n  deprecation.warn(\n      'Blockly.duplicate', 'December 2021', 'December 2022',\n      'Blockly.clipboard.duplicate');\n  clipboard.duplicate(toDuplicate);\n};\nexports.duplicate = duplicate;\n\n/**\n * Is the given string a number (includes negative and decimals).\n * @param {string} str Input string.\n * @return {boolean} True if number, false otherwise.\n * @deprecated Use Blockly.utils.string.isNumber(str). (2021 December)\n * @see Blockly.utils.string.isNumber\n * @alias Blockly.isNumber\n */\nconst isNumber = function(str) {\n  deprecation.warn(\n      'Blockly.isNumber', 'December 2021', 'December 2022',\n      'Blockly.utils.string.isNumber');\n  return utils.string.isNumber(str);\n};\nexports.isNumber = isNumber;\n\n/**\n * Convert a hue (HSV model) into an RGB hex triplet.\n * @param {number} hue Hue on a colour wheel (0-360).\n * @return {string} RGB code, e.g. '#5ba65b'.\n * @deprecated Use Blockly.utils.colour.hueToHex(). (2021 December)\n * @see Blockly.utils.colour.hueToHex\n * @alias Blockly.hueToHex\n */\nconst hueToHex = function(hue) {\n  deprecation.warn(\n      'Blockly.hueToHex', 'December 2021', 'December 2022',\n      'Blockly.utils.colour.hueToHex');\n  return colour.hueToHex(hue);\n};\nexports.hueToHex = hueToHex;\n\n/**\n * Bind an event handler that should be called regardless of whether it is part\n * of the active touch stream.\n * Use this for events that are not part of a multi-part gesture (e.g.\n * mouseover for tooltips).\n * @param {!EventTarget} node Node upon which to listen.\n * @param {string} name Event name to listen to (e.g. 'mousedown').\n * @param {?Object} thisObject The value of 'this' in the function.\n * @param {!Function} func Function to call when event is triggered.\n * @return {!browserEvents.Data} Opaque data that can be passed to\n *     unbindEvent_.\n * @deprecated Use Blockly.browserEvents.bind(). (December 2021)\n * @see Blockly.browserEvents.bind\n * @alias Blockly.bindEvent_\n */\nconst bindEvent_ = function(node, name, thisObject, func) {\n  deprecation.warn(\n      'Blockly.bindEvent_', 'December 2021', 'December 2022',\n      'Blockly.browserEvents.bind');\n  return browserEvents.bind(node, name, thisObject, func);\n};\nexports.bindEvent_ = bindEvent_;\n\n/**\n * Unbind one or more events event from a function call.\n * @param {!browserEvents.Data} bindData Opaque data from bindEvent_.\n *     This list is emptied during the course of calling this function.\n * @return {!Function} The function call.\n * @deprecated Use Blockly.browserEvents.unbind(). (December 2021)\n * @see browserEvents.unbind\n * @alias Blockly.unbindEvent_\n */\nconst unbindEvent_ = function(bindData) {\n  deprecation.warn(\n      'Blockly.unbindEvent_', 'December 2021', 'December 2022',\n      'Blockly.browserEvents.unbind');\n  return browserEvents.unbind(bindData);\n};\nexports.unbindEvent_ = unbindEvent_;\n\n/**\n * Bind an event handler that can be ignored if it is not part of the active\n * touch stream.\n * Use this for events that either start or continue a multi-part gesture (e.g.\n * mousedown or mousemove, which may be part of a drag or click).\n * @param {!EventTarget} node Node upon which to listen.\n * @param {string} name Event name to listen to (e.g. 'mousedown').\n * @param {?Object} thisObject The value of 'this' in the function.\n * @param {!Function} func Function to call when event is triggered.\n * @param {boolean=} opt_noCaptureIdentifier True if triggering on this event\n *     should not block execution of other event handlers on this touch or\n *     other simultaneous touches.  False by default.\n * @param {boolean=} opt_noPreventDefault True if triggering on this event\n *     should prevent the default handler.  False by default.  If\n *     opt_noPreventDefault is provided, opt_noCaptureIdentifier must also be\n *     provided.\n * @return {!browserEvents.Data} Opaque data that can be passed to\n *     unbindEvent_.\n * @deprecated Use Blockly.browserEvents.conditionalBind(). (December 2021)\n * @see browserEvents.conditionalBind\n * @alias Blockly.bindEventWithChecks_\n */\nconst bindEventWithChecks_ = function(\n    node, name, thisObject, func, opt_noCaptureIdentifier,\n    opt_noPreventDefault) {\n  deprecation.warn(\n      'Blockly.bindEventWithChecks_', 'December 2021', 'December 2022',\n      'Blockly.browserEvents.conditionalBind');\n  return browserEvents.conditionalBind(\n      node, name, thisObject, func, opt_noCaptureIdentifier,\n      opt_noPreventDefault);\n};\nexports.bindEventWithChecks_ = bindEventWithChecks_;\n\n// Aliases to allow external code to access these values for legacy reasons.\nexports.COLLAPSE_CHARS = internalConstants.COLLAPSE_CHARS;\nexports.DRAG_STACK = internalConstants.DRAG_STACK;\nexports.OPPOSITE_TYPE = internalConstants.OPPOSITE_TYPE;\nexports.RENAME_VARIABLE_ID = internalConstants.RENAME_VARIABLE_ID;\nexports.DELETE_VARIABLE_ID = internalConstants.DELETE_VARIABLE_ID;\nexports.COLLAPSED_INPUT_NAME = constants.COLLAPSED_INPUT_NAME;\nexports.COLLAPSED_FIELD_NAME = constants.COLLAPSED_FIELD_NAME;\n\n/**\n * String for use in the \"custom\" attribute of a category in toolbox XML.\n * This string indicates that the category should be dynamically populated with\n * variable blocks.\n * @const {string}\n * @alias Blockly.VARIABLE_CATEGORY_NAME\n */\nexports.VARIABLE_CATEGORY_NAME = Variables.CATEGORY_NAME;\n\n/**\n * String for use in the \"custom\" attribute of a category in toolbox XML.\n * This string indicates that the category should be dynamically populated with\n * variable blocks.\n * @const {string}\n * @alias Blockly.VARIABLE_DYNAMIC_CATEGORY_NAME\n */\nexports.VARIABLE_DYNAMIC_CATEGORY_NAME = VariablesDynamic.CATEGORY_NAME;\n/**\n * String for use in the \"custom\" attribute of a category in toolbox XML.\n * This string indicates that the category should be dynamically populated with\n * procedure blocks.\n * @const {string}\n * @alias Blockly.PROCEDURE_CATEGORY_NAME\n */\nexports.PROCEDURE_CATEGORY_NAME = Procedures.CATEGORY_NAME;\n\n// Re-export submodules that no longer declareLegacyNamespace.\nexports.ASTNode = ASTNode;\nexports.BasicCursor = BasicCursor;\nexports.Block = Block;\nexports.BlocklyOptions = BlocklyOptions;\nexports.BlockDragger = BlockDragger;\nexports.BlockDragSurfaceSvg = BlockDragSurfaceSvg;\nexports.BlockSvg = BlockSvg;\nexports.Blocks = Blocks;\nexports.Bubble = Bubble;\nexports.BubbleDragger = BubbleDragger;\nexports.CollapsibleToolboxCategory = CollapsibleToolboxCategory;\nexports.Comment = Comment;\nexports.ComponentManager = ComponentManager;\nexports.Connection = Connection;\nexports.ConnectionType = ConnectionType;\nexports.ConnectionChecker = ConnectionChecker;\nexports.ConnectionDB = ConnectionDB;\nexports.ContextMenu = ContextMenu;\nexports.ContextMenuItems = ContextMenuItems;\nexports.ContextMenuRegistry = ContextMenuRegistry;\nexports.Css = Css;\nexports.Cursor = Cursor;\nexports.DeleteArea = DeleteArea;\nexports.DragTarget = DragTarget;\nexports.DropDownDiv = dropDownDiv;\nexports.Events = Events;\nexports.Extensions = Extensions;\nexports.Field = Field;\nexports.FieldAngle = FieldAngle;\nexports.FieldCheckbox = FieldCheckbox;\nexports.FieldColour = FieldColour;\nexports.FieldDropdown = FieldDropdown;\nexports.FieldImage = FieldImage;\nexports.FieldLabel = FieldLabel;\nexports.FieldLabelSerializable = FieldLabelSerializable;\nexports.FieldMultilineInput = FieldMultilineInput;\nexports.FieldNumber = FieldNumber;\nexports.FieldTextInput = FieldTextInput;\nexports.FieldVariable = FieldVariable;\nexports.Flyout = Flyout;\nexports.FlyoutButton = FlyoutButton;\nexports.FlyoutMetricsManager = FlyoutMetricsManager;\nexports.Generator = Generator;\nexports.Gesture = Gesture;\nexports.Grid = Grid;\nexports.HorizontalFlyout = HorizontalFlyout;\nexports.IASTNodeLocation = IASTNodeLocation;\nexports.IASTNodeLocationSvg = IASTNodeLocationSvg;\nexports.IASTNodeLocationWithBlock = IASTNodeLocationWithBlock;\nexports.IAutoHideable = IAutoHideable;\nexports.IBlockDragger = IBlockDragger;\nexports.IBoundedElement = IBoundedElement;\nexports.IBubble = IBubble;\nexports.ICollapsibleToolboxItem = ICollapsibleToolboxItem;\nexports.IComponent = IComponent;\nexports.IConnectionChecker = IConnectionChecker;\nexports.IContextMenu = IContextMenu;\nexports.Icon = Icon;\nexports.ICopyable = ICopyable;\nexports.IDeletable = IDeletable;\nexports.IDeleteArea = IDeleteArea;\nexports.IDragTarget = IDragTarget;\nexports.IDraggable = IDraggable;\nexports.IFlyout = IFlyout;\nexports.IKeyboardAccessible = IKeyboardAccessible;\nexports.IMetricsManager = IMetricsManager;\nexports.IMovable = IMovable;\nexports.Input = Input;\nexports.InsertionMarkerManager = InsertionMarkerManager;\nexports.IPositionable = IPositionable;\nexports.IRegistrable = IRegistrable;\nexports.IRegistrableField = IRegistrableField;\nexports.ISelectable = ISelectable;\nexports.ISelectableToolboxItem = ISelectableToolboxItem;\nexports.IStyleable = IStyleable;\nexports.IToolbox = IToolbox;\nexports.IToolboxItem = IToolboxItem;\nexports.Marker = Marker;\nexports.MarkerManager = MarkerManager;\nexports.Menu = Menu;\nexports.MenuItem = MenuItem;\nexports.MetricsManager = MetricsManager;\nexports.Mutator = Mutator;\nexports.Msg = Msg;\nexports.Names = Names;\nexports.Options = Options;\nexports.Procedures = Procedures;\nexports.RenderedConnection = RenderedConnection;\nexports.Scrollbar = Scrollbar;\nexports.ScrollbarPair = ScrollbarPair;\nexports.ShortcutItems = ShortcutItems;\nexports.ShortcutRegistry = ShortcutRegistry;\nexports.TabNavigateCursor = TabNavigateCursor;\nexports.Theme = Theme;\nexports.Themes = Themes;\nexports.ThemeManager = ThemeManager;\nexports.Toolbox = Toolbox;\nexports.ToolboxCategory = ToolboxCategory;\nexports.ToolboxItem = ToolboxItem;\nexports.ToolboxSeparator = ToolboxSeparator;\nexports.Tooltip = Tooltip;\nexports.Touch = Touch;\nexports.TouchGesture = TouchGesture;\nexports.Trashcan = Trashcan;\nexports.VariableMap = VariableMap;\nexports.VariableModel = VariableModel;\nexports.Variables = Variables;\nexports.VariablesDynamic = VariablesDynamic;\nexports.VerticalFlyout = VerticalFlyout;\nexports.Warning = Warning;\nexports.WidgetDiv = WidgetDiv;\nexports.Workspace = Workspace;\nexports.WorkspaceAudio = WorkspaceAudio;\nexports.WorkspaceComment = WorkspaceComment;\nexports.WorkspaceCommentSvg = WorkspaceCommentSvg;\nexports.WorkspaceDragSurfaceSvg = WorkspaceDragSurfaceSvg;\nexports.WorkspaceDragger = WorkspaceDragger;\nexports.WorkspaceSvg = WorkspaceSvg;\nexports.Xml = Xml;\nexports.ZoomControls = ZoomControls;\nexports.blockAnimations = blockAnimations;\nexports.blockRendering = blockRendering;\nexports.browserEvents = browserEvents;\nexports.bumpObjects = bumpObjects;\nexports.clipboard = clipboard;\nexports.common = common;\nexports.config = config;\n/** @deprecated Use Blockly.ConnectionType instead. */\nexports.connectionTypes = ConnectionType;\nexports.constants = constants;\nexports.dialog = dialog;\nexports.fieldRegistry = fieldRegistry;\nexports.geras = geras;\nexports.inject = inject;\nexports.inputTypes = inputTypes;\nexports.minimalist = minimalist;\nexports.registry = registry;\nexports.serialization = {\n  blocks: serializationBlocks,\n  exceptions: serializationExceptions,\n  priorities: serializationPriorities,\n  registry: serializationRegistry,\n  variables: serializationVariables,\n  workspaces: serializationWorkspaces,\n  ISerializer: ISerializer,\n};\nexports.thrasos = thrasos;\nexports.uiPosition = uiPosition;\nexports.utils = utils;\nexports.zelos = zelos;\n\n// If Blockly is compiled with ADVANCED_COMPILATION and/or loaded as a\n// CJS or ES module there will not be a Blockly global variable\n// created.  This can cause problems because a very common way of\n// loading translations is to use a <script> tag to load one of\n// msg/js/*.js, which consists of lines like:\n//\n// Blockly.Msg[\"ADD_COMMENT\"] = \"Add Comment\";\n// Blockly.Msg[\"CLEAN_UP\"] = \"Clean up Blocks\";\n//\n// This obviously only works if Blockly.Msg is the Msg export from the\n// Blockly.Msg module - so make sure it is, but only if there is not\n// yet a Blockly global variable.\nif (!('Blockly' in globalThis)) {\n  globalThis['Blockly'] = {'Msg': Msg};\n}\n\n// Temporary hack to copy accessor properties from exports to the\n// global Blockly object as the routine to copy exports in\n// goog.exportPath_ (see closure/goog/base.js) invoked by\n// declareLegacyNamespace only copies normal data properties, not\n// accessors.  This can be removed once all remaining calls to\n// declareLegacyNamspace have been removed.\n//\n// This is only needed in uncompiled mode (see\n// google/blockly-samples#902); in compiled mode the exports object is\n// already the value of globalThis['Blockly'].\n//\n// Note that this code will still attempt to redefine accessors on a\n// previously-imported copy of the Blockly library if both are\n// imported in uncompiled mode.  This will fail with TypeError as the\n// accessors are nonconfigurable (which is good, as otherwise one\n// accessors on one copy would call get/set functions on the other\n// copy!)\n/* eslint-disable-next-line no-undef */\nif (!COMPILED && typeof globalThis['Blockly'] === 'object' &&\n    globalThis['Blockly'] !== exports) {\n  const descriptors = Object.getOwnPropertyDescriptors(exports);\n  const accessors = {};\n  for (const key in descriptors) {\n    if (descriptors[key].get || descriptors[key].set) {\n      accessors[key] = descriptors[key];\n    }\n  }\n  Object.defineProperties(globalThis['Blockly'], accessors);\n}\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/blockly.js?")},
"./core/blockly_options.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object that defines user-specified options for the workspace.\n */\n\n\n/**\n * Object that defines user-specified options for the workspace.\n * @namespace Blockly.BlocklyOptions\n */\ngoog.module('Blockly.BlocklyOptions');\n\n\n/**\n * Blockly options.\n * This interface is further described in\n * `typings/parts/blockly-interfaces.d.ts`.\n * @interface\n * @alias Blockly.BlocklyOptions\n */\nconst BlocklyOptions = function() {};\n\nexports.BlocklyOptions = BlocklyOptions;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/blockly_options.js?")},
"./core/blocks.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2013 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A mapping of block type names to block prototype objects.\n */\n\n\n/**\n * A mapping of block type names to block prototype objects.\n * @namespace Blockly.blocks\n */\ngoog.module('Blockly.blocks');\n\n\n/**\n * A block definition.  For now this very lose, but it can potentially\n * be refined e.g. by replacing this typedef with a class definition.\n * @typedef {!Object}\n */\nlet BlockDefinition;\nexports.BlockDefinition = BlockDefinition;\n\n/**\n * A mapping of block type names to block prototype objects.\n * @type {!Object<string,!BlockDefinition>}\n * @alias Blockly.blocks.Blocks\n */\nconst Blocks = Object.create(null);\nexports.Blocks = Blocks;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/blocks.js?")},
"./core/browser_events.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/touch.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\n__webpack_require__(\"./core/utils/global.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Browser event handling.\n */\n\n\n/**\n * Browser event handling.\n * @namespace Blockly.browserEvents\n */\ngoog.module('Blockly.browserEvents');\n\nconst Touch = goog.require('Blockly.Touch');\nconst userAgent = goog.require('Blockly.utils.userAgent');\nconst {globalThis} = goog.require('Blockly.utils.global');\n\n\n/**\n * Blockly opaque event data used to unbind events when using\n * `bind` and `conditionalBind`.\n * @typedef {!Array<!Array>}\n * @alias Blockly.browserEvents.Data\n */\nlet Data;\nexports.Data = Data;\n\n/**\n * The multiplier for scroll wheel deltas using the line delta mode.\n * See https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\n * for more information on deltaMode.\n * @type {number}\n * @const\n */\nconst LINE_MODE_MULTIPLIER = 40;\n\n/**\n * The multiplier for scroll wheel deltas using the page delta mode.\n * See https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\n * for more information on deltaMode.\n * @type {number}\n * @const\n */\nconst PAGE_MODE_MULTIPLIER = 125;\n\n/**\n * Bind an event handler that can be ignored if it is not part of the active\n * touch stream.\n * Use this for events that either start or continue a multi-part gesture (e.g.\n * mousedown or mousemove, which may be part of a drag or click).\n * @param {!EventTarget} node Node upon which to listen.\n * @param {string} name Event name to listen to (e.g. 'mousedown').\n * @param {?Object} thisObject The value of 'this' in the function.\n * @param {!Function} func Function to call when event is triggered.\n * @param {boolean=} opt_noCaptureIdentifier True if triggering on this event\n *     should not block execution of other event handlers on this touch or\n *     other simultaneous touches.  False by default.\n * @param {boolean=} opt_noPreventDefault True if triggering on this event\n *     should prevent the default handler.  False by default.  If\n *     opt_noPreventDefault is provided, opt_noCaptureIdentifier must also be\n *     provided.\n * @return {!Data} Opaque data that can be passed to\n *     unbindEvent_.\n * @alias Blockly.browserEvents.conditionalBind\n */\nconst conditionalBind = function(\n    node, name, thisObject, func, opt_noCaptureIdentifier,\n    opt_noPreventDefault) {\n  let handled = false;\n  const wrapFunc = function(e) {\n    const captureIdentifier = !opt_noCaptureIdentifier;\n    // Handle each touch point separately.  If the event was a mouse event, this\n    // will hand back an array with one element, which we're fine handling.\n    const events = Touch.splitEventByTouches(e);\n    for (let i = 0; i < events.length; i++) {\n      const event = events[i];\n      if (captureIdentifier && !Touch.shouldHandleEvent(event)) {\n        continue;\n      }\n      Touch.setClientFromTouch(event);\n      if (thisObject) {\n        func.call(thisObject, event);\n      } else {\n        func(event);\n      }\n      handled = true;\n    }\n  };\n\n  const bindData = [];\n  if (globalThis['PointerEvent'] && (name in Touch.TOUCH_MAP)) {\n    for (let i = 0; i < Touch.TOUCH_MAP[name].length; i++) {\n      const type = Touch.TOUCH_MAP[name][i];\n      node.addEventListener(type, wrapFunc, false);\n      bindData.push([node, type, wrapFunc]);\n    }\n  } else {\n    node.addEventListener(name, wrapFunc, false);\n    bindData.push([node, name, wrapFunc]);\n\n    // Add equivalent touch event.\n    if (name in Touch.TOUCH_MAP) {\n      const touchWrapFunc = function(e) {\n        wrapFunc(e);\n        // Calling preventDefault stops the browser from scrolling/zooming the\n        // page.\n        const preventDef = !opt_noPreventDefault;\n        if (handled && preventDef) {\n          e.preventDefault();\n        }\n      };\n      for (let i = 0; i < Touch.TOUCH_MAP[name].length; i++) {\n        const type = Touch.TOUCH_MAP[name][i];\n        node.addEventListener(type, touchWrapFunc, false);\n        bindData.push([node, type, touchWrapFunc]);\n      }\n    }\n  }\n  return bindData;\n};\nexports.conditionalBind = conditionalBind;\n\n\n/**\n * Bind an event handler that should be called regardless of whether it is part\n * of the active touch stream.\n * Use this for events that are not part of a multi-part gesture (e.g.\n * mouseover for tooltips).\n * @param {!EventTarget} node Node upon which to listen.\n * @param {string} name Event name to listen to (e.g. 'mousedown').\n * @param {?Object} thisObject The value of 'this' in the function.\n * @param {!Function} func Function to call when event is triggered.\n * @return {!Data} Opaque data that can be passed to\n *     unbindEvent_.\n * @alias Blockly.browserEvents.bind\n */\nconst bind = function(node, name, thisObject, func) {\n  const wrapFunc = function(e) {\n    if (thisObject) {\n      func.call(thisObject, e);\n    } else {\n      func(e);\n    }\n  };\n\n  const bindData = [];\n  if (globalThis['PointerEvent'] && (name in Touch.TOUCH_MAP)) {\n    for (let i = 0; i < Touch.TOUCH_MAP[name].length; i++) {\n      const type = Touch.TOUCH_MAP[name][i];\n      node.addEventListener(type, wrapFunc, false);\n      bindData.push([node, type, wrapFunc]);\n    }\n  } else {\n    node.addEventListener(name, wrapFunc, false);\n    bindData.push([node, name, wrapFunc]);\n\n    // Add equivalent touch event.\n    if (name in Touch.TOUCH_MAP) {\n      const touchWrapFunc = function(e) {\n        // Punt on multitouch events.\n        if (e.changedTouches && e.changedTouches.length === 1) {\n          // Map the touch event's properties to the event.\n          const touchPoint = e.changedTouches[0];\n          e.clientX = touchPoint.clientX;\n          e.clientY = touchPoint.clientY;\n        }\n        wrapFunc(e);\n\n        // Stop the browser from scrolling/zooming the page.\n        e.preventDefault();\n      };\n      for (let i = 0; i < Touch.TOUCH_MAP[name].length; i++) {\n        const type = Touch.TOUCH_MAP[name][i];\n        node.addEventListener(type, touchWrapFunc, false);\n        bindData.push([node, type, touchWrapFunc]);\n      }\n    }\n  }\n  return bindData;\n};\nexports.bind = bind;\n\n/**\n * Unbind one or more events event from a function call.\n * @param {!Data} bindData Opaque data from bindEvent_.\n *     This list is emptied during the course of calling this function.\n * @return {!Function} The function call.\n * @alias Blockly.browserEvents.unbind\n */\nconst unbind = function(bindData) {\n  let func;\n  while (bindData.length) {\n    const bindDatum = bindData.pop();\n    const node = bindDatum[0];\n    const name = bindDatum[1];\n    func = bindDatum[2];\n    node.removeEventListener(name, func, false);\n  }\n  return func;\n};\nexports.unbind = unbind;\n\n/**\n * Returns true if this event is targeting a text input widget?\n * @param {!Event} e An event.\n * @return {boolean} True if text input.\n * @alias Blockly.browserEvents.isTargetInput\n */\nconst isTargetInput = function(e) {\n  return e.target.type === 'textarea' || e.target.type === 'text' ||\n      e.target.type === 'number' || e.target.type === 'email' ||\n      e.target.type === 'password' || e.target.type === 'search' ||\n      e.target.type === 'tel' || e.target.type === 'url' ||\n      e.target.isContentEditable ||\n      (e.target.dataset && e.target.dataset.isTextInput === 'true');\n};\nexports.isTargetInput = isTargetInput;\n\n/**\n * Returns true this event is a right-click.\n * @param {!Event} e Mouse event.\n * @return {boolean} True if right-click.\n * @alias Blockly.browserEvents.isRightButton\n */\nconst isRightButton = function(e) {\n  if (e.ctrlKey && userAgent.MAC) {\n    // Control-clicking on Mac OS X is treated as a right-click.\n    // WebKit on Mac OS X fails to change button to 2 (but Gecko does).\n    return true;\n  }\n  return e.button === 2;\n};\nexports.isRightButton = isRightButton;\n\n/**\n * Returns the converted coordinates of the given mouse event.\n * The origin (0,0) is the top-left corner of the Blockly SVG.\n * @param {!Event} e Mouse event.\n * @param {!Element} svg SVG element.\n * @param {?SVGMatrix} matrix Inverted screen CTM to use.\n * @return {!SVGPoint} Object with .x and .y properties.\n * @alias Blockly.browserEvents.mouseToSvg\n */\nconst mouseToSvg = function(e, svg, matrix) {\n  const svgPoint = svg.createSVGPoint();\n  svgPoint.x = e.clientX;\n  svgPoint.y = e.clientY;\n\n  if (!matrix) {\n    matrix = svg.getScreenCTM().inverse();\n  }\n  return svgPoint.matrixTransform(matrix);\n};\nexports.mouseToSvg = mouseToSvg;\n\n/**\n * Returns the scroll delta of a mouse event in pixel units.\n * @param {!Event} e Mouse event.\n * @return {{x: number, y: number}} Scroll delta object with .x and .y\n *    properties.\n * @alias Blockly.browserEvents.getScrollDeltaPixels\n */\nconst getScrollDeltaPixels = function(e) {\n  switch (e.deltaMode) {\n    case 0x00:  // Pixel mode.\n    default:\n      return {x: e.deltaX, y: e.deltaY};\n    case 0x01:  // Line mode.\n      return {\n        x: e.deltaX * LINE_MODE_MULTIPLIER,\n        y: e.deltaY * LINE_MODE_MULTIPLIER,\n      };\n    case 0x02:  // Page mode.\n      return {\n        x: e.deltaX * PAGE_MODE_MULTIPLIER,\n        y: e.deltaY * PAGE_MODE_MULTIPLIER,\n      };\n  }\n};\nexports.getScrollDeltaPixels = getScrollDeltaPixels;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/browser_events.js?")},
"./core/bubble.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/touch.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/utils/math.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/interfaces/i_bubble.js\");\n__webpack_require__(\"./core/scrollbar.js\");\n__webpack_require__(\"./core/utils/size.js\");\n__webpack_require__(\"./core/utils/svg.js\");\n__webpack_require__(\"./core/workspace.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing a UI bubble.\n */\n\n\n/**\n * Object representing a UI bubble.\n * @class\n */\ngoog.module('Blockly.Bubble');\n\nconst Touch = goog.require('Blockly.Touch');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst dom = goog.require('Blockly.utils.dom');\nconst math = goog.require('Blockly.utils.math');\nconst userAgent = goog.require('Blockly.utils.userAgent');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockDragSurfaceSvg} = goog.requireType('Blockly.BlockDragSurfaceSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\n/* eslint-disable-next-line no-unused-vars */\nconst {IBubble} = goog.require('Blockly.IBubble');\n/* eslint-disable-next-line no-unused-vars */\nconst {MetricsManager} = goog.requireType('Blockly.MetricsManager');\nconst {Scrollbar} = goog.require('Blockly.Scrollbar');\nconst {Size} = goog.require('Blockly.utils.Size');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Workspace');\n\n\n/**\n * Class for UI bubble.\n * @implements {IBubble}\n * @alias Blockly.Bubble\n */\nconst Bubble = class {\n  /**\n   * @param {!WorkspaceSvg} workspace The workspace on which to draw the\n   *     bubble.\n   * @param {!Element} content SVG content for the bubble.\n   * @param {!Element} shape SVG element to avoid eclipsing.\n   * @param {!Coordinate} anchorXY Absolute position of bubble's\n   *     anchor point.\n   * @param {?number} bubbleWidth Width of bubble, or null if not resizable.\n   * @param {?number} bubbleHeight Height of bubble, or null if not resizable.\n   * @struct\n   */\n  constructor(workspace, content, shape, anchorXY, bubbleWidth, bubbleHeight) {\n    this.workspace_ = workspace;\n    this.content_ = content;\n    this.shape_ = shape;\n\n    /**\n     * Flag to stop incremental rendering during construction.\n     * @type {boolean}\n     * @private\n     */\n    this.rendered_ = false;\n\n    /**\n     * The SVG group containing all parts of the bubble.\n     * @type {SVGGElement}\n     * @private\n     */\n    this.bubbleGroup_ = null;\n\n    /**\n     * The SVG path for the arrow from the bubble to the icon on the block.\n     * @type {SVGPathElement}\n     * @private\n     */\n    this.bubbleArrow_ = null;\n\n    /**\n     * The SVG rect for the main body of the bubble.\n     * @type {SVGRectElement}\n     * @private\n     */\n    this.bubbleBack_ = null;\n\n    /**\n     * The SVG group for the resize hash marks on some bubbles.\n     * @type {SVGGElement}\n     * @private\n     */\n    this.resizeGroup_ = null;\n\n    /**\n     * Absolute coordinate of anchor point, in workspace coordinates.\n     * @type {Coordinate}\n     * @private\n     */\n    this.anchorXY_ = null;\n\n    /**\n     * Relative X coordinate of bubble with respect to the anchor's centre,\n     * in workspace units.\n     * In RTL mode the initial value is negated.\n     * @type {number}\n     * @private\n     */\n    this.relativeLeft_ = 0;\n\n    /**\n     * Relative Y coordinate of bubble with respect to the anchor's centre, in\n     * workspace units.\n     * @type {number}\n     * @private\n     */\n    this.relativeTop_ = 0;\n\n    /**\n     * Width of bubble, in workspace units.\n     * @type {number}\n     * @private\n     */\n    this.width_ = 0;\n\n    /**\n     * Height of bubble, in workspace units.\n     * @type {number}\n     * @private\n     */\n    this.height_ = 0;\n\n    /**\n     * Automatically position and reposition the bubble.\n     * @type {boolean}\n     * @private\n     */\n    this.autoLayout_ = true;\n\n    /**\n     * Method to call on resize of bubble.\n     * @type {?function()}\n     * @private\n     */\n    this.resizeCallback_ = null;\n\n    /**\n     * Method to call on move of bubble.\n     * @type {?function()}\n     * @private\n     */\n    this.moveCallback_ = null;\n\n    /**\n     * Mouse down on bubbleBack_ event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onMouseDownBubbleWrapper_ = null;\n\n    /**\n     * Mouse down on resizeGroup_ event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onMouseDownResizeWrapper_ = null;\n\n    /**\n     * Describes whether this bubble has been disposed of (nodes and event\n     * listeners removed from the page) or not.\n     * @type {boolean}\n     * @package\n     */\n    this.disposed = false;\n\n    let angle = Bubble.ARROW_ANGLE;\n    if (this.workspace_.RTL) {\n      angle = -angle;\n    }\n    this.arrow_radians_ = math.toRadians(angle);\n\n    const canvas = workspace.getBubbleCanvas();\n    canvas.appendChild(\n        this.createDom_(content, !!(bubbleWidth && bubbleHeight)));\n\n    this.setAnchorLocation(anchorXY);\n    if (!bubbleWidth || !bubbleHeight) {\n      const bBox = /** @type {SVGLocatable} */ (this.content_).getBBox();\n      bubbleWidth = bBox.width + 2 * Bubble.BORDER_WIDTH;\n      bubbleHeight = bBox.height + 2 * Bubble.BORDER_WIDTH;\n    }\n    this.setBubbleSize(bubbleWidth, bubbleHeight);\n\n    // Render the bubble.\n    this.positionBubble_();\n    this.renderArrow_();\n    this.rendered_ = true;\n  }\n\n  /**\n   * Create the bubble's DOM.\n   * @param {!Element} content SVG content for the bubble.\n   * @param {boolean} hasResize Add diagonal resize gripper if true.\n   * @return {!SVGElement} The bubble's SVG group.\n   * @private\n   */\n  createDom_(content, hasResize) {\n    /* Create the bubble.  Here's the markup that will be generated:\n    <g>\n      <g filter=\"url(#blocklyEmbossFilter837493)\">\n        <path d=\"... Z\" />\n        <rect class=\"blocklyDraggable\" rx=\"8\" ry=\"8\" width=\"180\" height=\"180\"/>\n      </g>\n      <g transform=\"translate(165, 165)\" class=\"blocklyResizeSE\">\n        <polygon points=\"0,15 15,15 15,0\"/>\n        <line class=\"blocklyResizeLine\" x1=\"5\" y1=\"14\" x2=\"14\" y2=\"5\"/>\n        <line class=\"blocklyResizeLine\" x1=\"10\" y1=\"14\" x2=\"14\" y2=\"10\"/>\n      </g>\n      [...content goes here...]\n    </g>\n    */\n    this.bubbleGroup_ = dom.createSvgElement(Svg.G, {}, null);\n    let filter = {\n      'filter': 'url(#' +\n          this.workspace_.getRenderer().getConstants().embossFilterId + ')',\n    };\n    if (userAgent.JAVA_FX) {\n      // Multiple reports that JavaFX can't handle filters.\n      // https://github.com/google/blockly/issues/99\n      filter = {};\n    }\n    const bubbleEmboss = dom.createSvgElement(Svg.G, filter, this.bubbleGroup_);\n    this.bubbleArrow_ = dom.createSvgElement(Svg.PATH, {}, bubbleEmboss);\n    this.bubbleBack_ = dom.createSvgElement(\n        Svg.RECT, {\n          'class': 'blocklyDraggable',\n          'x': 0,\n          'y': 0,\n          'rx': Bubble.BORDER_WIDTH,\n          'ry': Bubble.BORDER_WIDTH,\n        },\n        bubbleEmboss);\n    if (hasResize) {\n      this.resizeGroup_ = dom.createSvgElement(\n          Svg.G, {\n            'class': this.workspace_.RTL ? 'blocklyResizeSW' :\n                                           'blocklyResizeSE',\n          },\n          this.bubbleGroup_);\n      const resizeSize = 2 * Bubble.BORDER_WIDTH;\n      dom.createSvgElement(\n          Svg.POLYGON,\n          {'points': '0,x x,x x,0'.replace(/x/g, resizeSize.toString())},\n          this.resizeGroup_);\n      dom.createSvgElement(\n          Svg.LINE, {\n            'class': 'blocklyResizeLine',\n            'x1': resizeSize / 3,\n            'y1': resizeSize - 1,\n            'x2': resizeSize - 1,\n            'y2': resizeSize / 3,\n          },\n          this.resizeGroup_);\n      dom.createSvgElement(\n          Svg.LINE, {\n            'class': 'blocklyResizeLine',\n            'x1': resizeSize * 2 / 3,\n            'y1': resizeSize - 1,\n            'x2': resizeSize - 1,\n            'y2': resizeSize * 2 / 3,\n          },\n          this.resizeGroup_);\n    } else {\n      this.resizeGroup_ = null;\n    }\n\n    if (!this.workspace_.options.readOnly) {\n      this.onMouseDownBubbleWrapper_ = browserEvents.conditionalBind(\n          this.bubbleBack_, 'mousedown', this, this.bubbleMouseDown_);\n      if (this.resizeGroup_) {\n        this.onMouseDownResizeWrapper_ = browserEvents.conditionalBind(\n            this.resizeGroup_, 'mousedown', this, this.resizeMouseDown_);\n      }\n    }\n    this.bubbleGroup_.appendChild(content);\n    return this.bubbleGroup_;\n  }\n\n  /**\n   * Return the root node of the bubble's SVG group.\n   * @return {!SVGElement} The root SVG node of the bubble's group.\n   */\n  getSvgRoot() {\n    return /** @type {!SVGElement} */ (this.bubbleGroup_);\n  }\n\n  /**\n   * Expose the block's ID on the bubble's top-level SVG group.\n   * @param {string} id ID of block.\n   */\n  setSvgId(id) {\n    if (this.bubbleGroup_.dataset) {\n      this.bubbleGroup_.dataset['blockId'] = id;\n    }\n  }\n\n  /**\n   * Handle a mouse-down on bubble's border.\n   * @param {!Event} e Mouse down event.\n   * @private\n   */\n  bubbleMouseDown_(e) {\n    const gesture = this.workspace_.getGesture(e);\n    if (gesture) {\n      gesture.handleBubbleStart(e, this);\n    }\n  }\n\n  /**\n   * Show the context menu for this bubble.\n   * @param {!Event} _e Mouse event.\n   * @package\n   */\n  showContextMenu(_e) {\n    // NOP on bubbles, but used by the bubble dragger to pass events to\n    // workspace comments.\n  }\n\n  /**\n   * Get whether this bubble is deletable or not.\n   * @return {boolean} True if deletable.\n   * @package\n   */\n  isDeletable() {\n    return false;\n  }\n\n  /**\n   * Update the style of this bubble when it is dragged over a delete area.\n   * @param {boolean} _enable True if the bubble is about to be deleted, false\n   *     otherwise.\n   */\n  setDeleteStyle(_enable) {\n    // NOP if bubble is not deletable.\n  }\n\n  /**\n   * Handle a mouse-down on bubble's resize corner.\n   * @param {!Event} e Mouse down event.\n   * @private\n   */\n  resizeMouseDown_(e) {\n    this.promote();\n    Bubble.unbindDragEvents_();\n    if (browserEvents.isRightButton(e)) {\n      // No right-click.\n      e.stopPropagation();\n      return;\n    }\n    // Left-click (or middle click)\n    this.workspace_.startDrag(\n        e,\n        new Coordinate(\n            this.workspace_.RTL ? -this.width_ : this.width_, this.height_));\n\n    Bubble.onMouseUpWrapper_ = browserEvents.conditionalBind(\n        document, 'mouseup', this, Bubble.bubbleMouseUp_);\n    Bubble.onMouseMoveWrapper_ = browserEvents.conditionalBind(\n        document, 'mousemove', this, this.resizeMouseMove_);\n    this.workspace_.hideChaff();\n    // This event has been handled.  No need to bubble up to the document.\n    e.stopPropagation();\n  }\n\n  /**\n   * Resize this bubble to follow the mouse.\n   * @param {!Event} e Mouse move event.\n   * @private\n   */\n  resizeMouseMove_(e) {\n    this.autoLayout_ = false;\n    const newXY = this.workspace_.moveDrag(e);\n    this.setBubbleSize(this.workspace_.RTL ? -newXY.x : newXY.x, newXY.y);\n    if (this.workspace_.RTL) {\n      // RTL requires the bubble to move its left edge.\n      this.positionBubble_();\n    }\n  }\n\n  /**\n   * Register a function as a callback event for when the bubble is resized.\n   * @param {!Function} callback The function to call on resize.\n   */\n  registerResizeEvent(callback) {\n    this.resizeCallback_ = callback;\n  }\n\n  /**\n   * Register a function as a callback event for when the bubble is moved.\n   * @param {!Function} callback The function to call on move.\n   */\n  registerMoveEvent(callback) {\n    this.moveCallback_ = callback;\n  }\n\n  /**\n   * Move this bubble to the top of the stack.\n   * @return {boolean} Whether or not the bubble has been moved.\n   * @package\n   */\n  promote() {\n    const svgGroup = this.bubbleGroup_.parentNode;\n    if (svgGroup.lastChild !== this.bubbleGroup_) {\n      svgGroup.appendChild(this.bubbleGroup_);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Notification that the anchor has moved.\n   * Update the arrow and bubble accordingly.\n   * @param {!Coordinate} xy Absolute location.\n   */\n  setAnchorLocation(xy) {\n    this.anchorXY_ = xy;\n    if (this.rendered_) {\n      this.positionBubble_();\n    }\n  }\n\n  /**\n   * Position the bubble so that it does not fall off-screen.\n   * @private\n   */\n  layoutBubble_() {\n    // Get the metrics in workspace units.\n    const viewMetrics =\n        this.workspace_.getMetricsManager().getViewMetrics(true);\n\n    const optimalLeft = this.getOptimalRelativeLeft_(viewMetrics);\n    const optimalTop = this.getOptimalRelativeTop_(viewMetrics);\n    const bbox = this.shape_.getBBox();\n\n    const topPosition = {\n      x: optimalLeft,\n      y: -this.height_ -\n          this.workspace_.getRenderer().getConstants().MIN_BLOCK_HEIGHT,\n    };\n    const startPosition = {x: -this.width_ - 30, y: optimalTop};\n    const endPosition = {x: bbox.width, y: optimalTop};\n    const bottomPosition = {x: optimalLeft, y: bbox.height};\n\n    const closerPosition =\n        bbox.width < bbox.height ? endPosition : bottomPosition;\n    const fartherPosition =\n        bbox.width < bbox.height ? bottomPosition : endPosition;\n\n    const topPositionOverlap = this.getOverlap_(topPosition, viewMetrics);\n    const startPositionOverlap = this.getOverlap_(startPosition, viewMetrics);\n    const closerPositionOverlap = this.getOverlap_(closerPosition, viewMetrics);\n    const fartherPositionOverlap =\n        this.getOverlap_(fartherPosition, viewMetrics);\n\n    // Set the position to whichever position shows the most of the bubble,\n    // with tiebreaks going in the order: top > start > close > far.\n    const mostOverlap = Math.max(\n        topPositionOverlap, startPositionOverlap, closerPositionOverlap,\n        fartherPositionOverlap);\n    if (topPositionOverlap === mostOverlap) {\n      this.relativeLeft_ = topPosition.x;\n      this.relativeTop_ = topPosition.y;\n      return;\n    }\n    if (startPositionOverlap === mostOverlap) {\n      this.relativeLeft_ = startPosition.x;\n      this.relativeTop_ = startPosition.y;\n      return;\n    }\n    if (closerPositionOverlap === mostOverlap) {\n      this.relativeLeft_ = closerPosition.x;\n      this.relativeTop_ = closerPosition.y;\n      return;\n    }\n    // TODO: I believe relativeLeft_ should actually be called relativeStart_\n    //  and then the math should be fixed to reflect this. (hopefully it'll\n    //  make it look simpler)\n    this.relativeLeft_ = fartherPosition.x;\n    this.relativeTop_ = fartherPosition.y;\n  }\n\n  /**\n   * Calculate the what percentage of the bubble overlaps with the visible\n   * workspace (what percentage of the bubble is visible).\n   * @param {!{x: number, y: number}} relativeMin The position of the top-left\n   *     corner of the bubble relative to the anchor point.\n   * @param {!MetricsManager.ContainerRegion} viewMetrics The view metrics\n   *     of the workspace the bubble will appear in.\n   * @return {number} The percentage of the bubble that is visible.\n   * @private\n   */\n  getOverlap_(relativeMin, viewMetrics) {\n    // The position of the top-left corner of the bubble in workspace units.\n    const bubbleMin = {\n      x: this.workspace_.RTL ?\n          (this.anchorXY_.x - relativeMin.x - this.width_) :\n          (relativeMin.x + this.anchorXY_.x),\n      y: relativeMin.y + this.anchorXY_.y,\n    };\n    // The position of the bottom-right corner of the bubble in workspace units.\n    const bubbleMax = {\n      x: bubbleMin.x + this.width_,\n      y: bubbleMin.y + this.height_,\n    };\n\n    // We could adjust these values to account for the scrollbars, but the\n    // bubbles should have been adjusted to not collide with them anyway, so\n    // giving the workspace a slightly larger \"bounding box\" shouldn't affect\n    // the calculation.\n\n    // The position of the top-left corner of the workspace.\n    const workspaceMin = {x: viewMetrics.left, y: viewMetrics.top};\n    // The position of the bottom-right corner of the workspace.\n    const workspaceMax = {\n      x: viewMetrics.left + viewMetrics.width,\n      y: viewMetrics.top + viewMetrics.height,\n    };\n\n    const overlapWidth = Math.min(bubbleMax.x, workspaceMax.x) -\n        Math.max(bubbleMin.x, workspaceMin.x);\n    const overlapHeight = Math.min(bubbleMax.y, workspaceMax.y) -\n        Math.max(bubbleMin.y, workspaceMin.y);\n    return Math.max(\n        0,\n        Math.min(\n            1, (overlapWidth * overlapHeight) / (this.width_ * this.height_)));\n  }\n\n  /**\n   * Calculate what the optimal horizontal position of the top-left corner of\n   * the bubble is (relative to the anchor point) so that the most area of the\n   * bubble is shown.\n   * @param {!MetricsManager.ContainerRegion} viewMetrics The view metrics\n   *     of the workspace the bubble will appear in.\n   * @return {number} The optimal horizontal position of the top-left corner\n   *     of the bubble.\n   * @private\n   */\n  getOptimalRelativeLeft_(viewMetrics) {\n    let relativeLeft = -this.width_ / 4;\n\n    // No amount of sliding left or right will give us a better overlap.\n    if (this.width_ > viewMetrics.width) {\n      return relativeLeft;\n    }\n\n    if (this.workspace_.RTL) {\n      // Bubble coordinates are flipped in RTL.\n      const bubbleRight = this.anchorXY_.x - relativeLeft;\n      const bubbleLeft = bubbleRight - this.width_;\n\n      const workspaceRight = viewMetrics.left + viewMetrics.width;\n      const workspaceLeft = viewMetrics.left +\n          // Thickness in workspace units.\n          (Scrollbar.scrollbarThickness / this.workspace_.scale);\n\n      if (bubbleLeft < workspaceLeft) {\n        // Slide the bubble right until it is onscreen.\n        relativeLeft = -(workspaceLeft - this.anchorXY_.x + this.width_);\n      } else if (bubbleRight > workspaceRight) {\n        // Slide the bubble left until it is onscreen.\n        relativeLeft = -(workspaceRight - this.anchorXY_.x);\n      }\n    } else {\n      const bubbleLeft = relativeLeft + this.anchorXY_.x;\n      const bubbleRight = bubbleLeft + this.width_;\n\n      const workspaceLeft = viewMetrics.left;\n      const workspaceRight = viewMetrics.left + viewMetrics.width -\n          // Thickness in workspace units.\n          (Scrollbar.scrollbarThickness / this.workspace_.scale);\n\n      if (bubbleLeft < workspaceLeft) {\n        // Slide the bubble right until it is onscreen.\n        relativeLeft = workspaceLeft - this.anchorXY_.x;\n      } else if (bubbleRight > workspaceRight) {\n        // Slide the bubble left until it is onscreen.\n        relativeLeft = workspaceRight - this.anchorXY_.x - this.width_;\n      }\n    }\n\n    return relativeLeft;\n  }\n\n  /**\n   * Calculate what the optimal vertical position of the top-left corner of\n   * the bubble is (relative to the anchor point) so that the most area of the\n   * bubble is shown.\n   * @param {!MetricsManager.ContainerRegion} viewMetrics The view metrics\n   *     of the workspace the bubble will appear in.\n   * @return {number} The optimal vertical position of the top-left corner\n   *     of the bubble.\n   * @private\n   */\n  getOptimalRelativeTop_(viewMetrics) {\n    let relativeTop = -this.height_ / 4;\n\n    // No amount of sliding up or down will give us a better overlap.\n    if (this.height_ > viewMetrics.height) {\n      return relativeTop;\n    }\n\n    const bubbleTop = this.anchorXY_.y + relativeTop;\n    const bubbleBottom = bubbleTop + this.height_;\n    const workspaceTop = viewMetrics.top;\n    const workspaceBottom = viewMetrics.top + viewMetrics.height -\n        // Thickness in workspace units.\n        (Scrollbar.scrollbarThickness / this.workspace_.scale);\n\n    const anchorY = this.anchorXY_.y;\n    if (bubbleTop < workspaceTop) {\n      // Slide the bubble down until it is onscreen.\n      relativeTop = workspaceTop - anchorY;\n    } else if (bubbleBottom > workspaceBottom) {\n      // Slide the bubble up until it is onscreen.\n      relativeTop = workspaceBottom - anchorY - this.height_;\n    }\n\n    return relativeTop;\n  }\n\n  /**\n   * Move the bubble to a location relative to the anchor's centre.\n   * @private\n   */\n  positionBubble_() {\n    let left = this.anchorXY_.x;\n    if (this.workspace_.RTL) {\n      left -= this.relativeLeft_ + this.width_;\n    } else {\n      left += this.relativeLeft_;\n    }\n    const top = this.relativeTop_ + this.anchorXY_.y;\n    this.moveTo(left, top);\n  }\n\n  /**\n   * Move the bubble group to the specified location in workspace coordinates.\n   * @param {number} x The x position to move to.\n   * @param {number} y The y position to move to.\n   * @package\n   */\n  moveTo(x, y) {\n    this.bubbleGroup_.setAttribute(\n        'transform', 'translate(' + x + ',' + y + ')');\n  }\n\n  /**\n   * Triggers a move callback if one exists at the end of a drag.\n   * @param {boolean} adding True if adding, false if removing.\n   * @package\n   */\n  setDragging(adding) {\n    if (!adding && this.moveCallback_) {\n      this.moveCallback_();\n    }\n  }\n\n  /**\n   * Get the dimensions of this bubble.\n   * @return {!Size} The height and width of the bubble.\n   */\n  getBubbleSize() {\n    return new Size(this.width_, this.height_);\n  }\n\n  /**\n   * Size this bubble.\n   * @param {number} width Width of the bubble.\n   * @param {number} height Height of the bubble.\n   */\n  setBubbleSize(width, height) {\n    const doubleBorderWidth = 2 * Bubble.BORDER_WIDTH;\n    // Minimum size of a bubble.\n    width = Math.max(width, doubleBorderWidth + 45);\n    height = Math.max(height, doubleBorderWidth + 20);\n    this.width_ = width;\n    this.height_ = height;\n    this.bubbleBack_.setAttribute('width', width);\n    this.bubbleBack_.setAttribute('height', height);\n    if (this.resizeGroup_) {\n      if (this.workspace_.RTL) {\n        // Mirror the resize group.\n        const resizeSize = 2 * Bubble.BORDER_WIDTH;\n        this.resizeGroup_.setAttribute(\n            'transform',\n            'translate(' + resizeSize + ',' + (height - doubleBorderWidth) +\n                ') scale(-1 1)');\n      } else {\n        this.resizeGroup_.setAttribute(\n            'transform',\n            'translate(' + (width - doubleBorderWidth) + ',' +\n                (height - doubleBorderWidth) + ')');\n      }\n    }\n    if (this.autoLayout_) {\n      this.layoutBubble_();\n    }\n    this.positionBubble_();\n    this.renderArrow_();\n\n    // Allow the contents to resize.\n    if (this.resizeCallback_) {\n      this.resizeCallback_();\n    }\n  }\n\n  /**\n   * Draw the arrow between the bubble and the origin.\n   * @private\n   */\n  renderArrow_() {\n    const steps = [];\n    // Find the relative coordinates of the center of the bubble.\n    const relBubbleX = this.width_ / 2;\n    const relBubbleY = this.height_ / 2;\n    // Find the relative coordinates of the center of the anchor.\n    let relAnchorX = -this.relativeLeft_;\n    let relAnchorY = -this.relativeTop_;\n    if (relBubbleX === relAnchorX && relBubbleY === relAnchorY) {\n      // Null case.  Bubble is directly on top of the anchor.\n      // Short circuit this rather than wade through divide by zeros.\n      steps.push('M ' + relBubbleX + ',' + relBubbleY);\n    } else {\n      // Compute the angle of the arrow's line.\n      const rise = relAnchorY - relBubbleY;\n      let run = relAnchorX - relBubbleX;\n      if (this.workspace_.RTL) {\n        run *= -1;\n      }\n      const hypotenuse = Math.sqrt(rise * rise + run * run);\n      let angle = Math.acos(run / hypotenuse);\n      if (rise < 0) {\n        angle = 2 * Math.PI - angle;\n      }\n      // Compute a line perpendicular to the arrow.\n      let rightAngle = angle + Math.PI / 2;\n      if (rightAngle > Math.PI * 2) {\n        rightAngle -= Math.PI * 2;\n      }\n      const rightRise = Math.sin(rightAngle);\n      const rightRun = Math.cos(rightAngle);\n\n      // Calculate the thickness of the base of the arrow.\n      const bubbleSize = this.getBubbleSize();\n      let thickness =\n          (bubbleSize.width + bubbleSize.height) / Bubble.ARROW_THICKNESS;\n      thickness = Math.min(thickness, bubbleSize.width, bubbleSize.height) / 4;\n\n      // Back the tip of the arrow off of the anchor.\n      const backoffRatio = 1 - Bubble.ANCHOR_RADIUS / hypotenuse;\n      relAnchorX = relBubbleX + backoffRatio * run;\n      relAnchorY = relBubbleY + backoffRatio * rise;\n\n      // Coordinates for the base of the arrow.\n      const baseX1 = relBubbleX + thickness * rightRun;\n      const baseY1 = relBubbleY + thickness * rightRise;\n      const baseX2 = relBubbleX - thickness * rightRun;\n      const baseY2 = relBubbleY - thickness * rightRise;\n\n      // Distortion to curve the arrow.\n      let swirlAngle = angle + this.arrow_radians_;\n      if (swirlAngle > Math.PI * 2) {\n        swirlAngle -= Math.PI * 2;\n      }\n      const swirlRise = Math.sin(swirlAngle) * hypotenuse / Bubble.ARROW_BEND;\n      const swirlRun = Math.cos(swirlAngle) * hypotenuse / Bubble.ARROW_BEND;\n\n      steps.push('M' + baseX1 + ',' + baseY1);\n      steps.push(\n          'C' + (baseX1 + swirlRun) + ',' + (baseY1 + swirlRise) + ' ' +\n          relAnchorX + ',' + relAnchorY + ' ' + relAnchorX + ',' + relAnchorY);\n      steps.push(\n          'C' + relAnchorX + ',' + relAnchorY + ' ' + (baseX2 + swirlRun) +\n          ',' + (baseY2 + swirlRise) + ' ' + baseX2 + ',' + baseY2);\n    }\n    steps.push('z');\n    this.bubbleArrow_.setAttribute('d', steps.join(' '));\n  }\n\n  /**\n   * Change the colour of a bubble.\n   * @param {string} hexColour Hex code of colour.\n   */\n  setColour(hexColour) {\n    this.bubbleBack_.setAttribute('fill', hexColour);\n    this.bubbleArrow_.setAttribute('fill', hexColour);\n  }\n\n  /**\n   * Dispose of this bubble.\n   */\n  dispose() {\n    if (this.onMouseDownBubbleWrapper_) {\n      browserEvents.unbind(this.onMouseDownBubbleWrapper_);\n    }\n    if (this.onMouseDownResizeWrapper_) {\n      browserEvents.unbind(this.onMouseDownResizeWrapper_);\n    }\n    Bubble.unbindDragEvents_();\n    dom.removeNode(this.bubbleGroup_);\n    this.disposed = true;\n  }\n\n  /**\n   * Move this bubble during a drag, taking into account whether or not there is\n   * a drag surface.\n   * @param {BlockDragSurfaceSvg} dragSurface The surface that carries\n   *     rendered items during a drag, or null if no drag surface is in use.\n   * @param {!Coordinate} newLoc The location to translate to, in\n   *     workspace coordinates.\n   * @package\n   */\n  moveDuringDrag(dragSurface, newLoc) {\n    if (dragSurface) {\n      dragSurface.translateSurface(newLoc.x, newLoc.y);\n    } else {\n      this.moveTo(newLoc.x, newLoc.y);\n    }\n    if (this.workspace_.RTL) {\n      this.relativeLeft_ = this.anchorXY_.x - newLoc.x - this.width_;\n    } else {\n      this.relativeLeft_ = newLoc.x - this.anchorXY_.x;\n    }\n    this.relativeTop_ = newLoc.y - this.anchorXY_.y;\n    this.renderArrow_();\n  }\n\n  /**\n   * Return the coordinates of the top-left corner of this bubble's body\n   * relative to the drawing surface's origin (0,0), in workspace units.\n   * @return {!Coordinate} Object with .x and .y properties.\n   */\n  getRelativeToSurfaceXY() {\n    return new Coordinate(\n        this.workspace_.RTL ?\n            -this.relativeLeft_ + this.anchorXY_.x - this.width_ :\n            this.anchorXY_.x + this.relativeLeft_,\n        this.anchorXY_.y + this.relativeTop_);\n  }\n\n  /**\n   * Set whether auto-layout of this bubble is enabled.  The first time a bubble\n   * is shown it positions itself to not cover any blocks.  Once a user has\n   * dragged it to reposition, it renders where the user put it.\n   * @param {boolean} enable True if auto-layout should be enabled, false\n   *     otherwise.\n   * @package\n   */\n  setAutoLayout(enable) {\n    this.autoLayout_ = enable;\n  }\n\n  /**\n   * Stop binding to the global mouseup and mousemove events.\n   * @private\n   */\n  static unbindDragEvents_() {\n    if (Bubble.onMouseUpWrapper_) {\n      browserEvents.unbind(Bubble.onMouseUpWrapper_);\n      Bubble.onMouseUpWrapper_ = null;\n    }\n    if (Bubble.onMouseMoveWrapper_) {\n      browserEvents.unbind(Bubble.onMouseMoveWrapper_);\n      Bubble.onMouseMoveWrapper_ = null;\n    }\n  }\n\n  /**\n   * Handle a mouse-up event while dragging a bubble's border or resize handle.\n   * @param {!Event} _e Mouse up event.\n   * @private\n   */\n  static bubbleMouseUp_(_e) {\n    Touch.clearTouchIdentifier();\n    Bubble.unbindDragEvents_();\n  }\n\n  /**\n   * Create the text for a non editable bubble.\n   * @param {string} text The text to display.\n   * @return {!SVGTextElement} The top-level node of the text.\n   * @package\n   */\n  static textToDom(text) {\n    const paragraph = dom.createSvgElement(\n        Svg.TEXT, {\n          'class': 'blocklyText blocklyBubbleText blocklyNoPointerEvents',\n          'y': Bubble.BORDER_WIDTH,\n        },\n        null);\n    const lines = text.split('\\n');\n    for (let i = 0; i < lines.length; i++) {\n      const tspanElement = dom.createSvgElement(\n          Svg.TSPAN, {'dy': '1em', 'x': Bubble.BORDER_WIDTH}, paragraph);\n      const textNode = document.createTextNode(lines[i]);\n      tspanElement.appendChild(textNode);\n    }\n    return paragraph;\n  }\n\n  /**\n   * Creates a bubble that can not be edited.\n   * @param {!SVGTextElement} paragraphElement The text element for the non\n   *     editable bubble.\n   * @param {!BlockSvg} block The block that the bubble is attached to.\n   * @param {!Coordinate} iconXY The coordinate of the icon.\n   * @return {!Bubble} The non editable bubble.\n   * @package\n   */\n  static createNonEditableBubble(paragraphElement, block, iconXY) {\n    const bubble = new Bubble(\n        /** @type {!WorkspaceSvg} */ (block.workspace), paragraphElement,\n        block.pathObject.svgPath,\n        /** @type {!Coordinate} */ (iconXY), null, null);\n    // Expose this bubble's block's ID on its top-level SVG group.\n    bubble.setSvgId(block.id);\n    if (block.RTL) {\n      // Right-align the paragraph.\n      // This cannot be done until the bubble is rendered on screen.\n      const maxWidth = paragraphElement.getBBox().width;\n      for (let i = 0, textElement;\n           (textElement = paragraphElement.childNodes[i]); i++) {\n        textElement.setAttribute('text-anchor', 'end');\n        textElement.setAttribute('x', maxWidth + Bubble.BORDER_WIDTH);\n      }\n    }\n    return bubble;\n  }\n};\n\n/**\n * Width of the border around the bubble.\n */\nBubble.BORDER_WIDTH = 6;\n\n/**\n * Determines the thickness of the base of the arrow in relation to the size\n * of the bubble.  Higher numbers result in thinner arrows.\n */\nBubble.ARROW_THICKNESS = 5;\n\n/**\n * The number of degrees that the arrow bends counter-clockwise.\n */\nBubble.ARROW_ANGLE = 20;\n\n/**\n * The sharpness of the arrow's bend.  Higher numbers result in smoother arrows.\n */\nBubble.ARROW_BEND = 4;\n\n/**\n * Distance between arrow point and anchor point.\n */\nBubble.ANCHOR_RADIUS = 8;\n\n/**\n * Mouse up event data.\n * @type {?browserEvents.Data}\n * @private\n */\nBubble.onMouseUpWrapper_ = null;\n\n/**\n * Mouse move event data.\n * @type {?browserEvents.Data}\n * @private\n */\nBubble.onMouseMoveWrapper_ = null;\n\nexports.Bubble = Bubble;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/bubble.js?")},
"./core/bubble_dragger.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/utils/svg_math.js\");\n__webpack_require__(\"./core/component_manager.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/bubble.js\");\n__webpack_require__(\"./core/events/events_comment_move.js\");\n__webpack_require__(\"./core/constants.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Methods for dragging a bubble visually.\n */\n\n\n/**\n * Methods for dragging a bubble visually.\n * @class\n */\ngoog.module('Blockly.BubbleDragger');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst svgMath = goog.require('Blockly.utils.svgMath');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockDragSurfaceSvg} = goog.requireType('Blockly.BlockDragSurfaceSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {CommentMove} = goog.requireType('Blockly.Events.CommentMove');\nconst {ComponentManager} = goog.require('Blockly.ComponentManager');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\n/* eslint-disable-next-line no-unused-vars */\nconst {IBubble} = goog.requireType('Blockly.IBubble');\n/* eslint-disable-next-line no-unused-vars */\nconst {IDeleteArea} = goog.requireType('Blockly.IDeleteArea');\n/* eslint-disable-next-line no-unused-vars */\nconst {IDragTarget} = goog.requireType('Blockly.IDragTarget');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceCommentSvg} = goog.requireType('Blockly.WorkspaceCommentSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Bubble');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.CommentMove');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.constants');\n\n\n/**\n * Class for a bubble dragger.  It moves things on the bubble canvas around the\n * workspace when they are being dragged by a mouse or touch.  These can be\n * block comments, mutators, warnings, or workspace comments.\n * @alias Blockly.BubbleDragger\n */\nconst BubbleDragger = class {\n  /**\n   * @param {!IBubble} bubble The item on the bubble canvas to drag.\n   * @param {!WorkspaceSvg} workspace The workspace to drag on.\n   */\n  constructor(bubble, workspace) {\n    /**\n     * The item on the bubble canvas that is being dragged.\n     * @type {!IBubble}\n     * @private\n     */\n    this.draggingBubble_ = bubble;\n\n    /**\n     * The workspace on which the bubble is being dragged.\n     * @type {!WorkspaceSvg}\n     * @private\n     */\n    this.workspace_ = workspace;\n\n    /**\n     * Which drag target the mouse pointer is over, if any.\n     * @type {?IDragTarget}\n     * @private\n     */\n    this.dragTarget_ = null;\n\n    /**\n     * Whether the bubble would be deleted if dropped immediately.\n     * @type {boolean}\n     * @private\n     */\n    this.wouldDeleteBubble_ = false;\n\n    /**\n     * The location of the top left corner of the dragging bubble's body at the\n     * beginning of the drag, in workspace coordinates.\n     * @type {!Coordinate}\n     * @private\n     */\n    this.startXY_ = this.draggingBubble_.getRelativeToSurfaceXY();\n\n    /**\n     * The drag surface to move bubbles to during a drag, or null if none should\n     * be used.  Block dragging and bubble dragging use the same surface.\n     * @type {BlockDragSurfaceSvg}\n     * @private\n     */\n    this.dragSurface_ =\n        svgMath.is3dSupported() && !!workspace.getBlockDragSurface() ?\n        workspace.getBlockDragSurface() :\n        null;\n  }\n\n  /**\n   * Sever all links from this object.\n   * @package\n   * @suppress {checkTypes}\n   */\n  dispose() {\n    this.draggingBubble_ = null;\n    this.workspace_ = null;\n    this.dragSurface_ = null;\n  }\n\n  /**\n   * Start dragging a bubble.  This includes moving it to the drag surface.\n   * @package\n   */\n  startBubbleDrag() {\n    if (!eventUtils.getGroup()) {\n      eventUtils.setGroup(true);\n    }\n\n    this.workspace_.setResizesEnabled(false);\n    this.draggingBubble_.setAutoLayout(false);\n    if (this.dragSurface_) {\n      this.moveToDragSurface_();\n    }\n\n    this.draggingBubble_.setDragging && this.draggingBubble_.setDragging(true);\n  }\n\n  /**\n   * Execute a step of bubble dragging, based on the given event.  Update the\n   * display accordingly.\n   * @param {!Event} e The most recent move event.\n   * @param {!Coordinate} currentDragDeltaXY How far the pointer has\n   *     moved from the position at the start of the drag, in pixel units.\n   * @package\n   */\n  dragBubble(e, currentDragDeltaXY) {\n    const delta = this.pixelsToWorkspaceUnits_(currentDragDeltaXY);\n    const newLoc = Coordinate.sum(this.startXY_, delta);\n    this.draggingBubble_.moveDuringDrag(this.dragSurface_, newLoc);\n\n    const oldDragTarget = this.dragTarget_;\n    this.dragTarget_ = this.workspace_.getDragTarget(e);\n\n    const oldWouldDeleteBubble = this.wouldDeleteBubble_;\n    this.wouldDeleteBubble_ = this.shouldDelete_(this.dragTarget_);\n    if (oldWouldDeleteBubble !== this.wouldDeleteBubble_) {\n      // Prevent unnecessary add/remove class calls.\n      this.updateCursorDuringBubbleDrag_();\n    }\n\n    // Call drag enter/exit/over after wouldDeleteBlock is called in\n    // shouldDelete_\n    if (this.dragTarget_ !== oldDragTarget) {\n      oldDragTarget && oldDragTarget.onDragExit(this.draggingBubble_);\n      this.dragTarget_ && this.dragTarget_.onDragEnter(this.draggingBubble_);\n    }\n    this.dragTarget_ && this.dragTarget_.onDragOver(this.draggingBubble_);\n  }\n\n  /**\n   * Whether ending the drag would delete the bubble.\n   * @param {?IDragTarget} dragTarget The drag target that the bubblee is\n   *     currently over.\n   * @return {boolean} Whether dropping the bubble immediately would delete the\n   *    block.\n   * @private\n   */\n  shouldDelete_(dragTarget) {\n    if (dragTarget) {\n      const componentManager = this.workspace_.getComponentManager();\n      const isDeleteArea = componentManager.hasCapability(\n          dragTarget.id, ComponentManager.Capability.DELETE_AREA);\n      if (isDeleteArea) {\n        return (/** @type {!IDeleteArea} */ (dragTarget))\n            .wouldDelete(this.draggingBubble_, false);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Update the cursor (and possibly the trash can lid) to reflect whether the\n   * dragging bubble would be deleted if released immediately.\n   * @private\n   */\n  updateCursorDuringBubbleDrag_() {\n    this.draggingBubble_.setDeleteStyle(this.wouldDeleteBubble_);\n  }\n\n  /**\n   * Finish a bubble drag and put the bubble back on the workspace.\n   * @param {!Event} e The mouseup/touchend event.\n   * @param {!Coordinate} currentDragDeltaXY How far the pointer has\n   *     moved from the position at the start of the drag, in pixel units.\n   * @package\n   */\n  endBubbleDrag(e, currentDragDeltaXY) {\n    // Make sure internal state is fresh.\n    this.dragBubble(e, currentDragDeltaXY);\n\n    const preventMove = this.dragTarget_ &&\n        this.dragTarget_.shouldPreventMove(this.draggingBubble_);\n    let newLoc;\n    if (preventMove) {\n      newLoc = this.startXY_;\n    } else {\n      const delta = this.pixelsToWorkspaceUnits_(currentDragDeltaXY);\n      newLoc = Coordinate.sum(this.startXY_, delta);\n    }\n    // Move the bubble to its final location.\n    this.draggingBubble_.moveTo(newLoc.x, newLoc.y);\n\n    if (this.dragTarget_) {\n      this.dragTarget_.onDrop(this.draggingBubble_);\n    }\n\n    if (this.wouldDeleteBubble_) {\n      // Fire a move event, so we know where to go back to for an undo.\n      this.fireMoveEvent_();\n      this.draggingBubble_.dispose(false, true);\n    } else {\n      // Put everything back onto the bubble canvas.\n      if (this.dragSurface_) {\n        this.dragSurface_.clearAndHide(this.workspace_.getBubbleCanvas());\n      }\n      if (this.draggingBubble_.setDragging) {\n        this.draggingBubble_.setDragging(false);\n      }\n      this.fireMoveEvent_();\n    }\n    this.workspace_.setResizesEnabled(true);\n\n    eventUtils.setGroup(false);\n  }\n\n  /**\n   * Fire a move event at the end of a bubble drag.\n   * @private\n   */\n  fireMoveEvent_() {\n    if (this.draggingBubble_.isComment) {\n      // TODO (adodson): Resolve build errors when requiring\n      // WorkspaceCommentSvg.\n      const event = /** @type {!CommentMove} */\n          (new (eventUtils.get(eventUtils.COMMENT_MOVE))(\n              /** @type {!WorkspaceCommentSvg} */ (this.draggingBubble_)));\n      event.setOldCoordinate(this.startXY_);\n      event.recordNew();\n      eventUtils.fire(event);\n    }\n    // TODO (fenichel): move events for comments.\n    return;\n  }\n\n  /**\n   * Convert a coordinate object from pixels to workspace units, including a\n   * correction for mutator workspaces.\n   * This function does not consider differing origins.  It simply scales the\n   * input's x and y values.\n   * @param {!Coordinate} pixelCoord A coordinate with x and y\n   *     values in CSS pixel units.\n   * @return {!Coordinate} The input coordinate divided by the\n   *     workspace scale.\n   * @private\n   */\n  pixelsToWorkspaceUnits_(pixelCoord) {\n    const result = new Coordinate(\n        pixelCoord.x / this.workspace_.scale,\n        pixelCoord.y / this.workspace_.scale);\n    if (this.workspace_.isMutator) {\n      // If we're in a mutator, its scale is always 1, purely because of some\n      // oddities in our rendering optimizations.  The actual scale is the same\n      // as the scale on the parent workspace. Fix that for dragging.\n      const mainScale = this.workspace_.options.parentWorkspace.scale;\n      result.scale(1 / mainScale);\n    }\n    return result;\n  }\n\n  /**\n   * Move the bubble onto the drag surface at the beginning of a drag.  Move the\n   * drag surface to preserve the apparent location of the bubble.\n   * @private\n   */\n  moveToDragSurface_() {\n    this.draggingBubble_.moveTo(0, 0);\n    this.dragSurface_.translateSurface(this.startXY_.x, this.startXY_.y);\n    // Execute the move on the top-level SVG component.\n    this.dragSurface_.setBlocksAndShow(this.draggingBubble_.getSvgRoot());\n  }\n};\n\nexports.BubbleDragger = BubbleDragger;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/bubble_dragger.js?")},
"./core/bump_objects.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/utils/math.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utilities for bumping objects back into worksapce bounds.\n */\n\n\n/**\n * Utilities for bumping objects back into worksapce bounds.\n * @namespace Blockly.bumpObjects\n */\ngoog.module('Blockly.bumpObjects');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst mathUtils = goog.require('Blockly.utils.math');\n/* eslint-disable-next-line no-unused-vars */\nconst {Abstract} = goog.requireType('Blockly.Events.Abstract');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {IBoundedElement} = goog.requireType('Blockly.IBoundedElement');\n/* eslint-disable-next-line no-unused-vars */\nconst {MetricsManager} = goog.requireType('Blockly.MetricsManager');\n/* eslint-disable-next-line no-unused-vars */\nconst {ViewportChange} = goog.requireType('Blockly.Events.ViewportChange');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceCommentSvg} = goog.requireType('Blockly.WorkspaceCommentSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * Bumps the given object that has passed out of bounds.\n * @param {!WorkspaceSvg} workspace The workspace containing the object.\n * @param {!MetricsManager.ContainerRegion} scrollMetrics Scroll metrics\n *    in workspace coordinates.\n * @param {!IBoundedElement} object The object to bump.\n * @return {boolean} True if block was bumped.\n * @alias Blockly.bumpObjects.bumpIntoBounds\n */\nconst bumpObjectIntoBounds = function(workspace, scrollMetrics, object) {\n  // Compute new top/left position for object.\n  const objectMetrics = object.getBoundingRectangle();\n  const height = objectMetrics.bottom - objectMetrics.top;\n  const width = objectMetrics.right - objectMetrics.left;\n\n  const topClamp = scrollMetrics.top;\n  const scrollMetricsBottom = scrollMetrics.top + scrollMetrics.height;\n  const bottomClamp = scrollMetricsBottom - height;\n  // If the object is taller than the workspace we want to\n  // top-align the block\n  const newYPosition =\n      mathUtils.clamp(topClamp, objectMetrics.top, bottomClamp);\n  const deltaY = newYPosition - objectMetrics.top;\n\n  // Note: Even in RTL mode the \"anchor\" of the object is the\n  // top-left corner of the object.\n  let leftClamp = scrollMetrics.left;\n  const scrollMetricsRight = scrollMetrics.left + scrollMetrics.width;\n  let rightClamp = scrollMetricsRight - width;\n  if (workspace.RTL) {\n    // If the object is wider than the workspace and we're in RTL\n    // mode we want to right-align the block, which means setting\n    // the left clamp to match.\n    leftClamp = Math.min(rightClamp, leftClamp);\n  } else {\n    // If the object is wider than the workspace and we're in LTR\n    // mode we want to left-align the block, which means setting\n    // the right clamp to match.\n    rightClamp = Math.max(leftClamp, rightClamp);\n  }\n  const newXPosition =\n      mathUtils.clamp(leftClamp, objectMetrics.left, rightClamp);\n  const deltaX = newXPosition - objectMetrics.left;\n\n  if (deltaX || deltaY) {\n    object.moveBy(deltaX, deltaY);\n    return true;\n  }\n  return false;\n};\nexports.bumpIntoBounds = bumpObjectIntoBounds;\n\n/**\n * Creates a handler for bumping objects when they cross fixed bounds.\n * @param {!WorkspaceSvg} workspace The workspace to handle.\n * @return {function(Abstract)} The event handler.\n * @alias Blockly.bumpObjects.bumpIntoBoundsHandler\n */\nconst bumpIntoBoundsHandler = function(workspace) {\n  return function(e) {\n    const metricsManager = workspace.getMetricsManager();\n    if (!metricsManager.hasFixedEdges() || workspace.isDragging()) {\n      return;\n    }\n\n    if (eventUtils.BUMP_EVENTS.indexOf(e.type) !== -1) {\n      const scrollMetricsInWsCoords = metricsManager.getScrollMetrics(true);\n\n      // Triggered by move/create event\n      const object = extractObjectFromEvent(workspace, e);\n      if (!object) {\n        return;\n      }\n      // Handle undo.\n      const oldGroup = eventUtils.getGroup();\n      eventUtils.setGroup(e.group);\n\n      const wasBumped = bumpObjectIntoBounds(\n          workspace, scrollMetricsInWsCoords,\n          /** @type {!IBoundedElement} */ (object));\n\n      if (wasBumped && !e.group) {\n        console.warn(\n            'Moved object in bounds but there was no' +\n            ' event group. This may break undo.');\n      }\n      if (oldGroup !== null) {\n        eventUtils.setGroup(oldGroup);\n      }\n    } else if (e.type === eventUtils.VIEWPORT_CHANGE) {\n      const viewportEvent = /** @type {!ViewportChange} */ (e);\n      if (viewportEvent.scale > viewportEvent.oldScale) {\n        bumpTopObjectsIntoBounds(workspace);\n      }\n    }\n  };\n};\nexports.bumpIntoBoundsHandler = bumpIntoBoundsHandler;\n\n/**\n * Extracts the object from the given event.\n * @param {!WorkspaceSvg} workspace The workspace the event originated\n *    from.\n * @param {!eventUtils.BumpEvent} e An event containing an object.\n * @return {?BlockSvg|?WorkspaceCommentSvg} The extracted\n *    object.\n */\nconst extractObjectFromEvent = function(workspace, e) {\n  let object = null;\n  switch (e.type) {\n    case eventUtils.BLOCK_CREATE:\n    case eventUtils.BLOCK_MOVE:\n      object = workspace.getBlockById(e.blockId);\n      if (object) {\n        object = object.getRootBlock();\n      }\n      break;\n    case eventUtils.COMMENT_CREATE:\n    case eventUtils.COMMENT_MOVE:\n      object = (\n          /** @type {?WorkspaceCommentSvg} */\n          (workspace.getCommentById(e.commentId)));\n      break;\n  }\n  return object;\n};\n\n/**\n * Bumps the top objects in the given workspace into bounds.\n * @param {!WorkspaceSvg} workspace The workspace.\n * @alias Blockly.bumpObjects.bumpTopObjectsIntoBounds\n */\nconst bumpTopObjectsIntoBounds = function(workspace) {\n  const metricsManager = workspace.getMetricsManager();\n  if (!metricsManager.hasFixedEdges() || workspace.isDragging()) {\n    return;\n  }\n\n  const scrollMetricsInWsCoords = metricsManager.getScrollMetrics(true);\n  const topBlocks = workspace.getTopBoundedElements();\n  for (let i = 0, block; (block = topBlocks[i]); i++) {\n    bumpObjectIntoBounds(workspace, scrollMetricsInWsCoords, block);\n  }\n};\nexports.bumpTopObjectsIntoBounds = bumpTopObjectsIntoBounds;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/bump_objects.js?")},
"./core/clipboard.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Blockly's internal clipboard for managing copy-paste.\n */\n\n\n/**\n * Blockly's internal clipboard for managing copy-paste.\n * @namespace Blockly.clipboard\n */\ngoog.module('Blockly.clipboard');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ICopyable} = goog.requireType('Blockly.ICopyable');\n\n\n/**\n * Metadata about the object that is currently on the clipboard.\n * @type {?ICopyable.CopyData}\n */\nlet copyData = null;\n\n/**\n * Copy a block or workspace comment onto the local clipboard.\n * @param {!ICopyable} toCopy Block or Workspace Comment to be copied.\n * @alias Blockly.clipboard.copy\n * @package\n */\nconst copy = function(toCopy) {\n  copyData = toCopy.toCopyData();\n};\nexports.copy = copy;\n\n/**\n * Paste a block or workspace comment on to the main workspace.\n * @return {!ICopyable|null} The pasted thing if the paste\n *     was successful, null otherwise.\n * @alias Blockly.clipboard.paste\n * @package\n */\nconst paste = function() {\n  if (!copyData) {\n    return null;\n  }\n  // Pasting always pastes to the main workspace, even if the copy\n  // started in a flyout workspace.\n  let workspace = copyData.source;\n  if (workspace.isFlyout) {\n    workspace = workspace.targetWorkspace;\n  }\n  if (copyData.typeCounts &&\n      workspace.isCapacityAvailable(copyData.typeCounts)) {\n    return workspace.paste(copyData.saveInfo);\n  }\n  return null;\n};\nexports.paste = paste;\n\n/**\n * Duplicate this block and its children, or a workspace comment.\n * @param {!ICopyable} toDuplicate Block or Workspace Comment to be\n *     duplicated.\n * @return {!ICopyable|null} The block or workspace comment that was duplicated,\n *     or null if the duplication failed.\n * @alias Blockly.clipboard.duplicate\n * @package\n */\nconst duplicate = function(toDuplicate) {\n  const oldCopyData = copyData;\n  copy(toDuplicate);\n  const pastedThing = toDuplicate.workspace.paste(copyData.saveInfo);\n  copyData = oldCopyData;\n  return pastedThing;\n};\nexports.duplicate = duplicate;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/clipboard.js?")},
"./core/comment.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/css.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\n__webpack_require__(\"./core/bubble.js\");\n__webpack_require__(\"./core/icon.js\");\n__webpack_require__(\"./core/utils/svg.js\");\n__webpack_require__(\"./core/events/events_block_change.js\");\n__webpack_require__(\"./core/events/events_bubble_open.js\");\n__webpack_require__(\"./core/warning.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2011 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing a code comment.\n */\n\n\n/**\n * Object representing a code comment.\n * @class\n */\ngoog.module('Blockly.Comment');\n\nconst Css = goog.require('Blockly.Css');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst dom = goog.require('Blockly.utils.dom');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst userAgent = goog.require('Blockly.utils.userAgent');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\nconst {Bubble} = goog.require('Blockly.Bubble');\n/* eslint-disable-next-line no-unused-vars */\nconst {Coordinate} = goog.requireType('Blockly.utils.Coordinate');\nconst {Icon} = goog.require('Blockly.Icon');\n/* eslint-disable-next-line no-unused-vars */\nconst {Size} = goog.requireType('Blockly.utils.Size');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockChange');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BubbleOpen');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Warning');\n\n\n/**\n * Class for a comment.\n * @extends {Icon}\n * @alias Blockly.Comment\n */\nclass Comment extends Icon {\n  /**\n   * @param {!BlockSvg} block The block associated with this comment.\n   */\n  constructor(block) {\n    super(block);\n\n    /**\n     * The model for this comment.\n     * @type {!Block.CommentModel}\n     * @private\n     */\n    this.model_ = block.commentModel;\n    // If someone creates the comment directly instead of calling\n    // block.setCommentText we want to make sure the text is non-null;\n    this.model_.text = this.model_.text || '';\n\n    /**\n     * The model's text value at the start of an edit.\n     * Used to tell if an event should be fired at the end of an edit.\n     * @type {?string}\n     * @private\n     */\n    this.cachedText_ = '';\n\n    /**\n     * Mouse up event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onMouseUpWrapper_ = null;\n\n    /**\n     * Wheel event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onWheelWrapper_ = null;\n\n    /**\n     * Change event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onChangeWrapper_ = null;\n\n    /**\n     * Input event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onInputWrapper_ = null;\n\n    /**\n     * The SVG element that contains the text edit area, or null if not created.\n     * @type {?SVGForeignObjectElement}\n     * @private\n     */\n    this.foreignObject_ = null;\n\n    /**\n     * The editable text area, or null if not created.\n     * @type {?Element}\n     * @private\n     */\n    this.textarea_ = null;\n\n    /**\n     * The top-level node of the comment text, or null if not created.\n     * @type {?SVGTextElement}\n     * @private\n     */\n    this.paragraphElement_ = null;\n\n    this.createIcon();\n  }\n\n  /**\n   * Draw the comment icon.\n   * @param {!Element} group The icon group.\n   * @protected\n   */\n  drawIcon_(group) {\n    // Circle.\n    dom.createSvgElement(\n        Svg.CIRCLE,\n        {'class': 'blocklyIconShape', 'r': '8', 'cx': '8', 'cy': '8'}, group);\n    // Can't use a real '?' text character since different browsers and\n    // operating systems render it differently. Body of question mark.\n    dom.createSvgElement(\n        Svg.PATH, {\n          'class': 'blocklyIconSymbol',\n          'd': 'm6.8,10h2c0.003,-0.617 0.271,-0.962 0.633,-1.266 2.875,-2.405' +\n              '0.607,-5.534 -3.765,-3.874v1.7c3.12,-1.657 3.698,0.118 2.336,1.25' +\n              '-1.201,0.998 -1.201,1.528 -1.204,2.19z',\n        },\n        group);\n    // Dot of question mark.\n    dom.createSvgElement(\n        Svg.RECT, {\n          'class': 'blocklyIconSymbol',\n          'x': '6.8',\n          'y': '10.78',\n          'height': '2',\n          'width': '2',\n        },\n        group);\n  }\n\n  /**\n   * Create the editor for the comment's bubble.\n   * @return {!SVGElement} The top-level node of the editor.\n   * @private\n   */\n  createEditor_() {\n    /* Create the editor.  Here's the markup that will be generated in\n     * editable mode:\n      <foreignObject x=\"8\" y=\"8\" width=\"164\" height=\"164\">\n        <body xmlns=\"http://www.w3.org/1999/xhtml\" class=\"blocklyMinimalBody\">\n          <textarea xmlns=\"http://www.w3.org/1999/xhtml\"\n              class=\"blocklyCommentTextarea\"\n              style=\"height: 164px; width: 164px;\"></textarea>\n        </body>\n      </foreignObject>\n     * For non-editable mode see Warning.textToDom_.\n     */\n\n    this.foreignObject_ = dom.createSvgElement(\n        Svg.FOREIGNOBJECT, {'x': Bubble.BORDER_WIDTH, 'y': Bubble.BORDER_WIDTH},\n        null);\n\n    const body = document.createElementNS(dom.HTML_NS, 'body');\n    body.setAttribute('xmlns', dom.HTML_NS);\n    body.className = 'blocklyMinimalBody';\n\n    this.textarea_ = document.createElementNS(dom.HTML_NS, 'textarea');\n    const textarea = this.textarea_;\n    textarea.className = 'blocklyCommentTextarea';\n    textarea.setAttribute('dir', this.block_.RTL ? 'RTL' : 'LTR');\n    textarea.value = this.model_.text;\n    this.resizeTextarea_();\n\n    body.appendChild(textarea);\n    this.foreignObject_.appendChild(body);\n\n    // Ideally this would be hooked to the focus event for the comment.\n    // However doing so in Firefox swallows the cursor for unknown reasons.\n    // So this is hooked to mouseup instead.  No big deal.\n    this.onMouseUpWrapper_ = browserEvents.conditionalBind(\n        textarea, 'mouseup', this, this.startEdit_, true, true);\n    // Don't zoom with mousewheel.\n    this.onWheelWrapper_ =\n        browserEvents.conditionalBind(textarea, 'wheel', this, function(e) {\n          e.stopPropagation();\n        });\n    this.onChangeWrapper_ = browserEvents.conditionalBind(\n        textarea, 'change', this,\n        /**\n         * @this {Comment}\n         * @param {Event} _e Unused event parameter.\n         */\n        function(_e) {\n          if (this.cachedText_ !== this.model_.text) {\n            eventUtils.fire(new (eventUtils.get(eventUtils.BLOCK_CHANGE))(\n                this.block_, 'comment', null, this.cachedText_,\n                this.model_.text));\n          }\n        });\n    this.onInputWrapper_ = browserEvents.conditionalBind(\n        textarea, 'input', this,\n        /**\n         * @this {Comment}\n         * @param {Event} _e Unused event parameter.\n         */\n        function(_e) {\n          this.model_.text = textarea.value;\n        });\n\n    setTimeout(textarea.focus.bind(textarea), 0);\n\n    return this.foreignObject_;\n  }\n\n  /**\n   * Add or remove editability of the comment.\n   * @override\n   */\n  updateEditable() {\n    super.updateEditable();\n    if (this.isVisible()) {\n      // Recreate the bubble with the correct UI.\n      this.disposeBubble_();\n      this.createBubble_();\n    }\n  }\n\n  /**\n   * Callback function triggered when the bubble has resized.\n   * Resize the text area accordingly.\n   * @private\n   */\n  onBubbleResize_() {\n    if (!this.isVisible()) {\n      return;\n    }\n    this.model_.size = this.bubble_.getBubbleSize();\n    this.resizeTextarea_();\n  }\n\n  /**\n   * Resizes the text area to match the size defined on the model (which is\n   * the size of the bubble).\n   * @private\n   */\n  resizeTextarea_() {\n    const size = this.model_.size;\n    const doubleBorderWidth = 2 * Bubble.BORDER_WIDTH;\n    const widthMinusBorder = size.width - doubleBorderWidth;\n    const heightMinusBorder = size.height - doubleBorderWidth;\n    this.foreignObject_.setAttribute('width', widthMinusBorder);\n    this.foreignObject_.setAttribute('height', heightMinusBorder);\n    this.textarea_.style.width = (widthMinusBorder - 4) + 'px';\n    this.textarea_.style.height = (heightMinusBorder - 4) + 'px';\n  }\n\n  /**\n   * Show or hide the comment bubble.\n   * @param {boolean} visible True if the bubble should be visible.\n   */\n  setVisible(visible) {\n    if (visible === this.isVisible()) {\n      return;\n    }\n    eventUtils.fire(new (eventUtils.get(eventUtils.BUBBLE_OPEN))(\n        this.block_, visible, 'comment'));\n    this.model_.pinned = visible;\n    if (visible) {\n      this.createBubble_();\n    } else {\n      this.disposeBubble_();\n    }\n  }\n\n  /**\n   * Show the bubble. Handles deciding if it should be editable or not.\n   * @private\n   */\n  createBubble_() {\n    if (!this.block_.isEditable() || userAgent.IE) {\n      // MSIE does not support foreignobject; textareas are impossible.\n      // https://docs.microsoft.com/en-us/openspecs/ie_standards/ms-svg/56e6e04c-7c8c-44dd-8100-bd745ee42034\n      // Always treat comments in IE as uneditable.\n      this.createNonEditableBubble_();\n    } else {\n      this.createEditableBubble_();\n    }\n  }\n\n  /**\n   * Show an editable bubble.\n   * @private\n   */\n  createEditableBubble_() {\n    this.bubble_ = new Bubble(\n        /** @type {!WorkspaceSvg} */ (this.block_.workspace),\n        this.createEditor_(), this.block_.pathObject.svgPath,\n        /** @type {!Coordinate} */ (this.iconXY_), this.model_.size.width,\n        this.model_.size.height);\n    // Expose this comment's block's ID on its top-level SVG group.\n    this.bubble_.setSvgId(this.block_.id);\n    this.bubble_.registerResizeEvent(this.onBubbleResize_.bind(this));\n    this.applyColour();\n  }\n\n  /**\n   * Show a non-editable bubble.\n   * @private\n   * @suppress {checkTypes} Suppress `this` type mismatch.\n   */\n  createNonEditableBubble_() {\n    // TODO (#2917): It would be great if the comment could support line breaks.\n    this.paragraphElement_ = Bubble.textToDom(this.block_.getCommentText());\n    this.bubble_ = Bubble.createNonEditableBubble(\n        this.paragraphElement_, /** @type {!BlockSvg} */ (this.block_),\n        /** @type {!Coordinate} */ (this.iconXY_));\n    this.applyColour();\n  }\n\n  /**\n   * Dispose of the bubble.\n   * @private\n   * @suppress {checkTypes} Suppress `this` type mismatch.\n   */\n  disposeBubble_() {\n    if (this.onMouseUpWrapper_) {\n      browserEvents.unbind(this.onMouseUpWrapper_);\n      this.onMouseUpWrapper_ = null;\n    }\n    if (this.onWheelWrapper_) {\n      browserEvents.unbind(this.onWheelWrapper_);\n      this.onWheelWrapper_ = null;\n    }\n    if (this.onChangeWrapper_) {\n      browserEvents.unbind(this.onChangeWrapper_);\n      this.onChangeWrapper_ = null;\n    }\n    if (this.onInputWrapper_) {\n      browserEvents.unbind(this.onInputWrapper_);\n      this.onInputWrapper_ = null;\n    }\n    this.bubble_.dispose();\n    this.bubble_ = null;\n    this.textarea_ = null;\n    this.foreignObject_ = null;\n    this.paragraphElement_ = null;\n  }\n\n  /**\n   * Callback fired when an edit starts.\n   *\n   * Bring the comment to the top of the stack when clicked on. Also cache the\n   * current text so it can be used to fire a change event.\n   * @param {!Event} _e Mouse up event.\n   * @private\n   */\n  startEdit_(_e) {\n    if (this.bubble_.promote()) {\n      // Since the act of moving this node within the DOM causes a loss of\n      // focus, we need to reapply the focus.\n      this.textarea_.focus();\n    }\n\n    this.cachedText_ = this.model_.text;\n  }\n\n  /**\n   * Get the dimensions of this comment's bubble.\n   * @return {Size} Object with width and height properties.\n   */\n  getBubbleSize() {\n    return this.model_.size;\n  }\n\n  /**\n   * Size this comment's bubble.\n   * @param {number} width Width of the bubble.\n   * @param {number} height Height of the bubble.\n   */\n  setBubbleSize(width, height) {\n    if (this.bubble_) {\n      this.bubble_.setBubbleSize(width, height);\n    } else {\n      this.model_.size.width = width;\n      this.model_.size.height = height;\n    }\n  }\n\n  /**\n   * Update the comment's view to match the model.\n   * @package\n   */\n  updateText() {\n    if (this.textarea_) {\n      this.textarea_.value = this.model_.text;\n    } else if (this.paragraphElement_) {\n      // Non-Editable mode.\n      // TODO (#2917): If 2917 gets added this will probably need to be updated.\n      this.paragraphElement_.firstChild.textContent = this.model_.text;\n    }\n  }\n\n  /**\n   * Dispose of this comment.\n   *\n   * If you want to receive a comment \"delete\" event (newValue: null), then this\n   * should not be called directly. Instead call block.setCommentText(null);\n   */\n  dispose() {\n    this.block_.comment = null;\n    Icon.prototype.dispose.call(this);\n  }\n}\n\n/**\n * CSS for block comment.  See css.js for use.\n */\nCss.register(`\n.blocklyCommentTextarea {\n  background-color: #fef49c;\n  border: 0;\n  display: block;\n  margin: 0;\n  outline: 0;\n  padding: 3px;\n  resize: none;\n  text-overflow: hidden;\n}\n`);\n\nexports.Comment = Comment;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/comment.js?")},
"./core/common.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/blocks.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Common functions used both internally and externally, but which\n * must not be at the top level to avoid circular dependencies.\n */\n\n\n/**\n * Common functions used both internally and externally, but which\n * must not be at the top level to avoid circular dependencies.\n * @namespace Blockly.common\n */\ngoog.module('Blockly.common');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockDefinition, Blocks} = goog.require('Blockly.blocks');\n/* eslint-disable-next-line no-unused-vars */\nconst {Connection} = goog.requireType('Blockly.Connection');\n/* eslint-disable-next-line no-unused-vars */\nconst {ICopyable} = goog.requireType('Blockly.ICopyable');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Workspace} = goog.requireType('Blockly.Workspace');\n\n\n/**\n * The main workspace most recently used.\n * Set by Blockly.WorkspaceSvg.prototype.markFocused\n * @type {!Workspace}\n */\nlet mainWorkspace;\n\n/**\n * Returns the last used top level workspace (based on focus).  Try not to use\n * this function, particularly if there are multiple Blockly instances on a\n * page.\n * @return {!Workspace} The main workspace.\n * @alias Blockly.common.getMainWorkspace\n */\nconst getMainWorkspace = function() {\n  return mainWorkspace;\n};\nexports.getMainWorkspace = getMainWorkspace;\n\n/**\n * Sets last used main workspace.\n * @param {!Workspace} workspace The most recently used top level workspace.\n * @alias Blockly.common.setMainWorkspace\n */\nconst setMainWorkspace = function(workspace) {\n  mainWorkspace = workspace;\n};\nexports.setMainWorkspace = setMainWorkspace;\n\n/**\n * Currently selected block.\n * @type {?ICopyable}\n */\nlet selected = null;\n\n/**\n * Returns the currently selected block.\n * @return {?ICopyable} The currently selected block.\n * @alias Blockly.common.getSelected\n */\nconst getSelected = function() {\n  return selected;\n};\nexports.getSelected = getSelected;\n\n/**\n * Sets the currently selected block. This function does not visually mark the\n * block as selected or fire the required events. If you wish to\n * programmatically select a block, use `BlockSvg#select`.\n * @param {?ICopyable} newSelection The newly selected block.\n * @alias Blockly.common.setSelected\n * @package\n */\nconst setSelected = function(newSelection) {\n  selected = newSelection;\n};\nexports.setSelected = setSelected;\n\n/**\n * Container element in which to render the WidgetDiv, DropDownDiv and Tooltip.\n * @type {?Element}\n */\nlet parentContainer;\n\n/**\n * Get the container element in which to render the WidgetDiv, DropDownDiv and\\\n * Tooltip.\n * @return {?Element} The parent container.\n * @alias Blockly.common.getParentContainer\n */\nconst getParentContainer = function() {\n  return parentContainer;\n};\nexports.getParentContainer = getParentContainer;\n\n/**\n * Set the parent container.  This is the container element that the WidgetDiv,\n * DropDownDiv, and Tooltip are rendered into the first time `Blockly.inject`\n * is called.\n * This method is a NOP if called after the first ``Blockly.inject``.\n * @param {!Element} newParent The container element.\n * @alias Blockly.common.setParentContainer\n */\nconst setParentContainer = function(newParent) {\n  parentContainer = newParent;\n};\nexports.setParentContainer = setParentContainer;\n\n/**\n * Size the SVG image to completely fill its container. Call this when the view\n * actually changes sizes (e.g. on a window resize/device orientation change).\n * See workspace.resizeContents to resize the workspace when the contents\n * change (e.g. when a block is added or removed).\n * Record the height/width of the SVG image.\n * @param {!WorkspaceSvg} workspace Any workspace in the SVG.\n * @alias Blockly.common.svgResize\n */\nconst svgResize = function(workspace) {\n  let mainWorkspace = workspace;\n  while (mainWorkspace.options.parentWorkspace) {\n    mainWorkspace = mainWorkspace.options.parentWorkspace;\n  }\n  const svg = mainWorkspace.getParentSvg();\n  const cachedSize = mainWorkspace.getCachedParentSvgSize();\n  const div = svg.parentNode;\n  if (!div) {\n    // Workspace deleted, or something.\n    return;\n  }\n  const width = div.offsetWidth;\n  const height = div.offsetHeight;\n  if (cachedSize.width !== width) {\n    svg.setAttribute('width', width + 'px');\n    mainWorkspace.setCachedParentSvgSize(width, null);\n  }\n  if (cachedSize.height !== height) {\n    svg.setAttribute('height', height + 'px');\n    mainWorkspace.setCachedParentSvgSize(null, height);\n  }\n  mainWorkspace.resize();\n};\nexports.svgResize = svgResize;\n\n/**\n * All of the connections on blocks that are currently being dragged.\n * @type {!Array<!Connection>}\n */\nexports.draggingConnections = [];\n\n/**\n * Get a map of all the block's descendants mapping their type to the number of\n *    children with that type.\n * @param {!Block} block The block to map.\n * @param {boolean=} opt_stripFollowing Optionally ignore all following\n *    statements (blocks that are not inside a value or statement input\n *    of the block).\n * @return {!Object} Map of types to type counts for descendants of the bock.\n * @alias Blockly.common.getBlockTypeCounts\n */\nconst getBlockTypeCounts = function(block, opt_stripFollowing) {\n  const typeCountsMap = Object.create(null);\n  const descendants = block.getDescendants(true);\n  if (opt_stripFollowing) {\n    const nextBlock = block.getNextBlock();\n    if (nextBlock) {\n      const index = descendants.indexOf(nextBlock);\n      descendants.splice(index, descendants.length - index);\n    }\n  }\n  for (let i = 0, checkBlock; (checkBlock = descendants[i]); i++) {\n    if (typeCountsMap[checkBlock.type]) {\n      typeCountsMap[checkBlock.type]++;\n    } else {\n      typeCountsMap[checkBlock.type] = 1;\n    }\n  }\n  return typeCountsMap;\n};\nexports.getBlockTypeCounts = getBlockTypeCounts;\n\n/**\n * Helper function for defining a block from JSON.  The resulting function has\n * the correct value of jsonDef at the point in code where jsonInit is called.\n * @param {!Object} jsonDef The JSON definition of a block.\n * @return {function()} A function that calls jsonInit with the correct value\n *     of jsonDef.\n */\nconst jsonInitFactory = function(jsonDef) {\n  return /** @this {Block} */ function() {\n    this.jsonInit(jsonDef);\n  };\n};\n\n/**\n * Define blocks from an array of JSON block definitions, as might be generated\n * by the Blockly Developer Tools.\n * @param {!Array<!Object>} jsonArray An array of JSON block definitions.\n * @alias Blockly.common.defineBlocksWithJsonArray\n */\nconst defineBlocksWithJsonArray = function(jsonArray) {\n  defineBlocks(createBlockDefinitionsFromJsonArray(jsonArray));\n};\nexports.defineBlocksWithJsonArray = defineBlocksWithJsonArray;\n\n/**\n * Define blocks from an array of JSON block definitions, as might be generated\n * by the Blockly Developer Tools.\n * @param {!Array<!Object>} jsonArray An array of JSON block definitions.\n * @return {!Object<string, !BlockDefinition>} A map of the block\n *     definitions created.\n * @alias Blockly.common.defineBlocksWithJsonArray\n */\nconst createBlockDefinitionsFromJsonArray = function(jsonArray) {\n  const /** @type {!Object<string,!BlockDefinition>} */ blocks = {};\n  for (let i = 0; i < jsonArray.length; i++) {\n    const elem = jsonArray[i];\n    if (!elem) {\n      console.warn(`Block definition #${i} in JSON array is ${elem}. Skipping`);\n      continue;\n    }\n    const type = elem.type;\n    if (!type) {\n      console.warn(\n          `Block definition #${i} in JSON array is missing a type attribute. ` +\n          'Skipping.');\n      continue;\n    }\n    blocks[type] = {init: jsonInitFactory(elem)};\n  }\n  return blocks;\n};\nexports.createBlockDefinitionsFromJsonArray =\n    createBlockDefinitionsFromJsonArray;\n\n/**\n * Add the specified block definitions to the block definitions\n * dictionary (Blockly.Blocks).\n * @param {!Object<string,!BlockDefinition>} blocks A map of block\n *     type names to block definitions.\n * @alias Blockly.common.defineBlocks\n */\nconst defineBlocks = function(blocks) {\n  // Iterate over own enumerable properties.\n  for (const type of Object.keys(blocks)) {\n    const definition = blocks[type];\n    if (type in Blocks) {\n      console.warn(`Block definiton \"${type}\" overwrites previous definition.`);\n    }\n    Blocks[type] = definition;\n  }\n};\nexports.defineBlocks = defineBlocks;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/common.js?")},
"./core/component_manager.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/array.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Manager for all items registered with the workspace.\n */\n\n\n\n/**\n * Manager for all items registered with the workspace.\n * @class\n */\ngoog.module('Blockly.ComponentManager');\n\nconst arrayUtils = goog.require('Blockly.utils.array');\n/* eslint-disable-next-line no-unused-vars */\nconst {IAutoHideable} = goog.requireType('Blockly.IAutoHideable');\n/* eslint-disable-next-line no-unused-vars */\nconst {IComponent} = goog.requireType('Blockly.IComponent');\n/* eslint-disable-next-line no-unused-vars */\nconst {IDeleteArea} = goog.requireType('Blockly.IDeleteArea');\n/* eslint-disable-next-line no-unused-vars */\nconst {IDragTarget} = goog.requireType('Blockly.IDragTarget');\n/* eslint-disable-next-line no-unused-vars */\nconst {IPositionable} = goog.requireType('Blockly.IPositionable');\n\n\n/**\n * Manager for all items registered with the workspace.\n * @alias Blockly.ComponentManager\n */\nclass ComponentManager {\n  /**\n   * Creates a new ComponentManager instance.\n   */\n  constructor() {\n    /**\n     * A map of the components registered with the workspace, mapped to id.\n     * @type {!Object<string, !ComponentManager.ComponentDatum>}\n     * @private\n     */\n    this.componentData_ = Object.create(null);\n\n    /**\n     * A map of capabilities to component IDs.\n     * @type {!Object<string, !Array<string>>}\n     * @private\n     */\n    this.capabilityToComponentIds_ = Object.create(null);\n  }\n\n  /**\n   * Adds a component.\n   * @param {!ComponentManager.ComponentDatum} componentInfo The data for\n   *   the component to register.\n   * @param {boolean=} opt_allowOverrides True to prevent an error when\n   *     overriding an already registered item.\n   */\n  addComponent(componentInfo, opt_allowOverrides) {\n    // Don't throw an error if opt_allowOverrides is true.\n    const id = componentInfo.component.id;\n    if (!opt_allowOverrides && this.componentData_[id]) {\n      throw Error(\n          'Plugin \"' + id + '\" with capabilities \"' +\n          this.componentData_[id].capabilities + '\" already added.');\n    }\n    this.componentData_[id] = componentInfo;\n    const stringCapabilities = [];\n    for (let i = 0; i < componentInfo.capabilities.length; i++) {\n      const capability = String(componentInfo.capabilities[i]).toLowerCase();\n      stringCapabilities.push(capability);\n      if (this.capabilityToComponentIds_[capability] === undefined) {\n        this.capabilityToComponentIds_[capability] = [id];\n      } else {\n        this.capabilityToComponentIds_[capability].push(id);\n      }\n    }\n    this.componentData_[id].capabilities = stringCapabilities;\n  }\n\n  /**\n   * Removes a component.\n   * @param {string} id The ID of the component to remove.\n   */\n  removeComponent(id) {\n    const componentInfo = this.componentData_[id];\n    if (!componentInfo) {\n      return;\n    }\n    for (let i = 0; i < componentInfo.capabilities.length; i++) {\n      const capability = String(componentInfo.capabilities[i]).toLowerCase();\n      arrayUtils.removeElem(this.capabilityToComponentIds_[capability], id);\n    }\n    delete this.componentData_[id];\n  }\n\n  /**\n   * Adds a capability to a existing registered component.\n   * @param {string} id The ID of the component to add the capability to.\n   * @param {string|!ComponentManager.Capability<T>} capability The\n   *     capability to add.\n   * @template T\n   */\n  addCapability(id, capability) {\n    if (!this.getComponent(id)) {\n      throw Error(\n          'Cannot add capability, \"' + capability + '\". Plugin \"' + id +\n          '\" has not been added to the ComponentManager');\n    }\n    if (this.hasCapability(id, capability)) {\n      console.warn(\n          'Plugin \"' + id + 'already has capability \"' + capability + '\"');\n      return;\n    }\n    capability = String(capability).toLowerCase();\n    this.componentData_[id].capabilities.push(capability);\n    this.capabilityToComponentIds_[capability].push(id);\n  }\n\n  /**\n   * Removes a capability from an existing registered component.\n   * @param {string} id The ID of the component to remove the capability from.\n   * @param {string|!ComponentManager.Capability<T>} capability The\n   *     capability to remove.\n   * @template T\n   */\n  removeCapability(id, capability) {\n    if (!this.getComponent(id)) {\n      throw Error(\n          'Cannot remove capability, \"' + capability + '\". Plugin \"' + id +\n          '\" has not been added to the ComponentManager');\n    }\n    if (!this.hasCapability(id, capability)) {\n      console.warn(\n          'Plugin \"' + id + 'doesn\\'t have capability \"' + capability +\n          '\" to remove');\n      return;\n    }\n    capability = String(capability).toLowerCase();\n    arrayUtils.removeElem(this.componentData_[id].capabilities, capability);\n    arrayUtils.removeElem(this.capabilityToComponentIds_[capability], id);\n  }\n\n  /**\n   * Returns whether the component with this id has the specified capability.\n   * @param {string} id The ID of the component to check.\n   * @param {string|!ComponentManager.Capability<T>} capability The\n   *     capability to check for.\n   * @return {boolean} Whether the component has the capability.\n   * @template T\n   */\n  hasCapability(id, capability) {\n    capability = String(capability).toLowerCase();\n    return this.componentData_[id].capabilities.indexOf(capability) !== -1;\n  }\n\n  /**\n   * Gets the component with the given ID.\n   * @param {string} id The ID of the component to get.\n   * @return {!IComponent|undefined} The component with the given name\n   *    or undefined if not found.\n   */\n  getComponent(id) {\n    return this.componentData_[id] && this.componentData_[id].component;\n  }\n\n  /**\n   * Gets all the components with the specified capability.\n   * @param {string|!ComponentManager.Capability<T>\n   *   } capability The capability of the component.\n   * @param {boolean} sorted Whether to return list ordered by weights.\n   * @return {!Array<T>} The components that match the specified capability.\n   * @template T\n   */\n  getComponents(capability, sorted) {\n    capability = String(capability).toLowerCase();\n    const componentIds = this.capabilityToComponentIds_[capability];\n    if (!componentIds) {\n      return [];\n    }\n    const components = [];\n    if (sorted) {\n      const componentDataList = [];\n      const componentData = this.componentData_;\n      componentIds.forEach(function(id) {\n        componentDataList.push(componentData[id]);\n      });\n      componentDataList.sort(function(a, b) {\n        return a.weight - b.weight;\n      });\n      componentDataList.forEach(function(ComponentDatum) {\n        components.push(ComponentDatum.component);\n      });\n    } else {\n      const componentData = this.componentData_;\n      componentIds.forEach(function(id) {\n        components.push(componentData[id].component);\n      });\n    }\n    return components;\n  }\n}\n\n/**\n * An object storing component information.\n * @typedef {{\n *    component: !IComponent,\n *    capabilities: (\n *     !Array<string|!ComponentManager.Capability<!IComponent>>\n *       ),\n *    weight: number\n *  }}\n */\nComponentManager.ComponentDatum;\n\n/**\n * A name with the capability of the element stored in the generic.\n * @template T\n * @alias Blockly.ComponentManager.Capability\n */\nComponentManager.Capability = class {\n  /**\n   * @param {string} name The name of the component capability.\n   */\n  constructor(name) {\n    /**\n     * @type {string}\n     * @private\n     */\n    this.name_ = name;\n  }\n\n  /**\n   * Returns the name of the capability.\n   * @return {string} The name.\n   * @override\n   */\n  toString() {\n    return this.name_;\n  }\n};\n\n/** @type {!ComponentManager.Capability<!IPositionable>} */\nComponentManager.Capability.POSITIONABLE =\n    new ComponentManager.Capability('positionable');\n\n/** @type {!ComponentManager.Capability<!IDragTarget>} */\nComponentManager.Capability.DRAG_TARGET =\n    new ComponentManager.Capability('drag_target');\n\n/** @type {!ComponentManager.Capability<!IDeleteArea>} */\nComponentManager.Capability.DELETE_AREA =\n    new ComponentManager.Capability('delete_area');\n\n/** @type {!ComponentManager.Capability<!IAutoHideable>} */\nComponentManager.Capability.AUTOHIDEABLE =\n    new ComponentManager.Capability('autohideable');\n\nexports.ComponentManager = ComponentManager;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/component_manager.js?")},
"./core/config.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview All the values that we expect developers to be able to change\n * before injecting Blockly. Changing these values during run time is not\n * generally recommended.\n */\n\n\n/**\n * All the values that we expect developers to be able to change\n * before injecting Blockly. Changing these values during run time is not\n * generally recommended.\n * @namespace Blockly.config\n */\ngoog.module('Blockly.config');\n\n\n/**\n * All the values that we expect developers to be able to change\n * before injecting Blockly.\n * @typedef {{\n *      dragRadius: number,\n *      flyoutDragRadius: number,\n *      snapRadius: number,\n *      currentConnectionPreference: number,\n *      bumpDelay: number,\n *      connectingSnapRadius: number\n *    }}\n */\nlet Config;  // eslint-disable-line no-unused-vars\n\n/**\n * Default snap radius.\n * @type {number}\n */\nconst DEFAULT_SNAP_RADIUS = 28;\n\n/**\n * Object holding all the values on Blockly that we expect developers to be\n * able to change.\n * @type {Config}\n */\nconst config = {\n  /**\n   * Number of pixels the mouse must move before a drag starts.\n   * @alias Blockly.config.dragRadius\n   */\n  dragRadius: 5,\n  /**\n   * Number of pixels the mouse must move before a drag/scroll starts from the\n   * flyout.  Because the drag-intention is determined when this is reached, it\n   * is larger than dragRadius so that the drag-direction is clearer.\n   * @alias Blockly.config.flyoutDragRadius\n   */\n  flyoutDragRadius: 10,\n  /**\n   * Maximum misalignment between connections for them to snap together.\n   * @alias Blockly.config.snapRadius\n   */\n  snapRadius: DEFAULT_SNAP_RADIUS,\n  /**\n   * Maximum misalignment between connections for them to snap together.\n   * This should be the same as the snap radius.\n   * @alias Blockly.config.connectingSnapRadius\n   */\n  connectingSnapRadius: DEFAULT_SNAP_RADIUS,\n  /**\n   * How much to prefer staying connected to the current connection over moving\n   * to a new connection.  The current previewed connection is considered to be\n   * this much closer to the matching connection on the block than it actually\n   * is.\n   * @alias Blockly.config.currentConnectionPreference\n   */\n  currentConnectionPreference: 8,\n  /**\n   * Delay in ms between trigger and bumping unconnected block out of alignment.\n   * @alias Blockly.config.bumpDelay\n   */\n  bumpDelay: 250,\n};\n\nexports.config = config;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/config.js?")},
"./core/connection.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/xml.js\");\n__webpack_require__(\"./core/serialization/blocks.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/connection_type.js\");\n__webpack_require__(\"./core/interfaces/i_ast_node_location_with_block.js\");\n__webpack_require__(\"./core/events/events_block_move.js\");\n__webpack_require__(\"./core/constants.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2011 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Components for creating connections between blocks.\n */\n\n\n/**\n * Components for creating connections between blocks.\n * @class\n */\ngoog.module('Blockly.Connection');\n\nconst Xml = goog.require('Blockly.Xml');\nconst blocks = goog.require('Blockly.serialization.blocks');\nconst eventUtils = goog.require('Blockly.Events.utils');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockMove} = goog.requireType('Blockly.Events.BlockMove');\nconst {ConnectionType} = goog.require('Blockly.ConnectionType');\n/* eslint-disable-next-line no-unused-vars */\nconst {IASTNodeLocationWithBlock} = goog.require('Blockly.IASTNodeLocationWithBlock');\n/* eslint-disable-next-line no-unused-vars */\nconst {IConnectionChecker} = goog.requireType('Blockly.IConnectionChecker');\n/* eslint-disable-next-line no-unused-vars */\nconst {Input} = goog.requireType('Blockly.Input');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockMove');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.constants');\n\n\n/**\n * Class for a connection between blocks.\n * @implements {IASTNodeLocationWithBlock}\n * @alias Blockly.Connection\n */\nclass Connection {\n  /**\n   * @param {!Block} source The block establishing this connection.\n   * @param {number} type The type of the connection.\n   */\n  constructor(source, type) {\n    /**\n     * @type {!Block}\n     * @protected\n     */\n    this.sourceBlock_ = source;\n    /** @type {number} */\n    this.type = type;\n\n    /**\n     * Connection this connection connects to.  Null if not connected.\n     * @type {Connection}\n     */\n    this.targetConnection = null;\n\n    /**\n     * Has this connection been disposed of?\n     * @type {boolean}\n     * @package\n     */\n    this.disposed = false;\n\n    /**\n     * List of compatible value types.  Null if all types are compatible.\n     * @type {Array}\n     * @private\n     */\n    this.check_ = null;\n\n    /**\n     * DOM representation of a shadow block, or null if none.\n     * @type {Element}\n     * @private\n     */\n    this.shadowDom_ = null;\n\n    /**\n     * Horizontal location of this connection.\n     * @type {number}\n     * @package\n     */\n    this.x = 0;\n\n    /**\n     * Vertical location of this connection.\n     * @type {number}\n     * @package\n     */\n    this.y = 0;\n\n    /**\n     * @type {?blocks.State}\n     * @private\n     */\n    this.shadowState_ = null;\n  }\n\n  /**\n   * Connect two connections together.  This is the connection on the superior\n   * block.\n   * @param {!Connection} childConnection Connection on inferior block.\n   * @protected\n   */\n  connect_(childConnection) {\n    const INPUT = ConnectionType.INPUT_VALUE;\n    const parentConnection = this;\n    const parentBlock = parentConnection.getSourceBlock();\n    const childBlock = childConnection.getSourceBlock();\n\n    // Make sure the childConnection is available.\n    if (childConnection.isConnected()) {\n      childConnection.disconnect();\n    }\n\n    // Make sure the parentConnection is available.\n    let orphan;\n    if (parentConnection.isConnected()) {\n      const shadowState = parentConnection.stashShadowState_();\n      const target = parentConnection.targetBlock();\n      if (target.isShadow()) {\n        target.dispose(false);\n      } else {\n        parentConnection.disconnect();\n        orphan = target;\n      }\n      parentConnection.applyShadowState_(shadowState);\n    }\n\n    // Connect the new connection to the parent.\n    let event;\n    if (eventUtils.isEnabled()) {\n      event = /** @type {!BlockMove} */\n          (new (eventUtils.get(eventUtils.BLOCK_MOVE))(childBlock));\n    }\n    connectReciprocally(parentConnection, childConnection);\n    childBlock.setParent(parentBlock);\n    if (event) {\n      event.recordNew();\n      eventUtils.fire(event);\n    }\n\n    // Deal with the orphan if it exists.\n    if (orphan) {\n      const orphanConnection = parentConnection.type === INPUT ?\n          orphan.outputConnection :\n          orphan.previousConnection;\n      const connection = Connection.getConnectionForOrphanedConnection(\n          childBlock, /** @type {!Connection} */ (orphanConnection));\n      if (connection) {\n        orphanConnection.connect(connection);\n      } else {\n        orphanConnection.onFailedConnect(parentConnection);\n      }\n    }\n  }\n\n  /**\n   * Dispose of this connection and deal with connected blocks.\n   * @package\n   */\n  dispose() {\n    // isConnected returns true for shadows and non-shadows.\n    if (this.isConnected()) {\n      // Destroy the attached shadow block & its children (if it exists).\n      this.setShadowStateInternal_();\n\n      const targetBlock = this.targetBlock();\n      if (targetBlock) {\n        // Disconnect the attached normal block.\n        targetBlock.unplug();\n      }\n    }\n\n    this.disposed = true;\n  }\n\n  /**\n   * Get the source block for this connection.\n   * @return {!Block} The source block.\n   */\n  getSourceBlock() {\n    return this.sourceBlock_;\n  }\n\n  /**\n   * Does the connection belong to a superior block (higher in the source\n   * stack)?\n   * @return {boolean} True if connection faces down or right.\n   */\n  isSuperior() {\n    return this.type === ConnectionType.INPUT_VALUE ||\n        this.type === ConnectionType.NEXT_STATEMENT;\n  }\n\n  /**\n   * Is the connection connected?\n   * @return {boolean} True if connection is connected to another connection.\n   */\n  isConnected() {\n    return !!this.targetConnection;\n  }\n\n  /**\n   * Get the workspace's connection type checker object.\n   * @return {!IConnectionChecker} The connection type checker for the\n   *     source block's workspace.\n   * @package\n   */\n  getConnectionChecker() {\n    return this.sourceBlock_.workspace.connectionChecker;\n  }\n\n  /**\n   * Called when an attempted connection fails. NOP by default (i.e. for\n   * headless workspaces).\n   * @param {!Connection} _otherConnection Connection that this connection\n   *     failed to connect to.\n   * @package\n   */\n  onFailedConnect(_otherConnection) {\n    // NOP\n  }\n\n  /**\n   * Connect this connection to another connection.\n   * @param {!Connection} otherConnection Connection to connect to.\n   * @return {boolean} Whether the the blocks are now connected or not.\n   */\n  connect(otherConnection) {\n    if (this.targetConnection === otherConnection) {\n      // Already connected together.  NOP.\n      return true;\n    }\n\n    const checker = this.getConnectionChecker();\n    if (checker.canConnect(this, otherConnection, false)) {\n      const eventGroup = eventUtils.getGroup();\n      if (!eventGroup) {\n        eventUtils.setGroup(true);\n      }\n      // Determine which block is superior (higher in the source stack).\n      if (this.isSuperior()) {\n        // Superior block.\n        this.connect_(otherConnection);\n      } else {\n        // Inferior block.\n        otherConnection.connect_(this);\n      }\n      if (!eventGroup) {\n        eventUtils.setGroup(false);\n      }\n    }\n\n    return this.isConnected();\n  }\n\n  /**\n   * Disconnect this connection.\n   */\n  disconnect() {\n    const otherConnection = this.targetConnection;\n    if (!otherConnection) {\n      throw Error('Source connection not connected.');\n    }\n    if (otherConnection.targetConnection !== this) {\n      throw Error('Target connection not connected to source connection.');\n    }\n    let parentBlock;\n    let childBlock;\n    let parentConnection;\n    if (this.isSuperior()) {\n      // Superior block.\n      parentBlock = this.sourceBlock_;\n      childBlock = otherConnection.getSourceBlock();\n      parentConnection = this;\n    } else {\n      // Inferior block.\n      parentBlock = otherConnection.getSourceBlock();\n      childBlock = this.sourceBlock_;\n      parentConnection = otherConnection;\n    }\n\n    const eventGroup = eventUtils.getGroup();\n    if (!eventGroup) {\n      eventUtils.setGroup(true);\n    }\n    this.disconnectInternal_(parentBlock, childBlock);\n    if (!childBlock.isShadow()) {\n      // If we were disconnecting a shadow, no need to spawn a new one.\n      parentConnection.respawnShadow_();\n    }\n    if (!eventGroup) {\n      eventUtils.setGroup(false);\n    }\n  }\n\n  /**\n   * Disconnect two blocks that are connected by this connection.\n   * @param {!Block} parentBlock The superior block.\n   * @param {!Block} childBlock The inferior block.\n   * @protected\n   */\n  disconnectInternal_(parentBlock, childBlock) {\n    let event;\n    if (eventUtils.isEnabled()) {\n      event = /** @type {!BlockMove} */\n          (new (eventUtils.get(eventUtils.BLOCK_MOVE))(childBlock));\n    }\n    const otherConnection = this.targetConnection;\n    otherConnection.targetConnection = null;\n    this.targetConnection = null;\n    childBlock.setParent(null);\n    if (event) {\n      event.recordNew();\n      eventUtils.fire(event);\n    }\n  }\n\n  /**\n   * Respawn the shadow block if there was one connected to the this connection.\n   * @protected\n   */\n  respawnShadow_() {\n    // Have to keep respawnShadow_ for backwards compatibility.\n    this.createShadowBlock_(true);\n  }\n\n  /**\n   * Returns the block that this connection connects to.\n   * @return {?Block} The connected block or null if none is connected.\n   */\n  targetBlock() {\n    if (this.isConnected()) {\n      return this.targetConnection.getSourceBlock();\n    }\n    return null;\n  }\n\n  /**\n   * Function to be called when this connection's compatible types have changed.\n   * @protected\n   */\n  onCheckChanged_() {\n    // The new value type may not be compatible with the existing connection.\n    if (this.isConnected() &&\n        (!this.targetConnection ||\n         !this.getConnectionChecker().canConnect(\n             this, this.targetConnection, false))) {\n      const child = this.isSuperior() ? this.targetBlock() : this.sourceBlock_;\n      child.unplug();\n    }\n  }\n\n  /**\n   * Change a connection's compatibility.\n   * @param {?(string|!Array<string>)} check Compatible value type or list of\n   *     value types. Null if all types are compatible.\n   * @return {!Connection} The connection being modified\n   *     (to allow chaining).\n   */\n  setCheck(check) {\n    if (check) {\n      // Ensure that check is in an array.\n      if (!Array.isArray(check)) {\n        check = [check];\n      }\n      this.check_ = check;\n      this.onCheckChanged_();\n    } else {\n      this.check_ = null;\n    }\n    return this;\n  }\n\n  /**\n   * Get a connection's compatibility.\n   * @return {?Array} List of compatible value types.\n   *     Null if all types are compatible.\n   * @public\n   */\n  getCheck() {\n    return this.check_;\n  }\n\n  /**\n   * Changes the connection's shadow block.\n   * @param {?Element} shadowDom DOM representation of a block or null.\n   */\n  setShadowDom(shadowDom) {\n    this.setShadowStateInternal_({shadowDom: shadowDom});\n  }\n\n  /**\n   * Returns the xml representation of the connection's shadow block.\n   * @param {boolean=} returnCurrent If true, and the shadow block is currently\n   *     attached to this connection, this serializes the state of that block\n   *     and returns it (so that field values are correct). Otherwise the saved\n   *     shadowDom is just returned.\n   * @return {?Element} Shadow DOM representation of a block or null.\n   */\n  getShadowDom(returnCurrent) {\n    return (returnCurrent && this.targetBlock().isShadow()) ?\n        /** @type {!Element} */ (Xml.blockToDom(\n            /** @type {!Block} */ (this.targetBlock()))) :\n        this.shadowDom_;\n  }\n\n  /**\n   * Changes the connection's shadow block.\n   * @param {?blocks.State} shadowState An state represetation of the block or\n   *     null.\n   */\n  setShadowState(shadowState) {\n    this.setShadowStateInternal_({shadowState: shadowState});\n  }\n\n  /**\n   * Returns the serialized object representation of the connection's shadow\n   * block.\n   * @param {boolean=} returnCurrent If true, and the shadow block is currently\n   *     attached to this connection, this serializes the state of that block\n   *     and returns it (so that field values are correct). Otherwise the saved\n   *     state is just returned.\n   * @return {?blocks.State} Serialized object representation of the block, or\n   *     null.\n   */\n  getShadowState(returnCurrent) {\n    if (returnCurrent && this.targetBlock() && this.targetBlock().isShadow()) {\n      return blocks.save(/** @type {!Block} */ (this.targetBlock()));\n    }\n    return this.shadowState_;\n  }\n\n  /**\n   * Find all nearby compatible connections to this connection.\n   * Type checking does not apply, since this function is used for bumping.\n   *\n   * Headless configurations (the default) do not have neighboring connection,\n   * and always return an empty list (the default).\n   * {@link Blockly.RenderedConnection} overrides this behavior with a list\n   * computed from the rendered positioning.\n   * @param {number} _maxLimit The maximum radius to another connection.\n   * @return {!Array<!Connection>} List of connections.\n   * @package\n   */\n  neighbours(_maxLimit) {\n    return [];\n  }\n\n  /**\n   * Get the parent input of a connection.\n   * @return {?Input} The input that the connection belongs to or null if\n   *     no parent exists.\n   * @package\n   */\n  getParentInput() {\n    let parentInput = null;\n    const inputs = this.sourceBlock_.inputList;\n    for (let i = 0; i < inputs.length; i++) {\n      if (inputs[i].connection === this) {\n        parentInput = inputs[i];\n        break;\n      }\n    }\n    return parentInput;\n  }\n\n  /**\n   * This method returns a string describing this Connection in developer terms\n   * (English only). Intended to on be used in console logs and errors.\n   * @return {string} The description.\n   */\n  toString() {\n    const block = this.sourceBlock_;\n    if (!block) {\n      return 'Orphan Connection';\n    }\n    let msg;\n    if (block.outputConnection === this) {\n      msg = 'Output Connection of ';\n    } else if (block.previousConnection === this) {\n      msg = 'Previous Connection of ';\n    } else if (block.nextConnection === this) {\n      msg = 'Next Connection of ';\n    } else {\n      let parentInput = null;\n      for (let i = 0, input; (input = block.inputList[i]); i++) {\n        if (input.connection === this) {\n          parentInput = input;\n          break;\n        }\n      }\n      if (parentInput) {\n        msg = 'Input \"' + parentInput.name + '\" connection on ';\n      } else {\n        console.warn('Connection not actually connected to sourceBlock_');\n        return 'Orphan Connection';\n      }\n    }\n    return msg + block.toDevString();\n  }\n\n  /**\n   * Returns the state of the shadowDom_ and shadowState_ properties, then\n   * temporarily sets those properties to null so no shadow respawns.\n   * @return {{shadowDom: ?Element, shadowState: ?blocks.State}} The state of\n   *     both the shadowDom_ and shadowState_ properties.\n   * @private\n   */\n  stashShadowState_() {\n    const shadowDom = this.getShadowDom(true);\n    const shadowState = this.getShadowState(true);\n    // Set to null so it doesn't respawn.\n    this.shadowDom_ = null;\n    this.shadowState_ = null;\n    return {shadowDom, shadowState};\n  }\n\n  /**\n   * Reapplies the stashed state of the shadowDom_ and shadowState_ properties.\n   * @param {{shadowDom: ?Element, shadowState: ?blocks.State}} param0 The state\n   *     to reapply to the shadowDom_ and shadowState_ properties.\n   * @private\n   */\n  applyShadowState_({shadowDom, shadowState}) {\n    this.shadowDom_ = shadowDom;\n    this.shadowState_ = shadowState;\n  }\n\n  /**\n   * Sets the state of the shadow of this connection.\n   * @param {{shadowDom: (?Element|undefined), shadowState:\n   *     (?blocks.State|undefined)}=} param0 The state to set the shadow of this\n   *     connection to.\n   * @private\n   */\n  setShadowStateInternal_({shadowDom = null, shadowState = null} = {}) {\n    // One or both of these should always be null.\n    // If neither is null, the shadowState will get priority.\n    this.shadowDom_ = shadowDom;\n    this.shadowState_ = shadowState;\n\n    const target = this.targetBlock();\n    if (!target) {\n      this.respawnShadow_();\n      if (this.targetBlock() && this.targetBlock().isShadow()) {\n        this.serializeShadow_(this.targetBlock());\n      }\n    } else if (target.isShadow()) {\n      target.dispose(false);\n      this.respawnShadow_();\n      if (this.targetBlock() && this.targetBlock().isShadow()) {\n        this.serializeShadow_(this.targetBlock());\n      }\n    } else {\n      const shadow = this.createShadowBlock_(false);\n      this.serializeShadow_(shadow);\n      if (shadow) {\n        shadow.dispose(false);\n      }\n    }\n  }\n\n  /**\n   * Creates a shadow block based on the current shadowState_ or shadowDom_.\n   * shadowState_ gets priority.\n   * @param {boolean} attemptToConnect Whether to try to connect the shadow\n   *     block to this connection or not.\n   * @return {?Block} The shadow block that was created, or null if both the\n   *     shadowState_ and shadowDom_ are null.\n   * @private\n   */\n  createShadowBlock_(attemptToConnect) {\n    const parentBlock = this.getSourceBlock();\n    const shadowState = this.getShadowState();\n    const shadowDom = this.getShadowDom();\n    if (!parentBlock.workspace || (!shadowState && !shadowDom)) {\n      return null;\n    }\n\n    let blockShadow;\n    if (shadowState) {\n      blockShadow = blocks.appendInternal(shadowState, parentBlock.workspace, {\n        parentConnection: attemptToConnect ? this : undefined,\n        isShadow: true,\n        recordUndo: false,\n      });\n      return blockShadow;\n    }\n\n    if (shadowDom) {\n      blockShadow = Xml.domToBlock(shadowDom, parentBlock.workspace);\n      if (attemptToConnect) {\n        if (this.type === ConnectionType.INPUT_VALUE) {\n          if (!blockShadow.outputConnection) {\n            throw new Error('Shadow block is missing an output connection');\n          }\n          if (!this.connect(blockShadow.outputConnection)) {\n            throw new Error('Could not connect shadow block to connection');\n          }\n        } else if (this.type === ConnectionType.NEXT_STATEMENT) {\n          if (!blockShadow.previousConnection) {\n            throw new Error('Shadow block is missing previous connection');\n          }\n          if (!this.connect(blockShadow.previousConnection)) {\n            throw new Error('Could not connect shadow block to connection');\n          }\n        } else {\n          throw new Error(\n              'Cannot connect a shadow block to a previous/output connection');\n        }\n      }\n      return blockShadow;\n    }\n    return null;\n  }\n\n  /**\n   * Saves the given shadow block to both the shadowDom_ and shadowState_\n   * properties, in their respective serialized forms.\n   * @param {?Block} shadow The shadow to serialize, or null.\n   * @private\n   */\n  serializeShadow_(shadow) {\n    if (!shadow) {\n      return;\n    }\n    this.shadowDom_ = /** @type {!Element} */ (Xml.blockToDom(shadow));\n    this.shadowState_ = blocks.save(shadow);\n  }\n\n  /**\n   * Returns the connection (starting at the startBlock) which will accept\n   * the given connection. This includes compatible connection types and\n   * connection checks.\n   * @param {!Block} startBlock The block on which to start the search.\n   * @param {!Connection} orphanConnection The connection that is looking\n   *     for a home.\n   * @return {?Connection} The suitable connection point on the chain of\n   *     blocks, or null.\n   */\n  static getConnectionForOrphanedConnection(startBlock, orphanConnection) {\n    if (orphanConnection.type === ConnectionType.OUTPUT_VALUE) {\n      return getConnectionForOrphanedOutput(\n          startBlock, orphanConnection.getSourceBlock());\n    }\n    // Otherwise we're dealing with a stack.\n    const connection = startBlock.lastConnectionInStack(true);\n    const checker = orphanConnection.getConnectionChecker();\n    if (connection && checker.canConnect(orphanConnection, connection, false)) {\n      return connection;\n    }\n    return null;\n  }\n}\n\n/**\n * Constants for checking whether two connections are compatible.\n */\nConnection.CAN_CONNECT = 0;\nConnection.REASON_SELF_CONNECTION = 1;\nConnection.REASON_WRONG_TYPE = 2;\nConnection.REASON_TARGET_NULL = 3;\nConnection.REASON_CHECKS_FAILED = 4;\nConnection.REASON_DIFFERENT_WORKSPACES = 5;\nConnection.REASON_SHADOW_PARENT = 6;\nConnection.REASON_DRAG_CHECKS_FAILED = 7;\nConnection.REASON_PREVIOUS_AND_OUTPUT = 8;\n\n/**\n * Update two connections to target each other.\n * @param {Connection} first The first connection to update.\n * @param {Connection} second The second connection to update.\n */\nconst connectReciprocally = function(first, second) {\n  if (!first || !second) {\n    throw Error('Cannot connect null connections.');\n  }\n  first.targetConnection = second;\n  second.targetConnection = first;\n};\n\n/**\n * Returns the single connection on the block that will accept the orphaned\n * block, if one can be found. If the block has multiple compatible connections\n * (even if they are filled) this returns null. If the block has no compatible\n * connections, this returns null.\n * @param {!Block} block The superior block.\n * @param {!Block} orphanBlock The inferior block.\n * @return {?Connection} The suitable connection point on 'block',\n *     or null.\n */\nconst getSingleConnection = function(block, orphanBlock) {\n  let foundConnection = null;\n  const output = orphanBlock.outputConnection;\n  const typeChecker = output.getConnectionChecker();\n\n  for (let i = 0, input; (input = block.inputList[i]); i++) {\n    const connection = input.connection;\n    if (connection && typeChecker.canConnect(output, connection, false)) {\n      if (foundConnection) {\n        return null;  // More than one connection.\n      }\n      foundConnection = connection;\n    }\n  }\n  return foundConnection;\n};\n\n/**\n * Walks down a row a blocks, at each stage checking if there are any\n * connections that will accept the orphaned block.  If at any point there\n * are zero or multiple eligible connections, returns null.  Otherwise\n * returns the only input on the last block in the chain.\n * Terminates early for shadow blocks.\n * @param {!Block} startBlock The block on which to start the search.\n * @param {!Block} orphanBlock The block that is looking for a home.\n * @return {?Connection} The suitable connection point on the chain\n *     of blocks, or null.\n */\nconst getConnectionForOrphanedOutput = function(startBlock, orphanBlock) {\n  let newBlock = startBlock;\n  let connection;\n  while (\n      (connection = getSingleConnection(\n           /** @type {!Block} */ (newBlock), orphanBlock))) {\n    newBlock = connection.targetBlock();\n    if (!newBlock || newBlock.isShadow()) {\n      return connection;\n    }\n  }\n  return null;\n};\n\nexports.Connection = Connection;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/connection.js?")},
"./core/connection_checker.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/internal_constants.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/connection_type.js\");\n__webpack_require__(\"./core/connection.js\");\n__webpack_require__(\"./core/interfaces/i_connection_checker.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview An object that encapsulates logic for checking whether a\n * potential connection is safe and valid.\n */\n\n\n/**\n * An object that encapsulates logic for checking whether a\n * potential connection is safe and valid.\n * @class\n */\ngoog.module('Blockly.ConnectionChecker');\n\nconst common = goog.require('Blockly.common');\nconst internalConstants = goog.require('Blockly.internalConstants');\nconst registry = goog.require('Blockly.registry');\nconst {ConnectionType} = goog.require('Blockly.ConnectionType');\nconst {Connection} = goog.require('Blockly.Connection');\n/* eslint-disable-next-line no-unused-vars */\nconst {IConnectionChecker} = goog.require('Blockly.IConnectionChecker');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderedConnection} = goog.requireType('Blockly.RenderedConnection');\n\n\n/**\n * Class for connection type checking logic.\n * @implements {IConnectionChecker}\n * @alias Blockly.ConnectionChecker\n */\nclass ConnectionChecker {\n  /**\n   * Check whether the current connection can connect with the target\n   * connection.\n   * @param {Connection} a Connection to check compatibility with.\n   * @param {Connection} b Connection to check compatibility with.\n   * @param {boolean} isDragging True if the connection is being made by\n   *     dragging a block.\n   * @param {number=} opt_distance The max allowable distance between the\n   *     connections for drag checks.\n   * @return {boolean} Whether the connection is legal.\n   * @public\n   */\n  canConnect(a, b, isDragging, opt_distance) {\n    return this.canConnectWithReason(a, b, isDragging, opt_distance) ===\n        Connection.CAN_CONNECT;\n  }\n\n  /**\n   * Checks whether the current connection can connect with the target\n   * connection, and return an error code if there are problems.\n   * @param {Connection} a Connection to check compatibility with.\n   * @param {Connection} b Connection to check compatibility with.\n   * @param {boolean} isDragging True if the connection is being made by\n   *     dragging a block.\n   * @param {number=} opt_distance The max allowable distance between the\n   *     connections for drag checks.\n   * @return {number} Connection.CAN_CONNECT if the connection is legal,\n   *    an error code otherwise.\n   * @public\n   */\n  canConnectWithReason(a, b, isDragging, opt_distance) {\n    const safety = this.doSafetyChecks(a, b);\n    if (safety !== Connection.CAN_CONNECT) {\n      return safety;\n    }\n\n    // If the safety checks passed, both connections are non-null.\n    const connOne = /** @type {!Connection} **/ (a);\n    const connTwo = /** @type {!Connection} **/ (b);\n    if (!this.doTypeChecks(connOne, connTwo)) {\n      return Connection.REASON_CHECKS_FAILED;\n    }\n\n    if (isDragging &&\n        !this.doDragChecks(\n            /** @type {!RenderedConnection} **/ (a),\n            /** @type {!RenderedConnection} **/ (b), opt_distance || 0)) {\n      return Connection.REASON_DRAG_CHECKS_FAILED;\n    }\n\n    return Connection.CAN_CONNECT;\n  }\n\n  /**\n   * Helper method that translates a connection error code into a string.\n   * @param {number} errorCode The error code.\n   * @param {Connection} a One of the two connections being checked.\n   * @param {Connection} b The second of the two connections being\n   *     checked.\n   * @return {string} A developer-readable error string.\n   * @public\n   */\n  getErrorMessage(errorCode, a, b) {\n    switch (errorCode) {\n      case Connection.REASON_SELF_CONNECTION:\n        return 'Attempted to connect a block to itself.';\n      case Connection.REASON_DIFFERENT_WORKSPACES:\n        // Usually this means one block has been deleted.\n        return 'Blocks not on same workspace.';\n      case Connection.REASON_WRONG_TYPE:\n        return 'Attempt to connect incompatible types.';\n      case Connection.REASON_TARGET_NULL:\n        return 'Target connection is null.';\n      case Connection.REASON_CHECKS_FAILED: {\n        const connOne = /** @type {!Connection} **/ (a);\n        const connTwo = /** @type {!Connection} **/ (b);\n        let msg = 'Connection checks failed. ';\n        msg += connOne + ' expected ' + connOne.getCheck() + ', found ' +\n            connTwo.getCheck();\n        return msg;\n      }\n      case Connection.REASON_SHADOW_PARENT:\n        return 'Connecting non-shadow to shadow block.';\n      case Connection.REASON_DRAG_CHECKS_FAILED:\n        return 'Drag checks failed.';\n      case Connection.REASON_PREVIOUS_AND_OUTPUT:\n        return 'Block would have an output and a previous connection.';\n      default:\n        return 'Unknown connection failure: this should never happen!';\n    }\n  }\n\n  /**\n   * Check that connecting the given connections is safe, meaning that it would\n   * not break any of Blockly's basic assumptions (e.g. no self connections).\n   * @param {Connection} a The first of the connections to check.\n   * @param {Connection} b The second of the connections to check.\n   * @return {number} An enum with the reason this connection is safe or unsafe.\n   * @public\n   */\n  doSafetyChecks(a, b) {\n    if (!a || !b) {\n      return Connection.REASON_TARGET_NULL;\n    }\n    let superiorBlock;\n    let inferiorBlock;\n    let superiorConnection;\n    let inferiorConnection;\n    if (a.isSuperior()) {\n      superiorBlock = a.getSourceBlock();\n      inferiorBlock = b.getSourceBlock();\n      superiorConnection = a;\n      inferiorConnection = b;\n    } else {\n      inferiorBlock = a.getSourceBlock();\n      superiorBlock = b.getSourceBlock();\n      inferiorConnection = a;\n      superiorConnection = b;\n    }\n    if (superiorBlock === inferiorBlock) {\n      return Connection.REASON_SELF_CONNECTION;\n    } else if (\n        inferiorConnection.type !==\n        internalConstants.OPPOSITE_TYPE[superiorConnection.type]) {\n      return Connection.REASON_WRONG_TYPE;\n    } else if (superiorBlock.workspace !== inferiorBlock.workspace) {\n      return Connection.REASON_DIFFERENT_WORKSPACES;\n    } else if (superiorBlock.isShadow() && !inferiorBlock.isShadow()) {\n      return Connection.REASON_SHADOW_PARENT;\n    } else if (\n        inferiorConnection.type === ConnectionType.OUTPUT_VALUE &&\n        inferiorBlock.previousConnection &&\n        inferiorBlock.previousConnection.isConnected()) {\n      return Connection.REASON_PREVIOUS_AND_OUTPUT;\n    } else if (\n        inferiorConnection.type === ConnectionType.PREVIOUS_STATEMENT &&\n        inferiorBlock.outputConnection &&\n        inferiorBlock.outputConnection.isConnected()) {\n      return Connection.REASON_PREVIOUS_AND_OUTPUT;\n    }\n    return Connection.CAN_CONNECT;\n  }\n\n  /**\n   * Check whether this connection is compatible with another connection with\n   * respect to the value type system.  E.g. square_root(\"Hello\") is not\n   * compatible.\n   * @param {!Connection} a Connection to compare.\n   * @param {!Connection} b Connection to compare against.\n   * @return {boolean} True if the connections share a type.\n   * @public\n   */\n  doTypeChecks(a, b) {\n    const checkArrayOne = a.getCheck();\n    const checkArrayTwo = b.getCheck();\n\n    if (!checkArrayOne || !checkArrayTwo) {\n      // One or both sides are promiscuous enough that anything will fit.\n      return true;\n    }\n    // Find any intersection in the check lists.\n    for (let i = 0; i < checkArrayOne.length; i++) {\n      if (checkArrayTwo.indexOf(checkArrayOne[i]) !== -1) {\n        return true;\n      }\n    }\n    // No intersection.\n    return false;\n  }\n\n  /**\n   * Check whether this connection can be made by dragging.\n   * @param {!RenderedConnection} a Connection to compare.\n   * @param {!RenderedConnection} b Connection to compare against.\n   * @param {number} distance The maximum allowable distance between\n   *     connections.\n   * @return {boolean} True if the connection is allowed during a drag.\n   * @public\n   */\n  doDragChecks(a, b, distance) {\n    if (a.distanceFrom(b) > distance) {\n      return false;\n    }\n\n    // Don't consider insertion markers.\n    if (b.getSourceBlock().isInsertionMarker()) {\n      return false;\n    }\n\n    switch (b.type) {\n      case ConnectionType.PREVIOUS_STATEMENT:\n        return this.canConnectToPrevious_(a, b);\n      case ConnectionType.OUTPUT_VALUE: {\n        // Don't offer to connect an already connected left (male) value plug to\n        // an available right (female) value plug.\n        if ((b.isConnected() && !b.targetBlock().isInsertionMarker()) ||\n            a.isConnected()) {\n          return false;\n        }\n        break;\n      }\n      case ConnectionType.INPUT_VALUE: {\n        // Offering to connect the left (male) of a value block to an already\n        // connected value pair is ok, we'll splice it in.\n        // However, don't offer to splice into an immovable block.\n        if (b.isConnected() && !b.targetBlock().isMovable() &&\n            !b.targetBlock().isShadow()) {\n          return false;\n        }\n        break;\n      }\n      case ConnectionType.NEXT_STATEMENT: {\n        // Don't let a block with no next connection bump other blocks out of\n        // the stack.  But covering up a shadow block or stack of shadow blocks\n        // is fine.  Similarly, replacing a terminal statement with another\n        // terminal statement is allowed.\n        if (b.isConnected() && !a.getSourceBlock().nextConnection &&\n            !b.targetBlock().isShadow() && b.targetBlock().nextConnection) {\n          return false;\n        }\n        break;\n      }\n      default:\n        // Unexpected connection type.\n        return false;\n    }\n\n    // Don't let blocks try to connect to themselves or ones they nest.\n    if (common.draggingConnections.indexOf(b) !== -1) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Helper function for drag checking.\n   * @param {!Connection} a The connection to check, which must be a\n   *     statement input or next connection.\n   * @param {!Connection} b A nearby connection to check, which\n   *     must be a previous connection.\n   * @return {boolean} True if the connection is allowed, false otherwise.\n   * @protected\n   */\n  canConnectToPrevious_(a, b) {\n    if (a.targetConnection) {\n      // This connection is already occupied.\n      // A next connection will never disconnect itself mid-drag.\n      return false;\n    }\n\n    // Don't let blocks try to connect to themselves or ones they nest.\n    if (common.draggingConnections.indexOf(b) !== -1) {\n      return false;\n    }\n\n    if (!b.targetConnection) {\n      return true;\n    }\n\n    const targetBlock = b.targetBlock();\n    // If it is connected to a real block, game over.\n    if (!targetBlock.isInsertionMarker()) {\n      return false;\n    }\n    // If it's connected to an insertion marker but that insertion marker\n    // is the first block in a stack, it's still fine.  If that insertion\n    // marker is in the middle of a stack, it won't work.\n    return !targetBlock.getPreviousBlock();\n  }\n}\n\nregistry.register(\n    registry.Type.CONNECTION_CHECKER, registry.DEFAULT, ConnectionChecker);\n\nexports.ConnectionChecker = ConnectionChecker;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/connection_checker.js?")},
"./core/connection_db.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/connection_type.js\");\n__webpack_require__(\"./core/constants.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2011 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A database of all the rendered connections that could\n *    possibly be connected to (i.e. not collapsed, etc).\n *    Sorted by y coordinate.\n */\n\n\n/**\n * A database of all the rendered connections that could\n *    possibly be connected to (i.e. not collapsed, etc).\n *    Sorted by y coordinate.\n * @class\n */\ngoog.module('Blockly.ConnectionDB');\n\nconst {ConnectionType} = goog.require('Blockly.ConnectionType');\n/* eslint-disable-next-line no-unused-vars */\nconst {Coordinate} = goog.requireType('Blockly.utils.Coordinate');\n/* eslint-disable-next-line no-unused-vars */\nconst {IConnectionChecker} = goog.requireType('Blockly.IConnectionChecker');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderedConnection} = goog.requireType('Blockly.RenderedConnection');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.constants');\n\n\n/**\n * Database of connections.\n * Connections are stored in order of their vertical component.  This way\n * connections in an area may be looked up quickly using a binary search.\n * @alias Blockly.ConnectionDB\n */\nclass ConnectionDB {\n  /**\n   * @param {!IConnectionChecker} checker The workspace's\n   *     connection type checker, used to decide if connections are valid during\n   * a drag.\n   */\n  constructor(checker) {\n    /**\n     * Array of connections sorted by y position in workspace units.\n     * @type {!Array<!RenderedConnection>}\n     * @private\n     */\n    this.connections_ = [];\n    /**\n     * The workspace's connection type checker, used to decide if connections\n     * are valid during a drag.\n     * @type {!IConnectionChecker}\n     * @private\n     */\n    this.connectionChecker_ = checker;\n  }\n\n  /**\n   * Add a connection to the database. Should not already exist in the database.\n   * @param {!RenderedConnection} connection The connection to be added.\n   * @param {number} yPos The y position used to decide where to insert the\n   *    connection.\n   * @package\n   */\n  addConnection(connection, yPos) {\n    const index = this.calculateIndexForYPos_(yPos);\n    this.connections_.splice(index, 0, connection);\n  }\n\n  /**\n   * Finds the index of the given connection.\n   *\n   * Starts by doing a binary search to find the approximate location, then\n   * linearly searches nearby for the exact connection.\n   * @param {!RenderedConnection} conn The connection to find.\n   * @param {number} yPos The y position used to find the index of the\n   *     connection.\n   * @return {number} The index of the connection, or -1 if the connection was\n   *     not found.\n   * @private\n   */\n  findIndexOfConnection_(conn, yPos) {\n    if (!this.connections_.length) {\n      return -1;\n    }\n\n    const bestGuess = this.calculateIndexForYPos_(yPos);\n    if (bestGuess >= this.connections_.length) {\n      // Not in list\n      return -1;\n    }\n\n    yPos = conn.y;\n    // Walk forward and back on the y axis looking for the connection.\n    let pointer = bestGuess;\n    while (pointer >= 0 && this.connections_[pointer].y === yPos) {\n      if (this.connections_[pointer] === conn) {\n        return pointer;\n      }\n      pointer--;\n    }\n\n    pointer = bestGuess;\n    while (pointer < this.connections_.length &&\n           this.connections_[pointer].y === yPos) {\n      if (this.connections_[pointer] === conn) {\n        return pointer;\n      }\n      pointer++;\n    }\n    return -1;\n  }\n\n  /**\n   * Finds the correct index for the given y position.\n   * @param {number} yPos The y position used to decide where to\n   *    insert the connection.\n   * @return {number} The candidate index.\n   * @private\n   */\n  calculateIndexForYPos_(yPos) {\n    if (!this.connections_.length) {\n      return 0;\n    }\n    let pointerMin = 0;\n    let pointerMax = this.connections_.length;\n    while (pointerMin < pointerMax) {\n      const pointerMid = Math.floor((pointerMin + pointerMax) / 2);\n      if (this.connections_[pointerMid].y < yPos) {\n        pointerMin = pointerMid + 1;\n      } else if (this.connections_[pointerMid].y > yPos) {\n        pointerMax = pointerMid;\n      } else {\n        pointerMin = pointerMid;\n        break;\n      }\n    }\n    return pointerMin;\n  }\n\n  /**\n   * Remove a connection from the database.  Must already exist in DB.\n   * @param {!RenderedConnection} connection The connection to be removed.\n   * @param {number} yPos The y position used to find the index of the\n   *     connection.\n   * @throws {Error} If the connection cannot be found in the database.\n   */\n  removeConnection(connection, yPos) {\n    const index = this.findIndexOfConnection_(connection, yPos);\n    if (index === -1) {\n      throw Error('Unable to find connection in connectionDB.');\n    }\n    this.connections_.splice(index, 1);\n  }\n\n  /**\n   * Find all nearby connections to the given connection.\n   * Type checking does not apply, since this function is used for bumping.\n   * @param {!RenderedConnection} connection The connection whose\n   *     neighbours should be returned.\n   * @param {number} maxRadius The maximum radius to another connection.\n   * @return {!Array<!RenderedConnection>} List of connections.\n   */\n  getNeighbours(connection, maxRadius) {\n    const db = this.connections_;\n    const currentX = connection.x;\n    const currentY = connection.y;\n\n    // Binary search to find the closest y location.\n    let pointerMin = 0;\n    let pointerMax = db.length - 2;\n    let pointerMid = pointerMax;\n    while (pointerMin < pointerMid) {\n      if (db[pointerMid].y < currentY) {\n        pointerMin = pointerMid;\n      } else {\n        pointerMax = pointerMid;\n      }\n      pointerMid = Math.floor((pointerMin + pointerMax) / 2);\n    }\n\n    const neighbours = [];\n    /**\n     * Computes if the current connection is within the allowed radius of\n     * another connection. This function is a closure and has access to outside\n     * variables.\n     * @param {number} yIndex The other connection's index in the database.\n     * @return {boolean} True if the current connection's vertical distance from\n     *     the other connection is less than the allowed radius.\n     */\n    function checkConnection_(yIndex) {\n      const dx = currentX - db[yIndex].x;\n      const dy = currentY - db[yIndex].y;\n      const r = Math.sqrt(dx * dx + dy * dy);\n      if (r <= maxRadius) {\n        neighbours.push(db[yIndex]);\n      }\n      return dy < maxRadius;\n    }\n\n    // Walk forward and back on the y axis looking for the closest x,y point.\n    pointerMin = pointerMid;\n    pointerMax = pointerMid;\n    if (db.length) {\n      while (pointerMin >= 0 && checkConnection_(pointerMin)) {\n        pointerMin--;\n      }\n      do {\n        pointerMax++;\n      } while (pointerMax < db.length && checkConnection_(pointerMax));\n    }\n\n    return neighbours;\n  }\n\n  /**\n   * Is the candidate connection close to the reference connection.\n   * Extremely fast; only looks at Y distance.\n   * @param {number} index Index in database of candidate connection.\n   * @param {number} baseY Reference connection's Y value.\n   * @param {number} maxRadius The maximum radius to another connection.\n   * @return {boolean} True if connection is in range.\n   * @private\n   */\n  isInYRange_(index, baseY, maxRadius) {\n    return (Math.abs(this.connections_[index].y - baseY) <= maxRadius);\n  }\n\n  /**\n   * Find the closest compatible connection to this connection.\n   * @param {!RenderedConnection} conn The connection searching for a compatible\n   *     mate.\n   * @param {number} maxRadius The maximum radius to another connection.\n   * @param {!Coordinate} dxy Offset between this connection's\n   *     location in the database and the current location (as a result of\n   *     dragging).\n   * @return {!{connection: RenderedConnection, radius: number}}\n   *     Contains two properties: 'connection' which is either another\n   *     connection or null, and 'radius' which is the distance.\n   */\n  searchForClosest(conn, maxRadius, dxy) {\n    if (!this.connections_.length) {\n      // Don't bother.\n      return {connection: null, radius: maxRadius};\n    }\n\n    // Stash the values of x and y from before the drag.\n    const baseY = conn.y;\n    const baseX = conn.x;\n\n    conn.x = baseX + dxy.x;\n    conn.y = baseY + dxy.y;\n\n    // calculateIndexForYPos_ finds an index for insertion, which is always\n    // after any block with the same y index.  We want to search both forward\n    // and back, so search on both sides of the index.\n    const closestIndex = this.calculateIndexForYPos_(conn.y);\n\n    let bestConnection = null;\n    let bestRadius = maxRadius;\n    let temp;\n\n    // Walk forward and back on the y axis looking for the closest x,y point.\n    let pointerMin = closestIndex - 1;\n    while (pointerMin >= 0 && this.isInYRange_(pointerMin, conn.y, maxRadius)) {\n      temp = this.connections_[pointerMin];\n      if (this.connectionChecker_.canConnect(conn, temp, true, bestRadius)) {\n        bestConnection = temp;\n        bestRadius = temp.distanceFrom(conn);\n      }\n      pointerMin--;\n    }\n\n    let pointerMax = closestIndex;\n    while (pointerMax < this.connections_.length &&\n           this.isInYRange_(pointerMax, conn.y, maxRadius)) {\n      temp = this.connections_[pointerMax];\n      if (this.connectionChecker_.canConnect(conn, temp, true, bestRadius)) {\n        bestConnection = temp;\n        bestRadius = temp.distanceFrom(conn);\n      }\n      pointerMax++;\n    }\n\n    // Reset the values of x and y.\n    conn.x = baseX;\n    conn.y = baseY;\n\n    // If there were no valid connections, bestConnection will be null.\n    return {connection: bestConnection, radius: bestRadius};\n  }\n\n  /**\n   * Initialize a set of connection DBs for a workspace.\n   * @param {!IConnectionChecker} checker The workspace's\n   *     connection checker, used to decide if connections are valid during a\n   *     drag.\n   * @return {!Array<!ConnectionDB>} Array of databases.\n   */\n  static init(checker) {\n    // Create four databases, one for each connection type.\n    const dbList = [];\n    dbList[ConnectionType.INPUT_VALUE] = new ConnectionDB(checker);\n    dbList[ConnectionType.OUTPUT_VALUE] = new ConnectionDB(checker);\n    dbList[ConnectionType.NEXT_STATEMENT] = new ConnectionDB(checker);\n    dbList[ConnectionType.PREVIOUS_STATEMENT] = new ConnectionDB(checker);\n    return dbList;\n  }\n}\n\nexports.ConnectionDB = ConnectionDB;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/connection_db.js?")},
"./core/connection_type.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview An enum for the possible types of connections.\n */\n\n\n\n/**\n * An enum for the possible types of connections.\n * @namespace Blockly.ConnectionType\n */\ngoog.module('Blockly.ConnectionType');\n\n\n/**\n * Enum for the type of a connection or input.\n * @enum {number}\n * @alias Blockly.ConnectionType\n */\nconst ConnectionType = {\n  // A right-facing value input.  E.g. 'set item to' or 'return'.\n  INPUT_VALUE: 1,\n  // A left-facing value output.  E.g. 'random fraction'.\n  OUTPUT_VALUE: 2,\n  // A down-facing block stack.  E.g. 'if-do' or 'else'.\n  NEXT_STATEMENT: 3,\n  // An up-facing block stack.  E.g. 'break out of loop'.\n  PREVIOUS_STATEMENT: 4,\n};\n\nexports.ConnectionType = ConnectionType;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/connection_type.js?")},
"./core/constants.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Blockly constants.\n */\n\n\n/**\n * Blockly constants.\n * @namespace Blockly.constants\n */\ngoog.module('Blockly.constants');\n\n\n/**\n * The language-neutral ID given to the collapsed input.\n * @const {string}\n * @alias Blockly.constants.COLLAPSED_INPUT_NAME\n */\nconst COLLAPSED_INPUT_NAME = '_TEMP_COLLAPSED_INPUT';\nexports.COLLAPSED_INPUT_NAME = COLLAPSED_INPUT_NAME;\n\n/**\n * The language-neutral ID given to the collapsed field.\n * @const {string}\n * @alias Blockly.constants.COLLAPSED_FIELD_NAME\n */\nconst COLLAPSED_FIELD_NAME = '_TEMP_COLLAPSED_FIELD';\nexports.COLLAPSED_FIELD_NAME = COLLAPSED_FIELD_NAME;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/constants.js?")},
"./core/contextmenu.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/widgetdiv.js\");\n__webpack_require__(\"./core/xml.js\");\n__webpack_require__(\"./core/utils/aria.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/clipboard.js\");\n__webpack_require__(\"./core/utils/deprecation.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\n__webpack_require__(\"./core/utils/svg_math.js\");\n__webpack_require__(\"./core/config.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/menuitem.js\");\n__webpack_require__(\"./core/menu.js\");\n__webpack_require__(\"./core/msg.js\");\n__webpack_require__(\"./core/utils/rect.js\");\n__webpack_require__(\"./core/events/events_block_create.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2011 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Functionality for the right-click context menus.\n */\n\n\n/**\n * Functionality for the right-click context menus.\n * @namespace Blockly.ContextMenu\n */\ngoog.module('Blockly.ContextMenu');\n\nconst WidgetDiv = goog.require('Blockly.WidgetDiv');\nconst Xml = goog.require('Blockly.Xml');\nconst aria = goog.require('Blockly.utils.aria');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst clipboard = goog.require('Blockly.clipboard');\nconst deprecation = goog.require('Blockly.utils.deprecation');\nconst dom = goog.require('Blockly.utils.dom');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst userAgent = goog.require('Blockly.utils.userAgent');\nconst svgMath = goog.require('Blockly.utils.svgMath');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {config} = goog.require('Blockly.config');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\nconst {MenuItem} = goog.require('Blockly.MenuItem');\nconst {Menu} = goog.require('Blockly.Menu');\nconst {Msg} = goog.require('Blockly.Msg');\nconst {Rect} = goog.require('Blockly.utils.Rect');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceCommentSvg} = goog.requireType('Blockly.WorkspaceCommentSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockCreate');\n\n\n/**\n * Which block is the context menu attached to?\n * @type {?Block}\n */\nlet currentBlock = null;\n\n/**\n * Gets the block the context menu is currently attached to.\n * @return {?Block} The block the context menu is attached to.\n * @alias Blockly.ContextMenu.getCurrentBlock\n */\nconst getCurrentBlock = function() {\n  return currentBlock;\n};\nexports.getCurrentBlock = getCurrentBlock;\n\n/**\n * Sets the block the context menu is currently attached to.\n * @param {?Block} block The block the context menu is attached to.\n * @alias Blockly.ContextMenu.setCurrentBlock\n */\nconst setCurrentBlock = function(block) {\n  currentBlock = block;\n};\nexports.setCurrentBlock = setCurrentBlock;\n\n// Add JS accessors for backwards compatibility.\nObject.defineProperties(exports, {\n  /**\n   * Which block is the context menu attached to?\n   * @name Blockly.ContextMenu.currentBlock\n   * @type {Block}\n   * @deprecated Use Blockly.Tooltip.getCurrentBlock() /\n   *     .setCurrentBlock() instead.  (September 2021)\n   * @suppress {checkTypes}\n   */\n  currentBlock: {\n    get: function() {\n      deprecation.warn(\n          'Blockly.ContextMenu.currentBlock', 'September 2021',\n          'September 2022', 'Blockly.Tooltip.getCurrentBlock()');\n      return getCurrentBlock();\n    },\n    set: function(block) {\n      deprecation.warn(\n          'Blockly.ContextMenu.currentBlock', 'September 2021',\n          'September 2022', 'Blockly.Tooltip.setCurrentBlock(block)');\n      setCurrentBlock(block);\n    },\n  },\n});\n\n/**\n * Menu object.\n * @type {Menu}\n */\nlet menu_ = null;\n\n/**\n * Construct the menu based on the list of options and show the menu.\n * @param {!Event} e Mouse event.\n * @param {!Array<!Object>} options Array of menu options.\n * @param {boolean} rtl True if RTL, false if LTR.\n * @alias Blockly.ContextMenu.show\n */\nconst show = function(e, options, rtl) {\n  WidgetDiv.show(exports, rtl, dispose);\n  if (!options.length) {\n    hide();\n    return;\n  }\n  const menu = populate_(options, rtl);\n  menu_ = menu;\n\n  position_(menu, e, rtl);\n  // 1ms delay is required for focusing on context menus because some other\n  // mouse event is still waiting in the queue and clears focus.\n  setTimeout(function() {\n    menu.focus();\n  }, 1);\n  currentBlock = null;  // May be set by Blockly.Block.\n};\nexports.show = show;\n\n/**\n * Create the context menu object and populate it with the given options.\n * @param {!Array<!Object>} options Array of menu options.\n * @param {boolean} rtl True if RTL, false if LTR.\n * @return {!Menu} The menu that will be shown on right click.\n * @private\n */\nconst populate_ = function(options, rtl) {\n  /* Here's what one option object looks like:\n    {text: 'Make It So',\n     enabled: true,\n     callback: Blockly.MakeItSo}\n  */\n  const menu = new Menu();\n  menu.setRole(aria.Role.MENU);\n  for (let i = 0; i < options.length; i++) {\n    const option = options[i];\n    const menuItem = new MenuItem(option.text);\n    menuItem.setRightToLeft(rtl);\n    menuItem.setRole(aria.Role.MENUITEM);\n    menu.addChild(menuItem);\n    menuItem.setEnabled(option.enabled);\n    if (option.enabled) {\n      const actionHandler = function(_menuItem) {\n        // TODO: Create a type for option that can be used in an @this tag.\n        /* eslint-disable-next-line no-invalid-this */\n        const option = this;\n        hide();\n        option.callback(option.scope);\n      };\n      menuItem.onAction(actionHandler, option);\n    }\n  }\n  return menu;\n};\n\n/**\n * Add the menu to the page and position it correctly.\n * @param {!Menu} menu The menu to add and position.\n * @param {!Event} e Mouse event for the right click that is making the context\n *     menu appear.\n * @param {boolean} rtl True if RTL, false if LTR.\n * @private\n */\nconst position_ = function(menu, e, rtl) {\n  // Record windowSize and scrollOffset before adding menu.\n  const viewportBBox = svgMath.getViewportBBox();\n  // This one is just a point, but we'll pretend that it's a rect so we can use\n  // some helper functions.\n  const anchorBBox = new Rect(\n      e.clientY + viewportBBox.top, e.clientY + viewportBBox.top,\n      e.clientX + viewportBBox.left, e.clientX + viewportBBox.left);\n\n  createWidget_(menu);\n  const menuSize = menu.getSize();\n\n  if (rtl) {\n    anchorBBox.left += menuSize.width;\n    anchorBBox.right += menuSize.width;\n    viewportBBox.left += menuSize.width;\n    viewportBBox.right += menuSize.width;\n  }\n\n  WidgetDiv.positionWithAnchor(viewportBBox, anchorBBox, menuSize, rtl);\n  // Calling menuDom.focus() has to wait until after the menu has been placed\n  // correctly.  Otherwise it will cause a page scroll to get the misplaced menu\n  // in view.  See issue #1329.\n  menu.focus();\n};\n\n/**\n * Create and render the menu widget inside Blockly's widget div.\n * @param {!Menu} menu The menu to add to the widget div.\n * @private\n */\nconst createWidget_ = function(menu) {\n  const div = WidgetDiv.getDiv();\n  if (!div) {\n    throw Error('Attempting to create a context menu when widget div is null');\n  }\n  menu.render(div);\n  const menuDom = menu.getElement();\n  dom.addClass(\n      /** @type {!Element} */ (menuDom), 'blocklyContextMenu');\n  // Prevent system context menu when right-clicking a Blockly context menu.\n  browserEvents.conditionalBind(\n      /** @type {!EventTarget} */ (menuDom), 'contextmenu', null,\n      haltPropagation);\n  // Focus only after the initial render to avoid issue #1329.\n  menu.focus();\n};\n\n/**\n * Halts the propagation of the event without doing anything else.\n * @param {!Event} e An event.\n */\nconst haltPropagation = function(e) {\n  // This event has been handled.  No need to bubble up to the document.\n  e.preventDefault();\n  e.stopPropagation();\n};\n\n/**\n * Hide the context menu.\n * @alias Blockly.ContextMenu.hide\n */\nconst hide = function() {\n  WidgetDiv.hideIfOwner(exports);\n  currentBlock = null;\n};\nexports.hide = hide;\n\n/**\n * Dispose of the menu.\n * @alias Blockly.ContextMenu.dispose\n */\nconst dispose = function() {\n  if (menu_) {\n    menu_.dispose();\n    menu_ = null;\n  }\n};\nexports.dispose = dispose;\n\n/**\n * Create a callback function that creates and configures a block,\n *   then places the new block next to the original.\n * @param {!Block} block Original block.\n * @param {!Element} xml XML representation of new block.\n * @return {!Function} Function that creates a block.\n * @alias Blockly.ContextMenu.callbackFactory\n */\nconst callbackFactory = function(block, xml) {\n  return function() {\n    eventUtils.disable();\n    let newBlock;\n    try {\n      newBlock =\n          /** @type {!BlockSvg} */ (Xml.domToBlock(xml, block.workspace));\n      // Move the new block next to the old block.\n      const xy = block.getRelativeToSurfaceXY();\n      if (block.RTL) {\n        xy.x -= config.snapRadius;\n      } else {\n        xy.x += config.snapRadius;\n      }\n      xy.y += config.snapRadius * 2;\n      newBlock.moveBy(xy.x, xy.y);\n    } finally {\n      eventUtils.enable();\n    }\n    if (eventUtils.isEnabled() && !newBlock.isShadow()) {\n      eventUtils.fire(new (eventUtils.get(eventUtils.BLOCK_CREATE))(newBlock));\n    }\n    newBlock.select();\n  };\n};\nexports.callbackFactory = callbackFactory;\n\n// Helper functions for creating context menu options.\n\n/**\n * Make a context menu option for deleting the current workspace comment.\n * @param {!WorkspaceCommentSvg} comment The workspace comment where the\n *     right-click originated.\n * @return {!Object} A menu option, containing text, enabled, and a callback.\n * @alias Blockly.ContextMenu.commentDeleteOption\n * @package\n */\nconst commentDeleteOption = function(comment) {\n  const deleteOption = {\n    text: Msg['REMOVE_COMMENT'],\n    enabled: true,\n    callback: function() {\n      eventUtils.setGroup(true);\n      comment.dispose();\n      eventUtils.setGroup(false);\n    },\n  };\n  return deleteOption;\n};\nexports.commentDeleteOption = commentDeleteOption;\n\n/**\n * Make a context menu option for duplicating the current workspace comment.\n * @param {!WorkspaceCommentSvg} comment The workspace comment where the\n *     right-click originated.\n * @return {!Object} A menu option, containing text, enabled, and a callback.\n * @alias Blockly.ContextMenu.commentDuplicateOption\n * @package\n */\nconst commentDuplicateOption = function(comment) {\n  const duplicateOption = {\n    text: Msg['DUPLICATE_COMMENT'],\n    enabled: true,\n    callback: function() {\n      clipboard.duplicate(comment);\n    },\n  };\n  return duplicateOption;\n};\nexports.commentDuplicateOption = commentDuplicateOption;\n\n/**\n * Make a context menu option for adding a comment on the workspace.\n * @param {!WorkspaceSvg} ws The workspace where the right-click\n *     originated.\n * @param {!Event} e The right-click mouse event.\n * @return {!Object} A menu option, containing text, enabled, and a callback.\n * @package\n * @suppress {strictModuleDepCheck,checkTypes} Suppress checks while workspace\n *     comments are not bundled in.\n * @alias Blockly.ContextMenu.workspaceCommentOption\n */\nconst workspaceCommentOption = function(ws, e) {\n  const {WorkspaceCommentSvg} = goog.module.get('Blockly.WorkspaceCommentSvg');\n  if (!WorkspaceCommentSvg) {\n    throw Error('Missing require for Blockly.WorkspaceCommentSvg');\n  }\n  // Helper function to create and position a comment correctly based on the\n  // location of the mouse event.\n  const addWsComment = function() {\n    const comment = new WorkspaceCommentSvg(\n        ws, Msg['WORKSPACE_COMMENT_DEFAULT_TEXT'],\n        WorkspaceCommentSvg.DEFAULT_SIZE, WorkspaceCommentSvg.DEFAULT_SIZE);\n\n    const injectionDiv = ws.getInjectionDiv();\n    // Bounding rect coordinates are in client coordinates, meaning that they\n    // are in pixels relative to the upper left corner of the visible browser\n    // window.  These coordinates change when you scroll the browser window.\n    const boundingRect = injectionDiv.getBoundingClientRect();\n\n    // The client coordinates offset by the injection div's upper left corner.\n    const clientOffsetPixels = new Coordinate(\n        e.clientX - boundingRect.left, e.clientY - boundingRect.top);\n\n    // The offset in pixels between the main workspace's origin and the upper\n    // left corner of the injection div.\n    const mainOffsetPixels = ws.getOriginOffsetInPixels();\n\n    // The position of the new comment in pixels relative to the origin of the\n    // main workspace.\n    const finalOffset =\n        Coordinate.difference(clientOffsetPixels, mainOffsetPixels);\n    // The position of the new comment in main workspace coordinates.\n    finalOffset.scale(1 / ws.scale);\n\n    const commentX = finalOffset.x;\n    const commentY = finalOffset.y;\n    comment.moveBy(commentX, commentY);\n    if (ws.rendered) {\n      comment.initSvg();\n      comment.render();\n      comment.select();\n    }\n  };\n\n  const wsCommentOption = {\n    // Foreign objects don't work in IE.  Don't let the user create comments\n    // that they won't be able to edit.\n    enabled: !userAgent.IE,\n  };\n  wsCommentOption.text = Msg['ADD_COMMENT'];\n  wsCommentOption.callback = function() {\n    addWsComment();\n  };\n  return wsCommentOption;\n};\nexports.workspaceCommentOption = workspaceCommentOption;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/contextmenu.js?")},
"./core/contextmenu_items.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/events.js\");\n__webpack_require__(\"./core/clipboard.js\");\n__webpack_require__(\"./core/dialog.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/utils/idgenerator.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\n__webpack_require__(\"./core/contextmenu_registry.js\");\n__webpack_require__(\"./core/msg.js\");\n__webpack_require__(\"./core/input_types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Registers default context menu items.\n */\n\n\n/**\n * Registers default context menu items.\n * @namespace Blockly.ContextMenuItems\n */\ngoog.module('Blockly.ContextMenuItems');\n\nconst Events = goog.require('Blockly.Events');\nconst clipboard = goog.require('Blockly.clipboard');\nconst dialog = goog.require('Blockly.dialog');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst idGenerator = goog.require('Blockly.utils.idGenerator');\nconst userAgent = goog.require('Blockly.utils.userAgent');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {ContextMenuRegistry} = goog.require('Blockly.ContextMenuRegistry');\nconst {Msg} = goog.require('Blockly.Msg');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\nconst {inputTypes} = goog.require('Blockly.inputTypes');\n\n\n/**\n * Option to undo previous action.\n * @alias Blockly.ContextMenuItems.registerUndo\n */\nconst registerUndo = function() {\n  /** @type {!ContextMenuRegistry.RegistryItem} */\n  const undoOption = {\n    displayText: function() {\n      return Msg['UNDO'];\n    },\n    preconditionFn: function(/** @type {!ContextMenuRegistry.Scope} */\n                             scope) {\n      if (scope.workspace.getUndoStack().length > 0) {\n        return 'enabled';\n      }\n      return 'disabled';\n    },\n    callback: function(/** @type {!ContextMenuRegistry.Scope} */\n                       scope) {\n      scope.workspace.undo(false);\n    },\n    scopeType: ContextMenuRegistry.ScopeType.WORKSPACE,\n    id: 'undoWorkspace',\n    weight: 1,\n  };\n  ContextMenuRegistry.registry.register(undoOption);\n};\nexports.registerUndo = registerUndo;\n\n/**\n * Option to redo previous action.\n * @alias Blockly.ContextMenuItems.registerRedo\n */\nconst registerRedo = function() {\n  /** @type {!ContextMenuRegistry.RegistryItem} */\n  const redoOption = {\n    displayText: function() {\n      return Msg['REDO'];\n    },\n    preconditionFn: function(/** @type {!ContextMenuRegistry.Scope} */\n                             scope) {\n      if (scope.workspace.getRedoStack().length > 0) {\n        return 'enabled';\n      }\n      return 'disabled';\n    },\n    callback: function(/** @type {!ContextMenuRegistry.Scope} */\n                       scope) {\n      scope.workspace.undo(true);\n    },\n    scopeType: ContextMenuRegistry.ScopeType.WORKSPACE,\n    id: 'redoWorkspace',\n    weight: 2,\n  };\n  ContextMenuRegistry.registry.register(redoOption);\n};\nexports.registerRedo = registerRedo;\n\n/**\n * Option to clean up blocks.\n * @alias Blockly.ContextMenuItems.registerCleanup\n */\nconst registerCleanup = function() {\n  /** @type {!ContextMenuRegistry.RegistryItem} */\n  const cleanOption = {\n    displayText: function() {\n      return Msg['CLEAN_UP'];\n    },\n    preconditionFn: function(/** @type {!ContextMenuRegistry.Scope} */\n                             scope) {\n      if (scope.workspace.isMovable()) {\n        if (scope.workspace.getTopBlocks(false).length > 1) {\n          return 'enabled';\n        }\n        return 'disabled';\n      }\n      return 'hidden';\n    },\n    callback: function(/** @type {!ContextMenuRegistry.Scope} */\n                       scope) {\n      scope.workspace.cleanUp();\n    },\n    scopeType: ContextMenuRegistry.ScopeType.WORKSPACE,\n    id: 'cleanWorkspace',\n    weight: 3,\n  };\n  ContextMenuRegistry.registry.register(cleanOption);\n};\nexports.registerCleanup = registerCleanup;\n\n/**\n * Creates a callback to collapse or expand top blocks.\n * @param {boolean} shouldCollapse Whether a block should collapse.\n * @param {!Array<BlockSvg>} topBlocks Top blocks in the workspace.\n * @private\n */\nconst toggleOption_ = function(shouldCollapse, topBlocks) {\n  const DELAY = 10;\n  let ms = 0;\n  let timeoutCounter = 0;\n  const timeoutFn = function(block) {\n    timeoutCounter--;\n    block.setCollapsed(shouldCollapse);\n    if (timeoutCounter === 0) {\n      Events.setGroup(false);\n    }\n  };\n  Events.setGroup(true);\n  for (let i = 0; i < topBlocks.length; i++) {\n    let block = topBlocks[i];\n    while (block) {\n      timeoutCounter++;\n      setTimeout(timeoutFn.bind(null, block), ms);\n      block = block.getNextBlock();\n      ms += DELAY;\n    }\n  }\n};\n\n/**\n * Option to collapse all blocks.\n * @alias Blockly.ContextMenuItems.registerCollapse\n */\nconst registerCollapse = function() {\n  /** @type {!ContextMenuRegistry.RegistryItem} */\n  const collapseOption = {\n    displayText: function() {\n      return Msg['COLLAPSE_ALL'];\n    },\n    preconditionFn: function(/** @type {!ContextMenuRegistry.Scope} */\n                             scope) {\n      if (scope.workspace.options.collapse) {\n        const topBlocks = scope.workspace.getTopBlocks(false);\n        for (let i = 0; i < topBlocks.length; i++) {\n          let block = topBlocks[i];\n          while (block) {\n            if (!block.isCollapsed()) {\n              return 'enabled';\n            }\n            block = block.getNextBlock();\n          }\n        }\n        return 'disabled';\n      }\n      return 'hidden';\n    },\n    callback: function(/** @type {!ContextMenuRegistry.Scope} */\n                       scope) {\n      toggleOption_(true, scope.workspace.getTopBlocks(true));\n    },\n    scopeType: ContextMenuRegistry.ScopeType.WORKSPACE,\n    id: 'collapseWorkspace',\n    weight: 4,\n  };\n  ContextMenuRegistry.registry.register(collapseOption);\n};\nexports.registerCollapse = registerCollapse;\n\n/**\n * Option to expand all blocks.\n * @alias Blockly.ContextMenuItems.registerExpand\n */\nconst registerExpand = function() {\n  /** @type {!ContextMenuRegistry.RegistryItem} */\n  const expandOption = {\n    displayText: function() {\n      return Msg['EXPAND_ALL'];\n    },\n    preconditionFn: function(/** @type {!ContextMenuRegistry.Scope} */\n                             scope) {\n      if (scope.workspace.options.collapse) {\n        const topBlocks = scope.workspace.getTopBlocks(false);\n        for (let i = 0; i < topBlocks.length; i++) {\n          let block = topBlocks[i];\n          while (block) {\n            if (block.isCollapsed()) {\n              return 'enabled';\n            }\n            block = block.getNextBlock();\n          }\n        }\n        return 'disabled';\n      }\n      return 'hidden';\n    },\n    callback: function(/** @type {!ContextMenuRegistry.Scope} */\n                       scope) {\n      toggleOption_(false, scope.workspace.getTopBlocks(true));\n    },\n    scopeType: ContextMenuRegistry.ScopeType.WORKSPACE,\n    id: 'expandWorkspace',\n    weight: 5,\n  };\n  ContextMenuRegistry.registry.register(expandOption);\n};\nexports.registerExpand = registerExpand;\n\n/**\n * Adds a block and its children to a list of deletable blocks.\n * @param {!BlockSvg} block to delete.\n * @param {!Array<!BlockSvg>} deleteList list of blocks that can be deleted.\n *     This will be\n *    modified in place with the given block and its descendants.\n * @private\n */\nconst addDeletableBlocks_ = function(block, deleteList) {\n  if (block.isDeletable()) {\n    Array.prototype.push.apply(deleteList, block.getDescendants(false));\n  } else {\n    const children = block.getChildren(false);\n    for (let i = 0; i < children.length; i++) {\n      addDeletableBlocks_(children[i], deleteList);\n    }\n  }\n};\n\n/**\n * Constructs a list of blocks that can be deleted in the given workspace.\n * @param {!WorkspaceSvg} workspace to delete all blocks from.\n * @return {!Array<!BlockSvg>} list of blocks to delete.\n * @private\n */\nconst getDeletableBlocks_ = function(workspace) {\n  const deleteList = [];\n  const topBlocks = workspace.getTopBlocks(true);\n  for (let i = 0; i < topBlocks.length; i++) {\n    addDeletableBlocks_(topBlocks[i], deleteList);\n  }\n  return deleteList;\n};\n\n/**\n * Deletes the given blocks. Used to delete all blocks in the workspace.\n * @param {!Array<!BlockSvg>} deleteList list of blocks to delete.\n * @param {string} eventGroup event group ID with which all delete events should\n *     be associated.\n * @private\n */\nconst deleteNext_ = function(deleteList, eventGroup) {\n  const DELAY = 10;\n  eventUtils.setGroup(eventGroup);\n  const block = deleteList.shift();\n  if (block) {\n    if (block.workspace) {\n      block.dispose(false, true);\n      setTimeout(deleteNext_, DELAY, deleteList, eventGroup);\n    } else {\n      deleteNext_(deleteList, eventGroup);\n    }\n  }\n  eventUtils.setGroup(false);\n};\n\n/**\n * Option to delete all blocks.\n * @alias Blockly.ContextMenuItems.registerDeleteAll\n */\nconst registerDeleteAll = function() {\n  /** @type {!ContextMenuRegistry.RegistryItem} */\n  const deleteOption = {\n    displayText: function(/** @type {!ContextMenuRegistry.Scope} */\n                          scope) {\n      if (!scope.workspace) {\n        return;\n      }\n      const deletableBlocksLength = getDeletableBlocks_(scope.workspace).length;\n      if (deletableBlocksLength === 1) {\n        return Msg['DELETE_BLOCK'];\n      } else {\n        return Msg['DELETE_X_BLOCKS'].replace(\n            '%1', String(deletableBlocksLength));\n      }\n    },\n    preconditionFn: function(/** @type {!ContextMenuRegistry.Scope} */\n                             scope) {\n      if (!scope.workspace) {\n        return;\n      }\n      const deletableBlocksLength = getDeletableBlocks_(scope.workspace).length;\n      return deletableBlocksLength > 0 ? 'enabled' : 'disabled';\n    },\n    callback: function(/** @type {!ContextMenuRegistry.Scope} */\n                       scope) {\n      if (!scope.workspace) {\n        return;\n      }\n      scope.workspace.cancelCurrentGesture();\n      const deletableBlocks = getDeletableBlocks_(scope.workspace);\n      const eventGroup = idGenerator.genUid();\n      if (deletableBlocks.length < 2) {\n        deleteNext_(deletableBlocks, eventGroup);\n      } else {\n        dialog.confirm(\n            Msg['DELETE_ALL_BLOCKS'].replace(\n                '%1', String(deletableBlocks.length)),\n            function(ok) {\n              if (ok) {\n                deleteNext_(deletableBlocks, eventGroup);\n              }\n            });\n      }\n    },\n    scopeType: ContextMenuRegistry.ScopeType.WORKSPACE,\n    id: 'workspaceDelete',\n    weight: 6,\n  };\n  ContextMenuRegistry.registry.register(deleteOption);\n};\nexports.registerDeleteAll = registerDeleteAll;\n\n/**\n * Registers all workspace-scoped context menu items.\n * @private\n */\nconst registerWorkspaceOptions_ = function() {\n  registerUndo();\n  registerRedo();\n  registerCleanup();\n  registerCollapse();\n  registerExpand();\n  registerDeleteAll();\n};\n\n/**\n * Option to duplicate a block.\n * @alias Blockly.ContextMenuItems.registerDuplicate\n */\nconst registerDuplicate = function() {\n  /** @type {!ContextMenuRegistry.RegistryItem} */\n  const duplicateOption = {\n    displayText: function() {\n      return Msg['DUPLICATE_BLOCK'];\n    },\n    preconditionFn: function(/** @type {!ContextMenuRegistry.Scope} */\n                             scope) {\n      const block = scope.block;\n      if (!block.isInFlyout && block.isDeletable() && block.isMovable()) {\n        if (block.isDuplicatable()) {\n          return 'enabled';\n        }\n        return 'disabled';\n      }\n      return 'hidden';\n    },\n    callback: function(/** @type {!ContextMenuRegistry.Scope} */\n                       scope) {\n      if (scope.block) {\n        clipboard.duplicate(scope.block);\n      }\n    },\n    scopeType: ContextMenuRegistry.ScopeType.BLOCK,\n    id: 'blockDuplicate',\n    weight: 1,\n  };\n  ContextMenuRegistry.registry.register(duplicateOption);\n};\nexports.registerDuplicate = registerDuplicate;\n\n/**\n * Option to add or remove block-level comment.\n * @alias Blockly.ContextMenuItems.registerComment\n */\nconst registerComment = function() {\n  /** @type {!ContextMenuRegistry.RegistryItem} */\n  const commentOption = {\n    displayText: function(/** @type {!ContextMenuRegistry.Scope} */\n                          scope) {\n      if (scope.block.getCommentIcon()) {\n        // If there's already a comment,  option is to remove.\n        return Msg['REMOVE_COMMENT'];\n      }\n      // If there's no comment yet, option is to add.\n      return Msg['ADD_COMMENT'];\n    },\n    preconditionFn: function(/** @type {!ContextMenuRegistry.Scope} */\n                             scope) {\n      const block = scope.block;\n      // IE doesn't support necessary features for comment editing.\n      if (!userAgent.IE && !block.isInFlyout &&\n          block.workspace.options.comments && !block.isCollapsed() &&\n          block.isEditable()) {\n        return 'enabled';\n      }\n      return 'hidden';\n    },\n    callback: function(/** @type {!ContextMenuRegistry.Scope} */\n                       scope) {\n      const block = scope.block;\n      if (block.getCommentIcon()) {\n        block.setCommentText(null);\n      } else {\n        block.setCommentText('');\n      }\n    },\n    scopeType: ContextMenuRegistry.ScopeType.BLOCK,\n    id: 'blockComment',\n    weight: 2,\n  };\n  ContextMenuRegistry.registry.register(commentOption);\n};\nexports.registerComment = registerComment;\n\n/**\n * Option to inline variables.\n * @alias Blockly.ContextMenuItems.registerInline\n */\nconst registerInline = function() {\n  /** @type {!ContextMenuRegistry.RegistryItem} */\n  const inlineOption = {\n    displayText: function(/** @type {!ContextMenuRegistry.Scope} */\n                          scope) {\n      return (scope.block.getInputsInline()) ? Msg['EXTERNAL_INPUTS'] :\n                                               Msg['INLINE_INPUTS'];\n    },\n    preconditionFn: function(/** @type {!ContextMenuRegistry.Scope} */\n                             scope) {\n      const block = scope.block;\n      if (!block.isInFlyout && block.isMovable() && !block.isCollapsed()) {\n        for (let i = 1; i < block.inputList.length; i++) {\n          // Only display this option if there are two value or dummy inputs\n          // next to each other.\n          if (block.inputList[i - 1].type !== inputTypes.STATEMENT &&\n              block.inputList[i].type !== inputTypes.STATEMENT) {\n            return 'enabled';\n          }\n        }\n      }\n      return 'hidden';\n    },\n    callback: function(/** @type {!ContextMenuRegistry.Scope} */\n                       scope) {\n      scope.block.setInputsInline(!scope.block.getInputsInline());\n    },\n    scopeType: ContextMenuRegistry.ScopeType.BLOCK,\n    id: 'blockInline',\n    weight: 3,\n  };\n  ContextMenuRegistry.registry.register(inlineOption);\n};\nexports.registerInline = registerInline;\n\n/**\n * Option to collapse or expand a block.\n * @alias Blockly.ContextMenuItems.registerCollapseExpandBlock\n */\nconst registerCollapseExpandBlock = function() {\n  /** @type {!ContextMenuRegistry.RegistryItem} */\n  const collapseExpandOption = {\n    displayText: function(/** @type {!ContextMenuRegistry.Scope} */\n                          scope) {\n      return scope.block.isCollapsed() ? Msg['EXPAND_BLOCK'] :\n                                         Msg['COLLAPSE_BLOCK'];\n    },\n    preconditionFn: function(/** @type {!ContextMenuRegistry.Scope} */\n                             scope) {\n      const block = scope.block;\n      if (!block.isInFlyout && block.isMovable() &&\n          block.workspace.options.collapse) {\n        return 'enabled';\n      }\n      return 'hidden';\n    },\n    callback: function(/** @type {!ContextMenuRegistry.Scope} */\n                       scope) {\n      scope.block.setCollapsed(!scope.block.isCollapsed());\n    },\n    scopeType: ContextMenuRegistry.ScopeType.BLOCK,\n    id: 'blockCollapseExpand',\n    weight: 4,\n  };\n  ContextMenuRegistry.registry.register(collapseExpandOption);\n};\nexports.registerCollapseExpandBlock = registerCollapseExpandBlock;\n\n/**\n * Option to disable or enable a block.\n * @alias Blockly.ContextMenuItems.registerDisable\n */\nconst registerDisable = function() {\n  /** @type {!ContextMenuRegistry.RegistryItem} */\n  const disableOption = {\n    displayText: function(/** @type {!ContextMenuRegistry.Scope} */\n                          scope) {\n      return (scope.block.isEnabled()) ? Msg['DISABLE_BLOCK'] :\n                                         Msg['ENABLE_BLOCK'];\n    },\n    preconditionFn: function(/** @type {!ContextMenuRegistry.Scope} */\n                             scope) {\n      const block = scope.block;\n      if (!block.isInFlyout && block.workspace.options.disable &&\n          block.isEditable()) {\n        if (block.getInheritedDisabled()) {\n          return 'disabled';\n        }\n        return 'enabled';\n      }\n      return 'hidden';\n    },\n    callback: function(/** @type {!ContextMenuRegistry.Scope} */\n                       scope) {\n      const block = scope.block;\n      const group = eventUtils.getGroup();\n      if (!group) {\n        eventUtils.setGroup(true);\n      }\n      block.setEnabled(!block.isEnabled());\n      if (!group) {\n        eventUtils.setGroup(false);\n      }\n    },\n    scopeType: ContextMenuRegistry.ScopeType.BLOCK,\n    id: 'blockDisable',\n    weight: 5,\n  };\n  ContextMenuRegistry.registry.register(disableOption);\n};\nexports.registerDisable = registerDisable;\n\n/**\n * Option to delete a block.\n * @alias Blockly.ContextMenuItems.registerDelete\n */\nconst registerDelete = function() {\n  /** @type {!ContextMenuRegistry.RegistryItem} */\n  const deleteOption = {\n    displayText: function(/** @type {!ContextMenuRegistry.Scope} */\n                          scope) {\n      const block = scope.block;\n      // Count the number of blocks that are nested in this block.\n      let descendantCount = block.getDescendants(false).length;\n      const nextBlock = block.getNextBlock();\n      if (nextBlock) {\n        // Blocks in the current stack would survive this block's deletion.\n        descendantCount -= nextBlock.getDescendants(false).length;\n      }\n      return (descendantCount === 1) ?\n          Msg['DELETE_BLOCK'] :\n          Msg['DELETE_X_BLOCKS'].replace('%1', String(descendantCount));\n    },\n    preconditionFn: function(/** @type {!ContextMenuRegistry.Scope} */\n                             scope) {\n      if (!scope.block.isInFlyout && scope.block.isDeletable()) {\n        return 'enabled';\n      }\n      return 'hidden';\n    },\n    callback: function(/** @type {!ContextMenuRegistry.Scope} */\n                       scope) {\n      if (scope.block) {\n        scope.block.checkAndDelete();\n      }\n    },\n    scopeType: ContextMenuRegistry.ScopeType.BLOCK,\n    id: 'blockDelete',\n    weight: 6,\n  };\n  ContextMenuRegistry.registry.register(deleteOption);\n};\nexports.registerDelete = registerDelete;\n\n/**\n * Option to open help for a block.\n * @alias Blockly.ContextMenuItems.registerHelp\n */\nconst registerHelp = function() {\n  /** @type {!ContextMenuRegistry.RegistryItem} */\n  const helpOption = {\n    displayText: function() {\n      return Msg['HELP'];\n    },\n    preconditionFn: function(/** @type {!ContextMenuRegistry.Scope} */\n                             scope) {\n      const block = scope.block;\n      const url = (typeof block.helpUrl === 'function') ? block.helpUrl() :\n                                                          block.helpUrl;\n      if (url) {\n        return 'enabled';\n      }\n      return 'hidden';\n    },\n    callback: function(/** @type {!ContextMenuRegistry.Scope} */\n                       scope) {\n      scope.block.showHelp();\n    },\n    scopeType: ContextMenuRegistry.ScopeType.BLOCK,\n    id: 'blockHelp',\n    weight: 7,\n  };\n  ContextMenuRegistry.registry.register(helpOption);\n};\nexports.registerHelp = registerHelp;\n\n/**\n * Registers all block-scoped context menu items.\n * @private\n */\nconst registerBlockOptions_ = function() {\n  registerDuplicate();\n  registerComment();\n  registerInline();\n  registerCollapseExpandBlock();\n  registerDisable();\n  registerDelete();\n  registerHelp();\n};\n\n/**\n * Registers all default context menu items. This should be called once per\n * instance of ContextMenuRegistry.\n * @package\n * @alias Blockly.ContextMenuItems.registerDefaultOptions\n */\nconst registerDefaultOptions = function() {\n  registerWorkspaceOptions_();\n  registerBlockOptions_();\n};\nexports.registerDefaultOptions = registerDefaultOptions;\n\nregisterDefaultOptions();\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/contextmenu_items.js?")},
"./core/contextmenu_registry.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Registry for context menu option items.\n */\n\n\n/**\n * Registry for context menu option items.\n * @class\n */\ngoog.module('Blockly.ContextMenuRegistry');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * Class for the registry of context menu items. This is intended to be a\n * singleton. You should not create a new instance, and only access this class\n * from ContextMenuRegistry.registry.\n * @alias Blockly.ContextMenuRegistry\n */\nclass ContextMenuRegistry {\n  /**\n   * Resets the existing singleton instance of ContextMenuRegistry.\n   */\n  constructor() {\n    this.reset();\n  }\n\n  /**\n   * Clear and recreate the registry.\n   */\n  reset() {\n    /**\n     * Registry of all registered RegistryItems, keyed by ID.\n     * @type {!Object<string, !ContextMenuRegistry.RegistryItem>}\n     * @private\n     */\n    this.registry_ = Object.create(null);\n  }\n\n  /**\n   * Registers a RegistryItem.\n   * @param {!ContextMenuRegistry.RegistryItem} item Context menu item to\n   *     register.\n   * @throws {Error} if an item with the given ID already exists.\n   */\n  register(item) {\n    if (this.registry_[item.id]) {\n      throw Error('Menu item with ID \"' + item.id + '\" is already registered.');\n    }\n    this.registry_[item.id] = item;\n  }\n\n  /**\n   * Unregisters a RegistryItem with the given ID.\n   * @param {string} id The ID of the RegistryItem to remove.\n   * @throws {Error} if an item with the given ID does not exist.\n   */\n  unregister(id) {\n    if (!this.registry_[id]) {\n      throw new Error('Menu item with ID \"' + id + '\" not found.');\n    }\n    delete this.registry_[id];\n  }\n\n  /**\n   * @param {string} id The ID of the RegistryItem to get.\n   * @return {?ContextMenuRegistry.RegistryItem} RegistryItem or null if not\n   *     found\n   */\n  getItem(id) {\n    return this.registry_[id] || null;\n  }\n\n  /**\n   * Gets the valid context menu options for the given scope type (e.g. block or\n   * workspace) and scope. Blocks are only shown if the preconditionFn shows\n   * they should not be hidden.\n   * @param {!ContextMenuRegistry.ScopeType} scopeType Type of scope where menu\n   *     should be shown (e.g. on a block or on a workspace)\n   * @param {!ContextMenuRegistry.Scope} scope Current scope of context menu\n   *     (i.e., the exact workspace or block being clicked on)\n   * @return {!Array<!ContextMenuRegistry.ContextMenuOption>} the list of\n   *     ContextMenuOptions\n   */\n  getContextMenuOptions(scopeType, scope) {\n    const menuOptions = [];\n    const registry = this.registry_;\n    Object.keys(registry).forEach(function(id) {\n      const item = registry[id];\n      if (scopeType === item.scopeType) {\n        const precondition = item.preconditionFn(scope);\n        if (precondition !== 'hidden') {\n          const displayText = typeof item.displayText === 'function' ?\n              item.displayText(scope) :\n              item.displayText;\n          /** @type {!ContextMenuRegistry.ContextMenuOption} */\n          const menuOption = {\n            text: displayText,\n            enabled: (precondition === 'enabled'),\n            callback: item.callback,\n            scope: scope,\n            weight: item.weight,\n          };\n          menuOptions.push(menuOption);\n        }\n      }\n    });\n    menuOptions.sort(function(a, b) {\n      return a.weight - b.weight;\n    });\n    return menuOptions;\n  }\n}\n\n/**\n * Where this menu item should be rendered. If the menu item should be rendered\n * in multiple scopes, e.g. on both a block and a workspace, it should be\n * registered for each scope.\n * @enum {string}\n */\nContextMenuRegistry.ScopeType = {\n  BLOCK: 'block',\n  WORKSPACE: 'workspace',\n};\n\n/**\n * The actual workspace/block where the menu is being rendered. This is passed\n * to callback and displayText functions that depend on this information.\n * @typedef {{\n *    block: (BlockSvg|undefined),\n *    workspace: (WorkspaceSvg|undefined)\n * }}\n */\nContextMenuRegistry.Scope;\n\n/**\n * A menu item as entered in the registry.\n * @typedef {{\n *    callback: function(!ContextMenuRegistry.Scope),\n *    scopeType: !ContextMenuRegistry.ScopeType,\n *    displayText: ((function(!ContextMenuRegistry.Scope):string)|string),\n *    preconditionFn: function(!ContextMenuRegistry.Scope):string,\n *    weight: number,\n *    id: string\n * }}\n */\nContextMenuRegistry.RegistryItem;\n\n/**\n * A menu item as presented to contextmenu.js.\n * @typedef {{\n *    text: string,\n *    enabled: boolean,\n *    callback: function(!ContextMenuRegistry.Scope),\n *    scope: !ContextMenuRegistry.Scope,\n *    weight: number\n * }}\n */\nContextMenuRegistry.ContextMenuOption;\n\n/**\n * Singleton instance of this class. All interactions with this class should be\n * done on this object.\n * @type {!ContextMenuRegistry}\n */\nContextMenuRegistry.registry = new ContextMenuRegistry();\n\nexports.ContextMenuRegistry = ContextMenuRegistry;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/contextmenu_registry.js?")},
"./core/css.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/deprecation.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2013 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Inject Blockly's CSS synchronously.\n */\n\n\n/**\n * Inject Blockly's CSS synchronously.\n * @namespace Blockly.Css\n */\ngoog.module('Blockly.Css');\n\nconst deprecation = goog.require('Blockly.utils.deprecation');\n\n\n/**\n * Has CSS already been injected?\n * @type {boolean}\n * @private\n */\nlet injected = false;\n\n/**\n * Add some CSS to the blob that will be injected later.  Allows optional\n * components such as fields and the toolbox to store separate CSS.\n * @param {string|!Array<string>} cssContent Multiline CSS string or an array of\n *    single lines of CSS.\n * @alias Blockly.Css.register\n */\nconst register = function(cssContent) {\n  if (injected) {\n    throw Error('CSS already injected');\n  }\n\n  if (Array.isArray(cssContent)) {\n    deprecation.warn(\n        'Registering CSS by passing an array of strings', 'September 2021',\n        'September 2022', 'css.register passing a multiline string');\n    content += ('\\n' + cssContent.join('\\n'));\n  } else {\n    // Add new cssContent in the global content.\n    content += ('\\n' + cssContent);\n  }\n};\nexports.register = register;\n\n/**\n * Inject the CSS into the DOM.  This is preferable over using a regular CSS\n * file since:\n * a) It loads synchronously and doesn't force a redraw later.\n * b) It speeds up loading by not blocking on a separate HTTP transfer.\n * c) The CSS content may be made dynamic depending on init options.\n * @param {boolean} hasCss If false, don't inject CSS\n *     (providing CSS becomes the document's responsibility).\n * @param {string} pathToMedia Path from page to the Blockly media directory.\n * @alias Blockly.Css.inject\n */\nconst inject = function(hasCss, pathToMedia) {\n  // Only inject the CSS once.\n  if (injected) {\n    return;\n  }\n  injected = true;\n  if (!hasCss) {\n    return;\n  }\n  // Strip off any trailing slash (either Unix or Windows).\n  const mediaPath = pathToMedia.replace(/[\\\\/]$/, '');\n  const cssContent = content.replace(/<<<PATH>>>/g, mediaPath);\n  // Cleanup the collected css content after injecting it to the DOM.\n  content = '';\n\n  // Inject CSS tag at start of head.\n  const cssNode = document.createElement('style');\n  cssNode.id = 'blockly-common-style';\n  const cssTextNode = document.createTextNode(cssContent);\n  cssNode.appendChild(cssTextNode);\n  document.head.insertBefore(cssNode, document.head.firstChild);\n};\nexports.inject = inject;\n\n/**\n * The CSS content for Blockly.\n * @alias Blockly.Css.content\n */\nlet content = (`\n.blocklySvg {\n  background-color: #fff;\n  outline: none;\n  overflow: hidden;  /* IE overflows by default. */\n  position: absolute;\n  display: block;\n}\n\n.blocklyWidgetDiv {\n  display: none;\n  position: absolute;\n  z-index: 99999;  /* big value for bootstrap3 compatibility */\n}\n\n.injectionDiv {\n  height: 100%;\n  position: relative;\n  overflow: hidden;  /* So blocks in drag surface disappear at edges */\n  touch-action: none;\n}\n\n.blocklyNonSelectable {\n  user-select: none;\n  -ms-user-select: none;\n  -webkit-user-select: none;\n}\n\n.blocklyWsDragSurface {\n  display: none;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\n/* Added as a separate rule with multiple classes to make it more specific\n   than a bootstrap rule that selects svg:root. See issue #1275 for context.\n*/\n.blocklyWsDragSurface.blocklyOverflowVisible {\n  overflow: visible;\n}\n\n.blocklyBlockDragSurface {\n  display: none;\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  overflow: visible !important;\n  z-index: 50;  /* Display below toolbox, but above everything else. */\n}\n\n.blocklyBlockCanvas.blocklyCanvasTransitioning,\n.blocklyBubbleCanvas.blocklyCanvasTransitioning {\n  transition: transform .5s;\n}\n\n.blocklyTooltipDiv {\n  background-color: #ffffc7;\n  border: 1px solid #ddc;\n  box-shadow: 4px 4px 20px 1px rgba(0,0,0,.15);\n  color: #000;\n  display: none;\n  font: 9pt sans-serif;\n  opacity: .9;\n  padding: 2px;\n  position: absolute;\n  z-index: 100000;  /* big value for bootstrap3 compatibility */\n}\n\n.blocklyDropDownDiv {\n  position: absolute;\n  left: 0;\n  top: 0;\n  z-index: 1000;\n  display: none;\n  border: 1px solid;\n  border-color: #dadce0;\n  background-color: #fff;\n  border-radius: 2px;\n  padding: 4px;\n  box-shadow: 0 0 3px 1px rgba(0,0,0,.3);\n}\n\n.blocklyDropDownDiv.blocklyFocused {\n  box-shadow: 0 0 6px 1px rgba(0,0,0,.3);\n}\n\n.blocklyDropDownContent {\n  max-height: 300px;  // @todo: spec for maximum height.\n  overflow: auto;\n  overflow-x: hidden;\n  position: relative;\n}\n\n.blocklyDropDownArrow {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 16px;\n  height: 16px;\n  z-index: -1;\n  background-color: inherit;\n  border-color: inherit;\n}\n\n.blocklyDropDownButton {\n  display: inline-block;\n  float: left;\n  padding: 0;\n  margin: 4px;\n  border-radius: 4px;\n  outline: none;\n  border: 1px solid;\n  transition: box-shadow .1s;\n  cursor: pointer;\n}\n\n.blocklyArrowTop {\n  border-top: 1px solid;\n  border-left: 1px solid;\n  border-top-left-radius: 4px;\n  border-color: inherit;\n}\n\n.blocklyArrowBottom {\n  border-bottom: 1px solid;\n  border-right: 1px solid;\n  border-bottom-right-radius: 4px;\n  border-color: inherit;\n}\n\n.blocklyResizeSE {\n  cursor: se-resize;\n  fill: #aaa;\n}\n\n.blocklyResizeSW {\n  cursor: sw-resize;\n  fill: #aaa;\n}\n\n.blocklyResizeLine {\n  stroke: #515A5A;\n  stroke-width: 1;\n}\n\n.blocklyHighlightedConnectionPath {\n  fill: none;\n  stroke: #fc3;\n  stroke-width: 4px;\n}\n\n.blocklyPathLight {\n  fill: none;\n  stroke-linecap: round;\n  stroke-width: 1;\n}\n\n.blocklySelected>.blocklyPathLight {\n  display: none;\n}\n\n.blocklyDraggable {\n  /* backup for browsers (e.g. IE11) that don't support grab */\n  cursor: url(\"<<<PATH>>>/handopen.cur\"), auto;\n  cursor: grab;\n  cursor: -webkit-grab;\n}\n\n  /* backup for browsers (e.g. IE11) that don't support grabbing */\n.blocklyDragging {\n  /* backup for browsers (e.g. IE11) that don't support grabbing */\n  cursor: url(\"<<<PATH>>>/handclosed.cur\"), auto;\n  cursor: grabbing;\n  cursor: -webkit-grabbing;\n}\n\n  /* Changes cursor on mouse down. Not effective in Firefox because of\n     https://bugzilla.mozilla.org/show_bug.cgi?id=771241 */\n.blocklyDraggable:active {\n  /* backup for browsers (e.g. IE11) that don't support grabbing */\n  cursor: url(\"<<<PATH>>>/handclosed.cur\"), auto;\n  cursor: grabbing;\n  cursor: -webkit-grabbing;\n}\n\n/* Change the cursor on the whole drag surface in case the mouse gets\n   ahead of block during a drag. This way the cursor is still a closed hand.\n  */\n.blocklyBlockDragSurface .blocklyDraggable {\n  /* backup for browsers (e.g. IE11) that don't support grabbing */\n  cursor: url(\"<<<PATH>>>/handclosed.cur\"), auto;\n  cursor: grabbing;\n  cursor: -webkit-grabbing;\n}\n\n.blocklyDragging.blocklyDraggingDelete {\n  cursor: url(\"<<<PATH>>>/handdelete.cur\"), auto;\n}\n\n.blocklyDragging>.blocklyPath,\n.blocklyDragging>.blocklyPathLight {\n  fill-opacity: .8;\n  stroke-opacity: .8;\n}\n\n.blocklyDragging>.blocklyPathDark {\n  display: none;\n}\n\n.blocklyDisabled>.blocklyPath {\n  fill-opacity: .5;\n  stroke-opacity: .5;\n}\n\n.blocklyDisabled>.blocklyPathLight,\n.blocklyDisabled>.blocklyPathDark {\n  display: none;\n}\n\n.blocklyInsertionMarker>.blocklyPath,\n.blocklyInsertionMarker>.blocklyPathLight,\n.blocklyInsertionMarker>.blocklyPathDark {\n  fill-opacity: .2;\n  stroke: none;\n}\n\n.blocklyMultilineText {\n  font-family: monospace;\n}\n\n.blocklyNonEditableText>text {\n  pointer-events: none;\n}\n\n.blocklyFlyout {\n  position: absolute;\n  z-index: 20;\n}\n\n.blocklyText text {\n  cursor: default;\n}\n\n/*\n  Don't allow users to select text.  It gets annoying when trying to\n  drag a block and selected text moves instead.\n*/\n.blocklySvg text,\n.blocklyBlockDragSurface text {\n  user-select: none;\n  -ms-user-select: none;\n  -webkit-user-select: none;\n  cursor: inherit;\n}\n\n.blocklyHidden {\n  display: none;\n}\n\n.blocklyFieldDropdown:not(.blocklyHidden) {\n  display: block;\n}\n\n.blocklyIconGroup {\n  cursor: default;\n}\n\n.blocklyIconGroup:not(:hover),\n.blocklyIconGroupReadonly {\n  opacity: .6;\n}\n\n.blocklyIconShape {\n  fill: #00f;\n  stroke: #fff;\n  stroke-width: 1px;\n}\n\n.blocklyIconSymbol {\n  fill: #fff;\n}\n\n.blocklyMinimalBody {\n  margin: 0;\n  padding: 0;\n}\n\n.blocklyHtmlInput {\n  border: none;\n  border-radius: 4px;\n  height: 100%;\n  margin: 0;\n  outline: none;\n  padding: 0;\n  width: 100%;\n  text-align: center;\n  display: block;\n  box-sizing: border-box;\n}\n\n/* Edge and IE introduce a close icon when the input value is longer than a\n   certain length. This affects our sizing calculations of the text input.\n   Hiding the close icon to avoid that. */\n.blocklyHtmlInput::-ms-clear {\n  display: none;\n}\n\n.blocklyMainBackground {\n  stroke-width: 1;\n  stroke: #c6c6c6;  /* Equates to #ddd due to border being off-pixel. */\n}\n\n.blocklyMutatorBackground {\n  fill: #fff;\n  stroke: #ddd;\n  stroke-width: 1;\n}\n\n.blocklyFlyoutBackground {\n  fill: #ddd;\n  fill-opacity: .8;\n}\n\n.blocklyMainWorkspaceScrollbar {\n  z-index: 20;\n}\n\n.blocklyFlyoutScrollbar {\n  z-index: 30;\n}\n\n.blocklyScrollbarHorizontal,\n.blocklyScrollbarVertical {\n  position: absolute;\n  outline: none;\n}\n\n.blocklyScrollbarBackground {\n  opacity: 0;\n}\n\n.blocklyScrollbarHandle {\n  fill: #ccc;\n}\n\n.blocklyScrollbarBackground:hover+.blocklyScrollbarHandle,\n.blocklyScrollbarHandle:hover {\n  fill: #bbb;\n}\n\n/* Darken flyout scrollbars due to being on a grey background. */\n/* By contrast, workspace scrollbars are on a white background. */\n.blocklyFlyout .blocklyScrollbarHandle {\n  fill: #bbb;\n}\n\n.blocklyFlyout .blocklyScrollbarBackground:hover+.blocklyScrollbarHandle,\n.blocklyFlyout .blocklyScrollbarHandle:hover {\n  fill: #aaa;\n}\n\n.blocklyInvalidInput {\n  background: #faa;\n}\n\n.blocklyVerticalMarker {\n  stroke-width: 3px;\n  fill: rgba(255,255,255,.5);\n  pointer-events: none;\n}\n\n.blocklyComputeCanvas {\n  position: absolute;\n  width: 0;\n  height: 0;\n}\n\n.blocklyNoPointerEvents {\n  pointer-events: none;\n}\n\n.blocklyContextMenu {\n  border-radius: 4px;\n  max-height: 100%;\n}\n\n.blocklyDropdownMenu {\n  border-radius: 2px;\n  padding: 0 !important;\n}\n\n.blocklyDropdownMenu .blocklyMenuItem {\n  /* 28px on the left for icon or checkbox. */\n  padding-left: 28px;\n}\n\n/* BiDi override for the resting state. */\n.blocklyDropdownMenu .blocklyMenuItemRtl {\n  /* Flip left/right padding for BiDi. */\n  padding-left: 5px;\n  padding-right: 28px;\n}\n\n.blocklyWidgetDiv .blocklyMenu {\n  background: #fff;\n  border: 1px solid transparent;\n  box-shadow: 0 0 3px 1px rgba(0,0,0,.3);\n  font: normal 13px Arial, sans-serif;\n  margin: 0;\n  outline: none;\n  padding: 4px 0;\n  position: absolute;\n  overflow-y: auto;\n  overflow-x: hidden;\n  max-height: 100%;\n  z-index: 20000;  /* Arbitrary, but some apps depend on it... */\n}\n\n.blocklyWidgetDiv .blocklyMenu.blocklyFocused {\n  box-shadow: 0 0 6px 1px rgba(0,0,0,.3);\n}\n\n.blocklyDropDownDiv .blocklyMenu {\n  background: inherit;  /* Compatibility with gapi, reset from goog-menu */\n  border: inherit;  /* Compatibility with gapi, reset from goog-menu */\n  font: normal 13px \"Helvetica Neue\", Helvetica, sans-serif;\n  outline: none;\n  position: relative;  /* Compatibility with gapi, reset from goog-menu */\n  z-index: 20000;  /* Arbitrary, but some apps depend on it... */\n}\n\n/* State: resting. */\n.blocklyMenuItem {\n  border: none;\n  color: #000;\n  cursor: pointer;\n  list-style: none;\n  margin: 0;\n  /* 7em on the right for shortcut. */\n  min-width: 7em;\n  padding: 6px 15px;\n  white-space: nowrap;\n}\n\n/* State: disabled. */\n.blocklyMenuItemDisabled {\n  color: #ccc;\n  cursor: inherit;\n}\n\n/* State: hover. */\n.blocklyMenuItemHighlight {\n  background-color: rgba(0,0,0,.1);\n}\n\n/* State: selected/checked. */\n.blocklyMenuItemCheckbox {\n  height: 16px;\n  position: absolute;\n  width: 16px;\n}\n\n.blocklyMenuItemSelected .blocklyMenuItemCheckbox {\n  background: url(<<<PATH>>>/sprites.png) no-repeat -48px -16px;\n  float: left;\n  margin-left: -24px;\n  position: static;  /* Scroll with the menu. */\n}\n\n.blocklyMenuItemRtl .blocklyMenuItemCheckbox {\n  float: right;\n  margin-right: -24px;\n}\n`);\nexports.content = content;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/css.js?")},
"./core/delete_area.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/block_svg.js\");\n__webpack_require__(\"./core/drag_target.js\");\n__webpack_require__(\"./core/interfaces/i_delete_area.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The abstract class for a component that can delete a block or\n * bubble that is dropped on top of it.\n */\n\n\n\n/**\n * The abstract class for a component that can delete a block or\n * bubble that is dropped on top of it.\n * @class\n */\ngoog.module('Blockly.DeleteArea');\n\nconst {BlockSvg} = goog.require('Blockly.BlockSvg');\nconst {DragTarget} = goog.require('Blockly.DragTarget');\n/* eslint-disable-next-line no-unused-vars */\nconst {IDeleteArea} = goog.require('Blockly.IDeleteArea');\n/* eslint-disable-next-line no-unused-vars */\nconst {IDraggable} = goog.requireType('Blockly.IDraggable');\n\n\n/**\n * Abstract class for a component that can delete a block or bubble that is\n * dropped on top of it.\n * @extends {DragTarget}\n * @implements {IDeleteArea}\n * @alias Blockly.DeleteArea\n */\nclass DeleteArea extends DragTarget {\n  /**\n   * Constructor for DeleteArea. Should not be called directly, only by a\n   * subclass.\n   */\n  constructor() {\n    super();\n\n    /**\n     * Whether the last block or bubble dragged over this delete area would be\n     * deleted if dropped on this component.\n     * This property is not updated after the block or bubble is deleted.\n     * @type {boolean}\n     * @protected\n     */\n    this.wouldDelete_ = false;\n  }\n\n  /**\n   * Returns whether the provided block or bubble would be deleted if dropped on\n   * this area.\n   * This method should check if the element is deletable and is always called\n   * before onDragEnter/onDragOver/onDragExit.\n   * @param {!IDraggable} element The block or bubble currently being\n   *   dragged.\n   * @param {boolean} couldConnect Whether the element could could connect to\n   *     another.\n   * @return {boolean} Whether the element provided would be deleted if dropped\n   *     on this area.\n   */\n  wouldDelete(element, couldConnect) {\n    if (element instanceof BlockSvg) {\n      const block = /** @type {BlockSvg} */ (element);\n      const couldDeleteBlock = !block.getParent() && block.isDeletable();\n      this.updateWouldDelete_(couldDeleteBlock && !couldConnect);\n    } else {\n      this.updateWouldDelete_(element.isDeletable());\n    }\n    return this.wouldDelete_;\n  }\n\n  /**\n   * Updates the internal wouldDelete_ state.\n   * @param {boolean} wouldDelete The new value for the wouldDelete state.\n   * @protected\n   */\n  updateWouldDelete_(wouldDelete) {\n    this.wouldDelete_ = wouldDelete;\n  }\n}\n\nexports.DeleteArea = DeleteArea;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/delete_area.js?")},
"./core/dialog.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Wrapper functions around JS functions for showing\n * alert/confirmation dialogs.\n */\n\n\n\n/**\n * Wrapper functions around JS functions for showing alert/confirmation dialogs.\n * @namespace Blockly.dialog\n */\ngoog.module('Blockly.dialog');\n\nlet alertImplementation = function(message, opt_callback) {\n  window.alert(message);\n  if (opt_callback) {\n    opt_callback();\n  }\n};\n\nlet confirmImplementation = function(message, callback) {\n  callback(window.confirm(message));\n};\n\nlet promptImplementation = function(message, defaultValue, callback) {\n  callback(window.prompt(message, defaultValue));\n};\n\n/**\n * Wrapper to window.alert() that app developers may override via setAlert to\n * provide alternatives to the modal browser window.\n * @param {string} message The message to display to the user.\n * @param {function()=} opt_callback The callback when the alert is dismissed.\n * @alias Blockly.dialog.alert\n */\nconst alert = function(message, opt_callback) {\n  alertImplementation(message, opt_callback);\n};\nexports.alert = alert;\n\n/**\n * Sets the function to be run when Blockly.dialog.alert() is called.\n * @param {!function(string, function()=)} alertFunction The function to be run.\n * @see Blockly.dialog.alert\n * @alias Blockly.dialog.setAlert\n */\nconst setAlert = function(alertFunction) {\n  alertImplementation = alertFunction;\n};\nexports.setAlert = setAlert;\n\n/**\n * Wrapper to window.confirm() that app developers may override via setConfirm\n * to provide alternatives to the modal browser window.\n * @param {string} message The message to display to the user.\n * @param {!function(boolean)} callback The callback for handling user response.\n * @alias Blockly.dialog.confirm\n */\nconst confirm = function(message, callback) {\n  confirmImplementation(message, callback);\n};\nexports.confirm = confirm;\n\n/**\n * Sets the function to be run when Blockly.dialog.confirm() is called.\n * @param {!function(string, !function(boolean))} confirmFunction The function\n *    to be run.\n * @see Blockly.dialog.confirm\n * @alias Blockly.dialog.setConfirm\n */\nconst setConfirm = function(confirmFunction) {\n  confirmImplementation = confirmFunction;\n};\nexports.setConfirm = setConfirm;\n\n/**\n * Wrapper to window.prompt() that app developers may override via setPrompt to\n * provide alternatives to the modal browser window. Built-in browser prompts\n * are often used for better text input experience on mobile device. We strongly\n * recommend testing mobile when overriding this.\n * @param {string} message The message to display to the user.\n * @param {string} defaultValue The value to initialize the prompt with.\n * @param {!function(?string)} callback The callback for handling user response.\n * @alias Blockly.dialog.prompt\n */\nconst prompt = function(message, defaultValue, callback) {\n  promptImplementation(message, defaultValue, callback);\n};\nexports.prompt = prompt;\n\n/**\n * Sets the function to be run when Blockly.dialog.prompt() is called.\n * @param {!function(string, string, !function(?string))} promptFunction The\n *    function to be run.\n * @see Blockly.dialog.prompt\n * @alias Blockly.dialog.setPrompt\n */\nconst setPrompt = function(promptFunction) {\n  promptImplementation = promptFunction;\n};\nexports.setPrompt = setPrompt;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/dialog.js?")},
"./core/drag_target.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/interfaces/i_drag_target.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The abstract class for a component with custom behaviour when a\n * block or bubble is dragged over or dropped on top of it.\n */\n\n\n\n/**\n * The abstract class for a component with custom behaviour when a\n * block or bubble is dragged over or dropped on top of it.\n * @class\n */\ngoog.module('Blockly.DragTarget');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {IDragTarget} = goog.require('Blockly.IDragTarget');\n/* eslint-disable-next-line no-unused-vars */\nconst {IDraggable} = goog.requireType('Blockly.IDraggable');\n/* eslint-disable-next-line no-unused-vars */\nconst {Rect} = goog.requireType('Blockly.utils.Rect');\n\n\n/**\n * Abstract class for a component with custom behaviour when a block or bubble\n * is dragged over or dropped on top of it.\n * @implements {IDragTarget}\n * @alias Blockly.DragTarget\n */\nclass DragTarget {\n  /**\n   * Handles when a cursor with a block or bubble enters this drag target.\n   * @param {!IDraggable} _dragElement The block or bubble currently being\n   *   dragged.\n   */\n  onDragEnter(_dragElement) {\n    // no-op\n  }\n\n  /**\n   * Handles when a cursor with a block or bubble is dragged over this drag\n   * target.\n   * @param {!IDraggable} _dragElement The block or bubble currently being\n   *   dragged.\n   */\n  onDragOver(_dragElement) {\n    // no-op\n  }\n\n  /**\n   * Handles when a cursor with a block or bubble exits this drag target.\n   * @param {!IDraggable} _dragElement The block or bubble currently being\n   *   dragged.\n   */\n  onDragExit(_dragElement) {\n    // no-op\n  }\n\n  /**\n   * Handles when a block or bubble is dropped on this component.\n   * Should not handle delete here.\n   * @param {!IDraggable} _dragElement The block or bubble currently being\n   *   dragged.\n   */\n  onDrop(_dragElement) {\n    // no-op\n  }\n\n  /**\n   * Returns the bounding rectangle of the drag target area in pixel units\n   * relative to the Blockly injection div.\n   * @return {?Rect} The component's bounding box. Null if drag\n   *   target area should be ignored.\n   */\n  getClientRect() {\n    return null;\n  }\n\n  /**\n   * Returns whether the provided block or bubble should not be moved after\n   * being dropped on this component. If true, the element will return to where\n   * it was when the drag started.\n   * @param {!IDraggable} _dragElement The block or bubble currently being\n   *   dragged.\n   * @return {boolean} Whether the block or bubble provided should be returned\n   *     to drag start.\n   */\n  shouldPreventMove(_dragElement) {\n    return false;\n  }\n}\n\nexports.DragTarget = DragTarget;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/drag_target.js?")},
"./core/dropdowndiv.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/utils/math.js\");\n__webpack_require__(\"./core/utils/style.js\");\n__webpack_require__(\"./core/utils/rect.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2016 Massachusetts Institute of Technology\n * All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A div that floats on top of the workspace, for drop-down menus.\n * The drop-down can be kept inside the workspace, animate in/out, etc.\n */\n\n\n\n/**\n * A div that floats on top of the workspace, for drop-down menus.\n * @class\n */\ngoog.module('Blockly.dropDownDiv');\n\nconst common = goog.require('Blockly.common');\nconst dom = goog.require('Blockly.utils.dom');\nconst math = goog.require('Blockly.utils.math');\nconst style = goog.require('Blockly.utils.style');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Field} = goog.requireType('Blockly.Field');\nconst {Rect} = goog.require('Blockly.utils.Rect');\n/* eslint-disable-next-line no-unused-vars */\nconst {Size} = goog.requireType('Blockly.utils.Size');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * Arrow size in px. Should match the value in CSS\n * (need to position pre-render).\n * @type {number}\n * @const\n */\nconst ARROW_SIZE = 16;\nexports.ARROW_SIZE = ARROW_SIZE;\n\n/**\n * Drop-down border size in px. Should match the value in CSS (need to position\n * the arrow).\n * @type {number}\n * @const\n */\nconst BORDER_SIZE = 1;\nexports.BORDER_SIZE = BORDER_SIZE;\n\n/**\n * Amount the arrow must be kept away from the edges of the main drop-down div,\n * in px.\n * @type {number}\n * @const\n */\nconst ARROW_HORIZONTAL_PADDING = 12;\nexports.ARROW_HORIZONTAL_PADDING = ARROW_HORIZONTAL_PADDING;\n\n/**\n * Amount drop-downs should be padded away from the source, in px.\n * @type {number}\n * @const\n */\nconst PADDING_Y = 16;\nexports.PADDING_Y = PADDING_Y;\n\n/**\n * Length of animations in seconds.\n * @type {number}\n * @const\n */\nconst ANIMATION_TIME = 0.25;\nexports.ANIMATION_TIME = ANIMATION_TIME;\n\n/**\n * Timer for animation out, to be cleared if we need to immediately hide\n * without disrupting new shows.\n * @type {?number}\n */\nlet animateOutTimer = null;\n\n/**\n * Callback for when the drop-down is hidden.\n * @type {?Function}\n */\nlet onHide = null;\n\n/**\n * A class name representing the current owner's workspace renderer.\n * @type {string}\n */\nlet renderedClassName = '';\n\n/**\n * A class name representing the current owner's workspace theme.\n * @type {string}\n */\nlet themeClassName = '';\n\n/**\n * The content element.\n * @type {!HTMLDivElement}\n */\nlet div;\n\n/**\n * The content element.\n * @type {!HTMLDivElement}\n */\nlet content;\n\n/**\n * The arrow element.\n * @type {!HTMLDivElement}\n */\nlet arrow;\n\n/**\n * Drop-downs will appear within the bounds of this element if possible.\n * Set in setBoundsElement.\n * @type {?Element}\n */\nlet boundsElement = null;\n\n/**\n * The object currently using the drop-down.\n * @type {?Object}\n */\nlet owner = null;\n\n/**\n * Whether the dropdown was positioned to a field or the source block.\n * @type {?boolean}\n */\nlet positionToField = null;\n\n/**\n * Dropdown bounds info object used to encapsulate sizing information about a\n * bounding element (bounding box and width/height).\n * @typedef {{\n *        top:number,\n *        left:number,\n *        bottom:number,\n *        right:number,\n *        width:number,\n *        height:number\n * }}\n */\nlet BoundsInfo;\nexports.BoundsInfo = BoundsInfo;\n\n/**\n * Dropdown position metrics.\n * @typedef {{\n *        initialX:number,\n *        initialY:number,\n *        finalX:number,\n *        finalY:number,\n *        arrowX:?number,\n *        arrowY:?number,\n *        arrowAtTop:?boolean,\n *        arrowVisible:boolean\n * }}\n */\nlet PositionMetrics;\nexports.PositionMetrics = PositionMetrics;\n\n/**\n * Create and insert the DOM element for this div.\n * @package\n */\nconst createDom = function() {\n  if (div) {\n    return;  // Already created.\n  }\n  div = /** @type {!HTMLDivElement} */ (document.createElement('div'));\n  div.className = 'blocklyDropDownDiv';\n  const parentDiv = common.getParentContainer() || document.body;\n  parentDiv.appendChild(div);\n\n  content = /** @type {!HTMLDivElement} */ (document.createElement('div'));\n  content.className = 'blocklyDropDownContent';\n  div.appendChild(content);\n\n  arrow = /** @type {!HTMLDivElement} */ (document.createElement('div'));\n  arrow.className = 'blocklyDropDownArrow';\n  div.appendChild(arrow);\n\n  div.style.opacity = 0;\n\n  // Transition animation for transform: translate() and opacity.\n  div.style.transition = 'transform ' + ANIMATION_TIME + 's, ' +\n      'opacity ' + ANIMATION_TIME + 's';\n\n  // Handle focusin/out events to add a visual indicator when\n  // a child is focused or blurred.\n  div.addEventListener('focusin', function() {\n    dom.addClass(div, 'blocklyFocused');\n  });\n  div.addEventListener('focusout', function() {\n    dom.removeClass(div, 'blocklyFocused');\n  });\n};\nexports.createDom = createDom;\n\n/**\n * Set an element to maintain bounds within. Drop-downs will appear\n * within the box of this element if possible.\n * @param {?Element} boundsElem Element to bind drop-down to.\n */\nconst setBoundsElement = function(boundsElem) {\n  boundsElement = boundsElem;\n};\nexports.setBoundsElement = setBoundsElement;\n\n/**\n * Provide the div for inserting content into the drop-down.\n * @return {!Element} Div to populate with content.\n */\nconst getContentDiv = function() {\n  return content;\n};\nexports.getContentDiv = getContentDiv;\n\n/**\n * Clear the content of the drop-down.\n */\nconst clearContent = function() {\n  content.textContent = '';\n  content.style.width = '';\n};\nexports.clearContent = clearContent;\n\n/**\n * Set the colour for the drop-down.\n * @param {string} backgroundColour Any CSS colour for the background.\n * @param {string} borderColour Any CSS colour for the border.\n */\nconst setColour = function(backgroundColour, borderColour) {\n  div.style.backgroundColor = backgroundColour;\n  div.style.borderColor = borderColour;\n};\nexports.setColour = setColour;\n\n/**\n * Shortcut to show and place the drop-down with positioning determined\n * by a particular block. The primary position will be below the block,\n * and the secondary position above the block. Drop-down will be\n * constrained to the block's workspace.\n * @param {!Field} field The field showing the drop-down.\n * @param {!BlockSvg} block Block to position the drop-down around.\n * @param {Function=} opt_onHide Optional callback for when the drop-down is\n *   hidden.\n * @param {number=} opt_secondaryYOffset Optional Y offset for above-block\n *   positioning.\n * @return {boolean} True if the menu rendered below block; false if above.\n */\nconst showPositionedByBlock = function(\n    field, block, opt_onHide, opt_secondaryYOffset) {\n  return showPositionedByRect(\n      getScaledBboxOfBlock(block), field, opt_onHide, opt_secondaryYOffset);\n};\nexports.showPositionedByBlock = showPositionedByBlock;\n\n/**\n * Shortcut to show and place the drop-down with positioning determined\n * by a particular field. The primary position will be below the field,\n * and the secondary position above the field. Drop-down will be\n * constrained to the block's workspace.\n * @param {!Field} field The field to position the dropdown against.\n * @param {Function=} opt_onHide Optional callback for when the drop-down is\n *   hidden.\n * @param {number=} opt_secondaryYOffset Optional Y offset for above-block\n *   positioning.\n * @return {boolean} True if the menu rendered below block; false if above.\n */\nconst showPositionedByField = function(\n    field, opt_onHide, opt_secondaryYOffset) {\n  positionToField = true;\n  return showPositionedByRect(\n      getScaledBboxOfField(field), field, opt_onHide, opt_secondaryYOffset);\n};\nexports.showPositionedByField = showPositionedByField;\n\n/**\n * Get the scaled bounding box of a block.\n * @param {!BlockSvg} block The block.\n * @return {!Rect} The scaled bounding box of the block.\n */\nconst getScaledBboxOfBlock = function(block) {\n  const blockSvg = block.getSvgRoot();\n  const bBox = blockSvg.getBBox();\n  const scale = block.workspace.scale;\n  const scaledHeight = bBox.height * scale;\n  const scaledWidth = bBox.width * scale;\n  const xy = style.getPageOffset(blockSvg);\n  return new Rect(xy.y, xy.y + scaledHeight, xy.x, xy.x + scaledWidth);\n};\n\n/**\n * Get the scaled bounding box of a field.\n * @param {!Field} field The field.\n * @return {!Rect} The scaled bounding box of the field.\n */\nconst getScaledBboxOfField = function(field) {\n  const bBox = field.getScaledBBox();\n  return new Rect(bBox.top, bBox.bottom, bBox.left, bBox.right);\n};\n\n/**\n * Helper method to show and place the drop-down with positioning determined\n * by a scaled bounding box.  The primary position will be below the rect,\n * and the secondary position above the rect. Drop-down will be constrained to\n * the block's workspace.\n * @param {!Rect} bBox The scaled bounding box.\n * @param {!Field} field The field to position the dropdown against.\n * @param {Function=} opt_onHide Optional callback for when the drop-down is\n *   hidden.\n * @param {number=} opt_secondaryYOffset Optional Y offset for above-block\n *   positioning.\n * @return {boolean} True if the menu rendered below block; false if above.\n */\nconst showPositionedByRect = function(\n    bBox, field, opt_onHide, opt_secondaryYOffset) {\n  // If we can fit it, render below the block.\n  const primaryX = bBox.left + (bBox.right - bBox.left) / 2;\n  const primaryY = bBox.bottom;\n  // If we can't fit it, render above the entire parent block.\n  const secondaryX = primaryX;\n  let secondaryY = bBox.top;\n  if (opt_secondaryYOffset) {\n    secondaryY += opt_secondaryYOffset;\n  }\n  const sourceBlock = /** @type {!BlockSvg} */ (field.getSourceBlock());\n  // Set bounds to main workspace; show the drop-down.\n  let workspace = sourceBlock.workspace;\n  while (workspace.options.parentWorkspace) {\n    workspace =\n        /** @type {!WorkspaceSvg} */ (workspace.options.parentWorkspace);\n  }\n  setBoundsElement(\n      /** @type {?Element} */ (workspace.getParentSvg().parentNode));\n  return show(\n      field, sourceBlock.RTL, primaryX, primaryY, secondaryX, secondaryY,\n      opt_onHide);\n};\n\n/**\n * Show and place the drop-down.\n * The drop-down is placed with an absolute \"origin point\" (x, y) - i.e.,\n * the arrow will point at this origin and box will positioned below or above\n * it.  If we can maintain the container bounds at the primary point, the arrow\n * will point there, and the container will be positioned below it.\n * If we can't maintain the container bounds at the primary point, fall-back to\n * the secondary point and position above.\n * @param {?Object} newOwner The object showing the drop-down\n * @param {boolean} rtl Right-to-left (true) or left-to-right (false).\n * @param {number} primaryX Desired origin point x, in absolute px.\n * @param {number} primaryY Desired origin point y, in absolute px.\n * @param {number} secondaryX Secondary/alternative origin point x, in absolute\n *     px.\n * @param {number} secondaryY Secondary/alternative origin point y, in absolute\n *     px.\n * @param {Function=} opt_onHide Optional callback for when the drop-down is\n *     hidden.\n * @return {boolean} True if the menu rendered at the primary origin point.\n * @package\n */\nconst show = function(\n    newOwner, rtl, primaryX, primaryY, secondaryX, secondaryY, opt_onHide) {\n  owner = newOwner;\n  onHide = opt_onHide || null;\n  // Set direction.\n  div.style.direction = rtl ? 'rtl' : 'ltr';\n\n  const mainWorkspace =\n      /** @type {!WorkspaceSvg} */ (common.getMainWorkspace());\n  renderedClassName = mainWorkspace.getRenderer().getClassName();\n  themeClassName = mainWorkspace.getTheme().getClassName();\n  dom.addClass(div, renderedClassName);\n  dom.addClass(div, themeClassName);\n\n  // When we change `translate` multiple times in close succession,\n  // Chrome may choose to wait and apply them all at once.\n  // Since we want the translation to initial X, Y to be immediate,\n  // and the translation to final X, Y to be animated,\n  // we saw problems where both would be applied after animation was turned on,\n  // making the dropdown appear to fly in from (0, 0).\n  // Using both `left`, `top` for the initial translation and then `translate`\n  // for the animated transition to final X, Y is a workaround.\n\n  return positionInternal(primaryX, primaryY, secondaryX, secondaryY);\n};\nexports.show = show;\n\nconst internal = {};\n\n/**\n * Get sizing info about the bounding element.\n * @return {!BoundsInfo} An object containing size\n *     information about the bounding element (bounding box and width/height).\n */\ninternal.getBoundsInfo = function() {\n  const boundPosition = style.getPageOffset(\n      /** @type {!Element} */ (boundsElement));\n  const boundSize = style.getSize(\n      /** @type {!Element} */ (boundsElement));\n\n  return {\n    left: boundPosition.x,\n    right: boundPosition.x + boundSize.width,\n    top: boundPosition.y,\n    bottom: boundPosition.y + boundSize.height,\n    width: boundSize.width,\n    height: boundSize.height,\n  };\n};\n\n/**\n * Helper to position the drop-down and the arrow, maintaining bounds.\n * See explanation of origin points in show.\n * @param {number} primaryX Desired origin point x, in absolute px.\n * @param {number} primaryY Desired origin point y, in absolute px.\n * @param {number} secondaryX Secondary/alternative origin point x,\n *     in absolute px.\n * @param {number} secondaryY Secondary/alternative origin point y,\n *     in absolute px.\n * @return {!PositionMetrics} Various final metrics,\n *     including rendered positions for drop-down and arrow.\n */\ninternal.getPositionMetrics = function(\n    primaryX, primaryY, secondaryX, secondaryY) {\n  const boundsInfo = internal.getBoundsInfo();\n  const divSize = style.getSize(\n      /** @type {!Element} */ (div));\n\n  // Can we fit in-bounds below the target?\n  if (primaryY + divSize.height < boundsInfo.bottom) {\n    return getPositionBelowMetrics(primaryX, primaryY, boundsInfo, divSize);\n  }\n  // Can we fit in-bounds above the target?\n  if (secondaryY - divSize.height > boundsInfo.top) {\n    return getPositionAboveMetrics(secondaryX, secondaryY, boundsInfo, divSize);\n  }\n  // Can we fit outside the workspace bounds (but inside the window) below?\n  if (primaryY + divSize.height < document.documentElement.clientHeight) {\n    return getPositionBelowMetrics(primaryX, primaryY, boundsInfo, divSize);\n  }\n  // Can we fit outside the workspace bounds (but inside the window) above?\n  if (secondaryY - divSize.height > document.documentElement.clientTop) {\n    return getPositionAboveMetrics(secondaryX, secondaryY, boundsInfo, divSize);\n  }\n\n  // Last resort, render at top of page.\n  return getPositionTopOfPageMetrics(primaryX, boundsInfo, divSize);\n};\n\n/**\n * Get the metrics for positioning the div below the source.\n * @param {number} primaryX Desired origin point x, in absolute px.\n * @param {number} primaryY Desired origin point y, in absolute px.\n * @param {!BoundsInfo} boundsInfo An object containing size\n *     information about the bounding element (bounding box and width/height).\n * @param {!Size} divSize An object containing information about\n *     the size of the DropDownDiv (width & height).\n * @return {!PositionMetrics} Various final metrics,\n *     including rendered positions for drop-down and arrow.\n */\nconst getPositionBelowMetrics = function(\n    primaryX, primaryY, boundsInfo, divSize) {\n  const xCoords =\n      getPositionX(primaryX, boundsInfo.left, boundsInfo.right, divSize.width);\n\n  const arrowY = -(ARROW_SIZE / 2 + BORDER_SIZE);\n  const finalY = primaryY + PADDING_Y;\n\n  return {\n    initialX: xCoords.divX,\n    initialY: primaryY,\n    finalX: xCoords.divX,  // X position remains constant during animation.\n    finalY: finalY,\n    arrowX: xCoords.arrowX,\n    arrowY: arrowY,\n    arrowAtTop: true,\n    arrowVisible: true,\n  };\n};\n\n/**\n * Get the metrics for positioning the div above the source.\n * @param {number} secondaryX Secondary/alternative origin point x,\n *     in absolute px.\n * @param {number} secondaryY Secondary/alternative origin point y,\n *     in absolute px.\n * @param {!BoundsInfo} boundsInfo An object containing size\n *     information about the bounding element (bounding box and width/height).\n * @param {!Size} divSize An object containing information about\n *     the size of the DropDownDiv (width & height).\n * @return {!PositionMetrics} Various final metrics,\n *     including rendered positions for drop-down and arrow.\n */\nconst getPositionAboveMetrics = function(\n    secondaryX, secondaryY, boundsInfo, divSize) {\n  const xCoords = getPositionX(\n      secondaryX, boundsInfo.left, boundsInfo.right, divSize.width);\n\n  const arrowY = divSize.height - (BORDER_SIZE * 2) - (ARROW_SIZE / 2);\n  const finalY = secondaryY - divSize.height - PADDING_Y;\n  const initialY = secondaryY - divSize.height;  // No padding on Y.\n\n  return {\n    initialX: xCoords.divX,\n    initialY: initialY,\n    finalX: xCoords.divX,  // X position remains constant during animation.\n    finalY: finalY,\n    arrowX: xCoords.arrowX,\n    arrowY: arrowY,\n    arrowAtTop: false,\n    arrowVisible: true,\n  };\n};\n\n/**\n * Get the metrics for positioning the div at the top of the page.\n * @param {number} sourceX Desired origin point x, in absolute px.\n * @param {!BoundsInfo} boundsInfo An object containing size\n *     information about the bounding element (bounding box and width/height).\n * @param {!Size} divSize An object containing information about\n *     the size of the DropDownDiv (width & height).\n * @return {!PositionMetrics} Various final metrics,\n *     including rendered positions for drop-down and arrow.\n */\nconst getPositionTopOfPageMetrics = function(sourceX, boundsInfo, divSize) {\n  const xCoords =\n      getPositionX(sourceX, boundsInfo.left, boundsInfo.right, divSize.width);\n\n  // No need to provide arrow-specific information because it won't be visible.\n  return {\n    initialX: xCoords.divX,\n    initialY: 0,\n    finalX: xCoords.divX,  // X position remains constant during animation.\n    finalY: 0,             // Y position remains constant during animation.\n    arrowAtTop: null,\n    arrowX: null,\n    arrowY: null,\n    arrowVisible: false,\n  };\n};\n\n/**\n * Get the x positions for the left side of the DropDownDiv and the arrow,\n * accounting for the bounds of the workspace.\n * @param {number} sourceX Desired origin point x, in absolute px.\n * @param {number} boundsLeft The left edge of the bounding element, in\n *    absolute px.\n * @param {number} boundsRight The right edge of the bounding element, in\n *    absolute px.\n * @param {number} divWidth The width of the div in px.\n * @return {{divX: number, arrowX: number}} An object containing metrics for\n *    the x positions of the left side of the DropDownDiv and the arrow.\n * @package\n */\nconst getPositionX = function(sourceX, boundsLeft, boundsRight, divWidth) {\n  let divX = sourceX;\n  // Offset the topLeft coord so that the dropdowndiv is centered.\n  divX -= divWidth / 2;\n  // Fit the dropdowndiv within the bounds of the workspace.\n  divX = math.clamp(boundsLeft, divX, boundsRight - divWidth);\n\n  let arrowX = sourceX;\n  // Offset the arrow coord so that the arrow is centered.\n  arrowX -= ARROW_SIZE / 2;\n  // Convert the arrow position to be relative to the top left of the div.\n  let relativeArrowX = arrowX - divX;\n  const horizPadding = ARROW_HORIZONTAL_PADDING;\n  // Clamp the arrow position so that it stays attached to the dropdowndiv.\n  relativeArrowX = math.clamp(\n      horizPadding, relativeArrowX, divWidth - horizPadding - ARROW_SIZE);\n\n  return {arrowX: relativeArrowX, divX: divX};\n};\nexports.getPositionX = getPositionX;\n\n/**\n * Is the container visible?\n * @return {boolean} True if visible.\n */\nconst isVisible = function() {\n  return !!owner;\n};\nexports.isVisible = isVisible;\n\n/**\n * Hide the menu only if it is owned by the provided object.\n * @param {?Object} divOwner Object which must be owning the drop-down to hide.\n * @param {boolean=} opt_withoutAnimation True if we should hide the dropdown\n *     without animating.\n * @return {boolean} True if hidden.\n */\nconst hideIfOwner = function(divOwner, opt_withoutAnimation) {\n  if (owner === divOwner) {\n    if (opt_withoutAnimation) {\n      hideWithoutAnimation();\n    } else {\n      hide();\n    }\n    return true;\n  }\n  return false;\n};\nexports.hideIfOwner = hideIfOwner;\n\n/**\n * Hide the menu, triggering animation.\n */\nconst hide = function() {\n  // Start the animation by setting the translation and fading out.\n  // Reset to (initialX, initialY) - i.e., no translation.\n  div.style.transform = 'translate(0, 0)';\n  div.style.opacity = 0;\n  // Finish animation - reset all values to default.\n  animateOutTimer = setTimeout(function() {\n    hideWithoutAnimation();\n  }, ANIMATION_TIME * 1000);\n  if (onHide) {\n    onHide();\n    onHide = null;\n  }\n};\nexports.hide = hide;\n\n/**\n * Hide the menu, without animation.\n */\nconst hideWithoutAnimation = function() {\n  if (!isVisible()) {\n    return;\n  }\n  if (animateOutTimer) {\n    clearTimeout(animateOutTimer);\n  }\n\n  // Reset style properties in case this gets called directly\n  // instead of hide() - see discussion on #2551.\n  div.style.transform = '';\n  div.style.left = '';\n  div.style.top = '';\n  div.style.opacity = 0;\n  div.style.display = 'none';\n  div.style.backgroundColor = '';\n  div.style.borderColor = '';\n\n  if (onHide) {\n    onHide();\n    onHide = null;\n  }\n  clearContent();\n  owner = null;\n\n  if (renderedClassName) {\n    dom.removeClass(div, renderedClassName);\n    renderedClassName = '';\n  }\n  if (themeClassName) {\n    dom.removeClass(div, themeClassName);\n    themeClassName = '';\n  }\n  (/** @type {!WorkspaceSvg} */ (common.getMainWorkspace())).markFocused();\n};\nexports.hideWithoutAnimation = hideWithoutAnimation;\n\n/**\n * Set the dropdown div's position.\n * @param {number} primaryX Desired origin point x, in absolute px.\n * @param {number} primaryY Desired origin point y, in absolute px.\n * @param {number} secondaryX Secondary/alternative origin point x,\n *    in absolute px.\n * @param {number} secondaryY Secondary/alternative origin point y,\n *    in absolute px.\n * @return {boolean} True if the menu rendered at the primary origin point.\n */\nconst positionInternal = function(primaryX, primaryY, secondaryX, secondaryY) {\n  const metrics =\n      internal.getPositionMetrics(primaryX, primaryY, secondaryX, secondaryY);\n\n  // Update arrow CSS.\n  if (metrics.arrowVisible) {\n    arrow.style.display = '';\n    arrow.style.transform = 'translate(' + metrics.arrowX + 'px,' +\n        metrics.arrowY + 'px) rotate(45deg)';\n    arrow.setAttribute(\n        'class',\n        metrics.arrowAtTop ? 'blocklyDropDownArrow blocklyArrowTop' :\n                             'blocklyDropDownArrow blocklyArrowBottom');\n  } else {\n    arrow.style.display = 'none';\n  }\n\n  const initialX = Math.floor(metrics.initialX);\n  const initialY = Math.floor(metrics.initialY);\n  const finalX = Math.floor(metrics.finalX);\n  const finalY = Math.floor(metrics.finalY);\n\n  // First apply initial translation.\n  div.style.left = initialX + 'px';\n  div.style.top = initialY + 'px';\n\n  // Show the div.\n  div.style.display = 'block';\n  div.style.opacity = 1;\n  // Add final translate, animated through `transition`.\n  // Coordinates are relative to (initialX, initialY),\n  // where the drop-down is absolutely positioned.\n  const dx = finalX - initialX;\n  const dy = finalY - initialY;\n  div.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';\n\n  return !!metrics.arrowAtTop;\n};\n\n/**\n * Repositions the dropdownDiv on window resize. If it doesn't know how to\n * calculate the new position, it will just hide it instead.\n * @package\n */\nconst repositionForWindowResize = function() {\n  // This condition mainly catches the dropdown div when it is being used as a\n  // dropdown.  It is important not to close it in this case because on Android,\n  // when a field is focused, the soft keyboard opens triggering a window resize\n  // event and we want the dropdown div to stick around so users can type into\n  // it.\n  if (owner) {\n    const field = /** @type {!Field} */ (owner);\n    const block = /** @type {!BlockSvg} */ (field.getSourceBlock());\n    const bBox = positionToField ? getScaledBboxOfField(field) :\n                                   getScaledBboxOfBlock(block);\n    // If we can fit it, render below the block.\n    const primaryX = bBox.left + (bBox.right - bBox.left) / 2;\n    const primaryY = bBox.bottom;\n    // If we can't fit it, render above the entire parent block.\n    const secondaryX = primaryX;\n    const secondaryY = bBox.top;\n    positionInternal(primaryX, primaryY, secondaryX, secondaryY);\n  } else {\n    hide();\n  }\n};\nexports.repositionForWindowResize = repositionForWindowResize;\n\nexports.TEST_ONLY = internal;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/dropdowndiv.js?")},
"./core/events/events.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/deprecation.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/events/events_abstract.js\");\n__webpack_require__(\"./core/events/events_block_base.js\");\n__webpack_require__(\"./core/events/events_block_change.js\");\n__webpack_require__(\"./core/events/events_block_create.js\");\n__webpack_require__(\"./core/events/events_block_delete.js\");\n__webpack_require__(\"./core/events/events_block_drag.js\");\n__webpack_require__(\"./core/events/events_block_move.js\");\n__webpack_require__(\"./core/events/events_bubble_open.js\");\n__webpack_require__(\"./core/events/events_click.js\");\n__webpack_require__(\"./core/events/events_comment_base.js\");\n__webpack_require__(\"./core/events/events_comment_change.js\");\n__webpack_require__(\"./core/events/events_comment_create.js\");\n__webpack_require__(\"./core/events/events_comment_delete.js\");\n__webpack_require__(\"./core/events/events_comment_move.js\");\n__webpack_require__(\"./core/events/workspace_events.js\");\n__webpack_require__(\"./core/events/events_marker_move.js\");\n__webpack_require__(\"./core/events/events_selected.js\");\n__webpack_require__(\"./core/events/events_theme_change.js\");\n__webpack_require__(\"./core/events/events_toolbox_item_select.js\");\n__webpack_require__(\"./core/events/events_trashcan_open.js\");\n__webpack_require__(\"./core/events/events_ui_base.js\");\n__webpack_require__(\"./core/events/events_ui.js\");\n__webpack_require__(\"./core/events/events_var_base.js\");\n__webpack_require__(\"./core/events/events_var_create.js\");\n__webpack_require__(\"./core/events/events_var_delete.js\");\n__webpack_require__(\"./core/events/events_var_rename.js\");\n__webpack_require__(\"./core/events/events_viewport.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Events fired as a result of actions in Blockly's editor.\n */\n\n\n/**\n * Events fired as a result of actions in Blockly's editor.\n * @namespace Blockly.Events\n */\ngoog.module('Blockly.Events');\n\nconst deprecation = goog.require('Blockly.utils.deprecation');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst {Abstract: AbstractEvent} = goog.require('Blockly.Events.Abstract');\nconst {BlockBase} = goog.require('Blockly.Events.BlockBase');\nconst {BlockChange} = goog.require('Blockly.Events.BlockChange');\nconst {BlockCreate} = goog.require('Blockly.Events.BlockCreate');\nconst {BlockDelete} = goog.require('Blockly.Events.BlockDelete');\nconst {BlockDrag} = goog.require('Blockly.Events.BlockDrag');\nconst {BlockMove} = goog.require('Blockly.Events.BlockMove');\nconst {BubbleOpen} = goog.require('Blockly.Events.BubbleOpen');\nconst {Click} = goog.require('Blockly.Events.Click');\nconst {CommentBase} = goog.require('Blockly.Events.CommentBase');\nconst {CommentChange} = goog.require('Blockly.Events.CommentChange');\nconst {CommentCreate} = goog.require('Blockly.Events.CommentCreate');\nconst {CommentDelete} = goog.require('Blockly.Events.CommentDelete');\nconst {CommentMove} = goog.require('Blockly.Events.CommentMove');\nconst {FinishedLoading} = goog.require('Blockly.Events.FinishedLoading');\nconst {MarkerMove} = goog.require('Blockly.Events.MarkerMove');\nconst {Selected} = goog.require('Blockly.Events.Selected');\nconst {ThemeChange} = goog.require('Blockly.Events.ThemeChange');\nconst {ToolboxItemSelect} = goog.require('Blockly.Events.ToolboxItemSelect');\nconst {TrashcanOpen} = goog.require('Blockly.Events.TrashcanOpen');\nconst {UiBase} = goog.require('Blockly.Events.UiBase');\nconst {Ui} = goog.require('Blockly.Events.Ui');\nconst {VarBase} = goog.require('Blockly.Events.VarBase');\nconst {VarCreate} = goog.require('Blockly.Events.VarCreate');\nconst {VarDelete} = goog.require('Blockly.Events.VarDelete');\nconst {VarRename} = goog.require('Blockly.Events.VarRename');\nconst {ViewportChange} = goog.require('Blockly.Events.ViewportChange');\n\n\n// Events.\nexports.Abstract = AbstractEvent;\nexports.BubbleOpen = BubbleOpen;\nexports.BlockBase = BlockBase;\nexports.BlockChange = BlockChange;\nexports.BlockCreate = BlockCreate;\nexports.BlockDelete = BlockDelete;\nexports.BlockDrag = BlockDrag;\nexports.BlockMove = BlockMove;\nexports.Click = Click;\nexports.CommentBase = CommentBase;\nexports.CommentChange = CommentChange;\nexports.CommentCreate = CommentCreate;\nexports.CommentDelete = CommentDelete;\nexports.CommentMove = CommentMove;\nexports.FinishedLoading = FinishedLoading;\nexports.MarkerMove = MarkerMove;\nexports.Selected = Selected;\nexports.ThemeChange = ThemeChange;\nexports.ToolboxItemSelect = ToolboxItemSelect;\nexports.TrashcanOpen = TrashcanOpen;\nexports.Ui = Ui;\nexports.UiBase = UiBase;\nexports.VarBase = VarBase;\nexports.VarCreate = VarCreate;\nexports.VarDelete = VarDelete;\nexports.VarRename = VarRename;\nexports.ViewportChange = ViewportChange;\n\n// Event types.\nexports.BLOCK_CHANGE = eventUtils.BLOCK_CHANGE;\nexports.BLOCK_CREATE = eventUtils.BLOCK_CREATE;\nexports.BLOCK_DELETE = eventUtils.BLOCK_DELETE;\nexports.BLOCK_DRAG = eventUtils.BLOCK_DRAG;\nexports.BLOCK_MOVE = eventUtils.BLOCK_MOVE;\nexports.BUBBLE_OPEN = eventUtils.BUBBLE_OPEN;\nexports.BumpEvent = eventUtils.BumpEvent;\nexports.BUMP_EVENTS = eventUtils.BUMP_EVENTS;\nexports.CHANGE = eventUtils.CHANGE;\nexports.CLICK = eventUtils.CLICK;\nexports.COMMENT_CHANGE = eventUtils.COMMENT_CHANGE;\nexports.COMMENT_CREATE = eventUtils.COMMENT_CREATE;\nexports.COMMENT_DELETE = eventUtils.COMMENT_DELETE;\nexports.COMMENT_MOVE = eventUtils.COMMENT_MOVE;\nexports.CREATE = eventUtils.CREATE;\nexports.DELETE = eventUtils.DELETE;\nexports.FINISHED_LOADING = eventUtils.FINISHED_LOADING;\nexports.MARKER_MOVE = eventUtils.MARKER_MOVE;\nexports.MOVE = eventUtils.MOVE;\nexports.SELECTED = eventUtils.SELECTED;\nexports.THEME_CHANGE = eventUtils.THEME_CHANGE;\nexports.TOOLBOX_ITEM_SELECT = eventUtils.TOOLBOX_ITEM_SELECT;\nexports.TRASHCAN_OPEN = eventUtils.TRASHCAN_OPEN;\nexports.UI = eventUtils.UI;\nexports.VAR_CREATE = eventUtils.VAR_CREATE;\nexports.VAR_DELETE = eventUtils.VAR_DELETE;\nexports.VAR_RENAME = eventUtils.VAR_RENAME;\nexports.VIEWPORT_CHANGE = eventUtils.VIEWPORT_CHANGE;\n\n// Event utils.\nexports.clearPendingUndo = eventUtils.clearPendingUndo;\nexports.disable = eventUtils.disable;\nexports.enable = eventUtils.enable;\nexports.filter = eventUtils.filter;\nexports.fire = eventUtils.fire;\nexports.fromJson = eventUtils.fromJson;\nexports.getDescendantIds = eventUtils.getDescendantIds;\nexports.get = eventUtils.get;\nexports.getGroup = eventUtils.getGroup;\nexports.getRecordUndo = eventUtils.getRecordUndo;\nexports.isEnabled = eventUtils.isEnabled;\nexports.setGroup = eventUtils.setGroup;\nexports.setRecordUndo = eventUtils.setRecordUndo;\nexports.disableOrphans = eventUtils.disableOrphans;\n\nObject.defineProperties(exports, {\n  /**\n   * Sets whether the next event should be added to the undo stack.\n   * @name Blockly.Evenents.recordUndo\n   * @type {boolean}\n   * @deprecated Use Blockly.Events.getRecordUndo() and\n   *     .setRecordUndo().  (September 2021)\n   * @suppress {checkTypes}\n   */\n  recordUndo: {\n    get: function() {\n      deprecation.warn(\n          'Blockly.Events.recordUndo', 'September 2021', 'September 2022',\n          'Blockly.Events.getRecordUndo()');\n      return eventUtils.getRecordUndo();\n    },\n    set: function(record) {\n      deprecation.warn(\n          'Blockly.Events.recordUndo', 'September 2021', 'September 2022',\n          'Blockly.Events.setRecordUndo()');\n      eventUtils.setRecordUndo(record);\n    },\n  },\n});\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events.js?")},
"./core/events/events_abstract.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Abstract class for events fired as a result of actions in\n * Blockly's editor.\n */\n\n\n/**\n * Abstract class for events fired as a result of actions in\n * Blockly's editor.\n * @class\n */\ngoog.module('Blockly.Events.Abstract');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\n/* eslint-disable-next-line no-unused-vars */\nconst {Workspace} = goog.requireType('Blockly.Workspace');\n\n\n/**\n * Abstract class for an event.\n * @abstract\n * @alias Blockly.Events.Abstract\n */\nclass Abstract {\n  /**\n   * @alias Blockly.Events.Abstract\n   */\n  constructor() {\n    /**\n     * Whether or not the event is blank (to be populated by fromJson).\n     * @type {?boolean}\n     */\n    this.isBlank = null;\n\n    /**\n     * The workspace identifier for this event.\n     * @type {string|undefined}\n     */\n    this.workspaceId = undefined;\n\n    /**\n     * The event group id for the group this event belongs to. Groups define\n     * events that should be treated as an single action from the user's\n     * perspective, and should be undone together.\n     * @type {string}\n     */\n    this.group = eventUtils.getGroup();\n\n    /**\n     * Sets whether the event should be added to the undo stack.\n     * @type {boolean}\n     */\n    this.recordUndo = eventUtils.getRecordUndo();\n\n    /**\n     * Whether or not the event is a UI event.\n     * @type {boolean}\n     */\n    this.isUiEvent = false;\n\n    /**\n     * Type of this event.\n     * @type {string|undefined}\n     */\n    this.type = undefined;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = {'type': this.type};\n    if (this.group) {\n      json['group'] = this.group;\n    }\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    this.isBlank = false;\n    this.group = json['group'];\n  }\n\n  /**\n   * Does this event record any change of state?\n   * @return {boolean} True if null, false if something changed.\n   */\n  isNull() {\n    return false;\n  }\n\n  /**\n   * Run an event.\n   * @param {boolean} _forward True if run forward, false if run backward\n   *     (undo).\n   */\n  run(_forward) {\n    // Defined by subclasses.\n  }\n\n  /**\n   * Get workspace the event belongs to.\n   * @return {!Workspace} The workspace the event belongs to.\n   * @throws {Error} if workspace is null.\n   * @protected\n   */\n  getEventWorkspace_() {\n    let workspace;\n    if (this.workspaceId) {\n      const {Workspace} = goog.module.get('Blockly.Workspace');\n      workspace = Workspace.getById(this.workspaceId);\n    }\n    if (!workspace) {\n      throw Error(\n          'Workspace is null. Event must have been generated from real' +\n          ' Blockly events.');\n    }\n    return workspace;\n  }\n}\n\nexports.Abstract = Abstract;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_abstract.js?")},
"./core/events/events_block_base.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/events_abstract.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Base class for all types of block events.\n */\n\n\n/**\n * Base class for all types of block events.\n * @class\n */\ngoog.module('Blockly.Events.BlockBase');\n\nconst {Abstract: AbstractEvent} = goog.require('Blockly.Events.Abstract');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\n\n\n/**\n * Abstract class for a block event.\n * @extends {AbstractEvent}\n * @alias Blockly.Events.BlockBase\n */\nclass BlockBase extends AbstractEvent {\n  /**\n   * @param {!Block=} opt_block The block this event corresponds to.\n   *     Undefined for a blank event.\n   */\n  constructor(opt_block) {\n    super();\n    this.isBlank = typeof opt_block === 'undefined';\n\n    /**\n     * The block ID for the block this event pertains to\n     * @type {string}\n     */\n    this.blockId = this.isBlank ? '' : opt_block.id;\n\n    /**\n     * The workspace identifier for this event.\n     * @type {string}\n     */\n    this.workspaceId = this.isBlank ? '' : opt_block.workspace.id;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['blockId'] = this.blockId;\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.blockId = json['blockId'];\n  }\n}\n\nexports.BlockBase = BlockBase;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_block_base.js?")},
"./core/events/events_block_change.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/xml.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_block_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class for a block change event.\n */\n\n\n/**\n * Class for a block change event.\n * @class\n */\ngoog.module('Blockly.Events.BlockChange');\n\nconst Xml = goog.require('Blockly.Xml');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst {BlockBase} = goog.require('Blockly.Events.BlockBase');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\n\n\n/**\n * Class for a block change event.\n * @extends {BlockBase}\n * @alias Blockly.Events.BlockChange\n */\nclass BlockChange extends BlockBase {\n  /**\n   * @param {!Block=} opt_block The changed block.  Undefined for a blank\n   *     event.\n   * @param {string=} opt_element One of 'field', 'comment', 'disabled', etc.\n   * @param {?string=} opt_name Name of input or field affected, or null.\n   * @param {*=} opt_oldValue Previous value of element.\n   * @param {*=} opt_newValue New value of element.\n   */\n  constructor(opt_block, opt_element, opt_name, opt_oldValue, opt_newValue) {\n    super(opt_block);\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.BLOCK_CHANGE;\n\n    if (!opt_block) {\n      return;  // Blank event to be populated by fromJson.\n    }\n    this.element = typeof opt_element === 'undefined' ? '' : opt_element;\n    this.name = typeof opt_name === 'undefined' ? '' : opt_name;\n    this.oldValue = typeof opt_oldValue === 'undefined' ? '' : opt_oldValue;\n    this.newValue = typeof opt_newValue === 'undefined' ? '' : opt_newValue;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['element'] = this.element;\n    if (this.name) {\n      json['name'] = this.name;\n    }\n    json['oldValue'] = this.oldValue;\n    json['newValue'] = this.newValue;\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.element = json['element'];\n    this.name = json['name'];\n    this.oldValue = json['oldValue'];\n    this.newValue = json['newValue'];\n  }\n\n  /**\n   * Does this event record any change of state?\n   * @return {boolean} False if something changed.\n   */\n  isNull() {\n    return this.oldValue === this.newValue;\n  }\n\n  /**\n   * Run a change event.\n   * @param {boolean} forward True if run forward, false if run backward (undo).\n   */\n  run(forward) {\n    const workspace = this.getEventWorkspace_();\n    const block = workspace.getBlockById(this.blockId);\n    if (!block) {\n      console.warn('Can\\'t change non-existent block: ' + this.blockId);\n      return;\n    }\n\n    // Assume the block is rendered so that then we can check.\n    const blockSvg = /** @type {!BlockSvg} */ (block);\n    if (blockSvg.mutator) {\n      // Close the mutator (if open) since we don't want to update it.\n      blockSvg.mutator.setVisible(false);\n    }\n    const value = forward ? this.newValue : this.oldValue;\n    switch (this.element) {\n      case 'field': {\n        const field = block.getField(this.name);\n        if (field) {\n          field.setValue(value);\n        } else {\n          console.warn('Can\\'t set non-existent field: ' + this.name);\n        }\n        break;\n      }\n      case 'comment':\n        block.setCommentText(/** @type {string} */ (value) || null);\n        break;\n      case 'collapsed':\n        block.setCollapsed(!!value);\n        break;\n      case 'disabled':\n        block.setEnabled(!value);\n        break;\n      case 'inline':\n        block.setInputsInline(!!value);\n        break;\n      case 'mutation': {\n        const oldState = BlockChange.getExtraBlockState_(\n            /** @type {!BlockSvg} */ (block));\n        if (block.loadExtraState) {\n          block.loadExtraState(\n              JSON.parse(/** @type {string} */ (value) || '{}'));\n        } else if (block.domToMutation) {\n          block.domToMutation(\n              Xml.textToDom(/** @type {string} */ (value) || '<mutation/>'));\n        }\n        eventUtils.fire(\n            new BlockChange(block, 'mutation', null, oldState, value));\n        break;\n      }\n      default:\n        console.warn('Unknown change type: ' + this.element);\n    }\n  }\n\n  // TODO (#5397): Encapsulate this in the BlocklyMutationChange event when\n  //    refactoring change events.\n  /**\n   * Returns the extra state of the given block (either as XML or a JSO,\n   * depending on the block's definition).\n   * @param {!BlockSvg} block The block to get the extra state of.\n   * @return {string} A stringified version of the extra state of the given\n   *     block.\n   * @package\n   */\n  static getExtraBlockState_(block) {\n    if (block.saveExtraState) {\n      const state = block.saveExtraState();\n      return state ? JSON.stringify(state) : '';\n    } else if (block.mutationToDom) {\n      const state = block.mutationToDom();\n      return state ? Xml.domToText(state) : '';\n    }\n    return '';\n  }\n}\n\nregistry.register(registry.Type.EVENT, eventUtils.CHANGE, BlockChange);\n\nexports.BlockChange = BlockChange;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_block_change.js?")},
"./core/events/events_block_create.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/xml.js\");\n__webpack_require__(\"./core/serialization/blocks.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_block_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class for a block creation event.\n */\n\n\n/**\n * Class for a block creation event.\n * @class\n */\ngoog.module('Blockly.Events.BlockCreate');\n\nconst Xml = goog.require('Blockly.Xml');\nconst blocks = goog.require('Blockly.serialization.blocks');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst {BlockBase} = goog.require('Blockly.Events.BlockBase');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\n\n\n/**\n * Class for a block creation event.\n * @extends {BlockBase}\n * @alias Blockly.Events.BlockCreate\n */\nclass BlockCreate extends BlockBase {\n  /**\n   * @param {!Block=} opt_block The created block.  Undefined for a blank\n   *     event.\n   */\n  constructor(opt_block) {\n    super(opt_block);\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.BLOCK_CREATE;\n\n    if (!opt_block) {\n      return;  // Blank event to be populated by fromJson.\n    }\n    if (opt_block.isShadow()) {\n      // Moving shadow blocks is handled via disconnection.\n      this.recordUndo = false;\n    }\n\n    this.xml = Xml.blockToDomWithXY(opt_block);\n    this.ids = eventUtils.getDescendantIds(opt_block);\n\n    /**\n     * JSON representation of the block that was just created.\n     * @type {!blocks.State}\n     */\n    this.json = /** @type {!blocks.State} */ (\n        blocks.save(opt_block, {addCoordinates: true}));\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['xml'] = Xml.domToText(this.xml);\n    json['ids'] = this.ids;\n    json['json'] = this.json;\n    if (!this.recordUndo) {\n      json['recordUndo'] = this.recordUndo;\n    }\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.xml = Xml.textToDom(json['xml']);\n    this.ids = json['ids'];\n    this.json = /** @type {!blocks.State} */ (json['json']);\n    if (json['recordUndo'] !== undefined) {\n      this.recordUndo = json['recordUndo'];\n    }\n  }\n\n  /**\n   * Run a creation event.\n   * @param {boolean} forward True if run forward, false if run backward (undo).\n   */\n  run(forward) {\n    const workspace = this.getEventWorkspace_();\n    if (forward) {\n      blocks.append(this.json, workspace);\n    } else {\n      for (let i = 0; i < this.ids.length; i++) {\n        const id = this.ids[i];\n        const block = workspace.getBlockById(id);\n        if (block) {\n          block.dispose(false);\n        } else if (id === this.blockId) {\n          // Only complain about root-level block.\n          console.warn('Can\\'t uncreate non-existent block: ' + id);\n        }\n      }\n    }\n  }\n}\n\nregistry.register(registry.Type.EVENT, eventUtils.CREATE, BlockCreate);\n\nexports.BlockCreate = BlockCreate;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_block_create.js?")},
"./core/events/events_block_delete.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/xml.js\");\n__webpack_require__(\"./core/serialization/blocks.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_block_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class for a block delete event.\n */\n\n\n/**\n * Class for a block delete event.\n * @class\n */\ngoog.module('Blockly.Events.BlockDelete');\n\nconst Xml = goog.require('Blockly.Xml');\nconst blocks = goog.require('Blockly.serialization.blocks');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst {BlockBase} = goog.require('Blockly.Events.BlockBase');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\n\n\n/**\n * Class for a block deletion event.\n * @extends {BlockBase}\n * @alias Blockly.Events.BlockDelete\n */\nclass BlockDelete extends BlockBase {\n  /**\n   * @param {!Block=} opt_block The deleted block.  Undefined for a blank\n   *     event.\n   */\n  constructor(opt_block) {\n    super(opt_block);\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.BLOCK_DELETE;\n\n    if (!opt_block) {\n      return;  // Blank event to be populated by fromJson.\n    }\n    if (opt_block.getParent()) {\n      throw Error('Connected blocks cannot be deleted.');\n    }\n    if (opt_block.isShadow()) {\n      // Respawning shadow blocks is handled via disconnection.\n      this.recordUndo = false;\n    }\n\n    this.oldXml = Xml.blockToDomWithXY(opt_block);\n    this.ids = eventUtils.getDescendantIds(opt_block);\n\n    /**\n     * Was the block that was just deleted a shadow?\n     * @type {boolean}\n     */\n    this.wasShadow = opt_block.isShadow();\n\n    /**\n     * JSON representation of the block that was just deleted.\n     * @type {!blocks.State}\n     */\n    this.oldJson = /** @type {!blocks.State} */ (\n        blocks.save(opt_block, {addCoordinates: true}));\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['oldXml'] = Xml.domToText(this.oldXml);\n    json['ids'] = this.ids;\n    json['wasShadow'] = this.wasShadow;\n    json['oldJson'] = this.oldJson;\n    if (!this.recordUndo) {\n      json['recordUndo'] = this.recordUndo;\n    }\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.oldXml = Xml.textToDom(json['oldXml']);\n    this.ids = json['ids'];\n    this.wasShadow =\n        json['wasShadow'] || this.oldXml.tagName.toLowerCase() === 'shadow';\n    this.oldJson = /** @type {!blocks.State} */ (json['oldJson']);\n    if (json['recordUndo'] !== undefined) {\n      this.recordUndo = json['recordUndo'];\n    }\n  }\n\n  /**\n   * Run a deletion event.\n   * @param {boolean} forward True if run forward, false if run backward (undo).\n   */\n  run(forward) {\n    const workspace = this.getEventWorkspace_();\n    if (forward) {\n      for (let i = 0; i < this.ids.length; i++) {\n        const id = this.ids[i];\n        const block = workspace.getBlockById(id);\n        if (block) {\n          block.dispose(false);\n        } else if (id === this.blockId) {\n          // Only complain about root-level block.\n          console.warn('Can\\'t delete non-existent block: ' + id);\n        }\n      }\n    } else {\n      blocks.append(this.oldJson, workspace);\n    }\n  }\n}\n\nregistry.register(registry.Type.EVENT, eventUtils.DELETE, BlockDelete);\n\nexports.BlockDelete = BlockDelete;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_block_delete.js?")},
"./core/events/events_block_drag.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_ui_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Events fired as a block drag.\n */\n\n\n/**\n * Events fired as a block drag.\n * @class\n */\ngoog.module('Blockly.Events.BlockDrag');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\nconst {UiBase} = goog.require('Blockly.Events.UiBase');\n\n\n/**\n * Class for a block drag event.\n * @extends {UiBase}\n * @alias Blockly.Events.BlockDrag\n */\nclass BlockDrag extends UiBase {\n  /**\n   * @param {!Block=} opt_block The top block in the stack that is being\n   *    dragged. Undefined for a blank event.\n   * @param {boolean=} opt_isStart Whether this is the start of a block drag.\n   *    Undefined for a blank event.\n   * @param {!Array<!Block>=} opt_blocks The blocks affected by this\n   *    drag. Undefined for a blank event.\n   */\n  constructor(opt_block, opt_isStart, opt_blocks) {\n    const workspaceId = opt_block ? opt_block.workspace.id : undefined;\n    super(workspaceId);\n    this.blockId = opt_block ? opt_block.id : null;\n\n    /**\n     * Whether this is the start of a block drag.\n     * @type {boolean|undefined}\n     */\n    this.isStart = opt_isStart;\n\n    /**\n     * The blocks affected by this drag event.\n     * @type {!Array<!Block>|undefined}\n     */\n    this.blocks = opt_blocks;\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.BLOCK_DRAG;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['isStart'] = this.isStart;\n    json['blockId'] = this.blockId;\n    json['blocks'] = this.blocks;\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.isStart = json['isStart'];\n    this.blockId = json['blockId'];\n    this.blocks = json['blocks'];\n  }\n}\n\nregistry.register(registry.Type.EVENT, eventUtils.BLOCK_DRAG, BlockDrag);\n\nexports.BlockDrag = BlockDrag;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_block_drag.js?")},
"./core/events/events_block_move.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_block_base.js\");\n__webpack_require__(\"./core/connection_type.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class for a block move event.\n */\n\n\n/**\n * Class for a block move event.\n * @class\n */\ngoog.module('Blockly.Events.BlockMove');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst {BlockBase} = goog.require('Blockly.Events.BlockBase');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\nconst {ConnectionType} = goog.require('Blockly.ConnectionType');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\n\n\n/**\n * Class for a block move event.  Created before the move.\n * @extends {BlockBase}\n * @alias Blockly.Events.BlockMove\n */\nclass BlockMove extends BlockBase {\n  /**\n   * @param {!Block=} opt_block The moved block.  Undefined for a blank\n   *     event.\n   */\n  constructor(opt_block) {\n    super(opt_block);\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.BLOCK_MOVE;\n\n    if (!opt_block) {\n      return;  // Blank event to be populated by fromJson.\n    }\n    if (opt_block.isShadow()) {\n      // Moving shadow blocks is handled via disconnection.\n      this.recordUndo = false;\n    }\n\n    const location = this.currentLocation_();\n    this.oldParentId = location.parentId;\n    this.oldInputName = location.inputName;\n    this.oldCoordinate = location.coordinate;\n\n    this.newParentId = null;\n    this.newInputName = null;\n    this.newCoordinate = null;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    if (this.newParentId) {\n      json['newParentId'] = this.newParentId;\n    }\n    if (this.newInputName) {\n      json['newInputName'] = this.newInputName;\n    }\n    if (this.newCoordinate) {\n      json['newCoordinate'] = Math.round(this.newCoordinate.x) + ',' +\n          Math.round(this.newCoordinate.y);\n    }\n    if (!this.recordUndo) {\n      json['recordUndo'] = this.recordUndo;\n    }\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.newParentId = json['newParentId'];\n    this.newInputName = json['newInputName'];\n    if (json['newCoordinate']) {\n      const xy = json['newCoordinate'].split(',');\n      this.newCoordinate = new Coordinate(Number(xy[0]), Number(xy[1]));\n    }\n    if (json['recordUndo'] !== undefined) {\n      this.recordUndo = json['recordUndo'];\n    }\n  }\n\n  /**\n   * Record the block's new location.  Called after the move.\n   */\n  recordNew() {\n    const location = this.currentLocation_();\n    this.newParentId = location.parentId;\n    this.newInputName = location.inputName;\n    this.newCoordinate = location.coordinate;\n  }\n\n  /**\n   * Returns the parentId and input if the block is connected,\n   *   or the XY location if disconnected.\n   * @return {!Object} Collection of location info.\n   * @private\n   */\n  currentLocation_() {\n    const workspace = this.getEventWorkspace_();\n    const block = workspace.getBlockById(this.blockId);\n    const location = {};\n    const parent = block.getParent();\n    if (parent) {\n      location.parentId = parent.id;\n      const input = parent.getInputWithBlock(block);\n      if (input) {\n        location.inputName = input.name;\n      }\n    } else {\n      location.coordinate = block.getRelativeToSurfaceXY();\n    }\n    return location;\n  }\n\n  /**\n   * Does this event record any change of state?\n   * @return {boolean} False if something changed.\n   */\n  isNull() {\n    return this.oldParentId === this.newParentId &&\n        this.oldInputName === this.newInputName &&\n        Coordinate.equals(this.oldCoordinate, this.newCoordinate);\n  }\n\n  /**\n   * Run a move event.\n   * @param {boolean} forward True if run forward, false if run backward (undo).\n   */\n  run(forward) {\n    const workspace = this.getEventWorkspace_();\n    const block = workspace.getBlockById(this.blockId);\n    if (!block) {\n      console.warn('Can\\'t move non-existent block: ' + this.blockId);\n      return;\n    }\n    const parentId = forward ? this.newParentId : this.oldParentId;\n    const inputName = forward ? this.newInputName : this.oldInputName;\n    const coordinate = forward ? this.newCoordinate : this.oldCoordinate;\n    let parentBlock;\n    if (parentId) {\n      parentBlock = workspace.getBlockById(parentId);\n      if (!parentBlock) {\n        console.warn('Can\\'t connect to non-existent block: ' + parentId);\n        return;\n      }\n    }\n    if (block.getParent()) {\n      block.unplug();\n    }\n    if (coordinate) {\n      const xy = block.getRelativeToSurfaceXY();\n      block.moveBy(coordinate.x - xy.x, coordinate.y - xy.y);\n    } else {\n      let blockConnection = block.outputConnection;\n      if (!blockConnection ||\n          (block.previousConnection &&\n           block.previousConnection.isConnected())) {\n        blockConnection = block.previousConnection;\n      }\n      let parentConnection;\n      const connectionType = blockConnection.type;\n      if (inputName) {\n        const input = parentBlock.getInput(inputName);\n        if (input) {\n          parentConnection = input.connection;\n        }\n      } else if (connectionType === ConnectionType.PREVIOUS_STATEMENT) {\n        parentConnection = parentBlock.nextConnection;\n      }\n      if (parentConnection) {\n        blockConnection.connect(parentConnection);\n      } else {\n        console.warn('Can\\'t connect to non-existent input: ' + inputName);\n      }\n    }\n  }\n}\n\nregistry.register(registry.Type.EVENT, eventUtils.MOVE, BlockMove);\n\nexports.BlockMove = BlockMove;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_block_move.js?")},
"./core/events/events_bubble_open.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_ui_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Events fired as a result of bubble open.\n */\n\n\n/**\n * Events fired as a result of bubble open.\n * @class\n */\ngoog.module('Blockly.Events.BubbleOpen');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {UiBase} = goog.require('Blockly.Events.UiBase');\n\n\n/**\n * Class for a bubble open event.\n * @extends {UiBase}\n * @alias Blockly.Events.BubbleOpen\n */\nclass BubbleOpen extends UiBase {\n  /**\n   * @param {BlockSvg} opt_block The associated block. Undefined for a\n   *    blank event.\n   * @param {boolean=} opt_isOpen Whether the bubble is opening (false if\n   *    closing). Undefined for a blank event.\n   * @param {string=} opt_bubbleType The type of bubble. One of 'mutator',\n   *     'comment'\n   *    or 'warning'. Undefined for a blank event.\n   */\n  constructor(opt_block, opt_isOpen, opt_bubbleType) {\n    const workspaceId = opt_block ? opt_block.workspace.id : undefined;\n    super(workspaceId);\n    this.blockId = opt_block ? opt_block.id : null;\n\n    /**\n     * Whether the bubble is opening (false if closing).\n     * @type {boolean|undefined}\n     */\n    this.isOpen = opt_isOpen;\n\n    /**\n     * The type of bubble. One of 'mutator', 'comment', or 'warning'.\n     * @type {string|undefined}\n     */\n    this.bubbleType = opt_bubbleType;\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.BUBBLE_OPEN;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['isOpen'] = this.isOpen;\n    json['bubbleType'] = this.bubbleType;\n    json['blockId'] = this.blockId;\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.isOpen = json['isOpen'];\n    this.bubbleType = json['bubbleType'];\n    this.blockId = json['blockId'];\n  }\n}\n\nregistry.register(registry.Type.EVENT, eventUtils.BUBBLE_OPEN, BubbleOpen);\n\nexports.BubbleOpen = BubbleOpen;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_bubble_open.js?")},
"./core/events/events_click.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_ui_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Events fired as a result of UI click in Blockly's editor.\n */\n\n\n/**\n * Events fired as a result of UI click in Blockly's editor.\n * @class\n */\ngoog.module('Blockly.Events.Click');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\nconst {UiBase} = goog.require('Blockly.Events.UiBase');\n\n\n/**\n * Class for a click event.\n * @extends {UiBase}\n * @alias Blockly.Events.Click\n */\nclass Click extends UiBase {\n  /**\n   * @param {?Block=} opt_block The affected block. Null for click events\n   *    that do not have an associated block (i.e. workspace click). Undefined\n   *    for a blank event.\n   * @param {?string=} opt_workspaceId The workspace identifier for this event.\n   *    Not used if block is passed. Undefined for a blank event.\n   * @param {string=} opt_targetType The type of element targeted by this click\n   *    event. Undefined for a blank event.\n   */\n  constructor(opt_block, opt_workspaceId, opt_targetType) {\n    let workspaceId = opt_block ? opt_block.workspace.id : opt_workspaceId;\n    if (workspaceId === null) {\n      workspaceId = undefined;\n    }\n    super(workspaceId);\n    this.blockId = opt_block ? opt_block.id : null;\n\n    /**\n     * The type of element targeted by this click event.\n     * @type {string|undefined}\n     */\n    this.targetType = opt_targetType;\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.CLICK;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['targetType'] = this.targetType;\n    if (this.blockId) {\n      json['blockId'] = this.blockId;\n    }\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.targetType = json['targetType'];\n    this.blockId = json['blockId'];\n  }\n}\n\nregistry.register(registry.Type.EVENT, eventUtils.CLICK, Click);\n\nexports.Click = Click;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_click.js?")},
"./core/events/events_comment_base.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/xml.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/utils/xml.js\");\n__webpack_require__(\"./core/events/events_abstract.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Base class for comment events.\n */\n\n\n/**\n * Base class for comment events.\n * @class\n */\ngoog.module('Blockly.Events.CommentBase');\n\nconst Xml = goog.require('Blockly.Xml');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst utilsXml = goog.require('Blockly.utils.xml');\nconst {Abstract: AbstractEvent} = goog.require('Blockly.Events.Abstract');\n/* eslint-disable-next-line no-unused-vars */\nconst {CommentCreate} = goog.requireType('Blockly.Events.CommentCreate');\n/* eslint-disable-next-line no-unused-vars */\nconst {CommentDelete} = goog.requireType('Blockly.Events.CommentDelete');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceComment} = goog.requireType('Blockly.WorkspaceComment');\n\n\n/**\n * Abstract class for a comment event.\n * @extends {AbstractEvent}\n * @alias Blockly.Events.CommentBase\n */\nclass CommentBase extends AbstractEvent {\n  /**\n   * @param {!WorkspaceComment=} opt_comment The comment this event\n   *     corresponds to.  Undefined for a blank event.\n   */\n  constructor(opt_comment) {\n    super();\n    /**\n     * Whether or not an event is blank.\n     * @type {boolean}\n     */\n    this.isBlank = typeof opt_comment === 'undefined';\n\n    /**\n     * The ID of the comment this event pertains to.\n     * @type {string}\n     */\n    this.commentId = this.isBlank ? '' : opt_comment.id;\n\n    /**\n     * The workspace identifier for this event.\n     * @type {string}\n     */\n    this.workspaceId = this.isBlank ? '' : opt_comment.workspace.id;\n\n    /**\n     * The event group id for the group this event belongs to. Groups define\n     * events that should be treated as an single action from the user's\n     * perspective, and should be undone together.\n     * @type {string}\n     */\n    this.group = eventUtils.getGroup();\n\n    /**\n     * Sets whether the event should be added to the undo stack.\n     * @type {boolean}\n     */\n    this.recordUndo = eventUtils.getRecordUndo();\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    if (this.commentId) {\n      json['commentId'] = this.commentId;\n    }\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.commentId = json['commentId'];\n  }\n\n  /**\n   * Helper function for Comment[Create|Delete]\n   * @param {!CommentCreate|!CommentDelete} event\n   *     The event to run.\n   * @param {boolean} create if True then Create, if False then Delete\n   */\n  static CommentCreateDeleteHelper(event, create) {\n    const workspace = event.getEventWorkspace_();\n    if (create) {\n      const xmlElement = utilsXml.createElement('xml');\n      xmlElement.appendChild(event.xml);\n      Xml.domToWorkspace(xmlElement, workspace);\n    } else {\n      const comment = workspace.getCommentById(event.commentId);\n      if (comment) {\n        comment.dispose();\n      } else {\n        // Only complain about root-level block.\n        console.warn(\n            'Can\\'t uncreate non-existent comment: ' + event.commentId);\n      }\n    }\n  }\n}\n\nexports.CommentBase = CommentBase;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_comment_base.js?")},
"./core/events/events_comment_change.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_comment_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class for comment change event.\n */\n\n\n/**\n * Class for comment change event.\n * @class\n */\ngoog.module('Blockly.Events.CommentChange');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst {CommentBase} = goog.require('Blockly.Events.CommentBase');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceComment} = goog.requireType('Blockly.WorkspaceComment');\n\n\n/**\n * Class for a comment change event.\n * @extends {CommentBase}\n * @alias Blockly.Events.CommentChange\n */\nclass CommentChange extends CommentBase {\n  /**\n   * @param {!WorkspaceComment=} opt_comment The comment that is being\n   *     changed.  Undefined for a blank event.\n   * @param {string=} opt_oldContents Previous contents of the comment.\n   * @param {string=} opt_newContents New contents of the comment.\n   */\n  constructor(opt_comment, opt_oldContents, opt_newContents) {\n    super(opt_comment);\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.COMMENT_CHANGE;\n\n    if (!opt_comment) {\n      return;  // Blank event to be populated by fromJson.\n    }\n\n    this.oldContents_ =\n        typeof opt_oldContents === 'undefined' ? '' : opt_oldContents;\n    this.newContents_ =\n        typeof opt_newContents === 'undefined' ? '' : opt_newContents;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['oldContents'] = this.oldContents_;\n    json['newContents'] = this.newContents_;\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.oldContents_ = json['oldContents'];\n    this.newContents_ = json['newContents'];\n  }\n\n  /**\n   * Does this event record any change of state?\n   * @return {boolean} False if something changed.\n   */\n  isNull() {\n    return this.oldContents_ === this.newContents_;\n  }\n\n  /**\n   * Run a change event.\n   * @param {boolean} forward True if run forward, false if run backward (undo).\n   */\n  run(forward) {\n    const workspace = this.getEventWorkspace_();\n    const comment = workspace.getCommentById(this.commentId);\n    if (!comment) {\n      console.warn('Can\\'t change non-existent comment: ' + this.commentId);\n      return;\n    }\n    const contents = forward ? this.newContents_ : this.oldContents_;\n\n    comment.setContent(contents);\n  }\n}\n\nregistry.register(\n    registry.Type.EVENT, eventUtils.COMMENT_CHANGE, CommentChange);\n\nexports.CommentChange = CommentChange;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_comment_change.js?")},
"./core/events/events_comment_create.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/xml.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_comment_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class for comment creation event.\n */\n\n\n/**\n * Class for comment creation event.\n * @class\n */\ngoog.module('Blockly.Events.CommentCreate');\n\nconst Xml = goog.require('Blockly.Xml');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst {CommentBase} = goog.require('Blockly.Events.CommentBase');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceComment} = goog.requireType('Blockly.WorkspaceComment');\n\n\n/**\n * Class for a comment creation event.\n * @extends {CommentBase}\n * @alias Blockly.Events.CommentCreate\n */\nclass CommentCreate extends CommentBase {\n  /**\n   * @param {!WorkspaceComment=} opt_comment The created comment.\n   *     Undefined for a blank event.\n   */\n  constructor(opt_comment) {\n    super(opt_comment);\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.COMMENT_CREATE;\n\n    if (!opt_comment) {\n      return;  // Blank event to be populated by fromJson.\n    }\n\n    this.xml = opt_comment.toXmlWithXY();\n  }\n\n  // TODO (#1266): \"Full\" and \"minimal\" serialization.\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['xml'] = Xml.domToText(this.xml);\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.xml = Xml.textToDom(json['xml']);\n  }\n\n  /**\n   * Run a creation event.\n   * @param {boolean} forward True if run forward, false if run backward (undo).\n   */\n  run(forward) {\n    CommentBase.CommentCreateDeleteHelper(this, forward);\n  }\n}\n\nregistry.register(\n    registry.Type.EVENT, eventUtils.COMMENT_CREATE, CommentCreate);\n\nexports.CommentCreate = CommentCreate;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_comment_create.js?")},
"./core/events/events_comment_delete.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_comment_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class for comment deletion event.\n */\n\n\n/**\n * Class for comment deletion event.\n * @class\n */\ngoog.module('Blockly.Events.CommentDelete');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst {CommentBase} = goog.require('Blockly.Events.CommentBase');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceComment} = goog.requireType('Blockly.WorkspaceComment');\n\n\n/**\n * Class for a comment deletion event.\n * @extends {CommentBase}\n * @alias Blockly.Events.CommentDelete\n */\nclass CommentDelete extends CommentBase {\n  /**\n   * @param {!WorkspaceComment=} opt_comment The deleted comment.\n   *     Undefined for a blank event.\n   */\n  constructor(opt_comment) {\n    super(opt_comment);\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.COMMENT_DELETE;\n\n    if (!opt_comment) {\n      return;  // Blank event to be populated by fromJson.\n    }\n\n    this.xml = opt_comment.toXmlWithXY();\n  }\n\n  // TODO (#1266): \"Full\" and \"minimal\" serialization.\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n  }\n\n  /**\n   * Run a creation event.\n   * @param {boolean} forward True if run forward, false if run backward (undo).\n   */\n  run(forward) {\n    CommentBase.CommentCreateDeleteHelper(this, !forward);\n  }\n}\n\nregistry.register(\n    registry.Type.EVENT, eventUtils.COMMENT_DELETE, CommentDelete);\n\nexports.CommentDelete = CommentDelete;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_comment_delete.js?")},
"./core/events/events_comment_move.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_comment_base.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class for comment move event.\n */\n\n\n/**\n * Class for comment move event.\n * @class\n */\ngoog.module('Blockly.Events.CommentMove');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst {CommentBase} = goog.require('Blockly.Events.CommentBase');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceComment} = goog.requireType('Blockly.WorkspaceComment');\n\n\n/**\n * Class for a comment move event.  Created before the move.\n * @extends {CommentBase}\n * @alias Blockly.Events.CommentMove\n */\nclass CommentMove extends CommentBase {\n  /**\n   * @param {!WorkspaceComment=} opt_comment The comment that is being\n   *     moved.  Undefined for a blank event.\n   */\n  constructor(opt_comment) {\n    super(opt_comment);\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.COMMENT_MOVE;\n\n    if (!opt_comment) {\n      return;  // Blank event to be populated by fromJson.\n    }\n\n    /**\n     * The comment that is being moved.  Will be cleared after recording the new\n     * location.\n     * @type {WorkspaceComment}\n     */\n    this.comment_ = opt_comment;\n\n    /**\n     * The location before the move, in workspace coordinates.\n     * @type {!Coordinate}\n     */\n    this.oldCoordinate_ = opt_comment.getXY();\n\n    /**\n     * The location after the move, in workspace coordinates.\n     * @type {Coordinate}\n     */\n    this.newCoordinate_ = null;\n  }\n\n  /**\n   * Record the comment's new location.  Called after the move.  Can only be\n   * called once.\n   */\n  recordNew() {\n    if (!this.comment_) {\n      throw Error(\n          'Tried to record the new position of a comment on the ' +\n          'same event twice.');\n    }\n    this.newCoordinate_ = this.comment_.getXY();\n    this.comment_ = null;\n  }\n\n  /**\n   * Override the location before the move.  Use this if you don't create the\n   * event until the end of the move, but you know the original location.\n   * @param {!Coordinate} xy The location before the move,\n   *     in workspace coordinates.\n   */\n  setOldCoordinate(xy) {\n    this.oldCoordinate_ = xy;\n  }\n\n  // TODO (#1266): \"Full\" and \"minimal\" serialization.\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    if (this.oldCoordinate_) {\n      json['oldCoordinate'] = Math.round(this.oldCoordinate_.x) + ',' +\n          Math.round(this.oldCoordinate_.y);\n    }\n    if (this.newCoordinate_) {\n      json['newCoordinate'] = Math.round(this.newCoordinate_.x) + ',' +\n          Math.round(this.newCoordinate_.y);\n    }\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n\n    if (json['oldCoordinate']) {\n      const xy = json['oldCoordinate'].split(',');\n      this.oldCoordinate_ = new Coordinate(Number(xy[0]), Number(xy[1]));\n    }\n    if (json['newCoordinate']) {\n      const xy = json['newCoordinate'].split(',');\n      this.newCoordinate_ = new Coordinate(Number(xy[0]), Number(xy[1]));\n    }\n  }\n\n  /**\n   * Does this event record any change of state?\n   * @return {boolean} False if something changed.\n   */\n  isNull() {\n    return Coordinate.equals(this.oldCoordinate_, this.newCoordinate_);\n  }\n\n  /**\n   * Run a move event.\n   * @param {boolean} forward True if run forward, false if run backward (undo).\n   */\n  run(forward) {\n    const workspace = this.getEventWorkspace_();\n    const comment = workspace.getCommentById(this.commentId);\n    if (!comment) {\n      console.warn('Can\\'t move non-existent comment: ' + this.commentId);\n      return;\n    }\n\n    const target = forward ? this.newCoordinate_ : this.oldCoordinate_;\n    // TODO: Check if the comment is being dragged, and give up if so.\n    const current = comment.getXY();\n    comment.moveBy(target.x - current.x, target.y - current.y);\n  }\n}\n\nregistry.register(registry.Type.EVENT, eventUtils.COMMENT_MOVE, CommentMove);\n\nexports.CommentMove = CommentMove;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_comment_move.js?")},
"./core/events/events_marker_move.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/keyboard_nav/ast_node.js\");\n__webpack_require__(\"./core/events/events_ui_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Events fired as a result of a marker move.\n */\n\n\n/**\n * Events fired as a result of a marker move.\n * @class\n */\ngoog.module('Blockly.Events.MarkerMove');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst {ASTNode} = goog.require('Blockly.ASTNode');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\nconst {UiBase} = goog.require('Blockly.Events.UiBase');\n/* eslint-disable-next-line no-unused-vars */\nconst {Workspace} = goog.requireType('Blockly.Workspace');\n\n\n/**\n * Class for a marker move event.\n * @extends {UiBase}\n * @alias Blockly.Events.MarkerMove\n */\nclass MarkerMove extends UiBase {\n  /**\n   * @param {?Block=} opt_block The affected block. Null if current node\n   *    is of type workspace. Undefined for a blank event.\n   * @param {boolean=} isCursor Whether this is a cursor event. Undefined for a\n   *    blank event.\n   * @param {?ASTNode=} opt_oldNode The old node the marker used to be on.\n   *    Undefined for a blank event.\n   * @param {!ASTNode=} opt_newNode The new node the marker is now on.\n   *    Undefined for a blank event.\n   */\n  constructor(opt_block, isCursor, opt_oldNode, opt_newNode) {\n    let workspaceId = opt_block ? opt_block.workspace.id : undefined;\n    if (opt_newNode && opt_newNode.getType() === ASTNode.types.WORKSPACE) {\n      workspaceId = (/** @type {!Workspace} */ (opt_newNode.getLocation())).id;\n    }\n    super(workspaceId);\n\n    /**\n     * The workspace identifier for this event.\n     * @type {?string}\n     */\n    this.blockId = opt_block ? opt_block.id : null;\n\n    /**\n     * The old node the marker used to be on.\n     * @type {?ASTNode|undefined}\n     */\n    this.oldNode = opt_oldNode;\n\n    /**\n     * The new node the  marker is now on.\n     * @type {ASTNode|undefined}\n     */\n    this.newNode = opt_newNode;\n\n    /**\n     * Whether this is a cursor event.\n     * @type {boolean|undefined}\n     */\n    this.isCursor = isCursor;\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.MARKER_MOVE;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['isCursor'] = this.isCursor;\n    json['blockId'] = this.blockId;\n    json['oldNode'] = this.oldNode;\n    json['newNode'] = this.newNode;\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.isCursor = json['isCursor'];\n    this.blockId = json['blockId'];\n    this.oldNode = json['oldNode'];\n    this.newNode = json['newNode'];\n  }\n}\n\nregistry.register(registry.Type.EVENT, eventUtils.MARKER_MOVE, MarkerMove);\n\nexports.MarkerMove = MarkerMove;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_marker_move.js?")},
"./core/events/events_selected.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_ui_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Events fired as a result of element select action.\n */\n\n\n/**\n * Events fired as a result of element select action.\n * @class\n */\ngoog.module('Blockly.Events.Selected');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst {UiBase} = goog.require('Blockly.Events.UiBase');\n\n\n/**\n * Class for a selected event.\n * @extends {UiBase}\n * @alias Blockly.Events.Selected\n */\nclass Selected extends UiBase {\n  /**\n   * @param {?string=} opt_oldElementId The ID of the previously selected\n   *    element. Null if no element last selected. Undefined for a blank event.\n   * @param {?string=} opt_newElementId The ID of the selected element. Null if\n   *     no element currently selected (deselect). Undefined for a blank event.\n   * @param {string=} opt_workspaceId The workspace identifier for this event.\n   *    Null if no element previously selected. Undefined for a blank event.\n   */\n  constructor(opt_oldElementId, opt_newElementId, opt_workspaceId) {\n    super(opt_workspaceId);\n\n    /**\n     * The id of the last selected element.\n     * @type {?string|undefined}\n     */\n    this.oldElementId = opt_oldElementId;\n\n    /**\n     * The id of the selected element.\n     * @type {?string|undefined}\n     */\n    this.newElementId = opt_newElementId;\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.SELECTED;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['oldElementId'] = this.oldElementId;\n    json['newElementId'] = this.newElementId;\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.oldElementId = json['oldElementId'];\n    this.newElementId = json['newElementId'];\n  }\n}\n\nregistry.register(registry.Type.EVENT, eventUtils.SELECTED, Selected);\n\nexports.Selected = Selected;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_selected.js?")},
"./core/events/events_theme_change.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_ui_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Events fired as a result of a theme update.\n */\n\n\n/**\n * Events fired as a result of a theme update.\n * @class\n */\ngoog.module('Blockly.Events.ThemeChange');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst {UiBase} = goog.require('Blockly.Events.UiBase');\n\n\n/**\n * Class for a theme change event.\n * @extends {UiBase}\n * @alias Blockly.Events.ThemeChange\n */\nclass ThemeChange extends UiBase {\n  /**\n   * @param {string=} opt_themeName The theme name. Undefined for a blank event.\n   * @param {string=} opt_workspaceId The workspace identifier for this event.\n   *    event. Undefined for a blank event.\n   */\n  constructor(opt_themeName, opt_workspaceId) {\n    super(opt_workspaceId);\n\n    /**\n     * The theme name.\n     * @type {string|undefined}\n     */\n    this.themeName = opt_themeName;\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.THEME_CHANGE;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['themeName'] = this.themeName;\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.themeName = json['themeName'];\n  }\n}\n\nregistry.register(registry.Type.EVENT, eventUtils.THEME_CHANGE, ThemeChange);\n\nexports.ThemeChange = ThemeChange;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_theme_change.js?")},
"./core/events/events_toolbox_item_select.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_ui_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Events fired as a result of selecting an item on the toolbox.\n */\n\n\n/**\n * Events fired as a result of selecting an item on the toolbox.\n * @class\n */\ngoog.module('Blockly.Events.ToolboxItemSelect');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst {UiBase} = goog.require('Blockly.Events.UiBase');\n\n\n/**\n * Class for a toolbox item select event.\n * @extends {UiBase}\n * @alias Blockly.Events.ToolboxItemSelect\n */\nclass ToolboxItemSelect extends UiBase {\n  /**\n   * @param {?string=} opt_oldItem The previously selected toolbox item.\n   *     Undefined for a blank event.\n   * @param {?string=} opt_newItem The newly selected toolbox item. Undefined\n   *     for a blank event.\n   * @param {string=} opt_workspaceId The workspace identifier for this event.\n   *    Undefined for a blank event.\n   */\n  constructor(opt_oldItem, opt_newItem, opt_workspaceId) {\n    super(opt_workspaceId);\n\n    /**\n     * The previously selected toolbox item.\n     * @type {?string|undefined}\n     */\n    this.oldItem = opt_oldItem;\n\n    /**\n     * The newly selected toolbox item.\n     * @type {?string|undefined}\n     */\n    this.newItem = opt_newItem;\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.TOOLBOX_ITEM_SELECT;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['oldItem'] = this.oldItem;\n    json['newItem'] = this.newItem;\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.oldItem = json['oldItem'];\n    this.newItem = json['newItem'];\n  }\n}\n\nregistry.register(\n    registry.Type.EVENT, eventUtils.TOOLBOX_ITEM_SELECT, ToolboxItemSelect);\n\nexports.ToolboxItemSelect = ToolboxItemSelect;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_toolbox_item_select.js?")},
"./core/events/events_trashcan_open.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_ui_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Events fired as a result of trashcan flyout open and close.\n */\n\n\n/**\n * Events fired as a result of trashcan flyout open and close.\n * @class\n */\ngoog.module('Blockly.Events.TrashcanOpen');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst {UiBase} = goog.require('Blockly.Events.UiBase');\n\n\n/**\n * Class for a trashcan open event.\n * @extends {UiBase}\n * @alias Blockly.Events.TrashcanOpen\n */\nclass TrashcanOpen extends UiBase {\n  /**\n   * @param {boolean=} opt_isOpen Whether the trashcan flyout is opening (false\n   *     if opening). Undefined for a blank event.\n   * @param {string=} opt_workspaceId The workspace identifier for this event.\n   *    Undefined for a blank event.\n   */\n  constructor(opt_isOpen, opt_workspaceId) {\n    super(opt_workspaceId);\n\n    /**\n     * Whether the trashcan flyout is opening (false if closing).\n     * @type {boolean|undefined}\n     */\n    this.isOpen = opt_isOpen;\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.TRASHCAN_OPEN;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['isOpen'] = this.isOpen;\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.isOpen = json['isOpen'];\n  }\n}\n\nregistry.register(registry.Type.EVENT, eventUtils.TRASHCAN_OPEN, TrashcanOpen);\n\nexports.TrashcanOpen = TrashcanOpen;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_trashcan_open.js?")},
"./core/events/events_ui.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_ui_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview (Deprecated) Events fired as a result of UI actions in\n * Blockly's editor.\n */\n\n\n/**\n * (Deprecated) Events fired as a result of UI actions in\n * Blockly's editor.\n * @class\n */\ngoog.module('Blockly.Events.Ui');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\nconst {UiBase} = goog.require('Blockly.Events.UiBase');\n\n\n/**\n * Class for a UI event.\n * @extends {UiBase}\n * @deprecated December 2020. Instead use a more specific UI event.\n * @alias Blockly.Events.Ui\n */\nclass Ui extends UiBase {\n  /**\n   * @param {?Block=} opt_block The affected block.  Null for UI events\n   *     that do not have an associated block.  Undefined for a blank event.\n   * @param {string=} opt_element One of 'selected', 'comment', 'mutatorOpen',\n   *     etc.\n   * @param {*=} opt_oldValue Previous value of element.\n   * @param {*=} opt_newValue New value of element.\n   */\n  constructor(opt_block, opt_element, opt_oldValue, opt_newValue) {\n    const workspaceId = opt_block ? opt_block.workspace.id : undefined;\n    super(workspaceId);\n\n    this.blockId = opt_block ? opt_block.id : null;\n    this.element = typeof opt_element === 'undefined' ? '' : opt_element;\n    this.oldValue = typeof opt_oldValue === 'undefined' ? '' : opt_oldValue;\n    this.newValue = typeof opt_newValue === 'undefined' ? '' : opt_newValue;\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.UI;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['element'] = this.element;\n    if (this.newValue !== undefined) {\n      json['newValue'] = this.newValue;\n    }\n    if (this.blockId) {\n      json['blockId'] = this.blockId;\n    }\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.element = json['element'];\n    this.newValue = json['newValue'];\n    this.blockId = json['blockId'];\n  }\n}\n\nregistry.register(registry.Type.EVENT, eventUtils.UI, Ui);\n\nexports.Ui = Ui;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_ui.js?")},
"./core/events/events_ui_base.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/events_abstract.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Base class for events fired as a result of UI actions in\n * Blockly's editor.\n */\n\n\n/**\n * Base class for events fired as a result of UI actions in\n * Blockly's editor.\n * @class\n */\ngoog.module('Blockly.Events.UiBase');\n\nconst {Abstract: AbstractEvent} = goog.require('Blockly.Events.Abstract');\n\n\n/**\n * Base class for a UI event.\n * UI events are events that don't need to be sent over the wire for multi-user\n * editing to work (e.g. scrolling the workspace, zooming, opening toolbox\n * categories).\n * UI events do not undo or redo.\n * @extends {AbstractEvent}\n * @alias Blockly.Events.UiBase\n */\nclass UiBase extends AbstractEvent {\n  /**\n   * @param {string=} opt_workspaceId The workspace identifier for this event.\n   *    Undefined for a blank event.\n   */\n  constructor(opt_workspaceId) {\n    super();\n\n    /**\n     * Whether or not the event is blank (to be populated by fromJson).\n     * @type {boolean}\n     */\n    this.isBlank = typeof opt_workspaceId === 'undefined';\n\n    /**\n     * The workspace identifier for this event.\n     * @type {string}\n     */\n    this.workspaceId = opt_workspaceId ? opt_workspaceId : '';\n\n    // UI events do not undo or redo.\n    this.recordUndo = false;\n\n    /**\n     * Whether or not the event is a UI event.\n     * @type {boolean}\n     */\n    this.isUiEvent = true;\n  }\n}\n\nexports.UiBase = UiBase;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_ui_base.js?")},
"./core/events/events_var_base.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/events_abstract.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Abstract class for a variable event.\n */\n\n\n/**\n * Abstract class for a variable event.\n * @class\n */\ngoog.module('Blockly.Events.VarBase');\n\nconst {Abstract: AbstractEvent} = goog.require('Blockly.Events.Abstract');\n/* eslint-disable-next-line no-unused-vars */\nconst {VariableModel} = goog.requireType('Blockly.VariableModel');\n\n\n/**\n * Abstract class for a variable event.\n * @extends {AbstractEvent}\n * @alias Blockly.Events.VarBase\n */\nclass VarBase extends AbstractEvent {\n  /**\n   * @param {!VariableModel=} opt_variable The variable this event\n   *     corresponds to.  Undefined for a blank event.\n   */\n  constructor(opt_variable) {\n    super();\n    this.isBlank = typeof opt_variable === 'undefined';\n\n    /**\n     * The variable id for the variable this event pertains to.\n     * @type {string}\n     */\n    this.varId = this.isBlank ? '' : opt_variable.getId();\n\n    /**\n     * The workspace identifier for this event.\n     * @type {string}\n     */\n    this.workspaceId = this.isBlank ? '' : opt_variable.workspace.id;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['varId'] = this.varId;\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.varId = json['varId'];\n  }\n}\n\nexports.VarBase = VarBase;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_var_base.js?")},
"./core/events/events_var_create.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_var_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class for a variable creation event.\n */\n\n\n/**\n * Class for a variable creation event.\n * @class\n */\ngoog.module('Blockly.Events.VarCreate');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst {VarBase} = goog.require('Blockly.Events.VarBase');\n/* eslint-disable-next-line no-unused-vars */\nconst {VariableModel} = goog.requireType('Blockly.VariableModel');\n\n\n/**\n * Class for a variable creation event.\n * @extends {VarBase}\n * @alias Blockly.Events.VarCreate\n */\nclass VarCreate extends VarBase {\n  /**\n   * @param {!VariableModel=} opt_variable The created variable. Undefined\n   *     for a blank event.\n   */\n  constructor(opt_variable) {\n    super(opt_variable);\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.VAR_CREATE;\n\n    if (!opt_variable) {\n      return;  // Blank event to be populated by fromJson.\n    }\n\n    this.varType = opt_variable.type;\n    this.varName = opt_variable.name;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['varType'] = this.varType;\n    json['varName'] = this.varName;\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.varType = json['varType'];\n    this.varName = json['varName'];\n  }\n\n  /**\n   * Run a variable creation event.\n   * @param {boolean} forward True if run forward, false if run backward (undo).\n   */\n  run(forward) {\n    const workspace = this.getEventWorkspace_();\n    if (forward) {\n      workspace.createVariable(this.varName, this.varType, this.varId);\n    } else {\n      workspace.deleteVariableById(this.varId);\n    }\n  }\n}\n\nregistry.register(registry.Type.EVENT, eventUtils.VAR_CREATE, VarCreate);\n\nexports.VarCreate = VarCreate;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_var_create.js?")},
"./core/events/events_var_delete.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_var_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Classes for all types of variable events.\n */\n\n\n/**\n * Classes for all types of variable events.\n * @class\n */\ngoog.module('Blockly.Events.VarDelete');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst {VarBase} = goog.require('Blockly.Events.VarBase');\n/* eslint-disable-next-line no-unused-vars */\nconst {VariableModel} = goog.requireType('Blockly.VariableModel');\n\n\n/**\n * Class for a variable deletion event.\n * @extends {VarBase}\n * @alias Blockly.Events.VarDelete\n */\nclass VarDelete extends VarBase {\n  /**\n   * @param {!VariableModel=} opt_variable The deleted variable. Undefined\n   *     for a blank event.\n   */\n  constructor(opt_variable) {\n    super(opt_variable);\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.VAR_DELETE;\n\n    if (!opt_variable) {\n      return;  // Blank event to be populated by fromJson.\n    }\n\n    this.varType = opt_variable.type;\n    this.varName = opt_variable.name;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['varType'] = this.varType;\n    json['varName'] = this.varName;\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.varType = json['varType'];\n    this.varName = json['varName'];\n  }\n\n  /**\n   * Run a variable deletion event.\n   * @param {boolean} forward True if run forward, false if run backward (undo).\n   */\n  run(forward) {\n    const workspace = this.getEventWorkspace_();\n    if (forward) {\n      workspace.deleteVariableById(this.varId);\n    } else {\n      workspace.createVariable(this.varName, this.varType, this.varId);\n    }\n  }\n}\n\nregistry.register(registry.Type.EVENT, eventUtils.VAR_DELETE, VarDelete);\n\nexports.VarDelete = VarDelete;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_var_delete.js?")},
"./core/events/events_var_rename.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_var_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class for a variable rename event.\n */\n\n\n/**\n * Class for a variable rename event.\n * @class\n */\ngoog.module('Blockly.Events.VarRename');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst {VarBase} = goog.require('Blockly.Events.VarBase');\n/* eslint-disable-next-line no-unused-vars */\nconst {VariableModel} = goog.requireType('Blockly.VariableModel');\n\n\n/**\n * Class for a variable rename event.\n * @extends {VarBase}\n * @alias Blockly.Events.VarRename\n */\nclass VarRename extends VarBase {\n  /**\n   * @param {!VariableModel=} opt_variable The renamed variable. Undefined\n   *     for a blank event.\n   * @param {string=} newName The new name the variable will be changed to.\n   */\n  constructor(opt_variable, newName) {\n    super(opt_variable);\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.VAR_RENAME;\n\n    if (!opt_variable) {\n      return;  // Blank event to be populated by fromJson.\n    }\n\n    this.oldName = opt_variable.name;\n    this.newName = typeof newName === 'undefined' ? '' : newName;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['oldName'] = this.oldName;\n    json['newName'] = this.newName;\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.oldName = json['oldName'];\n    this.newName = json['newName'];\n  }\n\n  /**\n   * Run a variable rename event.\n   * @param {boolean} forward True if run forward, false if run backward (undo).\n   */\n  run(forward) {\n    const workspace = this.getEventWorkspace_();\n    if (forward) {\n      workspace.renameVariableById(this.varId, this.newName);\n    } else {\n      workspace.renameVariableById(this.varId, this.oldName);\n    }\n  }\n}\n\nregistry.register(registry.Type.EVENT, eventUtils.VAR_RENAME, VarRename);\n\nexports.VarRename = VarRename;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_var_rename.js?")},
"./core/events/events_viewport.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_ui_base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Events fired as a result of a viewport change.\n */\n\n\n/**\n * Events fired as a result of a viewport change.\n * @class\n */\ngoog.module('Blockly.Events.ViewportChange');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst {UiBase} = goog.require('Blockly.Events.UiBase');\n\n\n/**\n * Class for a viewport change event.\n * @extends {UiBase}\n * @alias Blockly.Events.ViewportChange\n */\nclass ViewportChange extends UiBase {\n  /**\n   * @param {number=} opt_top Top-edge of the visible portion of the workspace,\n   *    relative to the workspace origin. Undefined for a blank event.\n   * @param {number=} opt_left Left-edge of the visible portion of the\n   *     workspace relative to the workspace origin. Undefined for a blank\n   *     event.\n   * @param {number=} opt_scale The scale of the workspace. Undefined for a\n   *     blank event.\n   * @param {string=} opt_workspaceId The workspace identifier for this event.\n   *    Undefined for a blank event.\n   * @param {number=} opt_oldScale The old scale of the workspace. Undefined for\n   *     a blank event.\n   */\n  constructor(opt_top, opt_left, opt_scale, opt_workspaceId, opt_oldScale) {\n    super(opt_workspaceId);\n\n    /**\n     * Top-edge of the visible portion of the workspace, relative to the\n     * workspace origin.\n     * @type {number|undefined}\n     */\n    this.viewTop = opt_top;\n\n    /**\n     * Left-edge of the visible portion of the workspace, relative to the\n     * workspace origin.\n     * @type {number|undefined}\n     */\n    this.viewLeft = opt_left;\n\n    /**\n     * The scale of the workspace.\n     * @type {number|undefined}\n     */\n    this.scale = opt_scale;\n\n    /**\n     * The old scale of the workspace.\n     * @type {number|undefined}\n     */\n    this.oldScale = opt_oldScale;\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.VIEWPORT_CHANGE;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = super.toJson();\n    json['viewTop'] = this.viewTop;\n    json['viewLeft'] = this.viewLeft;\n    json['scale'] = this.scale;\n    json['oldScale'] = this.oldScale;\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    super.fromJson(json);\n    this.viewTop = json['viewTop'];\n    this.viewLeft = json['viewLeft'];\n    this.scale = json['scale'];\n    this.oldScale = json['oldScale'];\n  }\n}\n\nregistry.register(\n    registry.Type.EVENT, eventUtils.VIEWPORT_CHANGE, ViewportChange);\n\nexports.ViewportChange = ViewportChange;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/events_viewport.js?")},
"./core/events/utils.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/idgenerator.js\");\n__webpack_require__(\"./core/registry.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Helper methods for events that are fired as a result of\n * actions in Blockly's editor.\n */\n\n\n/**\n * Helper methods for events that are fired as a result of\n * actions in Blockly's editor.\n * @namespace Blockly.Events.utils\n */\ngoog.module('Blockly.Events.utils');\n\nconst idGenerator = goog.require('Blockly.utils.idGenerator');\nconst registry = goog.require('Blockly.registry');\n/* eslint-disable-next-line no-unused-vars */\nconst {Abstract} = goog.requireType('Blockly.Events.Abstract');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockChange} = goog.requireType('Blockly.Events.BlockChange');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockCreate} = goog.requireType('Blockly.Events.BlockCreate');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockMove} = goog.requireType('Blockly.Events.BlockMove');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\n/* eslint-disable-next-line no-unused-vars */\nconst {CommentCreate} = goog.requireType('Blockly.Events.CommentCreate');\n/* eslint-disable-next-line no-unused-vars */\nconst {CommentMove} = goog.requireType('Blockly.Events.CommentMove');\n/* eslint-disable-next-line no-unused-vars */\nconst {ViewportChange} = goog.requireType('Blockly.Events.ViewportChange');\n/* eslint-disable-next-line no-unused-vars */\nconst {Workspace} = goog.requireType('Blockly.Workspace');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * Group ID for new events.  Grouped events are indivisible.\n * @type {string}\n */\nlet group = '';\n\n/**\n * Sets whether the next event should be added to the undo stack.\n * @type {boolean}\n */\nlet recordUndo = true;\n\n/**\n * Sets whether events should be added to the undo stack.\n * @param {boolean} newValue True if events should be added to the undo stack.\n * @alias Blockly.Events.utils.setRecordUndo\n */\nconst setRecordUndo = function(newValue) {\n  recordUndo = newValue;\n};\nexports.setRecordUndo = setRecordUndo;\n\n/**\n * Returns whether or not events will be added to the undo stack.\n * @returns {boolean} True if events will be added to the undo stack.\n * @alias Blockly.Events.utils.getRecordUndo\n */\nconst getRecordUndo = function() {\n  return recordUndo;\n};\nexports.getRecordUndo = getRecordUndo;\n\n/**\n * Allow change events to be created and fired.\n * @type {number}\n */\nlet disabled = 0;\n\n/**\n * Name of event that creates a block. Will be deprecated for BLOCK_CREATE.\n * @const\n * @alias Blockly.Events.utils.CREATE\n */\nconst CREATE = 'create';\nexports.CREATE = CREATE;\n\n/**\n * Name of event that creates a block.\n * @const\n * @alias Blockly.Events.utils.BLOCK_CREATE\n */\nconst BLOCK_CREATE = CREATE;\nexports.BLOCK_CREATE = BLOCK_CREATE;\n\n/**\n * Name of event that deletes a block. Will be deprecated for BLOCK_DELETE.\n * @const\n * @alias Blockly.Events.utils.DELETE\n */\nconst DELETE = 'delete';\nexports.DELETE = DELETE;\n\n/**\n * Name of event that deletes a block.\n * @const\n * @alias Blockly.Events.utils.BLOCK_DELETE\n */\nconst BLOCK_DELETE = DELETE;\nexports.BLOCK_DELETE = BLOCK_DELETE;\n\n/**\n * Name of event that changes a block. Will be deprecated for BLOCK_CHANGE.\n * @const\n * @alias Blockly.Events.utils.CHANGE\n */\nconst CHANGE = 'change';\nexports.CHANGE = CHANGE;\n\n/**\n * Name of event that changes a block.\n * @const\n * @alias Blockly.Events.utils.BLOCK_CHANGE\n */\nconst BLOCK_CHANGE = CHANGE;\nexports.BLOCK_CHANGE = BLOCK_CHANGE;\n\n/**\n * Name of event that moves a block. Will be deprecated for BLOCK_MOVE.\n * @const\n * @alias Blockly.Events.utils.MOVE\n */\nconst MOVE = 'move';\nexports.MOVE = MOVE;\n\n/**\n * Name of event that moves a block.\n * @const\n * @alias Blockly.Events.utils.BLOCK_MOVE\n */\nconst BLOCK_MOVE = MOVE;\nexports.BLOCK_MOVE = BLOCK_MOVE;\n\n/**\n * Name of event that creates a variable.\n * @const\n * @alias Blockly.Events.utils.VAR_CREATE\n */\nconst VAR_CREATE = 'var_create';\nexports.VAR_CREATE = VAR_CREATE;\n\n/**\n * Name of event that deletes a variable.\n * @const\n * @alias Blockly.Events.utils.VAR_DELETE\n */\nconst VAR_DELETE = 'var_delete';\nexports.VAR_DELETE = VAR_DELETE;\n\n/**\n * Name of event that renames a variable.\n * @const\n * @alias Blockly.Events.utils.VAR_RENAME\n */\nconst VAR_RENAME = 'var_rename';\nexports.VAR_RENAME = VAR_RENAME;\n\n/**\n * Name of generic event that records a UI change.\n * @const\n * @alias Blockly.Events.utils.UI\n */\nconst UI = 'ui';\nexports.UI = UI;\n\n/**\n * Name of event that record a block drags a block.\n * @const\n * @alias Blockly.Events.utils.BLOCK_DRAG\n */\nconst BLOCK_DRAG = 'drag';\nexports.BLOCK_DRAG = BLOCK_DRAG;\n\n/**\n * Name of event that records a change in selected element.\n * @const\n * @alias Blockly.Events.utils.SELECTED\n */\nconst SELECTED = 'selected';\nexports.SELECTED = SELECTED;\n\n/**\n * Name of event that records a click.\n * @const\n * @alias Blockly.Events.utils.CLICK\n */\nconst CLICK = 'click';\nexports.CLICK = CLICK;\n\n/**\n * Name of event that records a marker move.\n * @const\n * @alias Blockly.Events.utils.MARKER_MOVE\n */\nconst MARKER_MOVE = 'marker_move';\nexports.MARKER_MOVE = MARKER_MOVE;\n\n/**\n * Name of event that records a bubble open.\n * @const\n * @alias Blockly.Events.utils.BUBBLE_OPEN\n */\nconst BUBBLE_OPEN = 'bubble_open';\nexports.BUBBLE_OPEN = BUBBLE_OPEN;\n\n/**\n * Name of event that records a trashcan open.\n * @const\n * @alias Blockly.Events.utils.TRASHCAN_OPEN\n */\nconst TRASHCAN_OPEN = 'trashcan_open';\nexports.TRASHCAN_OPEN = TRASHCAN_OPEN;\n\n/**\n * Name of event that records a toolbox item select.\n * @const\n * @alias Blockly.Events.utils.TOOLBOX_ITEM_SELECT\n */\nconst TOOLBOX_ITEM_SELECT = 'toolbox_item_select';\nexports.TOOLBOX_ITEM_SELECT = TOOLBOX_ITEM_SELECT;\n\n/**\n * Name of event that records a theme change.\n * @const\n * @alias Blockly.Events.utils.THEME_CHANGE\n */\nconst THEME_CHANGE = 'theme_change';\nexports.THEME_CHANGE = THEME_CHANGE;\n\n/**\n * Name of event that records a viewport change.\n * @const\n * @alias Blockly.Events.utils.VIEWPORT_CHANGE\n */\nconst VIEWPORT_CHANGE = 'viewport_change';\nexports.VIEWPORT_CHANGE = VIEWPORT_CHANGE;\n\n/**\n * Name of event that creates a comment.\n * @const\n * @alias Blockly.Events.utils.COMMENT_CREATE\n */\nconst COMMENT_CREATE = 'comment_create';\nexports.COMMENT_CREATE = COMMENT_CREATE;\n\n/**\n * Name of event that deletes a comment.\n * @const\n * @alias Blockly.Events.utils.COMMENT_DELETE\n */\nconst COMMENT_DELETE = 'comment_delete';\nexports.COMMENT_DELETE = COMMENT_DELETE;\n\n/**\n * Name of event that changes a comment.\n * @const\n * @alias Blockly.Events.utils.COMMENT_CHANGE\n */\nconst COMMENT_CHANGE = 'comment_change';\nexports.COMMENT_CHANGE = COMMENT_CHANGE;\n\n/**\n * Name of event that moves a comment.\n * @const\n * @alias Blockly.Events.utils.COMMENT_MOVE\n */\nconst COMMENT_MOVE = 'comment_move';\nexports.COMMENT_MOVE = COMMENT_MOVE;\n\n/**\n * Name of event that records a workspace load.\n * @alias Blockly.Events.utils.FINISHED_LOADING\n */\nconst FINISHED_LOADING = 'finished_loading';\nexports.FINISHED_LOADING = FINISHED_LOADING;\n\n/**\n * Type of events that cause objects to be bumped back into the visible\n * portion of the workspace.\n *\n * Not to be confused with bumping so that disconnected connections do not\n * appear connected.\n * @typedef {!BlockCreate|!BlockMove|\n * !CommentCreate|!CommentMove}\n * @alias Blockly.Events.utils.BumpEvent\n */\nlet BumpEvent;\nexports.BumpEvent = BumpEvent;\n\n/**\n * List of events that cause objects to be bumped back into the visible\n * portion of the workspace.\n *\n * Not to be confused with bumping so that disconnected connections do not\n * appear connected.\n * @const\n * @alias Blockly.Events.utils.BUMP_EVENTS\n */\nconst BUMP_EVENTS = [BLOCK_CREATE, BLOCK_MOVE, COMMENT_CREATE, COMMENT_MOVE];\nexports.BUMP_EVENTS = BUMP_EVENTS;\n\n/**\n * List of events queued for firing.\n * @type {!Array<!Abstract>}\n */\nconst FIRE_QUEUE = [];\n\n/**\n * Create a custom event and fire it.\n * @param {!Abstract} event Custom data for event.\n * @alias Blockly.Events.utils.fire\n */\nconst fire = function(event) {\n  if (!isEnabled()) {\n    return;\n  }\n  if (!FIRE_QUEUE.length) {\n    // First event added; schedule a firing of the event queue.\n    setTimeout(fireNow, 0);\n  }\n  FIRE_QUEUE.push(event);\n};\nexports.fire = fire;\n\n/**\n * Fire all queued events.\n */\nconst fireNow = function() {\n  const queue = filter(FIRE_QUEUE, true);\n  FIRE_QUEUE.length = 0;\n  for (let i = 0, event; (event = queue[i]); i++) {\n    if (!event.workspaceId) {\n      continue;\n    }\n    const {Workspace} = goog.module.get('Blockly.Workspace');\n    const eventWorkspace = Workspace.getById(event.workspaceId);\n    if (eventWorkspace) {\n      eventWorkspace.fireChangeListener(event);\n    }\n  }\n};\n\n/**\n * Filter the queued events and merge duplicates.\n * @param {!Array<!Abstract>} queueIn Array of events.\n * @param {boolean} forward True if forward (redo), false if backward (undo).\n * @return {!Array<!Abstract>} Array of filtered events.\n * @alias Blockly.Events.utils.filter\n */\nconst filter = function(queueIn, forward) {\n  let queue = queueIn.slice();  // Shallow copy of queue.\n  if (!forward) {\n    // Undo is merged in reverse order.\n    queue.reverse();\n  }\n  const mergedQueue = [];\n  const hash = Object.create(null);\n  // Merge duplicates.\n  for (let i = 0, event; (event = queue[i]); i++) {\n    if (!event.isNull()) {\n      // Treat all UI events as the same type in hash table.\n      const eventType = event.isUiEvent ? UI : event.type;\n      // TODO(#5927): Ceck whether `blockId` exists before accessing it.\n      const blockId = /** @type {*} */ (event).blockId;\n      const key = [eventType, blockId, event.workspaceId].join(' ');\n\n      const lastEntry = hash[key];\n      const lastEvent = lastEntry ? lastEntry.event : null;\n      if (!lastEntry) {\n        // Each item in the hash table has the event and the index of that event\n        // in the input array.  This lets us make sure we only merge adjacent\n        // move events.\n        hash[key] = {event: event, index: i};\n        mergedQueue.push(event);\n      } else if (event.type === MOVE && lastEntry.index === i - 1) {\n        const moveEvent = /** @type {!BlockMove} */ (event);\n        // Merge move events.\n        lastEvent.newParentId = moveEvent.newParentId;\n        lastEvent.newInputName = moveEvent.newInputName;\n        lastEvent.newCoordinate = moveEvent.newCoordinate;\n        lastEntry.index = i;\n      } else if (\n          event.type === CHANGE && event.element === lastEvent.element &&\n          event.name === lastEvent.name) {\n        const changeEvent = /** @type {!BlockChange} */ (event);\n        // Merge change events.\n        lastEvent.newValue = changeEvent.newValue;\n      } else if (event.type === VIEWPORT_CHANGE) {\n        const viewportEvent = /** @type {!ViewportChange} */ (event);\n        // Merge viewport change events.\n        lastEvent.viewTop = viewportEvent.viewTop;\n        lastEvent.viewLeft = viewportEvent.viewLeft;\n        lastEvent.scale = viewportEvent.scale;\n        lastEvent.oldScale = viewportEvent.oldScale;\n      } else if (event.type === CLICK && lastEvent.type === BUBBLE_OPEN) {\n        // Drop click events caused by opening/closing bubbles.\n      } else {\n        // Collision: newer events should merge into this event to maintain\n        // order.\n        hash[key] = {event: event, index: i};\n        mergedQueue.push(event);\n      }\n    }\n  }\n  // Filter out any events that have become null due to merging.\n  queue = mergedQueue.filter(function(e) {\n    return !e.isNull();\n  });\n  if (!forward) {\n    // Restore undo order.\n    queue.reverse();\n  }\n  // Move mutation events to the top of the queue.\n  // Intentionally skip first event.\n  for (let i = 1, event; (event = queue[i]); i++) {\n    if (event.type === CHANGE && event.element === 'mutation') {\n      queue.unshift(queue.splice(i, 1)[0]);\n    }\n  }\n  return queue;\n};\nexports.filter = filter;\n\n/**\n * Modify pending undo events so that when they are fired they don't land\n * in the undo stack.  Called by Workspace.clearUndo.\n * @alias Blockly.Events.utils.clearPendingUndo\n */\nconst clearPendingUndo = function() {\n  for (let i = 0, event; (event = FIRE_QUEUE[i]); i++) {\n    event.recordUndo = false;\n  }\n};\nexports.clearPendingUndo = clearPendingUndo;\n\n/**\n * Stop sending events.  Every call to this function MUST also call enable.\n * @alias Blockly.Events.utils.disable\n */\nconst disable = function() {\n  disabled++;\n};\nexports.disable = disable;\n\n/**\n * Start sending events.  Unless events were already disabled when the\n * corresponding call to disable was made.\n * @alias Blockly.Events.utils.enable\n */\nconst enable = function() {\n  disabled--;\n};\nexports.enable = enable;\n\n/**\n * Returns whether events may be fired or not.\n * @return {boolean} True if enabled.\n * @alias Blockly.Events.utils.isEnabled\n */\nconst isEnabled = function() {\n  return disabled === 0;\n};\nexports.isEnabled = isEnabled;\n\n/**\n * Current group.\n * @return {string} ID string.\n * @alias Blockly.Events.utils.getGroup\n */\nconst getGroup = function() {\n  return group;\n};\nexports.getGroup = getGroup;\n\n/**\n * Start or stop a group.\n * @param {boolean|string} state True to start new group, false to end group.\n *   String to set group explicitly.\n * @alias Blockly.Events.utils.setGroup\n */\nconst setGroup = function(state) {\n  if (typeof state === 'boolean') {\n    group = state ? idGenerator.genUid() : '';\n  } else {\n    group = state;\n  }\n};\nexports.setGroup = setGroup;\n\n/**\n * Compute a list of the IDs of the specified block and all its descendants.\n * @param {!Block} block The root block.\n * @return {!Array<string>} List of block IDs.\n * @alias Blockly.Events.utils.getDescendantIds\n * @package\n */\nconst getDescendantIds = function(block) {\n  const ids = [];\n  const descendants = block.getDescendants(false);\n  for (let i = 0, descendant; (descendant = descendants[i]); i++) {\n    ids[i] = descendant.id;\n  }\n  return ids;\n};\nexports.getDescendantIds = getDescendantIds;\n\n/**\n * Decode the JSON into an event.\n * @param {!Object} json JSON representation.\n * @param {!Workspace} workspace Target workspace for event.\n * @return {!Abstract} The event represented by the JSON.\n * @throws {Error} if an event type is not found in the registry.\n * @alias Blockly.Events.utils.fromJson\n */\nconst fromJson = function(json, workspace) {\n  const eventClass = get(json.type);\n  if (!eventClass) {\n    throw Error('Unknown event type.');\n  }\n  const event = new eventClass();\n  event.fromJson(json);\n  event.workspaceId = workspace.id;\n  return event;\n};\nexports.fromJson = fromJson;\n\n/**\n * Gets the class for a specific event type from the registry.\n * @param {string} eventType The type of the event to get.\n * @return {?function(new:Abstract, ...?)} The event class with\n *     the given type or null if none exists.\n * @alias Blockly.Events.utils.get\n */\nconst get = function(eventType) {\n  return registry.getClass(registry.Type.EVENT, eventType);\n};\nexports.get = get;\n\n/**\n * Enable/disable a block depending on whether it is properly connected.\n * Use this on applications where all blocks should be connected to a top block.\n * Recommend setting the 'disable' option to 'false' in the config so that\n * users don't try to re-enable disabled orphan blocks.\n * @param {!Abstract} event Custom data for event.\n * @alias Blockly.Events.utils.disableOrphans\n */\nconst disableOrphans = function(event) {\n  if (event.type === MOVE || event.type === CREATE) {\n    const blockEvent = /** @type {!BlockMove|!BlockCreate} */ (event);\n    if (!blockEvent.workspaceId) {\n      return;\n    }\n    const {Workspace} = goog.module.get('Blockly.Workspace');\n    const eventWorkspace =\n        /** @type {!WorkspaceSvg} */ (\n            Workspace.getById(blockEvent.workspaceId));\n    let block = eventWorkspace.getBlockById(blockEvent.blockId);\n    if (block) {\n      // Changing blocks as part of this event shouldn't be undoable.\n      const initialUndoFlag = recordUndo;\n      try {\n        recordUndo = false;\n        const parent = block.getParent();\n        if (parent && parent.isEnabled()) {\n          const children = block.getDescendants(false);\n          for (let i = 0, child; (child = children[i]); i++) {\n            child.setEnabled(true);\n          }\n        } else if (\n            (block.outputConnection || block.previousConnection) &&\n            !eventWorkspace.isDragging()) {\n          do {\n            block.setEnabled(false);\n            block = block.getNextBlock();\n          } while (block);\n        }\n      } finally {\n        recordUndo = initialUndoFlag;\n      }\n    }\n  }\n};\nexports.disableOrphans = disableOrphans;\n\nexports.TEST_ONLY = {\n  FIRE_QUEUE,\n  fireNow,\n};\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/utils.js?")},
"./core/events/workspace_events.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/events/events_abstract.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class for a finished loading workspace event.\n */\n\n\n/**\n * Class for a finished loading workspace event.\n * @class\n */\ngoog.module('Blockly.Events.FinishedLoading');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst {Abstract: AbstractEvent} = goog.require('Blockly.Events.Abstract');\n/* eslint-disable-next-line no-unused-vars */\nconst {Workspace} = goog.requireType('Blockly.Workspace');\n\n\n/**\n * Class for a finished loading event.\n * Used to notify the developer when the workspace has finished loading (i.e\n * domToWorkspace).\n * Finished loading events do not record undo or redo.\n * @extends {AbstractEvent}\n * @alias Blockly.Events.FinishedLoading\n */\nclass FinishedLoading extends AbstractEvent {\n  /**\n   * @param {!Workspace=} opt_workspace The workspace that has finished\n   *    loading.  Undefined for a blank event.\n   */\n  constructor(opt_workspace) {\n    super();\n    /**\n     * Whether or not the event is blank (to be populated by fromJson).\n     * @type {boolean}\n     */\n    this.isBlank = typeof opt_workspace === 'undefined';\n\n    /**\n     * The workspace identifier for this event.\n     * @type {string}\n     */\n    this.workspaceId = opt_workspace ? opt_workspace.id : '';\n\n    // Workspace events do not undo or redo.\n    this.recordUndo = false;\n\n    /**\n     * Type of this event.\n     * @type {string}\n     */\n    this.type = eventUtils.FINISHED_LOADING;\n  }\n\n  /**\n   * Encode the event as JSON.\n   * @return {!Object} JSON representation.\n   */\n  toJson() {\n    const json = {\n      'type': this.type,\n    };\n    if (this.group) {\n      json['group'] = this.group;\n    }\n    if (this.workspaceId) {\n      json['workspaceId'] = this.workspaceId;\n    }\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   * @param {!Object} json JSON representation.\n   */\n  fromJson(json) {\n    this.isBlank = false;\n    this.workspaceId = json['workspaceId'];\n    this.group = json['group'];\n  }\n}\n\nregistry.register(\n    registry.Type.EVENT, eventUtils.FINISHED_LOADING, FinishedLoading);\n\nexports.FinishedLoading = FinishedLoading;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/events/workspace_events.js?")},
"./core/extensions.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/parsing.js\");\n__webpack_require__(\"./core/field_dropdown.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Extensions are functions that help initialize blocks, usually\n *      adding dynamic behavior such as onchange handlers and mutators. These\n *      are applied using Block.applyExtension(), or the JSON \"extensions\"\n *      array attribute.\n */\n\n\n/**\n * Extensions are functions that help initialize blocks, usually\n *      adding dynamic behavior such as onchange handlers and mutators. These\n *      are applied using Block.applyExtension(), or the JSON \"extensions\"\n *      array attribute.\n * @namespace Blockly.Extensions\n */\ngoog.module('Blockly.Extensions');\n\nconst parsing = goog.require('Blockly.utils.parsing');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\nconst {FieldDropdown} = goog.require('Blockly.FieldDropdown');\ngoog.requireType('Blockly.Mutator');\n\n\n/**\n * The set of all registered extensions, keyed by extension name/id.\n * @private\n */\nconst allExtensions = Object.create(null);\nexports.TEST_ONLY = {allExtensions};\n\n/**\n * Registers a new extension function. Extensions are functions that help\n * initialize blocks, usually adding dynamic behavior such as onchange\n * handlers and mutators. These are applied using Block.applyExtension(), or\n * the JSON \"extensions\" array attribute.\n * @param {string} name The name of this extension.\n * @param {Function} initFn The function to initialize an extended block.\n * @throws {Error} if the extension name is empty, the extension is already\n *     registered, or extensionFn is not a function.\n * @alias Blockly.Extensions.register\n */\nconst register = function(name, initFn) {\n  if ((typeof name !== 'string') || (name.trim() === '')) {\n    throw Error('Error: Invalid extension name \"' + name + '\"');\n  }\n  if (allExtensions[name]) {\n    throw Error('Error: Extension \"' + name + '\" is already registered.');\n  }\n  if (typeof initFn !== 'function') {\n    throw Error('Error: Extension \"' + name + '\" must be a function');\n  }\n  allExtensions[name] = initFn;\n};\nexports.register = register;\n\n/**\n * Registers a new extension function that adds all key/value of mixinObj.\n * @param {string} name The name of this extension.\n * @param {!Object} mixinObj The values to mix in.\n * @throws {Error} if the extension name is empty or the extension is already\n *     registered.\n * @alias Blockly.Extensions.registerMixin\n */\nconst registerMixin = function(name, mixinObj) {\n  if (!mixinObj || typeof mixinObj !== 'object') {\n    throw Error('Error: Mixin \"' + name + '\" must be a object');\n  }\n  register(\n      name,\n      /** @this {Block} */\n      function() {\n        this.mixin(mixinObj);\n      });\n};\nexports.registerMixin = registerMixin;\n\n/**\n * Registers a new extension function that adds a mutator to the block.\n * At register time this performs some basic sanity checks on the mutator.\n * The wrapper may also add a mutator dialog to the block, if both compose and\n * decompose are defined on the mixin.\n * @param {string} name The name of this mutator extension.\n * @param {!Object} mixinObj The values to mix in.\n * @param {(function())=} opt_helperFn An optional function to apply after\n *     mixing in the object.\n * @param {!Array<string>=} opt_blockList A list of blocks to appear in the\n *     flyout of the mutator dialog.\n * @throws {Error} if the mutation is invalid or can't be applied to the block.\n * @alias Blockly.Extensions.registerMutator\n */\nconst registerMutator = function(name, mixinObj, opt_helperFn, opt_blockList) {\n  const errorPrefix = 'Error when registering mutator \"' + name + '\": ';\n\n  checkHasMutatorProperties(errorPrefix, mixinObj);\n  const hasMutatorDialog = checkMutatorDialog(mixinObj, errorPrefix);\n\n  if (opt_helperFn && (typeof opt_helperFn !== 'function')) {\n    throw Error(errorPrefix + 'Extension \"' + name + '\" is not a function');\n  }\n\n  // Sanity checks passed.\n  register(\n      name,\n      /** @this {Block} */\n      function() {\n        if (hasMutatorDialog) {\n          const {Mutator} = goog.module.get('Blockly.Mutator');\n          if (!Mutator) {\n            throw Error(errorPrefix + 'Missing require for Blockly.Mutator');\n          }\n          this.setMutator(new Mutator(opt_blockList || []));\n        }\n        // Mixin the object.\n        this.mixin(mixinObj);\n\n        if (opt_helperFn) {\n          opt_helperFn.apply(this);\n        }\n      });\n};\nexports.registerMutator = registerMutator;\n\n/**\n * Unregisters the extension registered with the given name.\n * @param {string} name The name of the extension to unregister.\n * @alias Blockly.Extensions.unregister\n */\nconst unregister = function(name) {\n  if (isRegistered(name)) {\n    delete allExtensions[name];\n  } else {\n    console.warn(\n        'No extension mapping for name \"' + name + '\" found to unregister');\n  }\n};\nexports.unregister = unregister;\n\n/**\n * Returns whether an extension is registered with the given name.\n * @param {string} name The name of the extension to check for.\n * @return {boolean} True if the extension is registered.  False if it is\n *     not registered.\n * @alias Blockly.Extensions.isRegistered\n */\nconst isRegistered = function(name) {\n  return !!allExtensions[name];\n};\nexports.isRegistered = isRegistered;\n\n/**\n * Applies an extension method to a block. This should only be called during\n * block construction.\n * @param {string} name The name of the extension.\n * @param {!Block} block The block to apply the named extension to.\n * @param {boolean} isMutator True if this extension defines a mutator.\n * @throws {Error} if the extension is not found.\n * @alias Blockly.Extensions.apply\n */\nconst apply = function(name, block, isMutator) {\n  const extensionFn = allExtensions[name];\n  if (typeof extensionFn !== 'function') {\n    throw Error('Error: Extension \"' + name + '\" not found.');\n  }\n  let mutatorProperties;\n  if (isMutator) {\n    // Fail early if the block already has mutation properties.\n    checkNoMutatorProperties(name, block);\n  } else {\n    // Record the old properties so we can make sure they don't change after\n    // applying the extension.\n    mutatorProperties = getMutatorProperties(block);\n  }\n  extensionFn.apply(block);\n\n  if (isMutator) {\n    const errorPrefix = 'Error after applying mutator \"' + name + '\": ';\n    checkHasMutatorProperties(errorPrefix, block);\n  } else {\n    if (!mutatorPropertiesMatch(\n            /** @type {!Array<Object>} */ (mutatorProperties), block)) {\n      throw Error(\n          'Error when applying extension \"' + name + '\": ' +\n          'mutation properties changed when applying a non-mutator extension.');\n    }\n  }\n};\nexports.apply = apply;\n\n/**\n * Check that the given block does not have any of the four mutator properties\n * defined on it.  This function should be called before applying a mutator\n * extension to a block, to make sure we are not overwriting properties.\n * @param {string} mutationName The name of the mutation to reference in error\n *     messages.\n * @param {!Block} block The block to check.\n * @throws {Error} if any of the properties already exist on the block.\n */\nconst checkNoMutatorProperties = function(mutationName, block) {\n  const properties = getMutatorProperties(block);\n  if (properties.length) {\n    throw Error(\n        'Error: tried to apply mutation \"' + mutationName +\n        '\" to a block that already has mutator functions.' +\n        '  Block id: ' + block.id);\n  }\n};\n\n/**\n * Checks if the given object has both the 'mutationToDom' and 'domToMutation'\n * functions.\n * @param {!Object} object The object to check.\n * @param {string} errorPrefix The string to prepend to any error message.\n * @return {boolean} True if the object has both functions.  False if it has\n *     neither function.\n * @throws {Error} if the object has only one of the functions, or either is\n *     not actually a function.\n */\nconst checkXmlHooks = function(object, errorPrefix) {\n  return checkHasFunctionPair(\n      object.mutationToDom, object.domToMutation,\n      errorPrefix + ' mutationToDom/domToMutation');\n};\n\n/**\n * Checks if the given object has both the 'saveExtraState' and 'loadExtraState'\n * functions.\n * @param {!Object} object The object to check.\n * @param {string} errorPrefix The string to prepend to any error message.\n * @return {boolean} True if the object has both functions.  False if it has\n *     neither function.\n * @throws {Error} if the object has only one of the functions, or either is\n *     not actually a function.\n */\nconst checkJsonHooks = function(object, errorPrefix) {\n  return checkHasFunctionPair(\n      object.saveExtraState, object.loadExtraState,\n      errorPrefix + ' saveExtraState/loadExtraState');\n};\n\n/**\n * Checks if the given object has both the 'compose' and 'decompose' functions.\n * @param {!Object} object The object to check.\n * @param {string} errorPrefix The string to prepend to any error message.\n * @return {boolean} True if the object has both functions.  False if it has\n *     neither function.\n * @throws {Error} if the object has only one of the functions, or either is\n *     not actually a function.\n */\nconst checkMutatorDialog = function(object, errorPrefix) {\n  return checkHasFunctionPair(\n      object.compose, object.decompose, errorPrefix + ' compose/decompose');\n};\n\n/**\n * Checks that both or neither of the given functions exist and that they are\n * indeed functions.\n * @param {*} func1 The first function in the pair.\n * @param {*} func2 The second function in the pair.\n * @param {string} errorPrefix The string to prepend to any error message.\n * @return {boolean} True if the object has both functions.  False if it has\n *     neither function.\n * @throws {Error} If the object has only one of the functions, or either is\n *     not actually a function.\n */\nconst checkHasFunctionPair = function(func1, func2, errorPrefix) {\n  if (func1 && func2) {\n    if (typeof func1 !== 'function' || typeof func2 !== 'function') {\n      throw Error(errorPrefix + ' must be a function');\n    }\n    return true;\n  } else if (!func1 && !func2) {\n    return false;\n  }\n  throw Error(errorPrefix + 'Must have both or neither functions');\n};\n\n/**\n * Checks that the given object required mutator properties.\n * @param {string} errorPrefix The string to prepend to any error message.\n * @param {!Object} object The object to inspect.\n */\nconst checkHasMutatorProperties = function(errorPrefix, object) {\n  const hasXmlHooks = checkXmlHooks(object, errorPrefix);\n  const hasJsonHooks = checkJsonHooks(object, errorPrefix);\n  if (!hasXmlHooks && !hasJsonHooks) {\n    throw Error(\n        errorPrefix +\n        'Mutations must contain either XML hooks, or JSON hooks, or both');\n  }\n  // A block with a mutator isn't required to have a mutation dialog, but\n  // it should still have both or neither of compose and decompose.\n  checkMutatorDialog(object, errorPrefix);\n};\n\n/**\n * Get a list of values of mutator properties on the given block.\n * @param {!Block} block The block to inspect.\n * @return {!Array<Object>} A list with all of the defined properties, which\n *     should be functions, but may be anything other than undefined.\n */\nconst getMutatorProperties = function(block) {\n  const result = [];\n  // List each function explicitly by reference to allow for renaming\n  // during compilation.\n  if (block.domToMutation !== undefined) {\n    result.push(block.domToMutation);\n  }\n  if (block.mutationToDom !== undefined) {\n    result.push(block.mutationToDom);\n  }\n  if (block.saveExtraState !== undefined) {\n    result.push(block.saveExtraState);\n  }\n  if (block.loadExtraState !== undefined) {\n    result.push(block.loadExtraState);\n  }\n  if (block.compose !== undefined) {\n    result.push(block.compose);\n  }\n  if (block.decompose !== undefined) {\n    result.push(block.decompose);\n  }\n  return result;\n};\n\n/**\n * Check that the current mutator properties match a list of old mutator\n * properties.  This should be called after applying a non-mutator extension,\n * to verify that the extension didn't change properties it shouldn't.\n * @param {!Array<Object>} oldProperties The old values to compare to.\n * @param {!Block} block The block to inspect for new values.\n * @return {boolean} True if the property lists match.\n */\nconst mutatorPropertiesMatch = function(oldProperties, block) {\n  const newProperties = getMutatorProperties(block);\n  if (newProperties.length !== oldProperties.length) {\n    return false;\n  }\n  for (let i = 0; i < newProperties.length; i++) {\n    if (oldProperties[i] !== newProperties[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Calls a function after the page has loaded, possibly immediately.\n * @param {function()} fn Function to run.\n * @throws Error Will throw if no global document can be found (e.g., Node.js).\n * @package\n */\nconst runAfterPageLoad = function(fn) {\n  if (typeof document !== 'object') {\n    throw Error('runAfterPageLoad() requires browser document.');\n  }\n  if (document.readyState === 'complete') {\n    fn();  // Page has already loaded. Call immediately.\n  } else {\n    // Poll readyState.\n    const readyStateCheckInterval = setInterval(function() {\n      if (document.readyState === 'complete') {\n        clearInterval(readyStateCheckInterval);\n        fn();\n      }\n    }, 10);\n  }\n};\nexports.runAfterPageLoad = runAfterPageLoad;\n\n/**\n * Builds an extension function that will map a dropdown value to a tooltip\n * string.\n *\n * This method includes multiple checks to ensure tooltips, dropdown options,\n * and message references are aligned. This aims to catch errors as early as\n * possible, without requiring developers to manually test tooltips under each\n * option. After the page is loaded, each tooltip text string will be checked\n * for matching message keys in the internationalized string table. Deferring\n * this until the page is loaded decouples loading dependencies. Later, upon\n * loading the first block of any given type, the extension will validate every\n * dropdown option has a matching tooltip in the lookupTable.  Errors are\n * reported as warnings in the console, and are never fatal.\n * @param {string} dropdownName The name of the field whose value is the key\n *     to the lookup table.\n * @param {!Object<string, string>} lookupTable The table of field values to\n *     tooltip text.\n * @return {!Function} The extension function.\n * @alias Blockly.Extensions.buildTooltipForDropdown\n */\nconst buildTooltipForDropdown = function(dropdownName, lookupTable) {\n  // List of block types already validated, to minimize duplicate warnings.\n  const blockTypesChecked = [];\n\n  // Check the tooltip string messages for invalid references.\n  // Wait for load, in case Blockly.Msg is not yet populated.\n  // runAfterPageLoad() does not run in a Node.js environment due to lack\n  // of document object, in which case skip the validation.\n  if (typeof document === 'object') {  // Relies on document.readyState\n    runAfterPageLoad(function() {\n      for (const key in lookupTable) {\n        // Will print warnings if reference is missing.\n        parsing.checkMessageReferences(lookupTable[key]);\n      }\n    });\n  }\n\n  /**\n   * The actual extension.\n   * @this {Block}\n   */\n  const extensionFn = function() {\n    if (this.type && blockTypesChecked.indexOf(this.type) === -1) {\n      checkDropdownOptionsInTable(this, dropdownName, lookupTable);\n      blockTypesChecked.push(this.type);\n    }\n\n    this.setTooltip(function() {\n      const value = String(this.getFieldValue(dropdownName));\n      let tooltip = lookupTable[value];\n      if (tooltip === null) {\n        if (blockTypesChecked.indexOf(this.type) === -1) {\n          // Warn for missing values on generated tooltips.\n          let warning = 'No tooltip mapping for value ' + value + ' of field ' +\n              dropdownName;\n          if (this.type !== null) {\n            warning += (' of block type ' + this.type);\n          }\n          console.warn(warning + '.');\n        }\n      } else {\n        tooltip = parsing.replaceMessageReferences(tooltip);\n      }\n      return tooltip;\n    }.bind(this));\n  };\n  return extensionFn;\n};\nexports.buildTooltipForDropdown = buildTooltipForDropdown;\n\n/**\n * Checks all options keys are present in the provided string lookup table.\n * Emits console warnings when they are not.\n * @param {!Block} block The block containing the dropdown\n * @param {string} dropdownName The name of the dropdown\n * @param {!Object<string, string>} lookupTable The string lookup table\n */\nconst checkDropdownOptionsInTable = function(block, dropdownName, lookupTable) {\n  // Validate all dropdown options have values.\n  const dropdown = block.getField(dropdownName);\n  if (dropdown instanceof FieldDropdown && !dropdown.isOptionListDynamic()) {\n    const options = dropdown.getOptions();\n    for (let i = 0; i < options.length; i++) {\n      const optionKey = options[i][1];  // label, then value\n      if (lookupTable[optionKey] === null) {\n        console.warn(\n            'No tooltip mapping for value ' + optionKey + ' of field ' +\n            dropdownName + ' of block type ' + block.type);\n      }\n    }\n  }\n};\n\n/**\n * Builds an extension function that will install a dynamic tooltip. The\n * tooltip message should include the string '%1' and that string will be\n * replaced with the text of the named field.\n * @param {string} msgTemplate The template form to of the message text, with\n *     %1 placeholder.\n * @param {string} fieldName The field with the replacement text.\n * @return {!Function} The extension function.\n * @alias Blockly.Extensions.buildTooltipWithFieldText\n */\nconst buildTooltipWithFieldText = function(msgTemplate, fieldName) {\n  // Check the tooltip string messages for invalid references.\n  // Wait for load, in case Blockly.Msg is not yet populated.\n  // runAfterPageLoad() does not run in a Node.js environment due to lack\n  // of document object, in which case skip the validation.\n  if (typeof document === 'object') {  // Relies on document.readyState\n    runAfterPageLoad(function() {\n      // Will print warnings if reference is missing.\n      parsing.checkMessageReferences(msgTemplate);\n    });\n  }\n\n  /**\n   * The actual extension.\n   * @this {Block}\n   */\n  const extensionFn = function() {\n    this.setTooltip(function() {\n      const field = this.getField(fieldName);\n      return parsing.replaceMessageReferences(msgTemplate)\n          .replace('%1', field ? field.getText() : '');\n    }.bind(this));\n  };\n  return extensionFn;\n};\nexports.buildTooltipWithFieldText = buildTooltipWithFieldText;\n\n/**\n * Configures the tooltip to mimic the parent block when connected. Otherwise,\n * uses the tooltip text at the time this extension is initialized. This takes\n * advantage of the fact that all other values from JSON are initialized before\n * extensions.\n * @this {Block}\n */\nconst extensionParentTooltip = function() {\n  const tooltipWhenNotConnected = this.tooltip;\n  this.setTooltip(function() {\n    const parent = this.getParent();\n    return (parent && parent.getInputsInline() && parent.tooltip) ||\n        tooltipWhenNotConnected;\n  }.bind(this));\n};\nregister('parent_tooltip_when_inline', extensionParentTooltip);\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/extensions.js?")},
"./core/field.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/tooltip.js\");\n__webpack_require__(\"./core/widgetdiv.js\");\n__webpack_require__(\"./core/xml.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/dropdowndiv.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/utils/parsing.js\");\n__webpack_require__(\"./core/utils/style.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\n__webpack_require__(\"./core/utils/xml.js\");\n__webpack_require__(\"./core/interfaces/i_ast_node_location_svg.js\");\n__webpack_require__(\"./core/interfaces/i_ast_node_location_with_block.js\");\n__webpack_require__(\"./core/interfaces/i_keyboard_accessible.js\");\n__webpack_require__(\"./core/interfaces/i_registrable.js\");\n__webpack_require__(\"./core/marker_manager.js\");\n__webpack_require__(\"./core/utils/rect.js\");\n__webpack_require__(\"./core/utils/sentinel.js\");\n__webpack_require__(\"./core/utils/size.js\");\n__webpack_require__(\"./core/utils/svg.js\");\n__webpack_require__(\"./core/events/events_block_change.js\");\n__webpack_require__(\"./core/gesture.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Field.  Used for editable titles, variables, etc.\n * This is an abstract class that defines the UI on the block.  Actual\n * instances would be FieldTextInput, FieldDropdown, etc.\n */\n\n\n/**\n * Field.  Used for editable titles, variables, etc.\n * This is an abstract class that defines the UI on the block.  Actual\n * instances would be FieldTextInput, FieldDropdown, etc.\n * @class\n */\ngoog.module('Blockly.Field');\n\nconst Tooltip = goog.require('Blockly.Tooltip');\nconst WidgetDiv = goog.require('Blockly.WidgetDiv');\nconst Xml = goog.require('Blockly.Xml');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst dom = goog.require('Blockly.utils.dom');\nconst dropDownDiv = goog.require('Blockly.dropDownDiv');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst parsing = goog.require('Blockly.utils.parsing');\nconst style = goog.require('Blockly.utils.style');\nconst userAgent = goog.require('Blockly.utils.userAgent');\nconst utilsXml = goog.require('Blockly.utils.xml');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {Coordinate} = goog.requireType('Blockly.utils.Coordinate');\n/* eslint-disable-next-line no-unused-vars */\nconst {IASTNodeLocationSvg} = goog.require('Blockly.IASTNodeLocationSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {IASTNodeLocationWithBlock} = goog.require('Blockly.IASTNodeLocationWithBlock');\n/* eslint-disable-next-line no-unused-vars */\nconst {IKeyboardAccessible} = goog.require('Blockly.IKeyboardAccessible');\n/* eslint-disable-next-line no-unused-vars */\nconst {IRegistrable} = goog.require('Blockly.IRegistrable');\n/* eslint-disable-next-line no-unused-vars */\nconst {Input} = goog.requireType('Blockly.Input');\nconst {MarkerManager} = goog.require('Blockly.MarkerManager');\nconst {Rect} = goog.require('Blockly.utils.Rect');\nconst {Sentinel} = goog.require('Blockly.utils.Sentinel');\n/* eslint-disable-next-line no-unused-vars */\nconst {ShortcutRegistry} = goog.requireType('Blockly.ShortcutRegistry');\nconst {Size} = goog.require('Blockly.utils.Size');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockChange');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Gesture');\n\n\n/**\n * Abstract class for an editable field.\n * @implements {IASTNodeLocationSvg}\n * @implements {IASTNodeLocationWithBlock}\n * @implements {IKeyboardAccessible}\n * @implements {IRegistrable}\n * @abstract\n * @alias Blockly.Field\n */\nclass Field {\n  /**\n   * @param {*} value The initial value of the field.\n   *     Also accepts Field.SKIP_SETUP if you wish to skip setup (only used by\n   *     subclasses that want to handle configuration and setting the field\n   *     value after their own constructors have run).\n   * @param {?Function=} opt_validator  A function that is called to validate\n   *    changes to the field's value. Takes in a value & returns a validated\n   *    value, or null to abort the change.\n   * @param {Object=} opt_config A map of options used to configure the field.\n   *    Refer to the individual field's documentation for a list of properties\n   *    this parameter supports.\n   */\n  constructor(value, opt_validator, opt_config) {\n    /**\n     * Name of field.  Unique within each block.\n     * Static labels are usually unnamed.\n     * @type {string|undefined}\n     */\n    this.name = undefined;\n\n    /**\n     * A generic value possessed by the field.\n     * Should generally be non-null, only null when the field is created.\n     * @type {*}\n     * @protected\n     */\n    this.value_ =\n        /** @type {typeof Field} */ (new.target).prototype.DEFAULT_VALUE;\n\n    /**\n     * Validation function called when user edits an editable field.\n     * @type {Function}\n     * @protected\n     */\n    this.validator_ = null;\n\n    /**\n     * Used to cache the field's tooltip value if setTooltip is called when the\n     * field is not yet initialized. Is *not* guaranteed to be accurate.\n     * @type {?Tooltip.TipInfo}\n     * @private\n     */\n    this.tooltip_ = null;\n\n    /**\n     * The size of the area rendered by the field.\n     * @type {!Size}\n     * @protected\n     */\n    this.size_ = new Size(0, 0);\n\n    /**\n     * Holds the cursors svg element when the cursor is attached to the field.\n     * This is null if there is no cursor on the field.\n     * @type {SVGElement}\n     * @private\n     */\n    this.cursorSvg_ = null;\n\n    /**\n     * Holds the markers svg element when the marker is attached to the field.\n     * This is null if there is no marker on the field.\n     * @type {SVGElement}\n     * @private\n     */\n    this.markerSvg_ = null;\n\n    /**\n     * The rendered field's SVG group element.\n     * @type {SVGGElement}\n     * @protected\n     */\n    this.fieldGroup_ = null;\n\n    /**\n     * The rendered field's SVG border element.\n     * @type {SVGRectElement}\n     * @protected\n     */\n    this.borderRect_ = null;\n\n    /**\n     * The rendered field's SVG text element.\n     * @type {SVGTextElement}\n     * @protected\n     */\n    this.textElement_ = null;\n\n    /**\n     * The rendered field's text content element.\n     * @type {Text}\n     * @protected\n     */\n    this.textContent_ = null;\n\n    /**\n     * Mouse down event listener data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.mouseDownWrapper_ = null;\n\n    /**\n     * Constants associated with the source block's renderer.\n     * @type {ConstantProvider}\n     * @protected\n     */\n    this.constants_ = null;\n\n    /**\n     * Has this field been disposed of?\n     * @type {boolean}\n     * @package\n     */\n    this.disposed = false;\n\n    /**\n     * Maximum characters of text to display before adding an ellipsis.\n     * @type {number}\n     */\n    this.maxDisplayLength = 50;\n\n    /**\n     * Block this field is attached to.  Starts as null, then set in init.\n     * @type {Block}\n     * @protected\n     */\n    this.sourceBlock_ = null;\n\n    /**\n     * Does this block need to be re-rendered?\n     * @type {boolean}\n     * @protected\n     */\n    this.isDirty_ = true;\n\n    /**\n     * Is the field visible, or hidden due to the block being collapsed?\n     * @type {boolean}\n     * @protected\n     */\n    this.visible_ = true;\n\n    /**\n     * Can the field value be changed using the editor on an editable block?\n     * @type {boolean}\n     * @protected\n     */\n    this.enabled_ = true;\n\n    /**\n     * The element the click handler is bound to.\n     * @type {Element}\n     * @protected\n     */\n    this.clickTarget_ = null;\n\n    /**\n     * The prefix field.\n     * @type {?string}\n     * @package\n     */\n    this.prefixField = null;\n\n    /**\n     * The suffix field.\n     * @type {?string}\n     * @package\n     */\n    this.suffixField = null;\n\n    /**\n     * Editable fields usually show some sort of UI indicating they are\n     * editable. They will also be saved by the serializer.\n     * @type {boolean}\n     */\n    this.EDITABLE = true;\n\n    /**\n     * Serializable fields are saved by the serializer, non-serializable fields\n     * are not. Editable fields should also be serializable. This is not the\n     * case by default so that SERIALIZABLE is backwards compatible.\n     * @type {boolean}\n     */\n    this.SERIALIZABLE = false;\n\n    /**\n     * Mouse cursor style when over the hotspot that initiates the editor.\n     * @type {string}\n     */\n    this.CURSOR = '';\n\n    if (value === Field.SKIP_SETUP) return;\n    if (opt_config) this.configure_(opt_config);\n    this.setValue(value);\n    if (opt_validator) this.setValidator(opt_validator);\n  }\n\n  /**\n   * Process the configuration map passed to the field.\n   * @param {!Object} config A map of options used to configure the field. See\n   *    the individual field's documentation for a list of properties this\n   *    parameter supports.\n   * @protected\n   */\n  configure_(config) {\n    let tooltip = config['tooltip'];\n    if (typeof tooltip === 'string') {\n      tooltip = parsing.replaceMessageReferences(config['tooltip']);\n    }\n    tooltip && this.setTooltip(tooltip);\n\n    // TODO (#2884): Possibly add CSS class config option.\n    // TODO (#2885): Possibly add cursor config option.\n  }\n\n  /**\n   * Attach this field to a block.\n   * @param {!Block} block The block containing this field.\n   */\n  setSourceBlock(block) {\n    if (this.sourceBlock_) {\n      throw Error('Field already bound to a block');\n    }\n    this.sourceBlock_ = block;\n  }\n\n  /**\n   * Get the renderer constant provider.\n   * @return {?ConstantProvider} The renderer constant\n   *     provider.\n   */\n  getConstants() {\n    if (!this.constants_ && this.sourceBlock_ && this.sourceBlock_.workspace &&\n        this.sourceBlock_.workspace.rendered) {\n      this.constants_ =\n          /** @type {!WorkspaceSvg} */ (this.sourceBlock_.workspace)\n              .getRenderer()\n              .getConstants();\n    }\n    return this.constants_;\n  }\n\n  /**\n   * Get the block this field is attached to.\n   * @return {Block} The block containing this field.\n   */\n  getSourceBlock() {\n    return this.sourceBlock_;\n  }\n\n  /**\n   * Initialize everything to render this field. Override\n   * methods initModel and initView rather than this method.\n   * @package\n   * @final\n   */\n  init() {\n    if (this.fieldGroup_) {\n      // Field has already been initialized once.\n      return;\n    }\n    this.fieldGroup_ = dom.createSvgElement(Svg.G, {}, null);\n    if (!this.isVisible()) {\n      this.fieldGroup_.style.display = 'none';\n    }\n    const sourceBlockSvg = /** @type {!BlockSvg} **/ (this.sourceBlock_);\n    sourceBlockSvg.getSvgRoot().appendChild(this.fieldGroup_);\n    this.initView();\n    this.updateEditable();\n    this.setTooltip(this.tooltip_);\n    this.bindEvents_();\n    this.initModel();\n  }\n\n  /**\n   * Create the block UI for this field.\n   * @package\n   */\n  initView() {\n    this.createBorderRect_();\n    this.createTextElement_();\n  }\n\n  /**\n   * Initializes the model of the field after it has been installed on a block.\n   * No-op by default.\n   * @package\n   */\n  initModel() {}\n\n  /**\n   * Create a field border rect element. Not to be overridden by subclasses.\n   * Instead modify the result of the function inside initView, or create a\n   * separate function to call.\n   * @protected\n   */\n  createBorderRect_() {\n    this.borderRect_ = dom.createSvgElement(\n        Svg.RECT, {\n          'rx': this.getConstants().FIELD_BORDER_RECT_RADIUS,\n          'ry': this.getConstants().FIELD_BORDER_RECT_RADIUS,\n          'x': 0,\n          'y': 0,\n          'height': this.size_.height,\n          'width': this.size_.width,\n          'class': 'blocklyFieldRect',\n        },\n        this.fieldGroup_);\n  }\n\n  /**\n   * Create a field text element. Not to be overridden by subclasses. Instead\n   * modify the result of the function inside initView, or create a separate\n   * function to call.\n   * @protected\n   */\n  createTextElement_() {\n    this.textElement_ = dom.createSvgElement(\n        Svg.TEXT, {\n          'class': 'blocklyText',\n        },\n        this.fieldGroup_);\n    if (this.getConstants().FIELD_TEXT_BASELINE_CENTER) {\n      this.textElement_.setAttribute('dominant-baseline', 'central');\n    }\n    this.textContent_ = document.createTextNode('');\n    this.textElement_.appendChild(this.textContent_);\n  }\n\n  /**\n   * Bind events to the field. Can be overridden by subclasses if they need to\n   * do custom input handling.\n   * @protected\n   */\n  bindEvents_() {\n    Tooltip.bindMouseEvents(this.getClickTarget_());\n    this.mouseDownWrapper_ = browserEvents.conditionalBind(\n        this.getClickTarget_(), 'mousedown', this, this.onMouseDown_);\n  }\n\n  /**\n   * Sets the field's value based on the given XML element. Should only be\n   * called by Blockly.Xml.\n   * @param {!Element} fieldElement The element containing info about the\n   *    field's state.\n   * @package\n   */\n  fromXml(fieldElement) {\n    this.setValue(fieldElement.textContent);\n  }\n\n  /**\n   * Serializes this field's value to XML. Should only be called by Blockly.Xml.\n   * @param {!Element} fieldElement The element to populate with info about the\n   *    field's state.\n   * @return {!Element} The element containing info about the field's state.\n   * @package\n   */\n  toXml(fieldElement) {\n    fieldElement.textContent = this.getValue();\n    return fieldElement;\n  }\n\n  /**\n   * Saves this fields value as something which can be serialized to JSON.\n   * Should only be called by the serialization system.\n   * @param {boolean=} _doFullSerialization If true, this signals to the field\n   *     that if it normally just saves a reference to some state (eg variable\n   *     fields) it should instead serialize the full state of the thing being\n   *     referenced.\n   * @return {*} JSON serializable state.\n   * @package\n   */\n  saveState(_doFullSerialization) {\n    const legacyState = this.saveLegacyState(Field);\n    if (legacyState !== null) {\n      return legacyState;\n    }\n    return this.getValue();\n  }\n\n  /**\n   * Sets the field's state based on the given state value. Should only be\n   * called by the serialization system.\n   * @param {*} state The state we want to apply to the field.\n   * @package\n   */\n  loadState(state) {\n    if (this.loadLegacyState(Field, state)) {\n      return;\n    }\n    this.setValue(state);\n  }\n\n  /**\n   * Returns a stringified version of the XML state, if it should be used.\n   * Otherwise this returns null, to signal the field should use its own\n   * serialization.\n   * @param {*} callingClass The class calling this method.\n   *     Used to see if `this` has overridden any relevant hooks.\n   * @return {?string} The stringified version of the XML state, or null.\n   * @protected\n   */\n  saveLegacyState(callingClass) {\n    if (callingClass.prototype.saveState === this.saveState &&\n        callingClass.prototype.toXml !== this.toXml) {\n      const elem = utilsXml.createElement('field');\n      elem.setAttribute('name', this.name || '');\n      const text = Xml.domToText(this.toXml(elem));\n      return text.replace(\n          ' xmlns=\"https://developers.google.com/blockly/xml\"', '');\n    }\n    // Either they called this on purpose from their saveState, or they have\n    // no implementations of either hook. Just do our thing.\n    return null;\n  }\n\n  /**\n   * Loads the given state using either the old XML hoooks, if they should be\n   * used. Returns true to indicate loading has been handled, false otherwise.\n   * @param {*} callingClass The class calling this method.\n   *     Used to see if `this` has overridden any relevant hooks.\n   * @param {*} state The state to apply to the field.\n   * @return {boolean} Whether the state was applied or not.\n   */\n  loadLegacyState(callingClass, state) {\n    if (callingClass.prototype.loadState === this.loadState &&\n        callingClass.prototype.fromXml !== this.fromXml) {\n      this.fromXml(Xml.textToDom(/** @type {string} */ (state)));\n      return true;\n    }\n    // Either they called this on purpose from their loadState, or they have\n    // no implementations of either hook. Just do our thing.\n    return false;\n  }\n\n  /**\n   * Dispose of all DOM objects and events belonging to this editable field.\n   * @package\n   */\n  dispose() {\n    dropDownDiv.hideIfOwner(this);\n    WidgetDiv.hideIfOwner(this);\n    Tooltip.unbindMouseEvents(this.getClickTarget_());\n\n    if (this.mouseDownWrapper_) {\n      browserEvents.unbind(this.mouseDownWrapper_);\n    }\n\n    dom.removeNode(this.fieldGroup_);\n\n    this.disposed = true;\n  }\n\n  /**\n   * Add or remove the UI indicating if this field is editable or not.\n   */\n  updateEditable() {\n    const group = this.fieldGroup_;\n    if (!this.EDITABLE || !group) {\n      return;\n    }\n    if (this.enabled_ && this.sourceBlock_.isEditable()) {\n      dom.addClass(group, 'blocklyEditableText');\n      dom.removeClass(group, 'blocklyNonEditableText');\n      group.style.cursor = this.CURSOR;\n    } else {\n      dom.addClass(group, 'blocklyNonEditableText');\n      dom.removeClass(group, 'blocklyEditableText');\n      group.style.cursor = '';\n    }\n  }\n\n  /**\n   * Set whether this field's value can be changed using the editor when the\n   *     source block is editable.\n   * @param {boolean} enabled True if enabled.\n   */\n  setEnabled(enabled) {\n    this.enabled_ = enabled;\n    this.updateEditable();\n  }\n\n  /**\n   * Check whether this field's value can be changed using the editor when the\n   *     source block is editable.\n   * @return {boolean} Whether this field is enabled.\n   */\n  isEnabled() {\n    return this.enabled_;\n  }\n\n  /**\n   * Check whether this field defines the showEditor_ function.\n   * @return {boolean} Whether this field is clickable.\n   */\n  isClickable() {\n    return this.enabled_ && !!this.sourceBlock_ &&\n        this.sourceBlock_.isEditable() &&\n        this.showEditor_ !== Field.prototype.showEditor_;\n  }\n\n  /**\n   * Check whether this field is currently editable.  Some fields are never\n   * EDITABLE (e.g. text labels). Other fields may be EDITABLE but may exist on\n   * non-editable blocks or be currently disabled.\n   * @return {boolean} Whether this field is currently enabled, editable and on\n   * an editable block.\n   */\n  isCurrentlyEditable() {\n    return this.enabled_ && this.EDITABLE && !!this.sourceBlock_ &&\n        this.sourceBlock_.isEditable();\n  }\n\n  /**\n   * Check whether this field should be serialized by the XML renderer.\n   * Handles the logic for backwards compatibility and incongruous states.\n   * @return {boolean} Whether this field should be serialized or not.\n   */\n  isSerializable() {\n    let isSerializable = false;\n    if (this.name) {\n      if (this.SERIALIZABLE) {\n        isSerializable = true;\n      } else if (this.EDITABLE) {\n        console.warn(\n            'Detected an editable field that was not serializable.' +\n            ' Please define SERIALIZABLE property as true on all editable custom' +\n            ' fields. Proceeding with serialization.');\n        isSerializable = true;\n      }\n    }\n    return isSerializable;\n  }\n\n  /**\n   * Gets whether this editable field is visible or not.\n   * @return {boolean} True if visible.\n   */\n  isVisible() {\n    return this.visible_;\n  }\n\n  /**\n   * Sets whether this editable field is visible or not. Should only be called\n   * by input.setVisible.\n   * @param {boolean} visible True if visible.\n   * @package\n   */\n  setVisible(visible) {\n    if (this.visible_ === visible) {\n      return;\n    }\n    this.visible_ = visible;\n    const root = this.getSvgRoot();\n    if (root) {\n      root.style.display = visible ? 'block' : 'none';\n    }\n  }\n\n  /**\n   * Sets a new validation function for editable fields, or clears a previously\n   * set validator.\n   *\n   * The validator function takes in the new field value, and returns\n   * validated value. The validated value could be the input value, a modified\n   * version of the input value, or null to abort the change.\n   *\n   * If the function does not return anything (or returns undefined) the new\n   * value is accepted as valid. This is to allow for fields using the\n   * validated function as a field-level change event notification.\n   *\n   * @param {Function} handler The validator function\n   *     or null to clear a previous validator.\n   */\n  setValidator(handler) {\n    this.validator_ = handler;\n  }\n\n  /**\n   * Gets the validation function for editable fields, or null if not set.\n   * @return {?Function} Validation function, or null.\n   */\n  getValidator() {\n    return this.validator_;\n  }\n\n  /**\n   * Gets the group element for this editable field.\n   * Used for measuring the size and for positioning.\n   * @return {!SVGGElement} The group element.\n   */\n  getSvgRoot() {\n    return /** @type {!SVGGElement} */ (this.fieldGroup_);\n  }\n\n  /**\n   * Updates the field to match the colour/style of the block. Should only be\n   * called by BlockSvg.applyColour().\n   * @package\n   */\n  applyColour() {\n    // Non-abstract sub-classes may wish to implement this. See FieldDropdown.\n  }\n\n  /**\n   * Used by getSize() to move/resize any DOM elements, and get the new size.\n   *\n   * All rendering that has an effect on the size/shape of the block should be\n   * done here, and should be triggered by getSize().\n   * @protected\n   */\n  render_() {\n    if (this.textContent_) {\n      this.textContent_.nodeValue = this.getDisplayText_();\n    }\n    this.updateSize_();\n  }\n\n  /**\n   * Calls showEditor_ when the field is clicked if the field is clickable.\n   * Do not override.\n   * @param {Event=} opt_e Optional mouse event that triggered the field to\n   *     open, or undefined if triggered programmatically.\n   * @package\n   * @final\n   */\n  showEditor(opt_e) {\n    if (this.isClickable()) {\n      this.showEditor_(opt_e);\n    }\n  }\n\n  /**\n   * A developer hook to create an editor for the field. This is no-op by\n   * default, and must be overriden to create an editor.\n   * @param {Event=} _e Optional mouse event that triggered the field to\n   *     open, or undefined if triggered programmatically.\n   * @return {void}\n   * @protected\n   */\n  showEditor_(_e) {\n    // NOP\n  }\n\n  /**\n   * Updates the size of the field based on the text.\n   * @param {number=} opt_margin margin to use when positioning the text\n   *     element.\n   * @protected\n   */\n  updateSize_(opt_margin) {\n    const constants = this.getConstants();\n    const xOffset = opt_margin !== undefined ?\n        opt_margin :\n        (this.borderRect_ ? this.getConstants().FIELD_BORDER_RECT_X_PADDING :\n                            0);\n    let totalWidth = xOffset * 2;\n    let totalHeight = constants.FIELD_TEXT_HEIGHT;\n\n    let contentWidth = 0;\n    if (this.textElement_) {\n      contentWidth = dom.getFastTextWidth(\n          this.textElement_, constants.FIELD_TEXT_FONTSIZE,\n          constants.FIELD_TEXT_FONTWEIGHT, constants.FIELD_TEXT_FONTFAMILY);\n      totalWidth += contentWidth;\n    }\n    if (this.borderRect_) {\n      totalHeight = Math.max(totalHeight, constants.FIELD_BORDER_RECT_HEIGHT);\n    }\n\n    this.size_.height = totalHeight;\n    this.size_.width = totalWidth;\n\n    this.positionTextElement_(xOffset, contentWidth);\n    this.positionBorderRect_();\n  }\n\n  /**\n   * Position a field's text element after a size change.  This handles both LTR\n   * and RTL positioning.\n   * @param {number} xOffset x offset to use when positioning the text element.\n   * @param {number} contentWidth The content width.\n   * @protected\n   */\n  positionTextElement_(xOffset, contentWidth) {\n    if (!this.textElement_) {\n      return;\n    }\n    const constants = this.getConstants();\n    const halfHeight = this.size_.height / 2;\n\n    this.textElement_.setAttribute(\n        'x',\n        this.sourceBlock_.RTL ? this.size_.width - contentWidth - xOffset :\n                                xOffset);\n    this.textElement_.setAttribute(\n        'y',\n        constants.FIELD_TEXT_BASELINE_CENTER ?\n            halfHeight :\n            halfHeight - constants.FIELD_TEXT_HEIGHT / 2 +\n                constants.FIELD_TEXT_BASELINE);\n  }\n\n  /**\n   * Position a field's border rect after a size change.\n   * @protected\n   */\n  positionBorderRect_() {\n    if (!this.borderRect_) {\n      return;\n    }\n    this.borderRect_.setAttribute('width', this.size_.width);\n    this.borderRect_.setAttribute('height', this.size_.height);\n    this.borderRect_.setAttribute(\n        'rx', this.getConstants().FIELD_BORDER_RECT_RADIUS);\n    this.borderRect_.setAttribute(\n        'ry', this.getConstants().FIELD_BORDER_RECT_RADIUS);\n  }\n\n  /**\n   * Returns the height and width of the field.\n   *\n   * This should *in general* be the only place render_ gets called from.\n   * @return {!Size} Height and width.\n   */\n  getSize() {\n    if (!this.isVisible()) {\n      return new Size(0, 0);\n    }\n\n    if (this.isDirty_) {\n      this.render_();\n      this.isDirty_ = false;\n    } else if (this.visible_ && this.size_.width === 0) {\n      // If the field is not visible the width will be 0 as well, one of the\n      // problems with the old system.\n      console.warn(\n          'Deprecated use of setting size_.width to 0 to rerender a' +\n          ' field. Set field.isDirty_ to true instead.');\n      this.render_();\n    }\n    return this.size_;\n  }\n\n  /**\n   * Returns the bounding box of the rendered field, accounting for workspace\n   * scaling.\n   * @return {!Rect} An object with top, bottom, left, and right in\n   *     pixels relative to the top left corner of the page (window\n   * coordinates).\n   * @package\n   */\n  getScaledBBox() {\n    let scaledWidth;\n    let scaledHeight;\n    let xy;\n    if (!this.borderRect_) {\n      // Browsers are inconsistent in what they return for a bounding box.\n      // - Webkit / Blink: fill-box / object bounding box\n      // - Gecko / Triden / EdgeHTML: stroke-box\n      const bBox = this.sourceBlock_.getHeightWidth();\n      const scale =\n          /** @type {!WorkspaceSvg} */ (this.sourceBlock_.workspace).scale;\n      xy = this.getAbsoluteXY_();\n      scaledWidth = bBox.width * scale;\n      scaledHeight = bBox.height * scale;\n\n      if (userAgent.GECKO) {\n        xy.x += 1.5 * scale;\n        xy.y += 1.5 * scale;\n        scaledWidth += 1 * scale;\n        scaledHeight += 1 * scale;\n      } else {\n        if (!userAgent.EDGE && !userAgent.IE) {\n          xy.x -= 0.5 * scale;\n          xy.y -= 0.5 * scale;\n        }\n        scaledWidth += 1 * scale;\n        scaledHeight += 1 * scale;\n      }\n    } else {\n      const bBox = this.borderRect_.getBoundingClientRect();\n      xy = style.getPageOffset(this.borderRect_);\n      scaledWidth = bBox.width;\n      scaledHeight = bBox.height;\n    }\n    return new Rect(xy.y, xy.y + scaledHeight, xy.x, xy.x + scaledWidth);\n  }\n\n  /**\n   * Get the text from this field to display on the block. May differ from\n   * ``getText`` due to ellipsis, and other formatting.\n   * @return {string} Text to display.\n   * @protected\n   */\n  getDisplayText_() {\n    let text = this.getText();\n    if (!text) {\n      // Prevent the field from disappearing if empty.\n      return Field.NBSP;\n    }\n    if (text.length > this.maxDisplayLength) {\n      // Truncate displayed string and add an ellipsis ('...').\n      text = text.substring(0, this.maxDisplayLength - 2) + '\\u2026';\n    }\n    // Replace whitespace with non-breaking spaces so the text doesn't collapse.\n    text = text.replace(/\\s/g, Field.NBSP);\n    if (this.sourceBlock_ && this.sourceBlock_.RTL) {\n      // The SVG is LTR, force text to be RTL.\n      text += '\\u200F';\n    }\n    return text;\n  }\n\n  /**\n   * Get the text from this field.\n   * Override getText_ to provide a different behavior than simply casting the\n   * value to a string.\n   * @return {string} Current text.\n   * @final\n   */\n  getText() {\n    // this.getText_ was intended so that devs don't have to remember to call\n    // super when overriding how the text of the field is generated. (#2910)\n    const text = this.getText_();\n    if (text !== null) return String(text);\n    return String(this.getValue());\n  }\n\n  /**\n   * A developer hook to override the returned text of this field.\n   * Override if the text representation of the value of this field\n   * is not just a string cast of its value.\n   * Return null to resort to a string cast.\n   * @return {?string} Current text or null.\n   * @protected\n   */\n  getText_() {\n    return null;\n  }\n\n  /**\n   * Force a rerender of the block that this field is installed on, which will\n   * rerender this field and adjust for any sizing changes.\n   * Other fields on the same block will not rerender, because their sizes have\n   * already been recorded.\n   * @package\n   */\n  markDirty() {\n    this.isDirty_ = true;\n    this.constants_ = null;\n  }\n\n  /**\n   * Force a rerender of the block that this field is installed on, which will\n   * rerender this field and adjust for any sizing changes.\n   * Other fields on the same block will not rerender, because their sizes have\n   * already been recorded.\n   * @package\n   */\n  forceRerender() {\n    this.isDirty_ = true;\n    if (this.sourceBlock_ && this.sourceBlock_.rendered) {\n      this.sourceBlock_.render();\n      this.sourceBlock_.bumpNeighbours();\n      this.updateMarkers_();\n    }\n  }\n\n  /**\n   * Used to change the value of the field. Handles validation and events.\n   * Subclasses should override doClassValidation_ and doValueUpdate_ rather\n   * than this method.\n   * @param {*} newValue New value.\n   * @final\n   */\n  setValue(newValue) {\n    const doLogging = false;\n    if (newValue === null) {\n      doLogging && console.log('null, return');\n      // Not a valid value to check.\n      return;\n    }\n\n    let validatedValue = this.doClassValidation_(newValue);\n    // Class validators might accidentally forget to return, we'll ignore that.\n    newValue = this.processValidation_(newValue, validatedValue);\n    if (newValue instanceof Error) {\n      doLogging && console.log('invalid class validation, return');\n      return;\n    }\n\n    const localValidator = this.getValidator();\n    if (localValidator) {\n      validatedValue = localValidator.call(this, newValue);\n      // Local validators might accidentally forget to return, we'll ignore\n      // that.\n      newValue = this.processValidation_(newValue, validatedValue);\n      if (newValue instanceof Error) {\n        doLogging && console.log('invalid local validation, return');\n        return;\n      }\n    }\n    const source = this.sourceBlock_;\n    if (source && source.disposed) {\n      doLogging && console.log('source disposed, return');\n      return;\n    }\n    const oldValue = this.getValue();\n    if (oldValue === newValue) {\n      doLogging && console.log('same, doValueUpdate_, return');\n      this.doValueUpdate_(newValue);\n      return;\n    }\n\n    this.doValueUpdate_(newValue);\n    if (source && eventUtils.isEnabled()) {\n      eventUtils.fire(new (eventUtils.get(eventUtils.BLOCK_CHANGE))(\n          source, 'field', this.name || null, oldValue, newValue));\n    }\n    if (this.isDirty_) {\n      this.forceRerender();\n    }\n    doLogging && console.log(this.value_);\n  }\n\n  /**\n   * Process the result of validation.\n   * @param {*} newValue New value.\n   * @param {*} validatedValue Validated value.\n   * @return {*} New value, or an Error object.\n   * @private\n   */\n  processValidation_(newValue, validatedValue) {\n    if (validatedValue === null) {\n      this.doValueInvalid_(newValue);\n      if (this.isDirty_) {\n        this.forceRerender();\n      }\n      return Error();\n    }\n    if (validatedValue !== undefined) {\n      newValue = validatedValue;\n    }\n    return newValue;\n  }\n\n  /**\n   * Get the current value of the field.\n   * @return {*} Current value.\n   */\n  getValue() {\n    return this.value_;\n  }\n\n  /**\n   * Used to validate a value. Returns input by default. Can be overridden by\n   * subclasses, see FieldDropdown.\n   * @param {*=} opt_newValue The value to be validated.\n   * @return {*} The validated value, same as input by default.\n   * @protected\n   */\n  doClassValidation_(opt_newValue) {\n    if (opt_newValue === null || opt_newValue === undefined) {\n      return null;\n    }\n    return opt_newValue;\n  }\n\n  /**\n   * Used to update the value of a field. Can be overridden by subclasses to do\n   * custom storage of values/updating of external things.\n   * @param {*} newValue The value to be saved.\n   * @protected\n   */\n  doValueUpdate_(newValue) {\n    this.value_ = newValue;\n    this.isDirty_ = true;\n  }\n\n  /**\n   * Used to notify the field an invalid value was input. Can be overridden by\n   * subclasses, see FieldTextInput.\n   * No-op by default.\n   * @param {*} _invalidValue The input value that was determined to be invalid.\n   * @protected\n   */\n  doValueInvalid_(_invalidValue) {\n    // NOP\n  }\n\n  /**\n   * Handle a mouse down event on a field.\n   * @param {!Event} e Mouse down event.\n   * @protected\n   */\n  onMouseDown_(e) {\n    if (!this.sourceBlock_ || !this.sourceBlock_.workspace) {\n      return;\n    }\n    const gesture =\n        /** @type {!WorkspaceSvg} */ (this.sourceBlock_.workspace)\n            .getGesture(e);\n    if (gesture) {\n      gesture.setStartField(this);\n    }\n  }\n\n  /**\n   * Sets the tooltip for this field.\n   * @param {?Tooltip.TipInfo} newTip The\n   *     text for the tooltip, a function that returns the text for the tooltip,\n   * a parent object whose tooltip will be used, or null to display the tooltip\n   *     of the parent block. To not display a tooltip pass the empty string.\n   */\n  setTooltip(newTip) {\n    if (!newTip && newTip !== '') {  // If null or undefined.\n      newTip = this.sourceBlock_;\n    }\n    const clickTarget = this.getClickTarget_();\n    if (clickTarget) {\n      clickTarget.tooltip = newTip;\n    } else {\n      // Field has not been initialized yet.\n      this.tooltip_ = newTip;\n    }\n  }\n\n  /**\n   * Returns the tooltip text for this field.\n   * @return {string} The tooltip text for this field.\n   */\n  getTooltip() {\n    const clickTarget = this.getClickTarget_();\n    if (clickTarget) {\n      return Tooltip.getTooltipOfObject(clickTarget);\n    }\n    // Field has not been initialized yet. Return stashed this.tooltip_ value.\n    return Tooltip.getTooltipOfObject({tooltip: this.tooltip_});\n  }\n\n  /**\n   * The element to bind the click handler to. If not set explicitly, defaults\n   * to the SVG root of the field. When this element is\n   * clicked on an editable field, the editor will open.\n   * @return {!Element} Element to bind click handler to.\n   * @protected\n   */\n  getClickTarget_() {\n    return this.clickTarget_ || this.getSvgRoot();\n  }\n\n  /**\n   * Return the absolute coordinates of the top-left corner of this field.\n   * The origin (0,0) is the top-left corner of the page body.\n   * @return {!Coordinate} Object with .x and .y properties.\n   * @protected\n   */\n  getAbsoluteXY_() {\n    return style.getPageOffset(\n        /** @type {!SVGRectElement} */ (this.getClickTarget_()));\n  }\n\n  /**\n   * Whether this field references any Blockly variables.  If true it may need\n   * to be handled differently during serialization and deserialization.\n   * Subclasses may override this.\n   * @return {boolean} True if this field has any variable references.\n   * @package\n   */\n  referencesVariables() {\n    return false;\n  }\n\n  /**\n   * Refresh the variable name referenced by this field if this field references\n   * variables.\n   * @package\n   */\n  refreshVariableName() {\n    // NOP\n  }\n\n  /**\n   * Search through the list of inputs and their fields in order to find the\n   * parent input of a field.\n   * @return {Input} The input that the field belongs to.\n   * @package\n   */\n  getParentInput() {\n    let parentInput = null;\n    const block = this.sourceBlock_;\n    const inputs = block.inputList;\n\n    for (let idx = 0; idx < block.inputList.length; idx++) {\n      const input = inputs[idx];\n      const fieldRows = input.fieldRow;\n      for (let j = 0; j < fieldRows.length; j++) {\n        if (fieldRows[j] === this) {\n          parentInput = input;\n          break;\n        }\n      }\n    }\n    return parentInput;\n  }\n\n  /**\n   * Returns whether or not we should flip the field in RTL.\n   * @return {boolean} True if we should flip in RTL.\n   */\n  getFlipRtl() {\n    return false;\n  }\n\n  /**\n   * Returns whether or not the field is tab navigable.\n   * @return {boolean} True if the field is tab navigable.\n   */\n  isTabNavigable() {\n    return false;\n  }\n\n  /**\n   * Handles the given keyboard shortcut.\n   * @param {!ShortcutRegistry.KeyboardShortcut} _shortcut The shortcut to be\n   *     handled.\n   * @return {boolean} True if the shortcut has been handled, false otherwise.\n   * @public\n   */\n  onShortcut(_shortcut) {\n    return false;\n  }\n\n  /**\n   * Add the cursor SVG to this fields SVG group.\n   * @param {SVGElement} cursorSvg The SVG root of the cursor to be added to the\n   *     field group.\n   * @package\n   */\n  setCursorSvg(cursorSvg) {\n    if (!cursorSvg) {\n      this.cursorSvg_ = null;\n      return;\n    }\n\n    this.fieldGroup_.appendChild(cursorSvg);\n    this.cursorSvg_ = cursorSvg;\n  }\n\n  /**\n   * Add the marker SVG to this fields SVG group.\n   * @param {SVGElement} markerSvg The SVG root of the marker to be added to the\n   *     field group.\n   * @package\n   */\n  setMarkerSvg(markerSvg) {\n    if (!markerSvg) {\n      this.markerSvg_ = null;\n      return;\n    }\n\n    this.fieldGroup_.appendChild(markerSvg);\n    this.markerSvg_ = markerSvg;\n  }\n\n  /**\n   * Redraw any attached marker or cursor svgs if needed.\n   * @protected\n   */\n  updateMarkers_() {\n    const workspace =\n        /** @type {!WorkspaceSvg} */ (this.sourceBlock_.workspace);\n    if (workspace.keyboardAccessibilityMode && this.cursorSvg_) {\n      workspace.getCursor().draw();\n    }\n    if (workspace.keyboardAccessibilityMode && this.markerSvg_) {\n      // TODO(#4592): Update all markers on the field.\n      workspace.getMarker(MarkerManager.LOCAL_MARKER).draw();\n    }\n  }\n}\n\n/**\n * The default value for this field.\n * @type {*}\n * @protected\n */\nField.prototype.DEFAULT_VALUE = null;\n\n/**\n * Non-breaking space.\n * @const\n */\nField.NBSP = '\\u00A0';\n\n/**\n * A value used to signal when a field's constructor should *not* set the\n * field's value or run configure_, and should allow a subclass to do that\n * instead.\n * @const\n */\nField.SKIP_SETUP = new Sentinel();\n\nexports.Field = Field;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/field.js?")},
"./core/field_angle.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/css.js\");\n__webpack_require__(\"./core/widgetdiv.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/dropdowndiv.js\");\n__webpack_require__(\"./core/field_registry.js\");\n__webpack_require__(\"./core/utils/math.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\n__webpack_require__(\"./core/field.js\");\n__webpack_require__(\"./core/field_textinput.js\");\n__webpack_require__(\"./core/utils/keycodes.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2013 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Angle input field.\n */\n\n\n/**\n * Angle input field.\n * @class\n */\ngoog.module('Blockly.FieldAngle');\n\nconst Css = goog.require('Blockly.Css');\nconst WidgetDiv = goog.require('Blockly.WidgetDiv');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst dom = goog.require('Blockly.utils.dom');\nconst dropDownDiv = goog.require('Blockly.dropDownDiv');\nconst fieldRegistry = goog.require('Blockly.fieldRegistry');\nconst math = goog.require('Blockly.utils.math');\nconst userAgent = goog.require('Blockly.utils.userAgent');\nconst {Field} = goog.require('Blockly.Field');\nconst {FieldTextInput} = goog.require('Blockly.FieldTextInput');\nconst {KeyCodes} = goog.require('Blockly.utils.KeyCodes');\n/* eslint-disable-next-line no-unused-vars */\nconst {Sentinel} = goog.requireType('Blockly.utils.Sentinel');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n\n\n/**\n * Class for an editable angle field.\n * @extends {FieldTextInput}\n * @alias Blockly.FieldAngle\n */\nclass FieldAngle extends FieldTextInput {\n  /**\n   * @param {(string|number|!Sentinel)=} opt_value The initial value of\n   *     the field. Should cast to a number. Defaults to 0.\n   *     Also accepts Field.SKIP_SETUP if you wish to skip setup (only used by\n   *     subclasses that want to handle configuration and setting the field\n   *     value after their own constructors have run).\n   * @param {Function=} opt_validator A function that is called to validate\n   *     changes to the field's value. Takes in a number & returns a\n   *     validated number, or null to abort the change.\n   * @param {Object=} opt_config A map of options used to configure the field.\n   *     See the [field creation documentation]{@link\n   *     https://developers.google.com/blockly/guides/create-custom-blocks/fields/built-in-fields/angle#creation}\n   *     for a list of properties this parameter supports.\n   */\n  constructor(opt_value, opt_validator, opt_config) {\n    super(Field.SKIP_SETUP);\n\n    /**\n     * Should the angle increase as the angle picker is moved clockwise (true)\n     * or counterclockwise (false)\n     * @see FieldAngle.CLOCKWISE\n     * @type {boolean}\n     * @private\n     */\n    this.clockwise_ = FieldAngle.CLOCKWISE;\n\n    /**\n     * The offset of zero degrees (and all other angles).\n     * @see FieldAngle.OFFSET\n     * @type {number}\n     * @private\n     */\n    this.offset_ = FieldAngle.OFFSET;\n\n    /**\n     * The maximum angle to allow before wrapping.\n     * @see FieldAngle.WRAP\n     * @type {number}\n     * @private\n     */\n    this.wrap_ = FieldAngle.WRAP;\n\n    /**\n     * The amount to round angles to when using a mouse or keyboard nav input.\n     * @see FieldAngle.ROUND\n     * @type {number}\n     * @private\n     */\n    this.round_ = FieldAngle.ROUND;\n\n    /**\n     * The angle picker's SVG element.\n     * @type {?SVGElement}\n     * @private\n     */\n    this.editor_ = null;\n\n    /**\n     * The angle picker's gauge path depending on the value.\n     * @type {?SVGElement}\n     */\n    this.gauge_ = null;\n\n    /**\n     * The angle picker's line drawn representing the value's angle.\n     * @type {?SVGElement}\n     */\n    this.line_ = null;\n\n    /**\n     * The degree symbol for this field.\n     * @type {SVGTSpanElement}\n     * @protected\n     */\n    this.symbol_ = null;\n\n    /**\n     * Wrapper click event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.clickWrapper_ = null;\n\n    /**\n     * Surface click event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.clickSurfaceWrapper_ = null;\n\n    /**\n     * Surface mouse move event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.moveSurfaceWrapper_ = null;\n\n    /**\n     * Serializable fields are saved by the serializer, non-serializable fields\n     * are not. Editable fields should also be serializable.\n     * @type {boolean}\n     */\n    this.SERIALIZABLE = true;\n\n    if (opt_value === Field.SKIP_SETUP) return;\n    if (opt_config) this.configure_(opt_config);\n    this.setValue(opt_value);\n    if (opt_validator) this.setValidator(opt_validator);\n  }\n\n  /**\n   * Configure the field based on the given map of options.\n   * @param {!Object} config A map of options to configure the field based on.\n   * @protected\n   * @override\n   */\n  configure_(config) {\n    super.configure_(config);\n\n    switch (config['mode']) {\n      case 'compass':\n        this.clockwise_ = true;\n        this.offset_ = 90;\n        break;\n      case 'protractor':\n        // This is the default mode, so we could do nothing. But just to\n        // future-proof, we'll set it anyway.\n        this.clockwise_ = false;\n        this.offset_ = 0;\n        break;\n    }\n\n    // Allow individual settings to override the mode setting.\n    const clockwise = config['clockwise'];\n    if (typeof clockwise === 'boolean') {\n      this.clockwise_ = clockwise;\n    }\n\n    // If these are passed as null then we should leave them on the default.\n    let offset = config['offset'];\n    if (offset !== null) {\n      offset = Number(offset);\n      if (!isNaN(offset)) {\n        this.offset_ = offset;\n      }\n    }\n    let wrap = config['wrap'];\n    if (wrap !== null) {\n      wrap = Number(wrap);\n      if (!isNaN(wrap)) {\n        this.wrap_ = wrap;\n      }\n    }\n    let round = config['round'];\n    if (round !== null) {\n      round = Number(round);\n      if (!isNaN(round)) {\n        this.round_ = round;\n      }\n    }\n  }\n\n  /**\n   * Create the block UI for this field.\n   * @package\n   */\n  initView() {\n    super.initView();\n    // Add the degree symbol to the left of the number, even in RTL (issue\n    // #2380)\n    this.symbol_ = dom.createSvgElement(Svg.TSPAN, {}, null);\n    this.symbol_.appendChild(document.createTextNode('\\u00B0'));\n    this.textElement_.appendChild(this.symbol_);\n  }\n\n  /**\n   * Updates the graph when the field rerenders.\n   * @protected\n   * @override\n   */\n  render_() {\n    super.render_();\n    this.updateGraph_();\n  }\n\n  /**\n   * Create and show the angle field's editor.\n   * @param {Event=} opt_e Optional mouse event that triggered the field to\n   *     open, or undefined if triggered programmatically.\n   * @protected\n   */\n  showEditor_(opt_e) {\n    // Mobile browsers have issues with in-line textareas (focus & keyboards).\n    const noFocus = userAgent.MOBILE || userAgent.ANDROID || userAgent.IPAD;\n    super.showEditor_(opt_e, noFocus);\n\n    this.dropdownCreate_();\n    dropDownDiv.getContentDiv().appendChild(this.editor_);\n\n    dropDownDiv.setColour(\n        this.sourceBlock_.style.colourPrimary,\n        this.sourceBlock_.style.colourTertiary);\n\n    dropDownDiv.showPositionedByField(this, this.dropdownDispose_.bind(this));\n\n    this.updateGraph_();\n  }\n\n  /**\n   * Create the angle dropdown editor.\n   * @private\n   */\n  dropdownCreate_() {\n    const svg = dom.createSvgElement(\n        Svg.SVG, {\n          'xmlns': dom.SVG_NS,\n          'xmlns:html': dom.HTML_NS,\n          'xmlns:xlink': dom.XLINK_NS,\n          'version': '1.1',\n          'height': (FieldAngle.HALF * 2) + 'px',\n          'width': (FieldAngle.HALF * 2) + 'px',\n          'style': 'touch-action: none',\n        },\n        null);\n    const circle = dom.createSvgElement(\n        Svg.CIRCLE, {\n          'cx': FieldAngle.HALF,\n          'cy': FieldAngle.HALF,\n          'r': FieldAngle.RADIUS,\n          'class': 'blocklyAngleCircle',\n        },\n        svg);\n    this.gauge_ =\n        dom.createSvgElement(Svg.PATH, {'class': 'blocklyAngleGauge'}, svg);\n    this.line_ = dom.createSvgElement(\n        Svg.LINE, {\n          'x1': FieldAngle.HALF,\n          'y1': FieldAngle.HALF,\n          'class': 'blocklyAngleLine',\n        },\n        svg);\n    // Draw markers around the edge.\n    for (let angle = 0; angle < 360; angle += 15) {\n      dom.createSvgElement(\n          Svg.LINE, {\n            'x1': FieldAngle.HALF + FieldAngle.RADIUS,\n            'y1': FieldAngle.HALF,\n            'x2': FieldAngle.HALF + FieldAngle.RADIUS -\n                (angle % 45 === 0 ? 10 : 5),\n            'y2': FieldAngle.HALF,\n            'class': 'blocklyAngleMarks',\n            'transform': 'rotate(' + angle + ',' + FieldAngle.HALF + ',' +\n                FieldAngle.HALF + ')',\n          },\n          svg);\n    }\n\n    // The angle picker is different from other fields in that it updates on\n    // mousemove even if it's not in the middle of a drag.  In future we may\n    // change this behaviour.\n    this.clickWrapper_ =\n        browserEvents.conditionalBind(svg, 'click', this, this.hide_);\n    // On touch devices, the picker's value is only updated with a drag. Add\n    // a click handler on the drag surface to update the value if the surface\n    // is clicked.\n    this.clickSurfaceWrapper_ = browserEvents.conditionalBind(\n        circle, 'click', this, this.onMouseMove_, true, true);\n    this.moveSurfaceWrapper_ = browserEvents.conditionalBind(\n        circle, 'mousemove', this, this.onMouseMove_, true, true);\n    this.editor_ = svg;\n  }\n\n  /**\n   * Disposes of events and DOM-references belonging to the angle editor.\n   * @private\n   */\n  dropdownDispose_() {\n    if (this.clickWrapper_) {\n      browserEvents.unbind(this.clickWrapper_);\n      this.clickWrapper_ = null;\n    }\n    if (this.clickSurfaceWrapper_) {\n      browserEvents.unbind(this.clickSurfaceWrapper_);\n      this.clickSurfaceWrapper_ = null;\n    }\n    if (this.moveSurfaceWrapper_) {\n      browserEvents.unbind(this.moveSurfaceWrapper_);\n      this.moveSurfaceWrapper_ = null;\n    }\n    this.gauge_ = null;\n    this.line_ = null;\n  }\n\n  /**\n   * Hide the editor.\n   * @private\n   */\n  hide_() {\n    dropDownDiv.hideIfOwner(this);\n    WidgetDiv.hide();\n  }\n\n  /**\n   * Set the angle to match the mouse's position.\n   * @param {!Event} e Mouse move event.\n   * @protected\n   */\n  onMouseMove_(e) {\n    // Calculate angle.\n    const bBox = this.gauge_.ownerSVGElement.getBoundingClientRect();\n    const dx = e.clientX - bBox.left - FieldAngle.HALF;\n    const dy = e.clientY - bBox.top - FieldAngle.HALF;\n    let angle = Math.atan(-dy / dx);\n    if (isNaN(angle)) {\n      // This shouldn't happen, but let's not let this error propagate further.\n      return;\n    }\n    angle = math.toDegrees(angle);\n    // 0: East, 90: North, 180: West, 270: South.\n    if (dx < 0) {\n      angle += 180;\n    } else if (dy > 0) {\n      angle += 360;\n    }\n\n    // Do offsetting.\n    if (this.clockwise_) {\n      angle = this.offset_ + 360 - angle;\n    } else {\n      angle = 360 - (this.offset_ - angle);\n    }\n\n    this.displayMouseOrKeyboardValue_(angle);\n  }\n\n  /**\n   * Handles and displays values that are input via mouse or arrow key input.\n   * These values need to be rounded and wrapped before being displayed so\n   * that the text input's value is appropriate.\n   * @param {number} angle New angle.\n   * @private\n   */\n  displayMouseOrKeyboardValue_(angle) {\n    if (this.round_) {\n      angle = Math.round(angle / this.round_) * this.round_;\n    }\n    angle = this.wrapValue_(angle);\n    if (angle !== this.value_) {\n      this.setEditorValue_(angle);\n    }\n  }\n\n  /**\n   * Redraw the graph with the current angle.\n   * @private\n   */\n  updateGraph_() {\n    if (!this.gauge_) {\n      return;\n    }\n    // Always display the input (i.e. getText) even if it is invalid.\n    let angleDegrees = Number(this.getText()) + this.offset_;\n    angleDegrees %= 360;\n    let angleRadians = math.toRadians(angleDegrees);\n    const path = ['M ', FieldAngle.HALF, ',', FieldAngle.HALF];\n    let x2 = FieldAngle.HALF;\n    let y2 = FieldAngle.HALF;\n    if (!isNaN(angleRadians)) {\n      const clockwiseFlag = Number(this.clockwise_);\n      const angle1 = math.toRadians(this.offset_);\n      const x1 = Math.cos(angle1) * FieldAngle.RADIUS;\n      const y1 = Math.sin(angle1) * -FieldAngle.RADIUS;\n      if (clockwiseFlag) {\n        angleRadians = 2 * angle1 - angleRadians;\n      }\n      x2 += Math.cos(angleRadians) * FieldAngle.RADIUS;\n      y2 -= Math.sin(angleRadians) * FieldAngle.RADIUS;\n      // Don't ask how the flag calculations work.  They just do.\n      let largeFlag =\n          Math.abs(Math.floor((angleRadians - angle1) / Math.PI) % 2);\n      if (clockwiseFlag) {\n        largeFlag = 1 - largeFlag;\n      }\n      path.push(\n          ' l ', x1, ',', y1, ' A ', FieldAngle.RADIUS, ',', FieldAngle.RADIUS,\n          ' 0 ', largeFlag, ' ', clockwiseFlag, ' ', x2, ',', y2, ' z');\n    }\n    this.gauge_.setAttribute('d', path.join(''));\n    this.line_.setAttribute('x2', x2);\n    this.line_.setAttribute('y2', y2);\n  }\n\n  /**\n   * Handle key down to the editor.\n   * @param {!Event} e Keyboard event.\n   * @protected\n   * @override\n   */\n  onHtmlInputKeyDown_(e) {\n    super.onHtmlInputKeyDown_(e);\n\n    let multiplier;\n    if (e.keyCode === KeyCodes.LEFT) {\n      // decrement (increment in RTL)\n      multiplier = this.sourceBlock_.RTL ? 1 : -1;\n    } else if (e.keyCode === KeyCodes.RIGHT) {\n      // increment (decrement in RTL)\n      multiplier = this.sourceBlock_.RTL ? -1 : 1;\n    } else if (e.keyCode === KeyCodes.DOWN) {\n      // decrement\n      multiplier = -1;\n    } else if (e.keyCode === KeyCodes.UP) {\n      // increment\n      multiplier = 1;\n    }\n    if (multiplier) {\n      const value = /** @type {number} */ (this.getValue());\n      this.displayMouseOrKeyboardValue_(value + (multiplier * this.round_));\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }\n\n  /**\n   * Ensure that the input value is a valid angle.\n   * @param {*=} opt_newValue The input value.\n   * @return {?number} A valid angle, or null if invalid.\n   * @protected\n   * @override\n   */\n  doClassValidation_(opt_newValue) {\n    const value = Number(opt_newValue);\n    if (isNaN(value) || !isFinite(value)) {\n      return null;\n    }\n    return this.wrapValue_(value);\n  }\n\n  /**\n   * Wraps the value so that it is in the range (-360 + wrap, wrap).\n   * @param {number} value The value to wrap.\n   * @return {number} The wrapped value.\n   * @private\n   */\n  wrapValue_(value) {\n    value %= 360;\n    if (value < 0) {\n      value += 360;\n    }\n    if (value > this.wrap_) {\n      value -= 360;\n    }\n    return value;\n  }\n\n  /**\n   * Construct a FieldAngle from a JSON arg object.\n   * @param {!Object} options A JSON object with options (angle).\n   * @return {!FieldAngle} The new field instance.\n   * @package\n   * @nocollapse\n   * @override\n   */\n  static fromJson(options) {\n    // `this` might be a subclass of FieldAngle if that class doesn't override\n    // the static fromJson method.\n    return new this(options['angle'], undefined, options);\n  }\n}\n\n/**\n * The default value for this field.\n * @type {*}\n * @protected\n */\nFieldAngle.prototype.DEFAULT_VALUE = 0;\n\n/**\n * The default amount to round angles to when using a mouse or keyboard nav\n * input. Must be a positive integer to support keyboard navigation.\n * @const {number}\n */\nFieldAngle.ROUND = 15;\n\n/**\n * Half the width of protractor image.\n * @const {number}\n */\nFieldAngle.HALF = 100 / 2;\n\n/**\n * Default property describing which direction makes an angle field's value\n * increase. Angle increases clockwise (true) or counterclockwise (false).\n * @const {boolean}\n */\nFieldAngle.CLOCKWISE = false;\n\n/**\n * The default offset of 0 degrees (and all angles). Always offsets in the\n * counterclockwise direction, regardless of the field's clockwise property.\n * Usually either 0 (0 = right) or 90 (0 = up).\n * @const {number}\n */\nFieldAngle.OFFSET = 0;\n\n/**\n * The default maximum angle to allow before wrapping.\n * Usually either 360 (for 0 to 359.9) or 180 (for -179.9 to 180).\n * @const {number}\n */\nFieldAngle.WRAP = 360;\n\n/**\n * Radius of protractor circle.  Slightly smaller than protractor size since\n * otherwise SVG crops off half the border at the edges.\n * @const {number}\n */\nFieldAngle.RADIUS = FieldAngle.HALF - 1;\n\n/**\n * CSS for angle field.  See css.js for use.\n */\nCss.register(`\n.blocklyAngleCircle {\n  stroke: #444;\n  stroke-width: 1;\n  fill: #ddd;\n  fill-opacity: .8;\n}\n\n.blocklyAngleMarks {\n  stroke: #444;\n  stroke-width: 1;\n}\n\n.blocklyAngleGauge {\n  fill: #f88;\n  fill-opacity: .8;\n  pointer-events: none;\n}\n\n.blocklyAngleLine {\n  stroke: #f00;\n  stroke-width: 2;\n  stroke-linecap: round;\n  pointer-events: none;\n}\n`);\n\nfieldRegistry.register('field_angle', FieldAngle);\n\nexports.FieldAngle = FieldAngle;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/field_angle.js?")},
"./core/field_checkbox.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/field_registry.js\");\n__webpack_require__(\"./core/field.js\");\n__webpack_require__(\"./core/events/events_block_change.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Checkbox field.  Checked or not checked.\n */\n\n\n/**\n * Checkbox field.  Checked or not checked.\n * @class\n */\ngoog.module('Blockly.FieldCheckbox');\n\nconst dom = goog.require('Blockly.utils.dom');\nconst fieldRegistry = goog.require('Blockly.fieldRegistry');\nconst {Field} = goog.require('Blockly.Field');\n/* eslint-disable-next-line no-unused-vars */\nconst {Sentinel} = goog.requireType('Blockly.utils.Sentinel');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockChange');\n\n\n/**\n * Class for a checkbox field.\n * @extends {Field}\n * @alias Blockly.FieldCheckbox\n */\nclass FieldCheckbox extends Field {\n  /**\n   * @param {(string|boolean|!Sentinel)=} opt_value The initial value of\n   *     the field. Should either be 'TRUE', 'FALSE' or a boolean. Defaults to\n   *     'FALSE'.\n   *     Also accepts Field.SKIP_SETUP if you wish to skip setup (only used by\n   *     subclasses that want to handle configuration and setting the field\n   *     value after their own constructors have run).\n   * @param {Function=} opt_validator  A function that is called to validate\n   *     changes to the field's value. Takes in a value ('TRUE' or 'FALSE') &\n   *     returns a validated value ('TRUE' or 'FALSE'), or null to abort the\n   *     change.\n   * @param {Object=} opt_config A map of options used to configure the field.\n   *     See the [field creation documentation]{@link\n   *     https://developers.google.com/blockly/guides/create-custom-blocks/fields/built-in-fields/checkbox#creation}\n   *     for a list of properties this parameter supports.\n   */\n  constructor(opt_value, opt_validator, opt_config) {\n    super(Field.SKIP_SETUP);\n\n    /**\n     * Character for the check mark. Used to apply a different check mark\n     * character to individual fields.\n     * @type {string}\n     * @private\n     */\n    this.checkChar_ = FieldCheckbox.CHECK_CHAR;\n\n    /**\n     * Serializable fields are saved by the serializer, non-serializable fields\n     * are not. Editable fields should also be serializable.\n     * @type {boolean}\n     */\n    this.SERIALIZABLE = true;\n\n    /**\n     * Mouse cursor style when over the hotspot that initiates editability.\n     * @type {string}\n     */\n    this.CURSOR = 'default';\n\n    if (opt_value === Field.SKIP_SETUP) return;\n    if (opt_config) this.configure_(opt_config);\n    this.setValue(opt_value);\n    if (opt_validator) this.setValidator(opt_validator);\n  }\n\n  /**\n   * Configure the field based on the given map of options.\n   * @param {!Object} config A map of options to configure the field based on.\n   * @protected\n   * @override\n   */\n  configure_(config) {\n    super.configure_(config);\n    if (config['checkCharacter']) {\n      this.checkChar_ = config['checkCharacter'];\n    }\n  }\n\n  /**\n   * Saves this field's value.\n   * @return {*} The boolean value held by this field.\n   * @override\n   * @package\n   */\n  saveState() {\n    const legacyState = this.saveLegacyState(FieldCheckbox);\n    if (legacyState !== null) {\n      return legacyState;\n    }\n    return this.getValueBoolean();\n  }\n\n  /**\n   * Create the block UI for this checkbox.\n   * @package\n   */\n  initView() {\n    super.initView();\n\n    dom.addClass(\n        /** @type {!SVGTextElement} **/ (this.textElement_), 'blocklyCheckbox');\n    this.textElement_.style.display = this.value_ ? 'block' : 'none';\n  }\n\n  /**\n   * @override\n   */\n  render_() {\n    if (this.textContent_) {\n      this.textContent_.nodeValue = this.getDisplayText_();\n    }\n    this.updateSize_(this.getConstants().FIELD_CHECKBOX_X_OFFSET);\n  }\n\n  /**\n   * @override\n   */\n  getDisplayText_() {\n    return this.checkChar_;\n  }\n\n  /**\n   * Set the character used for the check mark.\n   * @param {?string} character The character to use for the check mark, or\n   *    null to use the default.\n   */\n  setCheckCharacter(character) {\n    this.checkChar_ = character || FieldCheckbox.CHECK_CHAR;\n    this.forceRerender();\n  }\n\n  /**\n   * Toggle the state of the checkbox on click.\n   * @protected\n   */\n  showEditor_() {\n    this.setValue(!this.value_);\n  }\n\n  /**\n   * Ensure that the input value is valid ('TRUE' or 'FALSE').\n   * @param {*=} opt_newValue The input value.\n   * @return {?string} A valid value ('TRUE' or 'FALSE), or null if invalid.\n   * @protected\n   */\n  doClassValidation_(opt_newValue) {\n    if (opt_newValue === true || opt_newValue === 'TRUE') {\n      return 'TRUE';\n    }\n    if (opt_newValue === false || opt_newValue === 'FALSE') {\n      return 'FALSE';\n    }\n    return null;\n  }\n\n  /**\n   * Update the value of the field, and update the checkElement.\n   * @param {*} newValue The value to be saved. The default validator guarantees\n   * that this is a either 'TRUE' or 'FALSE'.\n   * @protected\n   */\n  doValueUpdate_(newValue) {\n    this.value_ = this.convertValueToBool_(newValue);\n    // Update visual.\n    if (this.textElement_) {\n      this.textElement_.style.display = this.value_ ? 'block' : 'none';\n    }\n  }\n\n  /**\n   * Get the value of this field, either 'TRUE' or 'FALSE'.\n   * @return {string} The value of this field.\n   */\n  getValue() {\n    return this.value_ ? 'TRUE' : 'FALSE';\n  }\n\n  /**\n   * Get the boolean value of this field.\n   * @return {boolean} The boolean value of this field.\n   */\n  getValueBoolean() {\n    return /** @type {boolean} */ (this.value_);\n  }\n\n  /**\n   * Get the text of this field. Used when the block is collapsed.\n   * @return {string} Text representing the value of this field\n   *    ('true' or 'false').\n   */\n  getText() {\n    return String(this.convertValueToBool_(this.value_));\n  }\n\n  /**\n   * Convert a value into a pure boolean.\n   *\n   * Converts 'TRUE' to true and 'FALSE' to false correctly, everything else\n   * is cast to a boolean.\n   * @param {*} value The value to convert.\n   * @return {boolean} The converted value.\n   * @private\n   */\n  convertValueToBool_(value) {\n    if (typeof value === 'string') {\n      return value === 'TRUE';\n    } else {\n      return !!value;\n    }\n  }\n\n  /**\n   * Construct a FieldCheckbox from a JSON arg object.\n   * @param {!Object} options A JSON object with options (checked).\n   * @return {!FieldCheckbox} The new field instance.\n   * @package\n   * @nocollapse\n   */\n  static fromJson(options) {\n    // `this` might be a subclass of FieldCheckbox if that class doesn't\n    // 'override' the static fromJson method.\n    return new this(options['checked'], undefined, options);\n  }\n}\n\n/**\n * The default value for this field.\n * @type {*}\n * @protected\n */\nFieldCheckbox.prototype.DEFAULT_VALUE = false;\n\n/**\n * Default character for the checkmark.\n * @type {string}\n * @const\n */\nFieldCheckbox.CHECK_CHAR = '\\u2713';\n\nfieldRegistry.register('field_checkbox', FieldCheckbox);\n\nexports.FieldCheckbox = FieldCheckbox;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/field_checkbox.js?")},
"./core/field_colour.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/css.js\");\n__webpack_require__(\"./core/utils/aria.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/utils/colour.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/dropdowndiv.js\");\n__webpack_require__(\"./core/field_registry.js\");\n__webpack_require__(\"./core/utils/idgenerator.js\");\n__webpack_require__(\"./core/field.js\");\n__webpack_require__(\"./core/utils/keycodes.js\");\n__webpack_require__(\"./core/utils/size.js\");\n__webpack_require__(\"./core/events/events_block_change.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Colour input field.\n */\n\n\n/**\n * Colour input field.\n * @class\n */\ngoog.module('Blockly.FieldColour');\n\nconst Css = goog.require('Blockly.Css');\nconst aria = goog.require('Blockly.utils.aria');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst colour = goog.require('Blockly.utils.colour');\nconst dom = goog.require('Blockly.utils.dom');\nconst dropDownDiv = goog.require('Blockly.dropDownDiv');\nconst fieldRegistry = goog.require('Blockly.fieldRegistry');\nconst idGenerator = goog.require('Blockly.utils.idGenerator');\nconst {Field} = goog.require('Blockly.Field');\nconst {KeyCodes} = goog.require('Blockly.utils.KeyCodes');\n/* eslint-disable-next-line no-unused-vars */\nconst {Sentinel} = goog.requireType('Blockly.utils.Sentinel');\nconst {Size} = goog.require('Blockly.utils.Size');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockChange');\n\n\n/**\n * Class for a colour input field.\n * @extends {Field}\n * @alias Blockly.FieldColour\n */\nclass FieldColour extends Field {\n  /**\n   * @param {(string|!Sentinel)=} opt_value The initial value of the\n   *     field. Should be in '#rrggbb' format. Defaults to the first value in\n   *     the default colour array.\n   *     Also accepts Field.SKIP_SETUP if you wish to skip setup (only used by\n   *     subclasses that want to handle configuration and setting the field\n   *     value after their own constructors have run).\n   * @param {Function=} opt_validator A function that is called to validate\n   *     changes to the field's value. Takes in a colour string & returns a\n   *     validated colour string ('#rrggbb' format), or null to abort the\n   *     change.Blockly.\n   * @param {Object=} opt_config A map of options used to configure the field.\n   *     See the [field creation documentation]{@link\n   *     https://developers.google.com/blockly/guides/create-custom-blocks/fields/built-in-fields/colour}\n   *     for a list of properties this parameter supports.\n   */\n  constructor(opt_value, opt_validator, opt_config) {\n    super(Field.SKIP_SETUP);\n\n    /**\n     * The field's colour picker element.\n     * @type {?Element}\n     * @private\n     */\n    this.picker_ = null;\n\n    /**\n     * Index of the currently highlighted element.\n     * @type {?number}\n     * @private\n     */\n    this.highlightedIndex_ = null;\n\n    /**\n     * Mouse click event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onClickWrapper_ = null;\n\n    /**\n     * Mouse move event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onMouseMoveWrapper_ = null;\n\n    /**\n     * Mouse enter event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onMouseEnterWrapper_ = null;\n\n    /**\n     * Mouse leave event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onMouseLeaveWrapper_ = null;\n\n    /**\n     * Key down event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onKeyDownWrapper_ = null;\n\n    /**\n     * Serializable fields are saved by the serializer, non-serializable fields\n     * are not. Editable fields should also be serializable.\n     * @type {boolean}\n     */\n    this.SERIALIZABLE = true;\n\n    /**\n     * Mouse cursor style when over the hotspot that initiates the editor.\n     * @type {string}\n     */\n    this.CURSOR = 'default';\n\n    /**\n     * Used to tell if the field needs to be rendered the next time the block is\n     * rendered. Colour fields are statically sized, and only need to be\n     * rendered at initialization.\n     * @type {boolean}\n     * @protected\n     */\n    this.isDirty_ = false;\n\n    /**\n     * Array of colours used by this field.  If null, use the global list.\n     * @type {Array<string>}\n     * @private\n     */\n    this.colours_ = null;\n\n    /**\n     * Array of colour tooltips used by this field.  If null, use the global\n     * list.\n     * @type {Array<string>}\n     * @private\n     */\n    this.titles_ = null;\n\n    /**\n     * Number of colour columns used by this field.  If 0, use the global\n     * setting. By default use the global constants for columns.\n     * @type {number}\n     * @private\n     */\n    this.columns_ = 0;\n\n    if (opt_value === Field.SKIP_SETUP) return;\n    if (opt_config) this.configure_(opt_config);\n    this.setValue(opt_value);\n    if (opt_validator) this.setValidator(opt_validator);\n  }\n\n  /**\n   * Configure the field based on the given map of options.\n   * @param {!Object} config A map of options to configure the field based on.\n   * @protected\n   * @override\n   */\n  configure_(config) {\n    super.configure_(config);\n    if (config['colourOptions']) {\n      this.colours_ = config['colourOptions'];\n      this.titles_ = config['colourTitles'];\n    }\n    if (config['columns']) {\n      this.columns_ = config['columns'];\n    }\n  }\n\n  /**\n   * Create the block UI for this colour field.\n   * @package\n   */\n  initView() {\n    this.size_ = new Size(\n        this.getConstants().FIELD_COLOUR_DEFAULT_WIDTH,\n        this.getConstants().FIELD_COLOUR_DEFAULT_HEIGHT);\n    if (!this.getConstants().FIELD_COLOUR_FULL_BLOCK) {\n      this.createBorderRect_();\n      this.borderRect_.style['fillOpacity'] = '1';\n    } else {\n      this.clickTarget_ = this.sourceBlock_.getSvgRoot();\n    }\n  }\n\n  /**\n   * @override\n   */\n  applyColour() {\n    if (!this.getConstants().FIELD_COLOUR_FULL_BLOCK) {\n      if (this.borderRect_) {\n        this.borderRect_.style.fill = /** @type {string} */ (this.getValue());\n      }\n    } else {\n      this.sourceBlock_.pathObject.svgPath.setAttribute(\n          'fill', this.getValue());\n      this.sourceBlock_.pathObject.svgPath.setAttribute('stroke', '#fff');\n    }\n  }\n\n  /**\n   * Ensure that the input value is a valid colour.\n   * @param {*=} opt_newValue The input value.\n   * @return {?string} A valid colour, or null if invalid.\n   * @protected\n   */\n  doClassValidation_(opt_newValue) {\n    if (typeof opt_newValue !== 'string') {\n      return null;\n    }\n    return colour.parse(opt_newValue);\n  }\n\n  /**\n   * Update the value of this colour field, and update the displayed colour.\n   * @param {*} newValue The value to be saved. The default validator guarantees\n   * that this is a colour in '#rrggbb' format.\n   * @protected\n   */\n  doValueUpdate_(newValue) {\n    this.value_ = newValue;\n    if (this.borderRect_) {\n      this.borderRect_.style.fill = /** @type {string} */ (newValue);\n    } else if (this.sourceBlock_ && this.sourceBlock_.rendered) {\n      this.sourceBlock_.pathObject.svgPath.setAttribute('fill', newValue);\n      this.sourceBlock_.pathObject.svgPath.setAttribute('stroke', '#fff');\n    }\n  }\n\n  /**\n   * Get the text for this field.  Used when the block is collapsed.\n   * @return {string} Text representing the value of this field.\n   */\n  getText() {\n    let colour = /** @type {string} */ (this.value_);\n    // Try to use #rgb format if possible, rather than #rrggbb.\n    if (/^#(.)\\1(.)\\2(.)\\3$/.test(colour)) {\n      colour = '#' + colour[1] + colour[3] + colour[5];\n    }\n    return colour;\n  }\n\n  /**\n   * Set a custom colour grid for this field.\n   * @param {Array<string>} colours Array of colours for this block,\n   *     or null to use default (FieldColour.COLOURS).\n   * @param {Array<string>=} opt_titles Optional array of colour tooltips,\n   *     or null to use default (FieldColour.TITLES).\n   * @return {!FieldColour} Returns itself (for method chaining).\n   */\n  setColours(colours, opt_titles) {\n    this.colours_ = colours;\n    if (opt_titles) {\n      this.titles_ = opt_titles;\n    }\n    return this;\n  }\n\n  /**\n   * Set a custom grid size for this field.\n   * @param {number} columns Number of columns for this block,\n   *     or 0 to use default (FieldColour.COLUMNS).\n   * @return {!FieldColour} Returns itself (for method chaining).\n   */\n  setColumns(columns) {\n    this.columns_ = columns;\n    return this;\n  }\n\n  /**\n   * Create and show the colour field's editor.\n   * @protected\n   */\n  showEditor_() {\n    this.dropdownCreate_();\n    dropDownDiv.getContentDiv().appendChild(this.picker_);\n\n    dropDownDiv.showPositionedByField(this, this.dropdownDispose_.bind(this));\n\n    // Focus so we can start receiving keyboard events.\n    this.picker_.focus({preventScroll: true});\n  }\n\n  /**\n   * Handle a click on a colour cell.\n   * @param {!MouseEvent} e Mouse event.\n   * @private\n   */\n  onClick_(e) {\n    const cell = /** @type {!Element} */ (e.target);\n    const colour = cell && cell.label;\n    if (colour !== null) {\n      this.setValue(colour);\n      dropDownDiv.hideIfOwner(this);\n    }\n  }\n\n  /**\n   * Handle a key down event. Navigate around the grid with the\n   * arrow keys. Enter selects the highlighted colour.\n   * @param {!KeyboardEvent} e Keyboard event.\n   * @private\n   */\n  onKeyDown_(e) {\n    let handled = false;\n    if (e.keyCode === KeyCodes.UP) {\n      this.moveHighlightBy_(0, -1);\n      handled = true;\n    } else if (e.keyCode === KeyCodes.DOWN) {\n      this.moveHighlightBy_(0, 1);\n      handled = true;\n    } else if (e.keyCode === KeyCodes.LEFT) {\n      this.moveHighlightBy_(-1, 0);\n      handled = true;\n    } else if (e.keyCode === KeyCodes.RIGHT) {\n      this.moveHighlightBy_(1, 0);\n      handled = true;\n    } else if (e.keyCode === KeyCodes.ENTER) {\n      // Select the highlighted colour.\n      const highlighted = this.getHighlighted_();\n      if (highlighted) {\n        const colour = highlighted && highlighted.label;\n        if (colour !== null) {\n          this.setValue(colour);\n        }\n      }\n      dropDownDiv.hideWithoutAnimation();\n      handled = true;\n    }\n    if (handled) {\n      e.stopPropagation();\n    }\n  }\n\n  /**\n   * Move the currently highlighted position by dx and dy.\n   * @param {number} dx Change of x\n   * @param {number} dy Change of y\n   * @private\n   */\n  moveHighlightBy_(dx, dy) {\n    const colours = this.colours_ || FieldColour.COLOURS;\n    const columns = this.columns_ || FieldColour.COLUMNS;\n\n    // Get the current x and y coordinates\n    let x = this.highlightedIndex_ % columns;\n    let y = Math.floor(this.highlightedIndex_ / columns);\n\n    // Add the offset\n    x += dx;\n    y += dy;\n\n    if (dx < 0) {\n      // Move left one grid cell, even in RTL.\n      // Loop back to the end of the previous row if we have room.\n      if (x < 0 && y > 0) {\n        x = columns - 1;\n        y--;\n      } else if (x < 0) {\n        x = 0;\n      }\n    } else if (dx > 0) {\n      // Move right one grid cell, even in RTL.\n      // Loop to the start of the next row, if there's room.\n      if (x > columns - 1 && y < Math.floor(colours.length / columns) - 1) {\n        x = 0;\n        y++;\n      } else if (x > columns - 1) {\n        x--;\n      }\n    } else if (dy < 0) {\n      // Move up one grid cell, stop at the top.\n      if (y < 0) {\n        y = 0;\n      }\n    } else if (dy > 0) {\n      // Move down one grid cell, stop at the bottom.\n      if (y > Math.floor(colours.length / columns) - 1) {\n        y = Math.floor(colours.length / columns) - 1;\n      }\n    }\n\n    // Move the highlight to the new coordinates.\n    const cell =\n        /** @type {!Element} */ (this.picker_.childNodes[y].childNodes[x]);\n    const index = (y * columns) + x;\n    this.setHighlightedCell_(cell, index);\n  }\n\n  /**\n   * Handle a mouse move event. Highlight the hovered colour.\n   * @param {!MouseEvent} e Mouse event.\n   * @private\n   */\n  onMouseMove_(e) {\n    const cell = /** @type {!Element} */ (e.target);\n    const index = cell && Number(cell.getAttribute('data-index'));\n    if (index !== null && index !== this.highlightedIndex_) {\n      this.setHighlightedCell_(cell, index);\n    }\n  }\n\n  /**\n   * Handle a mouse enter event. Focus the picker.\n   * @private\n   */\n  onMouseEnter_() {\n    this.picker_.focus({preventScroll: true});\n  }\n\n  /**\n   * Handle a mouse leave event. Blur the picker and unhighlight\n   * the currently highlighted colour.\n   * @private\n   */\n  onMouseLeave_() {\n    this.picker_.blur();\n    const highlighted = this.getHighlighted_();\n    if (highlighted) {\n      dom.removeClass(highlighted, 'blocklyColourHighlighted');\n    }\n  }\n\n  /**\n   * Returns the currently highlighted item (if any).\n   * @return {?HTMLElement} Highlighted item (null if none).\n   * @private\n   */\n  getHighlighted_() {\n    const columns = this.columns_ || FieldColour.COLUMNS;\n    const x = this.highlightedIndex_ % columns;\n    const y = Math.floor(this.highlightedIndex_ / columns);\n    const row = this.picker_.childNodes[y];\n    if (!row) {\n      return null;\n    }\n    const col = /** @type {HTMLElement} */ (row.childNodes[x]);\n    return col;\n  }\n\n  /**\n   * Update the currently highlighted cell.\n   * @param {!Element} cell the new cell to highlight\n   * @param {number} index the index of the new cell\n   * @private\n   */\n  setHighlightedCell_(cell, index) {\n    // Unhighlight the current item.\n    const highlighted = this.getHighlighted_();\n    if (highlighted) {\n      dom.removeClass(highlighted, 'blocklyColourHighlighted');\n    }\n    // Highlight new item.\n    dom.addClass(cell, 'blocklyColourHighlighted');\n    // Set new highlighted index.\n    this.highlightedIndex_ = index;\n\n    // Update accessibility roles.\n    aria.setState(\n        /** @type {!Element} */ (this.picker_), aria.State.ACTIVEDESCENDANT,\n        cell.getAttribute('id'));\n  }\n\n  /**\n   * Create a colour picker dropdown editor.\n   * @private\n   */\n  dropdownCreate_() {\n    const columns = this.columns_ || FieldColour.COLUMNS;\n    const colours = this.colours_ || FieldColour.COLOURS;\n    const titles = this.titles_ || FieldColour.TITLES;\n    const selectedColour = this.getValue();\n    // Create the palette.\n    const table = document.createElement('table');\n    table.className = 'blocklyColourTable';\n    table.tabIndex = 0;\n    table.dir = 'ltr';\n    aria.setRole(table, aria.Role.GRID);\n    aria.setState(table, aria.State.EXPANDED, true);\n    aria.setState(\n        table, aria.State.ROWCOUNT, Math.floor(colours.length / columns));\n    aria.setState(table, aria.State.COLCOUNT, columns);\n    let row;\n    for (let i = 0; i < colours.length; i++) {\n      if (i % columns === 0) {\n        row = document.createElement('tr');\n        aria.setRole(row, aria.Role.ROW);\n        table.appendChild(row);\n      }\n      const cell = document.createElement('td');\n      row.appendChild(cell);\n      cell.label = colours[i];  // This becomes the value, if clicked.\n      cell.title = titles[i] || colours[i];\n      cell.id = idGenerator.getNextUniqueId();\n      cell.setAttribute('data-index', i);\n      aria.setRole(cell, aria.Role.GRIDCELL);\n      aria.setState(cell, aria.State.LABEL, colours[i]);\n      aria.setState(cell, aria.State.SELECTED, colours[i] === selectedColour);\n      cell.style.backgroundColor = colours[i];\n      if (colours[i] === selectedColour) {\n        cell.className = 'blocklyColourSelected';\n        this.highlightedIndex_ = i;\n      }\n    }\n\n    // Configure event handler on the table to listen for any event in a cell.\n    this.onClickWrapper_ = browserEvents.conditionalBind(\n        table, 'click', this, this.onClick_, true);\n    this.onMouseMoveWrapper_ = browserEvents.conditionalBind(\n        table, 'mousemove', this, this.onMouseMove_, true);\n    this.onMouseEnterWrapper_ = browserEvents.conditionalBind(\n        table, 'mouseenter', this, this.onMouseEnter_, true);\n    this.onMouseLeaveWrapper_ = browserEvents.conditionalBind(\n        table, 'mouseleave', this, this.onMouseLeave_, true);\n    this.onKeyDownWrapper_ =\n        browserEvents.conditionalBind(table, 'keydown', this, this.onKeyDown_);\n\n    this.picker_ = table;\n  }\n\n  /**\n   * Disposes of events and DOM-references belonging to the colour editor.\n   * @private\n   */\n  dropdownDispose_() {\n    if (this.onClickWrapper_) {\n      browserEvents.unbind(this.onClickWrapper_);\n      this.onClickWrapper_ = null;\n    }\n    if (this.onMouseMoveWrapper_) {\n      browserEvents.unbind(this.onMouseMoveWrapper_);\n      this.onMouseMoveWrapper_ = null;\n    }\n    if (this.onMouseEnterWrapper_) {\n      browserEvents.unbind(this.onMouseEnterWrapper_);\n      this.onMouseEnterWrapper_ = null;\n    }\n    if (this.onMouseLeaveWrapper_) {\n      browserEvents.unbind(this.onMouseLeaveWrapper_);\n      this.onMouseLeaveWrapper_ = null;\n    }\n    if (this.onKeyDownWrapper_) {\n      browserEvents.unbind(this.onKeyDownWrapper_);\n      this.onKeyDownWrapper_ = null;\n    }\n    this.picker_ = null;\n    this.highlightedIndex_ = null;\n  }\n\n  /**\n   * Construct a FieldColour from a JSON arg object.\n   * @param {!Object} options A JSON object with options (colour).\n   * @return {!FieldColour} The new field instance.\n   * @package\n   * @nocollapse\n   */\n  static fromJson(options) {\n    // `this` might be a subclass of FieldColour if that class doesn't override\n    // the static fromJson method.\n    return new this(options['colour'], undefined, options);\n  }\n}\n\n/**\n * An array of colour strings for the palette.\n * Copied from goog.ui.ColorPicker.SIMPLE_GRID_COLORS\n * All colour pickers use this unless overridden with setColours.\n * @type {!Array<string>}\n */\nFieldColour.COLOURS = [\n  // grays\n  '#ffffff',\n  '#cccccc',\n  '#c0c0c0',\n  '#999999',\n  '#666666',\n  '#333333',\n  '#000000',\n  // reds\n  '#ffcccc',\n  '#ff6666',\n  '#ff0000',\n  '#cc0000',\n  '#990000',\n  '#660000',\n  '#330000',\n  // oranges\n  '#ffcc99',\n  '#ff9966',\n  '#ff9900',\n  '#ff6600',\n  '#cc6600',\n  '#993300',\n  '#663300',\n  // yellows\n  '#ffff99',\n  '#ffff66',\n  '#ffcc66',\n  '#ffcc33',\n  '#cc9933',\n  '#996633',\n  '#663333',\n  // olives\n  '#ffffcc',\n  '#ffff33',\n  '#ffff00',\n  '#ffcc00',\n  '#999900',\n  '#666600',\n  '#333300',\n  // greens\n  '#99ff99',\n  '#66ff99',\n  '#33ff33',\n  '#33cc00',\n  '#009900',\n  '#006600',\n  '#003300',\n  // turquoises\n  '#99ffff',\n  '#33ffff',\n  '#66cccc',\n  '#00cccc',\n  '#339999',\n  '#336666',\n  '#003333',\n  // blues\n  '#ccffff',\n  '#66ffff',\n  '#33ccff',\n  '#3366ff',\n  '#3333ff',\n  '#000099',\n  '#000066',\n  // purples\n  '#ccccff',\n  '#9999ff',\n  '#6666cc',\n  '#6633ff',\n  '#6600cc',\n  '#333399',\n  '#330099',\n  // violets\n  '#ffccff',\n  '#ff99ff',\n  '#cc66cc',\n  '#cc33cc',\n  '#993399',\n  '#663366',\n  '#330033',\n];\n\n/**\n * The default value for this field.\n * @type {*}\n * @protected\n */\nFieldColour.prototype.DEFAULT_VALUE = FieldColour.COLOURS[0];\n\n/**\n * An array of tooltip strings for the palette.  If not the same length as\n * COLOURS, the colour's hex code will be used for any missing titles.\n * All colour pickers use this unless overridden with setColours.\n * @type {!Array<string>}\n */\nFieldColour.TITLES = [];\n\n/**\n * Number of columns in the palette.\n * All colour pickers use this unless overridden with setColumns.\n */\nFieldColour.COLUMNS = 7;\n\n/**\n * CSS for colour picker.  See css.js for use.\n */\nCss.register(`\n.blocklyColourTable {\n  border-collapse: collapse;\n  display: block;\n  outline: none;\n  padding: 1px;\n}\n\n.blocklyColourTable>tr>td {\n  border: .5px solid #888;\n  box-sizing: border-box;\n  cursor: pointer;\n  display: inline-block;\n  height: 20px;\n  padding: 0;\n  width: 20px;\n}\n\n.blocklyColourTable>tr>td.blocklyColourHighlighted {\n  border-color: #eee;\n  box-shadow: 2px 2px 7px 2px rgba(0,0,0,.3);\n  position: relative;\n}\n\n.blocklyColourSelected, .blocklyColourSelected:hover {\n  border-color: #eee !important;\n  outline: 1px solid #333;\n  position: relative;\n}\n`);\n\nfieldRegistry.register('field_colour', FieldColour);\n\nexports.FieldColour = FieldColour;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/field_colour.js?")},
"./core/field_dropdown.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/aria.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/dropdowndiv.js\");\n__webpack_require__(\"./core/field_registry.js\");\n__webpack_require__(\"./core/utils/parsing.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\n__webpack_require__(\"./core/utils/string.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/field.js\");\n__webpack_require__(\"./core/menuitem.js\");\n__webpack_require__(\"./core/menu.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Dropdown input field.  Used for editable titles and variables.\n * In the interests of a consistent UI, the toolbox shares some functions and\n * properties with the context menu.\n */\n\n\n/**\n * Dropdown input field.  Used for editable titles and variables.\n * In the interests of a consistent UI, the toolbox shares some functions and\n * properties with the context menu.\n * @class\n */\ngoog.module('Blockly.FieldDropdown');\n\nconst aria = goog.require('Blockly.utils.aria');\nconst dom = goog.require('Blockly.utils.dom');\nconst dropDownDiv = goog.require('Blockly.dropDownDiv');\nconst fieldRegistry = goog.require('Blockly.fieldRegistry');\nconst parsing = goog.require('Blockly.utils.parsing');\nconst userAgent = goog.require('Blockly.utils.userAgent');\nconst utilsString = goog.require('Blockly.utils.string');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\nconst {Field} = goog.require('Blockly.Field');\nconst {MenuItem} = goog.require('Blockly.MenuItem');\nconst {Menu} = goog.require('Blockly.Menu');\n/* eslint-disable-next-line no-unused-vars */\nconst {Sentinel} = goog.requireType('Blockly.utils.Sentinel');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n\n\n/**\n * Class for an editable dropdown field.\n * @extends {Field}\n * @alias Blockly.FieldDropdown\n */\nclass FieldDropdown extends Field {\n  /**\n   * @param {(!Array<!Array>|!Function|!Sentinel)} menuGenerator\n   *     A non-empty array of options for a dropdown list, or a function which\n   *     generates these options.\n   *     Also accepts Field.SKIP_SETUP if you wish to skip setup (only used by\n   *     subclasses that want to handle configuration and setting the field\n   *     value after their own constructors have run).\n   * @param {Function=} opt_validator A function that is called to validate\n   *     changes to the field's value. Takes in a language-neutral dropdown\n   *     option & returns a validated language-neutral dropdown option, or null\n   *     to abort the change.\n   * @param {Object=} opt_config A map of options used to configure the field.\n   *     See the [field creation documentation]{@link\n   *     https://developers.google.com/blockly/guides/create-custom-blocks/fields/built-in-fields/dropdown#creation}\n   *     for a list of properties this parameter supports.\n   * @throws {TypeError} If `menuGenerator` options are incorrectly structured.\n   */\n  constructor(menuGenerator, opt_validator, opt_config) {\n    super(Field.SKIP_SETUP);\n\n    /**\n     * A reference to the currently selected menu item.\n     * @type {?MenuItem}\n     * @private\n     */\n    this.selectedMenuItem_ = null;\n\n    /**\n     * The dropdown menu.\n     * @type {?Menu}\n     * @protected\n     */\n    this.menu_ = null;\n\n    /**\n     * SVG image element if currently selected option is an image, or null.\n     * @type {?SVGImageElement}\n     * @private\n     */\n    this.imageElement_ = null;\n\n    /**\n     * Tspan based arrow element.\n     * @type {?SVGTSpanElement}\n     * @private\n     */\n    this.arrow_ = null;\n\n    /**\n     * SVG based arrow element.\n     * @type {?SVGElement}\n     * @private\n     */\n    this.svgArrow_ = null;\n\n    /**\n     * Serializable fields are saved by the serializer, non-serializable fields\n     * are not. Editable fields should also be serializable.\n     * @type {boolean}\n     */\n    this.SERIALIZABLE = true;\n\n    /**\n     * Mouse cursor style when over the hotspot that initiates the editor.\n     * @type {string}\n     */\n    this.CURSOR = 'default';\n\n\n    // If we pass SKIP_SETUP, don't do *anything* with the menu generator.\n    if (menuGenerator === Field.SKIP_SETUP) return;\n\n    if (Array.isArray(menuGenerator)) {\n      validateOptions(menuGenerator);\n    }\n\n    /**\n     * An array of options for a dropdown list,\n     * or a function which generates these options.\n     * @type {(!Array<!Array>|!function(this:FieldDropdown): !Array<!Array>)}\n     * @protected\n     */\n    this.menuGenerator_ =\n        /**\n         * @type {(!Array<!Array>|\n         *    !function(this:FieldDropdown):!Array<!Array>)}\n         */\n        (menuGenerator);\n\n    /**\n     * A cache of the most recently generated options.\n     * @type {Array<!Array<string>>}\n     * @private\n     */\n    this.generatedOptions_ = null;\n\n    /**\n     * The prefix field label, of common words set after options are trimmed.\n     * @type {?string}\n     * @package\n     */\n    this.prefixField = null;\n\n    /**\n     * The suffix field label, of common words set after options are trimmed.\n     * @type {?string}\n     * @package\n     */\n    this.suffixField = null;\n\n    this.trimOptions_();\n\n    /**\n     * The currently selected option. The field is initialized with the\n     * first option selected.\n     * @type {!Array<string|!ImageProperties>}\n     * @private\n     */\n    this.selectedOption_ = this.getOptions(false)[0];\n\n    if (opt_config) this.configure_(opt_config);\n    this.setValue(this.selectedOption_[1]);\n    if (opt_validator) this.setValidator(opt_validator);\n  }\n\n  /**\n   * Sets the field's value based on the given XML element. Should only be\n   * called by Blockly.Xml.\n   * @param {!Element} fieldElement The element containing info about the\n   *    field's state.\n   * @package\n   */\n  fromXml(fieldElement) {\n    if (this.isOptionListDynamic()) {\n      this.getOptions(false);\n    }\n    this.setValue(fieldElement.textContent);\n  }\n\n  /**\n   * Sets the field's value based on the given state.\n   * @param {*} state The state to apply to the dropdown field.\n   * @override\n   * @package\n   */\n  loadState(state) {\n    if (this.loadLegacyState(FieldDropdown, state)) {\n      return;\n    }\n    if (this.isOptionListDynamic()) {\n      this.getOptions(false);\n    }\n    this.setValue(state);\n  }\n\n  /**\n   * Create the block UI for this dropdown.\n   * @package\n   */\n  initView() {\n    if (this.shouldAddBorderRect_()) {\n      this.createBorderRect_();\n    } else {\n      this.clickTarget_ = this.sourceBlock_.getSvgRoot();\n    }\n    this.createTextElement_();\n\n    this.imageElement_ = dom.createSvgElement(Svg.IMAGE, {}, this.fieldGroup_);\n\n    if (this.getConstants().FIELD_DROPDOWN_SVG_ARROW) {\n      this.createSVGArrow_();\n    } else {\n      this.createTextArrow_();\n    }\n\n    if (this.borderRect_) {\n      dom.addClass(this.borderRect_, 'blocklyDropdownRect');\n    }\n  }\n\n  /**\n   * Whether or not the dropdown should add a border rect.\n   * @return {boolean} True if the dropdown field should add a border rect.\n   * @protected\n   */\n  shouldAddBorderRect_() {\n    return !this.getConstants().FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW ||\n        (this.getConstants().FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW &&\n         !this.sourceBlock_.isShadow());\n  }\n\n  /**\n   * Create a tspan based arrow.\n   * @protected\n   */\n  createTextArrow_() {\n    this.arrow_ = dom.createSvgElement(Svg.TSPAN, {}, this.textElement_);\n    this.arrow_.appendChild(document.createTextNode(\n        this.sourceBlock_.RTL ? FieldDropdown.ARROW_CHAR + ' ' :\n                                ' ' + FieldDropdown.ARROW_CHAR));\n    if (this.sourceBlock_.RTL) {\n      this.textElement_.insertBefore(this.arrow_, this.textContent_);\n    } else {\n      this.textElement_.appendChild(this.arrow_);\n    }\n  }\n\n  /**\n   * Create an SVG based arrow.\n   * @protected\n   */\n  createSVGArrow_() {\n    this.svgArrow_ = dom.createSvgElement(\n        Svg.IMAGE, {\n          'height': this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE + 'px',\n          'width': this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE + 'px',\n        },\n        this.fieldGroup_);\n    this.svgArrow_.setAttributeNS(\n        dom.XLINK_NS, 'xlink:href',\n        this.getConstants().FIELD_DROPDOWN_SVG_ARROW_DATAURI);\n  }\n\n  /**\n   * Create a dropdown menu under the text.\n   * @param {Event=} opt_e Optional mouse event that triggered the field to\n   *     open, or undefined if triggered programmatically.\n   * @protected\n   */\n  showEditor_(opt_e) {\n    this.dropdownCreate_();\n    if (opt_e && typeof opt_e.clientX === 'number') {\n      this.menu_.openingCoords = new Coordinate(opt_e.clientX, opt_e.clientY);\n    } else {\n      this.menu_.openingCoords = null;\n    }\n\n    // Remove any pre-existing elements in the dropdown.\n    dropDownDiv.clearContent();\n    // Element gets created in render.\n    this.menu_.render(dropDownDiv.getContentDiv());\n    const menuElement = /** @type {!Element} */ (this.menu_.getElement());\n    dom.addClass(menuElement, 'blocklyDropdownMenu');\n\n    if (this.getConstants().FIELD_DROPDOWN_COLOURED_DIV) {\n      const primaryColour = (this.sourceBlock_.isShadow()) ?\n          this.sourceBlock_.getParent().getColour() :\n          this.sourceBlock_.getColour();\n      const borderColour = (this.sourceBlock_.isShadow()) ?\n          this.sourceBlock_.getParent().style.colourTertiary :\n          this.sourceBlock_.style.colourTertiary;\n      dropDownDiv.setColour(primaryColour, borderColour);\n    }\n\n    dropDownDiv.showPositionedByField(this, this.dropdownDispose_.bind(this));\n\n    // Focusing needs to be handled after the menu is rendered and positioned.\n    // Otherwise it will cause a page scroll to get the misplaced menu in\n    // view. See issue #1329.\n    this.menu_.focus();\n\n    if (this.selectedMenuItem_) {\n      this.menu_.setHighlighted(this.selectedMenuItem_);\n    }\n\n    this.applyColour();\n  }\n\n  /**\n   * Create the dropdown editor.\n   * @private\n   */\n  dropdownCreate_() {\n    const menu = new Menu();\n    menu.setRole(aria.Role.LISTBOX);\n    this.menu_ = menu;\n\n    const options = this.getOptions(false);\n    this.selectedMenuItem_ = null;\n    for (let i = 0; i < options.length; i++) {\n      let content = options[i][0];  // Human-readable text or image.\n      const value = options[i][1];  // Language-neutral value.\n      if (typeof content === 'object') {\n        // An image, not text.\n        const image = new Image(content['width'], content['height']);\n        image.src = content['src'];\n        image.alt = content['alt'] || '';\n        content = image;\n      }\n      const menuItem = new MenuItem(content, value);\n      menuItem.setRole(aria.Role.OPTION);\n      menuItem.setRightToLeft(this.sourceBlock_.RTL);\n      menuItem.setCheckable(true);\n      menu.addChild(menuItem);\n      menuItem.setChecked(value === this.value_);\n      if (value === this.value_) {\n        this.selectedMenuItem_ = menuItem;\n      }\n      menuItem.onAction(this.handleMenuActionEvent_, this);\n    }\n  }\n\n  /**\n   * Disposes of events and DOM-references belonging to the dropdown editor.\n   * @private\n   */\n  dropdownDispose_() {\n    if (this.menu_) {\n      this.menu_.dispose();\n    }\n    this.menu_ = null;\n    this.selectedMenuItem_ = null;\n    this.applyColour();\n  }\n\n  /**\n   * Handle an action in the dropdown menu.\n   * @param {!MenuItem} menuItem The MenuItem selected within menu.\n   * @private\n   */\n  handleMenuActionEvent_(menuItem) {\n    dropDownDiv.hideIfOwner(this, true);\n    this.onItemSelected_(/** @type {!Menu} */ (this.menu_), menuItem);\n  }\n\n  /**\n   * Handle the selection of an item in the dropdown menu.\n   * @param {!Menu} menu The Menu component clicked.\n   * @param {!MenuItem} menuItem The MenuItem selected within menu.\n   * @protected\n   */\n  onItemSelected_(menu, menuItem) {\n    this.setValue(menuItem.getValue());\n  }\n\n  /**\n   * Factor out common words in statically defined options.\n   * Create prefix and/or suffix labels.\n   * @private\n   */\n  trimOptions_() {\n    const options = this.menuGenerator_;\n    if (!Array.isArray(options)) {\n      return;\n    }\n    let hasImages = false;\n\n    // Localize label text and image alt text.\n    for (let i = 0; i < options.length; i++) {\n      const label = options[i][0];\n      if (typeof label === 'string') {\n        options[i][0] = parsing.replaceMessageReferences(label);\n      } else {\n        if (label.alt !== null) {\n          options[i][0].alt = parsing.replaceMessageReferences(label.alt);\n        }\n        hasImages = true;\n      }\n    }\n    if (hasImages || options.length < 2) {\n      return;  // Do nothing if too few items or at least one label is an image.\n    }\n    const strings = [];\n    for (let i = 0; i < options.length; i++) {\n      strings.push(options[i][0]);\n    }\n    const shortest = utilsString.shortestStringLength(strings);\n    const prefixLength = utilsString.commonWordPrefix(strings, shortest);\n    const suffixLength = utilsString.commonWordSuffix(strings, shortest);\n    if (!prefixLength && !suffixLength) {\n      return;\n    }\n    if (shortest <= prefixLength + suffixLength) {\n      // One or more strings will entirely vanish if we proceed.  Abort.\n      return;\n    }\n    if (prefixLength) {\n      this.prefixField = strings[0].substring(0, prefixLength - 1);\n    }\n    if (suffixLength) {\n      this.suffixField = strings[0].substr(1 - suffixLength);\n    }\n\n    this.menuGenerator_ =\n        FieldDropdown.applyTrim_(options, prefixLength, suffixLength);\n  }\n\n  /**\n   * @return {boolean} True if the option list is generated by a function.\n   *     Otherwise false.\n   */\n  isOptionListDynamic() {\n    return typeof this.menuGenerator_ === 'function';\n  }\n\n  /**\n   * Return a list of the options for this dropdown.\n   * @param {boolean=} opt_useCache For dynamic options, whether or not to use\n   *     the cached options or to re-generate them.\n   * @return {!Array<!Array>} A non-empty array of option tuples:\n   *     (human-readable text or image, language-neutral name).\n   * @throws {TypeError} If generated options are incorrectly structured.\n   */\n  getOptions(opt_useCache) {\n    if (this.isOptionListDynamic()) {\n      if (!this.generatedOptions_ || !opt_useCache) {\n        this.generatedOptions_ = this.menuGenerator_.call(this);\n        validateOptions(this.generatedOptions_);\n      }\n      return this.generatedOptions_;\n    }\n    return /** @type {!Array<!Array<string>>} */ (this.menuGenerator_);\n  }\n\n  /**\n   * Ensure that the input value is a valid language-neutral option.\n   * @param {*=} opt_newValue The input value.\n   * @return {?string} A valid language-neutral option, or null if invalid.\n   * @protected\n   */\n  doClassValidation_(opt_newValue) {\n    let isValueValid = false;\n    const options = this.getOptions(true);\n    for (let i = 0, option; (option = options[i]); i++) {\n      // Options are tuples of human-readable text and language-neutral values.\n      if (option[1] === opt_newValue) {\n        isValueValid = true;\n        break;\n      }\n    }\n    if (!isValueValid) {\n      if (this.sourceBlock_) {\n        console.warn(\n            'Cannot set the dropdown\\'s value to an unavailable option.' +\n            ' Block type: ' + this.sourceBlock_.type +\n            ', Field name: ' + this.name + ', Value: ' + opt_newValue);\n      }\n      return null;\n    }\n    return /** @type {string} */ (opt_newValue);\n  }\n\n  /**\n   * Update the value of this dropdown field.\n   * @param {*} newValue The value to be saved. The default validator guarantees\n   * that this is one of the valid dropdown options.\n   * @protected\n   */\n  doValueUpdate_(newValue) {\n    super.doValueUpdate_(newValue);\n    const options = this.getOptions(true);\n    for (let i = 0, option; (option = options[i]); i++) {\n      if (option[1] === this.value_) {\n        this.selectedOption_ = option;\n      }\n    }\n  }\n\n  /**\n   * Updates the dropdown arrow to match the colour/style of the block.\n   * @package\n   */\n  applyColour() {\n    if (this.borderRect_) {\n      this.borderRect_.setAttribute(\n          'stroke', this.sourceBlock_.style.colourTertiary);\n      if (this.menu_) {\n        this.borderRect_.setAttribute(\n            'fill', this.sourceBlock_.style.colourTertiary);\n      } else {\n        this.borderRect_.setAttribute('fill', 'transparent');\n      }\n    }\n    // Update arrow's colour.\n    if (this.sourceBlock_ && this.arrow_) {\n      if (this.sourceBlock_.isShadow()) {\n        this.arrow_.style.fill = this.sourceBlock_.style.colourSecondary;\n      } else {\n        this.arrow_.style.fill = this.sourceBlock_.style.colourPrimary;\n      }\n    }\n  }\n\n  /**\n   * Draws the border with the correct width.\n   * @protected\n   */\n  render_() {\n    // Hide both elements.\n    this.textContent_.nodeValue = '';\n    this.imageElement_.style.display = 'none';\n\n    // Show correct element.\n    const option = this.selectedOption_ && this.selectedOption_[0];\n    if (option && typeof option === 'object') {\n      this.renderSelectedImage_(\n          /** @type {!ImageProperties} */ (option));\n    } else {\n      this.renderSelectedText_();\n    }\n\n    this.positionBorderRect_();\n  }\n\n  /**\n   * Renders the selected option, which must be an image.\n   * @param {!ImageProperties} imageJson Selected\n   *   option that must be an image.\n   * @private\n   */\n  renderSelectedImage_(imageJson) {\n    this.imageElement_.style.display = '';\n    this.imageElement_.setAttributeNS(\n        dom.XLINK_NS, 'xlink:href', imageJson.src);\n    this.imageElement_.setAttribute('height', imageJson.height);\n    this.imageElement_.setAttribute('width', imageJson.width);\n\n    const imageHeight = Number(imageJson.height);\n    const imageWidth = Number(imageJson.width);\n\n    // Height and width include the border rect.\n    const hasBorder = !!this.borderRect_;\n    const height = Math.max(\n        hasBorder ? this.getConstants().FIELD_DROPDOWN_BORDER_RECT_HEIGHT : 0,\n        imageHeight + IMAGE_Y_PADDING);\n    const xPadding =\n        hasBorder ? this.getConstants().FIELD_BORDER_RECT_X_PADDING : 0;\n    let arrowWidth = 0;\n    if (this.svgArrow_) {\n      arrowWidth = this.positionSVGArrow_(\n          imageWidth + xPadding,\n          height / 2 - this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE / 2);\n    } else {\n      arrowWidth = dom.getFastTextWidth(\n          /** @type {!SVGTSpanElement} */ (this.arrow_),\n          this.getConstants().FIELD_TEXT_FONTSIZE,\n          this.getConstants().FIELD_TEXT_FONTWEIGHT,\n          this.getConstants().FIELD_TEXT_FONTFAMILY);\n    }\n    this.size_.width = imageWidth + arrowWidth + xPadding * 2;\n    this.size_.height = height;\n\n    let arrowX = 0;\n    if (this.sourceBlock_.RTL) {\n      const imageX = xPadding + arrowWidth;\n      this.imageElement_.setAttribute('x', imageX);\n    } else {\n      arrowX = imageWidth + arrowWidth;\n      this.textElement_.setAttribute('text-anchor', 'end');\n      this.imageElement_.setAttribute('x', xPadding);\n    }\n    this.imageElement_.setAttribute('y', height / 2 - imageHeight / 2);\n\n    this.positionTextElement_(arrowX + xPadding, imageWidth + arrowWidth);\n  }\n\n  /**\n   * Renders the selected option, which must be text.\n   * @private\n   */\n  renderSelectedText_() {\n    // Retrieves the selected option to display through getText_.\n    this.textContent_.nodeValue = this.getDisplayText_();\n    dom.addClass(\n        /** @type {!Element} */ (this.textElement_), 'blocklyDropdownText');\n    this.textElement_.setAttribute('text-anchor', 'start');\n\n    // Height and width include the border rect.\n    const hasBorder = !!this.borderRect_;\n    const height = Math.max(\n        hasBorder ? this.getConstants().FIELD_DROPDOWN_BORDER_RECT_HEIGHT : 0,\n        this.getConstants().FIELD_TEXT_HEIGHT);\n    const textWidth = dom.getFastTextWidth(\n        this.textElement_, this.getConstants().FIELD_TEXT_FONTSIZE,\n        this.getConstants().FIELD_TEXT_FONTWEIGHT,\n        this.getConstants().FIELD_TEXT_FONTFAMILY);\n    const xPadding =\n        hasBorder ? this.getConstants().FIELD_BORDER_RECT_X_PADDING : 0;\n    let arrowWidth = 0;\n    if (this.svgArrow_) {\n      arrowWidth = this.positionSVGArrow_(\n          textWidth + xPadding,\n          height / 2 - this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE / 2);\n    }\n    this.size_.width = textWidth + arrowWidth + xPadding * 2;\n    this.size_.height = height;\n\n    this.positionTextElement_(xPadding, textWidth);\n  }\n\n  /**\n   * Position a drop-down arrow at the appropriate location at render-time.\n   * @param {number} x X position the arrow is being rendered at, in px.\n   * @param {number} y Y position the arrow is being rendered at, in px.\n   * @return {number} Amount of space the arrow is taking up, in px.\n   * @private\n   */\n  positionSVGArrow_(x, y) {\n    if (!this.svgArrow_) {\n      return 0;\n    }\n    const hasBorder = !!this.borderRect_;\n    const xPadding =\n        hasBorder ? this.getConstants().FIELD_BORDER_RECT_X_PADDING : 0;\n    const textPadding = this.getConstants().FIELD_DROPDOWN_SVG_ARROW_PADDING;\n    const svgArrowSize = this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE;\n    const arrowX = this.sourceBlock_.RTL ? xPadding : x + textPadding;\n    this.svgArrow_.setAttribute(\n        'transform', 'translate(' + arrowX + ',' + y + ')');\n    return svgArrowSize + textPadding;\n  }\n\n  /**\n   * Use the `getText_` developer hook to override the field's text\n   * representation.  Get the selected option text. If the selected option is an\n   * image we return the image alt text.\n   * @return {?string} Selected option text.\n   * @protected\n   * @override\n   */\n  getText_() {\n    if (!this.selectedOption_) {\n      return null;\n    }\n    const option = this.selectedOption_[0];\n    if (typeof option === 'object') {\n      return option['alt'];\n    }\n    return option;\n  }\n\n  /**\n   * Construct a FieldDropdown from a JSON arg object.\n   * @param {!Object} options A JSON object with options (options).\n   * @return {!FieldDropdown} The new field instance.\n   * @package\n   * @nocollapse\n   */\n  static fromJson(options) {\n    // `this` might be a subclass of FieldDropdown if that class doesn't\n    // override the static fromJson method.\n    return new this(options['options'], undefined, options);\n  }\n\n  /**\n   * Use the calculated prefix and suffix lengths to trim all of the options in\n   * the given array.\n   * @param {!Array<!Array>} options Array of option tuples:\n   *     (human-readable text or image, language-neutral name).\n   * @param {number} prefixLength The length of the common prefix.\n   * @param {number} suffixLength The length of the common suffix\n   * @return {!Array<!Array>} A new array with all of the option text trimmed.\n   */\n  static applyTrim_(options, prefixLength, suffixLength) {\n    const newOptions = [];\n    // Remove the prefix and suffix from the options.\n    for (let i = 0; i < options.length; i++) {\n      let text = options[i][0];\n      const value = options[i][1];\n      text = text.substring(prefixLength, text.length - suffixLength);\n      newOptions[i] = [text, value];\n    }\n    return newOptions;\n  }\n}\n\n/**\n * Dropdown image properties.\n * @typedef {{\n *            src:string,\n *            alt:string,\n *            width:number,\n *            height:number\n *          }}\n */\nlet ImageProperties;  // eslint-disable-line no-unused-vars\n\n/**\n * Horizontal distance that a checkmark overhangs the dropdown.\n */\nFieldDropdown.CHECKMARK_OVERHANG = 25;\n\n/**\n * Maximum height of the dropdown menu, as a percentage of the viewport height.\n */\nFieldDropdown.MAX_MENU_HEIGHT_VH = 0.45;\n\n/**\n * The y offset from the top of the field to the top of the image, if an image\n * is selected.\n * @type {number}\n * @const\n */\nconst IMAGE_Y_OFFSET = 5;\n\n/**\n * The total vertical padding above and below an image.\n * @type {number}\n * @const\n */\nconst IMAGE_Y_PADDING = IMAGE_Y_OFFSET * 2;\n\n/**\n * Android can't (in 2014) display \"\u25be\", so use \"\u25bc\" instead.\n */\nFieldDropdown.ARROW_CHAR = userAgent.ANDROID ? '\\u25BC' : '\\u25BE';\n\n/**\n * Validates the data structure to be processed as an options list.\n * @param {?} options The proposed dropdown options.\n * @throws {TypeError} If proposed options are incorrectly structured.\n */\nconst validateOptions = function(options) {\n  if (!Array.isArray(options)) {\n    throw TypeError('FieldDropdown options must be an array.');\n  }\n  if (!options.length) {\n    throw TypeError('FieldDropdown options must not be an empty array.');\n  }\n  let foundError = false;\n  for (let i = 0; i < options.length; i++) {\n    const tuple = options[i];\n    if (!Array.isArray(tuple)) {\n      foundError = true;\n      console.error(\n          'Invalid option[' + i + ']: Each FieldDropdown option must be an ' +\n              'array. Found: ',\n          tuple);\n    } else if (typeof tuple[1] !== 'string') {\n      foundError = true;\n      console.error(\n          'Invalid option[' + i + ']: Each FieldDropdown option id must be ' +\n              'a string. Found ' + tuple[1] + ' in: ',\n          tuple);\n    } else if (\n        tuple[0] && (typeof tuple[0] !== 'string') &&\n        (typeof tuple[0].src !== 'string')) {\n      foundError = true;\n      console.error(\n          'Invalid option[' + i + ']: Each FieldDropdown option must have a ' +\n              'string label or image description. Found' + tuple[0] + ' in: ',\n          tuple);\n    }\n  }\n  if (foundError) {\n    throw TypeError('Found invalid FieldDropdown options.');\n  }\n};\n\nfieldRegistry.register('field_dropdown', FieldDropdown);\n\nexports.FieldDropdown = FieldDropdown;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/field_dropdown.js?")},
"./core/field_image.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/field_registry.js\");\n__webpack_require__(\"./core/utils/parsing.js\");\n__webpack_require__(\"./core/field.js\");\n__webpack_require__(\"./core/utils/size.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Image field.  Used for pictures, icons, etc.\n */\n\n\n/**\n * Image field.  Used for pictures, icons, etc.\n * @class\n */\ngoog.module('Blockly.FieldImage');\n\nconst dom = goog.require('Blockly.utils.dom');\nconst fieldRegistry = goog.require('Blockly.fieldRegistry');\nconst parsing = goog.require('Blockly.utils.parsing');\nconst {Field} = goog.require('Blockly.Field');\n/* eslint-disable-next-line no-unused-vars */\nconst {Sentinel} = goog.requireType('Blockly.utils.Sentinel');\nconst {Size} = goog.require('Blockly.utils.Size');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n\n\n/**\n * Class for an image on a block.\n * @extends {Field}\n * @alias Blockly.FieldImage\n */\nclass FieldImage extends Field {\n  /**\n   * @param {string|!Sentinel} src The URL of the image.\n   *     Also accepts Field.SKIP_SETUP if you wish to skip setup (only used by\n   *     subclasses that want to handle configuration and setting the field\n   *     value after their own constructors have run).\n   * @param {!(string|number)} width Width of the image.\n   * @param {!(string|number)} height Height of the image.\n   * @param {string=} opt_alt Optional alt text for when block is collapsed.\n   * @param {function(!FieldImage)=} opt_onClick Optional function to be\n   *     called when the image is clicked. If opt_onClick is defined, opt_alt\n   *     must also be defined.\n   * @param {boolean=} opt_flipRtl Whether to flip the icon in RTL.\n   * @param {Object=} opt_config A map of options used to configure the field.\n   *     See the [field creation documentation]{@link\n   *     https://developers.google.com/blockly/guides/create-custom-blocks/fields/built-in-fields/image#creation}\n   *     for a list of properties this parameter supports.\n   */\n  constructor(\n      src, width, height, opt_alt, opt_onClick, opt_flipRtl, opt_config) {\n    super(Field.SKIP_SETUP);\n\n    // Return early.\n    if (!src) {\n      throw Error('Src value of an image field is required');\n    }\n    const imageHeight = Number(parsing.replaceMessageReferences(height));\n    const imageWidth = Number(parsing.replaceMessageReferences(width));\n    if (isNaN(imageHeight) || isNaN(imageWidth)) {\n      throw Error(\n          'Height and width values of an image field must cast to' +\n          ' numbers.');\n    }\n    if (imageHeight <= 0 || imageWidth <= 0) {\n      throw Error(\n          'Height and width values of an image field must be greater' +\n          ' than 0.');\n    }\n\n    /**\n     * The size of the area rendered by the field.\n     * @type {Size}\n     * @protected\n     * @override\n     */\n    this.size_ = new Size(imageWidth, imageHeight + FieldImage.Y_PADDING);\n\n    /**\n     * Store the image height, since it is different from the field height.\n     * @type {number}\n     * @private\n     */\n    this.imageHeight_ = imageHeight;\n\n    /**\n     * The function to be called when this field is clicked.\n     * @type {?function(!FieldImage)}\n     * @private\n     */\n    this.clickHandler_ = null;\n\n    if (typeof opt_onClick === 'function') {\n      this.clickHandler_ = opt_onClick;\n    }\n\n    /**\n     * The rendered field's image element.\n     * @type {SVGImageElement}\n     * @private\n     */\n    this.imageElement_ = null;\n\n    /**\n     * Editable fields usually show some sort of UI indicating they are\n     * editable. This field should not.\n     * @type {boolean}\n     * @const\n     */\n    this.EDITABLE = false;\n\n    /**\n     * Used to tell if the field needs to be rendered the next time the block is\n     * rendered. Image fields are statically sized, and only need to be\n     * rendered at initialization.\n     * @type {boolean}\n     * @protected\n     */\n    this.isDirty_ = false;\n\n    /**\n     * Whether to flip this image in RTL.\n     * @type {boolean}\n     * @private\n     */\n    this.flipRtl_ = false;\n\n    /**\n     * Alt text of this image.\n     * @type {string}\n     * @private\n     */\n    this.altText_ = '';\n\n    if (src === Field.SKIP_SETUP) return;\n\n    if (opt_config) {\n      this.configure_(opt_config);\n    } else {\n      this.flipRtl_ = !!opt_flipRtl;\n      this.altText_ = parsing.replaceMessageReferences(opt_alt) || '';\n    }\n    this.setValue(parsing.replaceMessageReferences(src));\n  }\n\n  /**\n   * Configure the field based on the given map of options.\n   * @param {!Object} config A map of options to configure the field based on.\n   * @protected\n   * @override\n   */\n  configure_(config) {\n    super.configure_(config);\n    this.flipRtl_ = !!config['flipRtl'];\n    this.altText_ = parsing.replaceMessageReferences(config['alt']) || '';\n  }\n\n  /**\n   * Create the block UI for this image.\n   * @package\n   */\n  initView() {\n    this.imageElement_ = dom.createSvgElement(\n        Svg.IMAGE, {\n          'height': this.imageHeight_ + 'px',\n          'width': this.size_.width + 'px',\n          'alt': this.altText_,\n        },\n        this.fieldGroup_);\n    this.imageElement_.setAttributeNS(\n        dom.XLINK_NS, 'xlink:href', /** @type {string} */ (this.value_));\n\n    if (this.clickHandler_) {\n      this.imageElement_.style.cursor = 'pointer';\n    }\n  }\n\n  /**\n   * @override\n   */\n  updateSize_() {\n    // NOP\n  }\n\n  /**\n   * Ensure that the input value (the source URL) is a string.\n   * @param {*=} opt_newValue The input value.\n   * @return {?string} A string, or null if invalid.\n   * @protected\n   */\n  doClassValidation_(opt_newValue) {\n    if (typeof opt_newValue !== 'string') {\n      return null;\n    }\n    return opt_newValue;\n  }\n\n  /**\n   * Update the value of this image field, and update the displayed image.\n   * @param {*} newValue The value to be saved. The default validator guarantees\n   * that this is a string.\n   * @protected\n   */\n  doValueUpdate_(newValue) {\n    this.value_ = newValue;\n    if (this.imageElement_) {\n      this.imageElement_.setAttributeNS(\n          dom.XLINK_NS, 'xlink:href', String(this.value_));\n    }\n  }\n\n  /**\n   * Get whether to flip this image in RTL\n   * @return {boolean} True if we should flip in RTL.\n   * @override\n   */\n  getFlipRtl() {\n    return this.flipRtl_;\n  }\n\n  /**\n   * Set the alt text of this image.\n   * @param {?string} alt New alt text.\n   * @public\n   */\n  setAlt(alt) {\n    if (alt === this.altText_) {\n      return;\n    }\n    this.altText_ = alt || '';\n    if (this.imageElement_) {\n      this.imageElement_.setAttribute('alt', this.altText_);\n    }\n  }\n\n  /**\n   * If field click is called, and click handler defined,\n   * call the handler.\n   * @protected\n   */\n  showEditor_() {\n    if (this.clickHandler_) {\n      this.clickHandler_(this);\n    }\n  }\n\n  /**\n   * Set the function that is called when this image  is clicked.\n   * @param {?function(!FieldImage)} func The function that is called\n   *    when the image is clicked, or null to remove.\n   */\n  setOnClickHandler(func) {\n    this.clickHandler_ = func;\n  }\n\n  /**\n   * Use the `getText_` developer hook to override the field's text\n   * representation.\n   * Return the image alt text instead.\n   * @return {?string} The image alt text.\n   * @protected\n   * @override\n   */\n  getText_() {\n    return this.altText_;\n  }\n\n  /**\n   * Construct a FieldImage from a JSON arg object,\n   * dereferencing any string table references.\n   * @param {!Object} options A JSON object with options (src, width, height,\n   *    alt, and flipRtl).\n   * @return {!FieldImage} The new field instance.\n   * @package\n   * @nocollapse\n   */\n  static fromJson(options) {\n    // `this` might be a subclass of FieldImage if that class doesn't override\n    // the static fromJson method.\n    return new this(\n        options['src'], options['width'], options['height'], undefined,\n        undefined, undefined, options);\n  }\n}\n\n/**\n * The default value for this field.\n * @type {*}\n * @protected\n */\nFieldImage.prototype.DEFAULT_VALUE = '';\n\n/**\n * Vertical padding below the image, which is included in the reported height of\n * the field.\n * @type {number}\n * @private\n */\nFieldImage.Y_PADDING = 1;\n\nfieldRegistry.register('field_image', FieldImage);\n\nexports.FieldImage = FieldImage;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/field_image.js?")},
"./core/field_label.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/field_registry.js\");\n__webpack_require__(\"./core/utils/parsing.js\");\n__webpack_require__(\"./core/field.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Non-editable, non-serializable text field.  Used for titles,\n *    labels, etc.\n */\n\n\n/**\n * Non-editable, non-serializable text field.  Used for titles,\n *    labels, etc.\n * @class\n */\ngoog.module('Blockly.FieldLabel');\n\nconst dom = goog.require('Blockly.utils.dom');\nconst fieldRegistry = goog.require('Blockly.fieldRegistry');\nconst parsing = goog.require('Blockly.utils.parsing');\nconst {Field} = goog.require('Blockly.Field');\n/* eslint-disable-next-line no-unused-vars */\nconst {Sentinel} = goog.requireType('Blockly.utils.Sentinel');\n\n\n/**\n * Class for a non-editable, non-serializable text field.\n * @extends {Field}\n * @alias Blockly.FieldLabel\n */\nclass FieldLabel extends Field {\n  /**\n   * @param {(string|!Sentinel)=} opt_value The initial value of the\n   *     field. Should cast to a string. Defaults to an empty string if null or\n   *     undefined.\n   *     Also accepts Field.SKIP_SETUP if you wish to skip setup (only used by\n   *     subclasses that want to handle configuration and setting the field\n   *     value after their own constructors have run).\n   * @param {string=} opt_class Optional CSS class for the field's text.\n   * @param {Object=} opt_config A map of options used to configure the field.\n   *    See the [field creation documentation]{@link\n   * https://developers.google.com/blockly/guides/create-custom-blocks/fields/built-in-fields/label#creation}\n   *    for a list of properties this parameter supports.\n   */\n  constructor(opt_value, opt_class, opt_config) {\n    super(Field.SKIP_SETUP);\n\n    /**\n     * The html class name to use for this field.\n     * @type {?string}\n     * @private\n     */\n    this.class_ = null;\n\n    /**\n     * Editable fields usually show some sort of UI indicating they are\n     * editable. This field should not.\n     * @type {boolean}\n     */\n    this.EDITABLE = false;\n\n    if (opt_value === Field.SKIP_SETUP) return;\n    if (opt_config) {\n      this.configure_(opt_config);\n    } else {\n      this.class_ = opt_class || null;\n    }\n    this.setValue(opt_value);\n  }\n\n  /**\n   * @override\n   */\n  configure_(config) {\n    super.configure_(config);\n    this.class_ = config['class'];\n  }\n\n  /**\n   * Create block UI for this label.\n   * @package\n   */\n  initView() {\n    this.createTextElement_();\n    if (this.class_) {\n      dom.addClass(\n          /** @type {!SVGTextElement} */ (this.textElement_), this.class_);\n    }\n  }\n\n  /**\n   * Ensure that the input value casts to a valid string.\n   * @param {*=} opt_newValue The input value.\n   * @return {?string} A valid string, or null if invalid.\n   * @protected\n   */\n  doClassValidation_(opt_newValue) {\n    if (opt_newValue === null || opt_newValue === undefined) {\n      return null;\n    }\n    return String(opt_newValue);\n  }\n\n  /**\n   * Set the CSS class applied to the field's textElement_.\n   * @param {?string} cssClass The new CSS class name, or null to remove.\n   */\n  setClass(cssClass) {\n    if (this.textElement_) {\n      // This check isn't necessary, but it's faster than letting removeClass\n      // figure it out.\n      if (this.class_) {\n        dom.removeClass(this.textElement_, this.class_);\n      }\n      if (cssClass) {\n        dom.addClass(this.textElement_, cssClass);\n      }\n    }\n    this.class_ = cssClass;\n  }\n\n  /**\n   * Construct a FieldLabel from a JSON arg object,\n   * dereferencing any string table references.\n   * @param {!Object} options A JSON object with options (text, and class).\n   * @return {!FieldLabel} The new field instance.\n   * @package\n   * @nocollapse\n   */\n  static fromJson(options) {\n    const text = parsing.replaceMessageReferences(options['text']);\n    // `this` might be a subclass of FieldLabel if that class doesn't override\n    // the static fromJson method.\n    return new this(text, undefined, options);\n  }\n}\n\n/**\n * The default value for this field.\n * @type {*}\n * @protected\n */\nFieldLabel.prototype.DEFAULT_VALUE = '';\n\nfieldRegistry.register('field_label', FieldLabel);\n\nexports.FieldLabel = FieldLabel;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/field_label.js?")},
"./core/field_label_serializable.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/field_registry.js\");\n__webpack_require__(\"./core/utils/parsing.js\");\n__webpack_require__(\"./core/field_label.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Non-editable, serializable text field. Behaves like a\n *    normal label but is serialized to XML. It may only be\n *    edited programmatically.\n */\n\n\n/**\n * Non-editable, serializable text field. Behaves like a\n *    normal label but is serialized to XML. It may only be\n *    edited programmatically.\n * @class\n */\ngoog.module('Blockly.FieldLabelSerializable');\n\nconst fieldRegistry = goog.require('Blockly.fieldRegistry');\nconst parsing = goog.require('Blockly.utils.parsing');\nconst {FieldLabel} = goog.require('Blockly.FieldLabel');\n\n\n/**\n * Class for a non-editable, serializable text field.\n * @extends {FieldLabel}\n * @alias Blockly.FieldLabelSerializable\n */\nclass FieldLabelSerializable extends FieldLabel {\n  /**\n   * @param {string=} opt_value The initial value of the field. Should cast to a\n   *    string. Defaults to an empty string if null or undefined.\n   * @param {string=} opt_class Optional CSS class for the field's text.\n   * @param {Object=} opt_config A map of options used to configure the field.\n   *    See the [field creation documentation]{@link\n   * https://developers.google.com/blockly/guides/create-custom-blocks/fields/built-in-fields/label-serializable#creation}\n   *    for a list of properties this parameter supports.\n   */\n  constructor(opt_value, opt_class, opt_config) {\n    super(String(opt_value || ''), opt_class, opt_config);\n\n    /**\n     * Editable fields usually show some sort of UI indicating they are\n     * editable. This field should not.\n     * @type {boolean}\n     */\n    this.EDITABLE = false;\n\n    /**\n     * Serializable fields are saved by the XML renderer, non-serializable\n     * fields are not.  This field should be serialized, but only edited\n     * programmatically.\n     * @type {boolean}\n     */\n    this.SERIALIZABLE = true;\n  }\n\n  /**\n   * Construct a FieldLabelSerializable from a JSON arg object,\n   * dereferencing any string table references.\n   * @param {!Object} options A JSON object with options (text, and class).\n   * @return {!FieldLabelSerializable} The new field instance.\n   * @package\n   * @nocollapse\n   * @override\n   */\n  static fromJson(options) {\n    const text = parsing.replaceMessageReferences(options['text']);\n    // `this` might be a subclass of FieldLabelSerializable if that class\n    // doesn't override the static fromJson method.\n    return new this(text, undefined, options);\n  }\n}\n\nfieldRegistry.register('field_label_serializable', FieldLabelSerializable);\n\nexports.FieldLabelSerializable = FieldLabelSerializable;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/field_label_serializable.js?")},
"./core/field_multilineinput.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/css.js\");\n__webpack_require__(\"./core/widgetdiv.js\");\n__webpack_require__(\"./core/utils/aria.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/field_registry.js\");\n__webpack_require__(\"./core/utils/parsing.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\n__webpack_require__(\"./core/field_textinput.js\");\n__webpack_require__(\"./core/field.js\");\n__webpack_require__(\"./core/utils/keycodes.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Text Area field.\n */\n\n\n/**\n * Text Area field.\n * @class\n */\ngoog.module('Blockly.FieldMultilineInput');\n\nconst Css = goog.require('Blockly.Css');\nconst WidgetDiv = goog.require('Blockly.WidgetDiv');\nconst aria = goog.require('Blockly.utils.aria');\nconst dom = goog.require('Blockly.utils.dom');\nconst fieldRegistry = goog.require('Blockly.fieldRegistry');\nconst parsing = goog.require('Blockly.utils.parsing');\nconst userAgent = goog.require('Blockly.utils.userAgent');\nconst {FieldTextInput} = goog.require('Blockly.FieldTextInput');\nconst {Field} = goog.require('Blockly.Field');\nconst {KeyCodes} = goog.require('Blockly.utils.KeyCodes');\n/* eslint-disable-next-line no-unused-vars */\nconst {Sentinel} = goog.requireType('Blockly.utils.Sentinel');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n\n\n/**\n * Class for an editable text area field.\n * @extends {FieldTextInput}\n * @alias Blockly.FieldMultilineInput\n */\nclass FieldMultilineInput extends FieldTextInput {\n  /**\n   * @param {(string|!Sentinel)=} opt_value The initial content of the\n   *     field. Should cast to a string. Defaults to an empty string if null or\n   *     undefined.\n   *     Also accepts Field.SKIP_SETUP if you wish to skip setup (only used by\n   *     subclasses that want to handle configuration and setting the field\n   *     value after their own constructors have run).\n   * @param {Function=} opt_validator An optional function that is called\n   *     to validate any constraints on what the user entered.  Takes the new\n   *     text as an argument and returns either the accepted text, a replacement\n   *     text, or null to abort the change.\n   * @param {Object=} opt_config A map of options used to configure the field.\n   *     See the [field creation documentation]{@link\n   *     https://developers.google.com/blockly/guides/create-custom-blocks/fields/built-in-fields/multiline-text-input#creation}\n   *     for a list of properties this parameter supports.\n   */\n  constructor(opt_value, opt_validator, opt_config) {\n    super(Field.SKIP_SETUP);\n\n    /**\n     * The SVG group element that will contain a text element for each text row\n     *     when initialized.\n     * @type {SVGGElement}\n     */\n    this.textGroup_ = null;\n\n    /**\n     * Defines the maximum number of lines of field.\n     * If exceeded, scrolling functionality is enabled.\n     * @type {number}\n     * @protected\n     */\n    this.maxLines_ = Infinity;\n\n    /**\n     * Whether Y overflow is currently occurring.\n     * @type {boolean}\n     * @protected\n     */\n    this.isOverflowedY_ = false;\n\n    if (opt_value === Field.SKIP_SETUP) return;\n    if (opt_config) this.configure_(opt_config);\n    this.setValue(opt_value);\n    if (opt_validator) this.setValidator(opt_validator);\n  }\n\n  /**\n   * @override\n   */\n  configure_(config) {\n    super.configure_(config);\n    config.maxLines && this.setMaxLines(config.maxLines);\n  }\n\n  /**\n   * Serializes this field's value to XML. Should only be called by Blockly.Xml.\n   * @param {!Element} fieldElement The element to populate with info about the\n   *    field's state.\n   * @return {!Element} The element containing info about the field's state.\n   * @package\n   */\n  toXml(fieldElement) {\n    // Replace '\\n' characters with HTML-escaped equivalent '&#10'. This is\n    // needed so the plain-text representation of the XML produced by\n    // `Blockly.Xml.domToText` will appear on a single line (this is a\n    // limitation of the plain-text format).\n    fieldElement.textContent = this.getValue().replace(/\\n/g, '&#10;');\n    return fieldElement;\n  }\n\n  /**\n   * Sets the field's value based on the given XML element. Should only be\n   * called by Blockly.Xml.\n   * @param {!Element} fieldElement The element containing info about the\n   *    field's state.\n   * @package\n   */\n  fromXml(fieldElement) {\n    this.setValue(fieldElement.textContent.replace(/&#10;/g, '\\n'));\n  }\n\n  /**\n   * Saves this field's value.\n   * @return {*} The state of this field.\n   * @package\n   */\n  saveState() {\n    const legacyState = this.saveLegacyState(FieldMultilineInput);\n    if (legacyState !== null) {\n      return legacyState;\n    }\n    return this.getValue();\n  }\n\n  /**\n   * Sets the field's value based on the given state.\n   * @param {*} state The state of the variable to assign to this variable\n   *     field.\n   * @override\n   * @package\n   */\n  loadState(state) {\n    if (this.loadLegacyState(Field, state)) {\n      return;\n    }\n    this.setValue(state);\n  }\n\n  /**\n   * Create the block UI for this field.\n   * @package\n   */\n  initView() {\n    this.createBorderRect_();\n    this.textGroup_ = dom.createSvgElement(\n        Svg.G, {\n          'class': 'blocklyEditableText',\n        },\n        this.fieldGroup_);\n  }\n\n  /**\n   * Get the text from this field as displayed on screen.  May differ from\n   * getText due to ellipsis, and other formatting.\n   * @return {string} Currently displayed text.\n   * @protected\n   * @override\n   */\n  getDisplayText_() {\n    let textLines = this.getText();\n    if (!textLines) {\n      // Prevent the field from disappearing if empty.\n      return Field.NBSP;\n    }\n    const lines = textLines.split('\\n');\n    textLines = '';\n    const displayLinesNumber =\n        this.isOverflowedY_ ? this.maxLines_ : lines.length;\n    for (let i = 0; i < displayLinesNumber; i++) {\n      let text = lines[i];\n      if (text.length > this.maxDisplayLength) {\n        // Truncate displayed string and add an ellipsis ('...').\n        text = text.substring(0, this.maxDisplayLength - 4) + '...';\n      } else if (this.isOverflowedY_ && i === displayLinesNumber - 1) {\n        text = text.substring(0, text.length - 3) + '...';\n      }\n      // Replace whitespace with non-breaking spaces so the text doesn't\n      // collapse.\n      text = text.replace(/\\s/g, Field.NBSP);\n\n      textLines += text;\n      if (i !== displayLinesNumber - 1) {\n        textLines += '\\n';\n      }\n    }\n    if (this.sourceBlock_.RTL) {\n      // The SVG is LTR, force value to be RTL.\n      textLines += '\\u200F';\n    }\n    return textLines;\n  }\n\n  /**\n   * Called by setValue if the text input is valid. Updates the value of the\n   * field, and updates the text of the field if it is not currently being\n   * edited (i.e. handled by the htmlInput_). Is being redefined here to update\n   * overflow state of the field.\n   * @param {*} newValue The value to be saved. The default validator guarantees\n   * that this is a string.\n   * @protected\n   */\n  doValueUpdate_(newValue) {\n    super.doValueUpdate_(newValue);\n    this.isOverflowedY_ = this.value_.split('\\n').length > this.maxLines_;\n  }\n\n  /**\n   * Updates the text of the textElement.\n   * @protected\n   */\n  render_() {\n    // Remove all text group children.\n    let currentChild;\n    while ((currentChild = this.textGroup_.firstChild)) {\n      this.textGroup_.removeChild(currentChild);\n    }\n\n    // Add in text elements into the group.\n    const lines = this.getDisplayText_().split('\\n');\n    let y = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineHeight = this.getConstants().FIELD_TEXT_HEIGHT +\n          this.getConstants().FIELD_BORDER_RECT_Y_PADDING;\n      const span = dom.createSvgElement(\n          Svg.TEXT, {\n            'class': 'blocklyText blocklyMultilineText',\n            'x': this.getConstants().FIELD_BORDER_RECT_X_PADDING,\n            'y': y + this.getConstants().FIELD_BORDER_RECT_Y_PADDING,\n            'dy': this.getConstants().FIELD_TEXT_BASELINE,\n          },\n          this.textGroup_);\n      span.appendChild(document.createTextNode(lines[i]));\n      y += lineHeight;\n    }\n\n    if (this.isBeingEdited_) {\n      const htmlInput = /** @type {!HTMLElement} */ (this.htmlInput_);\n      if (this.isOverflowedY_) {\n        dom.addClass(htmlInput, 'blocklyHtmlTextAreaInputOverflowedY');\n      } else {\n        dom.removeClass(htmlInput, 'blocklyHtmlTextAreaInputOverflowedY');\n      }\n    }\n\n    this.updateSize_();\n\n    if (this.isBeingEdited_) {\n      if (this.sourceBlock_.RTL) {\n        // in RTL, we need to let the browser reflow before resizing\n        // in order to get the correct bounding box of the borderRect\n        // avoiding issue #2777.\n        setTimeout(this.resizeEditor_.bind(this), 0);\n      } else {\n        this.resizeEditor_();\n      }\n      const htmlInput = /** @type {!HTMLElement} */ (this.htmlInput_);\n      if (!this.isTextValid_) {\n        dom.addClass(htmlInput, 'blocklyInvalidInput');\n        aria.setState(htmlInput, aria.State.INVALID, true);\n      } else {\n        dom.removeClass(htmlInput, 'blocklyInvalidInput');\n        aria.setState(htmlInput, aria.State.INVALID, false);\n      }\n    }\n  }\n\n  /**\n   * Updates the size of the field based on the text.\n   * @protected\n   */\n  updateSize_() {\n    const nodes = this.textGroup_.childNodes;\n    let totalWidth = 0;\n    let totalHeight = 0;\n    for (let i = 0; i < nodes.length; i++) {\n      const tspan = /** @type {!Element} */ (nodes[i]);\n      const textWidth = dom.getTextWidth(tspan);\n      if (textWidth > totalWidth) {\n        totalWidth = textWidth;\n      }\n      totalHeight += this.getConstants().FIELD_TEXT_HEIGHT +\n          (i > 0 ? this.getConstants().FIELD_BORDER_RECT_Y_PADDING : 0);\n    }\n    if (this.isBeingEdited_) {\n      // The default width is based on the longest line in the display text,\n      // but when it's being edited, width should be calculated based on the\n      // absolute longest line, even if it would be truncated after editing.\n      // Otherwise we would get wrong editor width when there are more\n      // lines than this.maxLines_.\n      const actualEditorLines = this.value_.split('\\n');\n      const dummyTextElement = dom.createSvgElement(\n          Svg.TEXT, {'class': 'blocklyText blocklyMultilineText'});\n      const fontSize = this.getConstants().FIELD_TEXT_FONTSIZE;\n      const fontWeight = this.getConstants().FIELD_TEXT_FONTWEIGHT;\n      const fontFamily = this.getConstants().FIELD_TEXT_FONTFAMILY;\n\n      for (let i = 0; i < actualEditorLines.length; i++) {\n        if (actualEditorLines[i].length > this.maxDisplayLength) {\n          actualEditorLines[i] =\n              actualEditorLines[i].substring(0, this.maxDisplayLength);\n        }\n        dummyTextElement.textContent = actualEditorLines[i];\n        const lineWidth = dom.getFastTextWidth(\n            dummyTextElement, fontSize, fontWeight, fontFamily);\n        if (lineWidth > totalWidth) {\n          totalWidth = lineWidth;\n        }\n      }\n\n      const scrollbarWidth =\n          this.htmlInput_.offsetWidth - this.htmlInput_.clientWidth;\n      totalWidth += scrollbarWidth;\n    }\n    if (this.borderRect_) {\n      totalHeight += this.getConstants().FIELD_BORDER_RECT_Y_PADDING * 2;\n      totalWidth += this.getConstants().FIELD_BORDER_RECT_X_PADDING * 2;\n      this.borderRect_.setAttribute('width', totalWidth);\n      this.borderRect_.setAttribute('height', totalHeight);\n    }\n    this.size_.width = totalWidth;\n    this.size_.height = totalHeight;\n\n    this.positionBorderRect_();\n  }\n\n  /**\n   * Show the inline free-text editor on top of the text.\n   * Overrides the default behaviour to force rerender in order to\n   * correct block size, based on editor text.\n   * @param {Event=} _opt_e Optional mouse event that triggered the field to\n   *     open, or undefined if triggered programmatically.\n   * @param {boolean=} opt_quietInput True if editor should be created without\n   *     focus.  Defaults to false.\n   * @override\n   */\n  showEditor_(_opt_e, opt_quietInput) {\n    super.showEditor_(_opt_e, opt_quietInput);\n    this.forceRerender();\n  }\n\n  /**\n   * Create the text input editor widget.\n   * @return {!HTMLTextAreaElement} The newly created text input editor.\n   * @protected\n   */\n  widgetCreate_() {\n    const div = WidgetDiv.getDiv();\n    const scale = this.workspace_.getScale();\n\n    const htmlInput =\n        /** @type {HTMLTextAreaElement} */ (document.createElement('textarea'));\n    htmlInput.className = 'blocklyHtmlInput blocklyHtmlTextAreaInput';\n    htmlInput.setAttribute('spellcheck', this.spellcheck_);\n    const fontSize = (this.getConstants().FIELD_TEXT_FONTSIZE * scale) + 'pt';\n    div.style.fontSize = fontSize;\n    htmlInput.style.fontSize = fontSize;\n    const borderRadius = (FieldTextInput.BORDERRADIUS * scale) + 'px';\n    htmlInput.style.borderRadius = borderRadius;\n    const paddingX = this.getConstants().FIELD_BORDER_RECT_X_PADDING * scale;\n    const paddingY =\n        this.getConstants().FIELD_BORDER_RECT_Y_PADDING * scale / 2;\n    htmlInput.style.padding = paddingY + 'px ' + paddingX + 'px ' + paddingY +\n        'px ' + paddingX + 'px';\n    const lineHeight = this.getConstants().FIELD_TEXT_HEIGHT +\n        this.getConstants().FIELD_BORDER_RECT_Y_PADDING;\n    htmlInput.style.lineHeight = (lineHeight * scale) + 'px';\n\n    div.appendChild(htmlInput);\n\n    htmlInput.value = htmlInput.defaultValue = this.getEditorText_(this.value_);\n    htmlInput.untypedDefaultValue_ = this.value_;\n    htmlInput.oldValue_ = null;\n    if (userAgent.GECKO) {\n      // In FF, ensure the browser reflows before resizing to avoid issue #2777.\n      setTimeout(this.resizeEditor_.bind(this), 0);\n    } else {\n      this.resizeEditor_();\n    }\n\n    this.bindInputEvents_(htmlInput);\n\n    return htmlInput;\n  }\n\n  /**\n   * Sets the maxLines config for this field.\n   * @param {number} maxLines Defines the maximum number of lines allowed,\n   *     before scrolling functionality is enabled.\n   */\n  setMaxLines(maxLines) {\n    if (typeof maxLines === 'number' && maxLines > 0 &&\n        maxLines !== this.maxLines_) {\n      this.maxLines_ = maxLines;\n      this.forceRerender();\n    }\n  }\n\n  /**\n   * Returns the maxLines config of this field.\n   * @return {number} The maxLines config value.\n   */\n  getMaxLines() {\n    return this.maxLines_;\n  }\n\n  /**\n   * Handle key down to the editor. Override the text input definition of this\n   * so as to not close the editor when enter is typed in.\n   * @param {!Event} e Keyboard event.\n   * @protected\n   */\n  onHtmlInputKeyDown_(e) {\n    if (e.keyCode !== KeyCodes.ENTER) {\n      super.onHtmlInputKeyDown_(e);\n    }\n  }\n\n  /**\n   * Construct a FieldMultilineInput from a JSON arg object,\n   * dereferencing any string table references.\n   * @param {!Object} options A JSON object with options (text, and spellcheck).\n   * @return {!FieldMultilineInput} The new field instance.\n   * @package\n   * @nocollapse\n   * @override\n   */\n  static fromJson(options) {\n    const text = parsing.replaceMessageReferences(options['text']);\n    // `this` might be a subclass of FieldMultilineInput if that class doesn't\n    // override the static fromJson method.\n    return new this(text, undefined, options);\n  }\n}\n\n/**\n * CSS for multiline field.  See css.js for use.\n */\nCss.register(`\n.blocklyHtmlTextAreaInput {\n  font-family: monospace;\n  resize: none;\n  overflow: hidden;\n  height: 100%;\n  text-align: left;\n}\n\n.blocklyHtmlTextAreaInputOverflowedY {\n  overflow-y: scroll;\n}\n`);\n\nfieldRegistry.register('field_multilinetext', FieldMultilineInput);\n\nexports.FieldMultilineInput = FieldMultilineInput;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/field_multilineinput.js?")},
"./core/field_number.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/aria.js\");\n__webpack_require__(\"./core/field_registry.js\");\n__webpack_require__(\"./core/field.js\");\n__webpack_require__(\"./core/field_textinput.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Number input field\n */\n\n\n/**\n * Number input field\n * @class\n */\ngoog.module('Blockly.FieldNumber');\n\nconst aria = goog.require('Blockly.utils.aria');\nconst fieldRegistry = goog.require('Blockly.fieldRegistry');\nconst {Field} = goog.require('Blockly.Field');\nconst {FieldTextInput} = goog.require('Blockly.FieldTextInput');\n/* eslint-disable-next-line no-unused-vars */\nconst {Sentinel} = goog.requireType('Blockly.utils.Sentinel');\n\n\n/**\n * Class for an editable number field.\n * @extends {FieldTextInput}\n * @alias Blockly.FieldNumber\n */\nclass FieldNumber extends FieldTextInput {\n  /**\n   * @param {(string|number|!Sentinel)=} opt_value The initial value of\n   *     the field. Should cast to a number. Defaults to 0.\n   *     Also accepts Field.SKIP_SETUP if you wish to skip setup (only used by\n   *     subclasses that want to handle configuration and setting the field\n   *     value after their own constructors have run).\n   * @param {?(string|number)=} opt_min Minimum value. Will only be used if\n   *     opt_config is not provided.\n   * @param {?(string|number)=} opt_max Maximum value. Will only be used if\n   *     opt_config is not provided.\n   * @param {?(string|number)=} opt_precision Precision for value. Will only be\n   *     used if opt_config is not provided.\n   * @param {?Function=} opt_validator A function that is called to validate\n   *     changes to the field's value. Takes in a number & returns a validated\n   *     number, or null to abort the change.\n   * @param {Object=} opt_config A map of options used to configure the field.\n   *     See the [field creation documentation]{@link\n   *     https://developers.google.com/blockly/guides/create-custom-blocks/fields/built-in-fields/number#creation}\n   *     for a list of properties this parameter supports.\n   */\n  constructor(\n      opt_value, opt_min, opt_max, opt_precision, opt_validator, opt_config) {\n    // Pass SENTINEL so that we can define properties before value validation.\n    super(Field.SKIP_SETUP);\n\n    /**\n     * The minimum value this number field can contain.\n     * @type {number}\n     * @protected\n     */\n    this.min_ = -Infinity;\n\n    /**\n     * The maximum value this number field can contain.\n     * @type {number}\n     * @protected\n     */\n    this.max_ = Infinity;\n\n    /**\n     * The multiple to which this fields value is rounded.\n     * @type {number}\n     * @protected\n     */\n    this.precision_ = 0;\n\n    /**\n     * The number of decimal places to allow, or null to allow any number of\n     * decimal digits.\n     * @type {?number}\n     * @private\n     */\n    this.decimalPlaces_ = null;\n\n    /**\n     * Serializable fields are saved by the serializer, non-serializable fields\n     * are not. Editable fields should also be serializable.\n     * @type {boolean}\n     */\n    this.SERIALIZABLE = true;\n\n    if (opt_value === Field.SKIP_SETUP) return;\n    if (opt_config) {\n      this.configure_(opt_config);\n    } else {\n      this.setConstraints(opt_min, opt_max, opt_precision);\n    }\n    this.setValue(opt_value);\n    if (opt_validator) this.setValidator(opt_validator);\n  }\n\n  /**\n   * Configure the field based on the given map of options.\n   * @param {!Object} config A map of options to configure the field based on.\n   * @protected\n   * @override\n   */\n  configure_(config) {\n    super.configure_(config);\n    this.setMinInternal_(config['min']);\n    this.setMaxInternal_(config['max']);\n    this.setPrecisionInternal_(config['precision']);\n  }\n\n  /**\n   * Set the maximum, minimum and precision constraints on this field.\n   * Any of these properties may be undefined or NaN to be disabled.\n   * Setting precision (usually a power of 10) enforces a minimum step between\n   * values. That is, the user's value will rounded to the closest multiple of\n   * precision. The least significant digit place is inferred from the\n   * precision. Integers values can be enforces by choosing an integer\n   * precision.\n   * @param {?(number|string|undefined)} min Minimum value.\n   * @param {?(number|string|undefined)} max Maximum value.\n   * @param {?(number|string|undefined)} precision Precision for value.\n   */\n  setConstraints(min, max, precision) {\n    this.setMinInternal_(min);\n    this.setMaxInternal_(max);\n    this.setPrecisionInternal_(precision);\n    this.setValue(this.getValue());\n  }\n\n  /**\n   * Sets the minimum value this field can contain. Updates the value to\n   * reflect.\n   * @param {?(number|string|undefined)} min Minimum value.\n   */\n  setMin(min) {\n    this.setMinInternal_(min);\n    this.setValue(this.getValue());\n  }\n\n  /**\n   * Sets the minimum value this field can contain. Called internally to avoid\n   * value updates.\n   * @param {?(number|string|undefined)} min Minimum value.\n   * @private\n   */\n  setMinInternal_(min) {\n    if (min == null) {\n      this.min_ = -Infinity;\n    } else {\n      min = Number(min);\n      if (!isNaN(min)) {\n        this.min_ = min;\n      }\n    }\n  }\n\n  /**\n   * Returns the current minimum value this field can contain. Default is\n   * -Infinity.\n   * @return {number} The current minimum value this field can contain.\n   */\n  getMin() {\n    return this.min_;\n  }\n\n  /**\n   * Sets the maximum value this field can contain. Updates the value to\n   * reflect.\n   * @param {?(number|string|undefined)} max Maximum value.\n   */\n  setMax(max) {\n    this.setMaxInternal_(max);\n    this.setValue(this.getValue());\n  }\n\n  /**\n   * Sets the maximum value this field can contain. Called internally to avoid\n   * value updates.\n   * @param {?(number|string|undefined)} max Maximum value.\n   * @private\n   */\n  setMaxInternal_(max) {\n    if (max == null) {\n      this.max_ = Infinity;\n    } else {\n      max = Number(max);\n      if (!isNaN(max)) {\n        this.max_ = max;\n      }\n    }\n  }\n\n  /**\n   * Returns the current maximum value this field can contain. Default is\n   * Infinity.\n   * @return {number} The current maximum value this field can contain.\n   */\n  getMax() {\n    return this.max_;\n  }\n\n  /**\n   * Sets the precision of this field's value, i.e. the number to which the\n   * value is rounded. Updates the field to reflect.\n   * @param {?(number|string|undefined)} precision The number to which the\n   *    field's value is rounded.\n   */\n  setPrecision(precision) {\n    this.setPrecisionInternal_(precision);\n    this.setValue(this.getValue());\n  }\n\n  /**\n   * Sets the precision of this field's value. Called internally to avoid\n   * value updates.\n   * @param {?(number|string|undefined)} precision The number to which the\n   *    field's value is rounded.\n   * @private\n   */\n  setPrecisionInternal_(precision) {\n    this.precision_ = Number(precision) || 0;\n    let precisionString = String(this.precision_);\n    if (precisionString.indexOf('e') !== -1) {\n      // String() is fast.  But it turns .0000001 into '1e-7'.\n      // Use the much slower toLocaleString to access all the digits.\n      precisionString =\n          this.precision_.toLocaleString('en-US', {maximumFractionDigits: 20});\n    }\n    const decimalIndex = precisionString.indexOf('.');\n    if (decimalIndex === -1) {\n      // If the precision is 0 (float) allow any number of decimals,\n      // otherwise allow none.\n      this.decimalPlaces_ = precision ? 0 : null;\n    } else {\n      this.decimalPlaces_ = precisionString.length - decimalIndex - 1;\n    }\n  }\n\n  /**\n   * Returns the current precision of this field. The precision being the\n   * number to which the field's value is rounded. A precision of 0 means that\n   * the value is not rounded.\n   * @return {number} The number to which this field's value is rounded.\n   */\n  getPrecision() {\n    return this.precision_;\n  }\n\n  /**\n   * Ensure that the input value is a valid number (must fulfill the\n   * constraints placed on the field).\n   * @param {*=} opt_newValue The input value.\n   * @return {?number} A valid number, or null if invalid.\n   * @protected\n   * @override\n   */\n  doClassValidation_(opt_newValue) {\n    if (opt_newValue === null) {\n      return null;\n    }\n    // Clean up text.\n    let newValue = String(opt_newValue);\n    // TODO: Handle cases like 'ten', '1.203,14', etc.\n    // 'O' is sometimes mistaken for '0' by inexperienced users.\n    newValue = newValue.replace(/O/ig, '0');\n    // Strip out thousands separators.\n    newValue = newValue.replace(/,/g, '');\n    // Ignore case of 'Infinity'.\n    newValue = newValue.replace(/infinity/i, 'Infinity');\n\n    // Clean up number.\n    let n = Number(newValue || 0);\n    if (isNaN(n)) {\n      // Invalid number.\n      return null;\n    }\n    // Get the value in range.\n    n = Math.min(Math.max(n, this.min_), this.max_);\n    // Round to nearest multiple of precision.\n    if (this.precision_ && isFinite(n)) {\n      n = Math.round(n / this.precision_) * this.precision_;\n    }\n    // Clean up floating point errors.\n    if (this.decimalPlaces_ !== null) {\n      n = Number(n.toFixed(this.decimalPlaces_));\n    }\n    return n;\n  }\n\n  /**\n   * Create the number input editor widget.\n   * @return {!HTMLElement} The newly created number input editor.\n   * @protected\n   * @override\n   */\n  widgetCreate_() {\n    const htmlInput = super.widgetCreate_();\n\n    // Set the accessibility state\n    if (this.min_ > -Infinity) {\n      aria.setState(htmlInput, aria.State.VALUEMIN, this.min_);\n    }\n    if (this.max_ < Infinity) {\n      aria.setState(htmlInput, aria.State.VALUEMAX, this.max_);\n    }\n    return htmlInput;\n  }\n\n  /**\n   * Construct a FieldNumber from a JSON arg object.\n   * @param {!Object} options A JSON object with options (value, min, max, and\n   *                          precision).\n   * @return {!FieldNumber} The new field instance.\n   * @package\n   * @nocollapse\n   * @override\n   */\n  static fromJson(options) {\n    // `this` might be a subclass of FieldNumber if that class doesn't override\n    // the static fromJson method.\n    return new this(\n        options['value'], undefined, undefined, undefined, undefined, options);\n  }\n}\n\n/**\n * The default value for this field.\n * @type {*}\n * @protected\n */\nFieldNumber.prototype.DEFAULT_VALUE = 0;\n\nfieldRegistry.register('field_number', FieldNumber);\n\nexports.FieldNumber = FieldNumber;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/field_number.js?")},
"./core/field_registry.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/registry.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Fields can be created based on a JSON definition. This file\n *    contains methods for registering those JSON definitions, and building the\n *    fields based on JSON.\n */\n\n\n/**\n * Fields can be created based on a JSON definition. This file\n *    contains methods for registering those JSON definitions, and building the\n *    fields based on JSON.\n * @namespace Blockly.fieldRegistry\n */\ngoog.module('Blockly.fieldRegistry');\n\nconst registry = goog.require('Blockly.registry');\n/* eslint-disable-next-line no-unused-vars */\nconst {Field} = goog.requireType('Blockly.Field');\n/* eslint-disable-next-line no-unused-vars */\nconst {IRegistrableField} = goog.requireType('Blockly.IRegistrableField');\n\n\n/**\n * Registers a field type.\n * fieldRegistry.fromJson uses this registry to\n * find the appropriate field type.\n * @param {string} type The field type name as used in the JSON definition.\n * @param {!IRegistrableField} fieldClass The field class containing a\n *     fromJson function that can construct an instance of the field.\n * @throws {Error} if the type name is empty, the field is already\n *     registered, or the fieldClass is not an object containing a fromJson\n *     function.\n * @alias Blockly.fieldRegistry.register\n */\nconst register = function(type, fieldClass) {\n  registry.register(registry.Type.FIELD, type, fieldClass);\n};\nexports.register = register;\n\n/**\n * Unregisters the field registered with the given type.\n * @param {string} type The field type name as used in the JSON definition.\n * @alias Blockly.fieldRegistry.unregister\n */\nconst unregister = function(type) {\n  registry.unregister(registry.Type.FIELD, type);\n};\nexports.unregister = unregister;\n\n/**\n * Construct a Field from a JSON arg object.\n * Finds the appropriate registered field by the type name as registered using\n * fieldRegistry.register.\n * @param {!Object} options A JSON object with a type and options specific\n *     to the field type.\n * @return {?Field} The new field instance or null if a field wasn't\n *     found with the given type name\n * @alias Blockly.fieldRegistry.fromJson\n * @package\n */\nconst fromJson = function(options) {\n  const fieldObject = /** @type {?IRegistrableField} */ (\n      registry.getObject(registry.Type.FIELD, options['type']));\n  if (!fieldObject) {\n    console.warn(\n        'Blockly could not create a field of type ' + options['type'] +\n        '. The field is probably not being registered. This could be because' +\n        ' the file is not loaded, the field does not register itself (Issue' +\n        ' #1584), or the registration is not being reached.');\n    return null;\n  }\n  return fieldObject.fromJson(options);\n};\nexports.fromJson = fromJson;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/field_registry.js?")},
"./core/field_textinput.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/widgetdiv.js\");\n__webpack_require__(\"./core/utils/aria.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/dialog.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/dropdowndiv.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/field_registry.js\");\n__webpack_require__(\"./core/utils/parsing.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/field.js\");\n__webpack_require__(\"./core/utils/keycodes.js\");\n__webpack_require__(\"./core/msg.js\");\n__webpack_require__(\"./core/events/events_block_change.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Text input field.\n */\n\n\n/**\n * Text input field.\n * @class\n */\ngoog.module('Blockly.FieldTextInput');\n\nconst WidgetDiv = goog.require('Blockly.WidgetDiv');\nconst aria = goog.require('Blockly.utils.aria');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst dialog = goog.require('Blockly.dialog');\nconst dom = goog.require('Blockly.utils.dom');\nconst dropDownDiv = goog.require('Blockly.dropDownDiv');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst fieldRegistry = goog.require('Blockly.fieldRegistry');\nconst parsing = goog.require('Blockly.utils.parsing');\nconst userAgent = goog.require('Blockly.utils.userAgent');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\nconst {Field} = goog.require('Blockly.Field');\nconst {KeyCodes} = goog.require('Blockly.utils.KeyCodes');\nconst {Msg} = goog.require('Blockly.Msg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Sentinel} = goog.requireType('Blockly.utils.Sentinel');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockChange');\n\n\n/**\n * Class for an editable text field.\n * @alias Blockly.FieldTextInput\n */\nclass FieldTextInput extends Field {\n  /**\n   * @param {(string|!Sentinel)=} opt_value The initial value of the\n   *     field. Should cast to a string. Defaults to an empty string if null or\n   *     undefined.\n   *     Also accepts Field.SKIP_SETUP if you wish to skip setup (only used by\n   *     subclasses that want to handle configuration and setting the field\n   *     value after their own constructors have run).\n   * @param {?Function=} opt_validator A function that is called to validate\n   *     changes to the field's value. Takes in a string & returns a validated\n   *     string, or null to abort the change.\n   * @param {Object=} opt_config A map of options used to configure the field.\n   *     See the [field creation documentation]{@link\n   * https://developers.google.com/blockly/guides/create-custom-blocks/fields/built-in-fields/text-input#creation}\n   *     for a list of properties this parameter supports.\n   */\n  constructor(opt_value, opt_validator, opt_config) {\n    super(Field.SKIP_SETUP);\n\n    /**\n     * Allow browser to spellcheck this field.\n     * @type {boolean}\n     * @protected\n     */\n    this.spellcheck_ = true;\n\n    /**\n     * The HTML input element.\n     * @type {HTMLElement}\n     * @protected\n     */\n    this.htmlInput_ = null;\n\n    /**\n     * True if the field's value is currently being edited via the UI.\n     * @type {boolean}\n     * @private\n     */\n    this.isBeingEdited_ = false;\n\n    /**\n     * True if the value currently displayed in the field's editory UI is valid.\n     * @type {boolean}\n     * @private\n     */\n    this.isTextValid_ = false;\n\n    /**\n     * Key down event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onKeyDownWrapper_ = null;\n\n    /**\n     * Key input event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onKeyInputWrapper_ = null;\n\n    /**\n     * Whether the field should consider the whole parent block to be its click\n     * target.\n     * @type {?boolean}\n     */\n    this.fullBlockClickTarget_ = false;\n\n    /**\n     * The workspace that this field belongs to.\n     * @type {?WorkspaceSvg}\n     * @protected\n     */\n    this.workspace_ = null;\n\n    /**\n     * Serializable fields are saved by the serializer, non-serializable fields\n     * are not. Editable fields should also be serializable.\n     * @type {boolean}\n     */\n    this.SERIALIZABLE = true;\n\n    /**\n     * Mouse cursor style when over the hotspot that initiates the editor.\n     * @type {string}\n     */\n    this.CURSOR = 'text';\n\n    if (opt_value === Field.SKIP_SETUP) return;\n    if (opt_config) this.configure_(opt_config);\n    this.setValue(opt_value);\n    if (opt_validator) this.setValidator(opt_validator);\n  }\n\n  /**\n   * @override\n   */\n  configure_(config) {\n    super.configure_(config);\n    if (typeof config['spellcheck'] === 'boolean') {\n      this.spellcheck_ = config['spellcheck'];\n    }\n  }\n\n  /**\n   * @override\n   */\n  initView() {\n    if (this.getConstants().FULL_BLOCK_FIELDS) {\n      // Step one: figure out if this is the only field on this block.\n      // Rendering is quite different in that case.\n      let nFields = 0;\n      let nConnections = 0;\n\n      // Count the number of fields, excluding text fields\n      for (let i = 0, input; (input = this.sourceBlock_.inputList[i]); i++) {\n        for (let j = 0; (input.fieldRow[j]); j++) {\n          nFields++;\n        }\n        if (input.connection) {\n          nConnections++;\n        }\n      }\n      // The special case is when this is the only non-label field on the block\n      // and it has an output but no inputs.\n      this.fullBlockClickTarget_ =\n          nFields <= 1 && this.sourceBlock_.outputConnection && !nConnections;\n    } else {\n      this.fullBlockClickTarget_ = false;\n    }\n\n    if (this.fullBlockClickTarget_) {\n      this.clickTarget_ = this.sourceBlock_.getSvgRoot();\n    } else {\n      this.createBorderRect_();\n    }\n    this.createTextElement_();\n  }\n\n  /**\n   * Ensure that the input value casts to a valid string.\n   * @param {*=} opt_newValue The input value.\n   * @return {*} A valid string, or null if invalid.\n   * @protected\n   */\n  doClassValidation_(opt_newValue) {\n    if (opt_newValue === null || opt_newValue === undefined) {\n      return null;\n    }\n    return String(opt_newValue);\n  }\n\n  /**\n   * Called by setValue if the text input is not valid. If the field is\n   * currently being edited it reverts value of the field to the previous\n   * value while allowing the display text to be handled by the htmlInput_.\n   * @param {*} _invalidValue The input value that was determined to be invalid.\n   *    This is not used by the text input because its display value is stored\n   * on the htmlInput_.\n   * @protected\n   */\n  doValueInvalid_(_invalidValue) {\n    if (this.isBeingEdited_) {\n      this.isTextValid_ = false;\n      const oldValue = this.value_;\n      // Revert value when the text becomes invalid.\n      this.value_ = this.htmlInput_.untypedDefaultValue_;\n      if (this.sourceBlock_ && eventUtils.isEnabled()) {\n        eventUtils.fire(new (eventUtils.get(eventUtils.BLOCK_CHANGE))(\n            this.sourceBlock_, 'field', this.name || null, oldValue,\n            this.value_));\n      }\n    }\n  }\n\n  /**\n   * Called by setValue if the text input is valid. Updates the value of the\n   * field, and updates the text of the field if it is not currently being\n   * edited (i.e. handled by the htmlInput_).\n   * @param {*} newValue The value to be saved. The default validator guarantees\n   * that this is a string.\n   * @protected\n   */\n  doValueUpdate_(newValue) {\n    this.isTextValid_ = true;\n    this.value_ = newValue;\n    if (!this.isBeingEdited_) {\n      // This should only occur if setValue is triggered programmatically.\n      this.isDirty_ = true;\n    }\n  }\n\n  /**\n   * Updates text field to match the colour/style of the block.\n   * @package\n   */\n  applyColour() {\n    if (this.sourceBlock_ && this.getConstants().FULL_BLOCK_FIELDS) {\n      if (this.borderRect_) {\n        this.borderRect_.setAttribute(\n            'stroke', this.sourceBlock_.style.colourTertiary);\n      } else {\n        this.sourceBlock_.pathObject.svgPath.setAttribute(\n            'fill', this.getConstants().FIELD_BORDER_RECT_COLOUR);\n      }\n    }\n  }\n\n  /**\n   * Updates the colour of the htmlInput given the current validity of the\n   * field's value.\n   * @protected\n   */\n  render_() {\n    super.render_();\n    // This logic is done in render_ rather than doValueInvalid_ or\n    // doValueUpdate_ so that the code is more centralized.\n    if (this.isBeingEdited_) {\n      this.resizeEditor_();\n      const htmlInput = /** @type {!HTMLElement} */ (this.htmlInput_);\n      if (!this.isTextValid_) {\n        dom.addClass(htmlInput, 'blocklyInvalidInput');\n        aria.setState(htmlInput, aria.State.INVALID, true);\n      } else {\n        dom.removeClass(htmlInput, 'blocklyInvalidInput');\n        aria.setState(htmlInput, aria.State.INVALID, false);\n      }\n    }\n  }\n\n  /**\n   * Set whether this field is spellchecked by the browser.\n   * @param {boolean} check True if checked.\n   */\n  setSpellcheck(check) {\n    if (check === this.spellcheck_) {\n      return;\n    }\n    this.spellcheck_ = check;\n    if (this.htmlInput_) {\n      this.htmlInput_.setAttribute('spellcheck', this.spellcheck_);\n    }\n  }\n\n  /**\n   * Show the inline free-text editor on top of the text.\n   * @param {Event=} _opt_e Optional mouse event that triggered the field to\n   *     open, or undefined if triggered programmatically.\n   * @param {boolean=} opt_quietInput True if editor should be created without\n   *     focus.  Defaults to false.\n   * @protected\n   */\n  showEditor_(_opt_e, opt_quietInput) {\n    this.workspace_ = (/** @type {!BlockSvg} */ (this.sourceBlock_)).workspace;\n    const quietInput = opt_quietInput || false;\n    if (!quietInput &&\n        (userAgent.MOBILE || userAgent.ANDROID || userAgent.IPAD)) {\n      this.showPromptEditor_();\n    } else {\n      this.showInlineEditor_(quietInput);\n    }\n  }\n\n  /**\n   * Create and show a text input editor that is a prompt (usually a popup).\n   * Mobile browsers have issues with in-line textareas (focus and keyboards).\n   * @private\n   */\n  showPromptEditor_() {\n    dialog.prompt(Msg['CHANGE_VALUE_TITLE'], this.getText(), function(text) {\n      // Text is null if user pressed cancel button.\n      if (text !== null) {\n        this.setValue(this.getValueFromEditorText_(text));\n      }\n    }.bind(this));\n  }\n\n  /**\n   * Create and show a text input editor that sits directly over the text input.\n   * @param {boolean} quietInput True if editor should be created without\n   *     focus.\n   * @private\n   */\n  showInlineEditor_(quietInput) {\n    WidgetDiv.show(this, this.sourceBlock_.RTL, this.widgetDispose_.bind(this));\n    this.htmlInput_ = this.widgetCreate_();\n    this.isBeingEdited_ = true;\n\n    if (!quietInput) {\n      this.htmlInput_.focus({preventScroll: true});\n      this.htmlInput_.select();\n    }\n  }\n\n  /**\n   * Create the text input editor widget.\n   * @return {!HTMLElement} The newly created text input editor.\n   * @protected\n   */\n  widgetCreate_() {\n    eventUtils.setGroup(true);\n    const div = WidgetDiv.getDiv();\n\n    dom.addClass(this.getClickTarget_(), 'editing');\n\n    const htmlInput =\n        /** @type {HTMLInputElement} */ (document.createElement('input'));\n    htmlInput.className = 'blocklyHtmlInput';\n    htmlInput.setAttribute('spellcheck', this.spellcheck_);\n    const scale = this.workspace_.getScale();\n    const fontSize = (this.getConstants().FIELD_TEXT_FONTSIZE * scale) + 'pt';\n    div.style.fontSize = fontSize;\n    htmlInput.style.fontSize = fontSize;\n    let borderRadius = (FieldTextInput.BORDERRADIUS * scale) + 'px';\n\n    if (this.fullBlockClickTarget_) {\n      const bBox = this.getScaledBBox();\n\n      // Override border radius.\n      borderRadius = (bBox.bottom - bBox.top) / 2 + 'px';\n      // Pull stroke colour from the existing shadow block\n      const strokeColour = this.sourceBlock_.getParent() ?\n          this.sourceBlock_.getParent().style.colourTertiary :\n          this.sourceBlock_.style.colourTertiary;\n      htmlInput.style.border = (1 * scale) + 'px solid ' + strokeColour;\n      div.style.borderRadius = borderRadius;\n      div.style.transition = 'box-shadow 0.25s ease 0s';\n      if (this.getConstants().FIELD_TEXTINPUT_BOX_SHADOW) {\n        div.style.boxShadow =\n            'rgba(255, 255, 255, 0.3) 0 0 0 ' + (4 * scale) + 'px';\n      }\n    }\n    htmlInput.style.borderRadius = borderRadius;\n\n    div.appendChild(htmlInput);\n\n    htmlInput.value = htmlInput.defaultValue = this.getEditorText_(this.value_);\n    htmlInput.untypedDefaultValue_ = this.value_;\n    htmlInput.oldValue_ = null;\n\n    this.resizeEditor_();\n\n    this.bindInputEvents_(htmlInput);\n\n    return htmlInput;\n  }\n\n  /**\n   * Closes the editor, saves the results, and disposes of any events or\n   * DOM-references belonging to the editor.\n   * @protected\n   */\n  widgetDispose_() {\n    // Non-disposal related things that we do when the editor closes.\n    this.isBeingEdited_ = false;\n    this.isTextValid_ = true;\n    // Make sure the field's node matches the field's internal value.\n    this.forceRerender();\n    this.onFinishEditing_(this.value_);\n    eventUtils.setGroup(false);\n\n    // Actual disposal.\n    this.unbindInputEvents_();\n    const style = WidgetDiv.getDiv().style;\n    style.width = 'auto';\n    style.height = 'auto';\n    style.fontSize = '';\n    style.transition = '';\n    style.boxShadow = '';\n    this.htmlInput_ = null;\n\n    dom.removeClass(this.getClickTarget_(), 'editing');\n  }\n\n  /**\n   * A callback triggered when the user is done editing the field via the UI.\n   * @param {*} _value The new value of the field.\n   */\n  onFinishEditing_(_value) {\n    // NOP by default.\n    // TODO(#2496): Support people passing a func into the field.\n  }\n\n  /**\n   * Bind handlers for user input on the text input field's editor.\n   * @param {!HTMLElement} htmlInput The htmlInput to which event\n   *    handlers will be bound.\n   * @protected\n   */\n  bindInputEvents_(htmlInput) {\n    // Trap Enter without IME and Esc to hide.\n    this.onKeyDownWrapper_ = browserEvents.conditionalBind(\n        htmlInput, 'keydown', this, this.onHtmlInputKeyDown_);\n    // Resize after every input change.\n    this.onKeyInputWrapper_ = browserEvents.conditionalBind(\n        htmlInput, 'input', this, this.onHtmlInputChange_);\n  }\n\n  /**\n   * Unbind handlers for user input and workspace size changes.\n   * @protected\n   */\n  unbindInputEvents_() {\n    if (this.onKeyDownWrapper_) {\n      browserEvents.unbind(this.onKeyDownWrapper_);\n      this.onKeyDownWrapper_ = null;\n    }\n    if (this.onKeyInputWrapper_) {\n      browserEvents.unbind(this.onKeyInputWrapper_);\n      this.onKeyInputWrapper_ = null;\n    }\n  }\n\n  /**\n   * Handle key down to the editor.\n   * @param {!Event} e Keyboard event.\n   * @protected\n   */\n  onHtmlInputKeyDown_(e) {\n    if (e.keyCode === KeyCodes.ENTER) {\n      WidgetDiv.hide();\n      dropDownDiv.hideWithoutAnimation();\n    } else if (e.keyCode === KeyCodes.ESC) {\n      this.setValue(this.htmlInput_.untypedDefaultValue_);\n      WidgetDiv.hide();\n      dropDownDiv.hideWithoutAnimation();\n    } else if (e.keyCode === KeyCodes.TAB) {\n      WidgetDiv.hide();\n      dropDownDiv.hideWithoutAnimation();\n      this.sourceBlock_.tab(this, !e.shiftKey);\n      e.preventDefault();\n    }\n  }\n\n  /**\n   * Handle a change to the editor.\n   * @param {!Event} _e Keyboard event.\n   * @private\n   */\n  onHtmlInputChange_(_e) {\n    const text = this.htmlInput_.value;\n    if (text !== this.htmlInput_.oldValue_) {\n      this.htmlInput_.oldValue_ = text;\n\n      const value = this.getValueFromEditorText_(text);\n      this.setValue(value);\n      this.forceRerender();\n      this.resizeEditor_();\n    }\n  }\n\n  /**\n   * Set the HTML input value and the field's internal value. The difference\n   * between this and ``setValue`` is that this also updates the HTML input\n   * value whilst editing.\n   * @param {*} newValue New value.\n   * @protected\n   */\n  setEditorValue_(newValue) {\n    this.isDirty_ = true;\n    if (this.isBeingEdited_) {\n      // In the case this method is passed an invalid value, we still\n      // pass it through the transformation method `getEditorText` to deal\n      // with. Otherwise, the internal field's state will be inconsistent\n      // with what's shown to the user.\n      this.htmlInput_.value = this.getEditorText_(newValue);\n    }\n    this.setValue(newValue);\n  }\n\n  /**\n   * Resize the editor to fit the text.\n   * @protected\n   */\n  resizeEditor_() {\n    const div = WidgetDiv.getDiv();\n    const bBox = this.getScaledBBox();\n    div.style.width = bBox.right - bBox.left + 'px';\n    div.style.height = bBox.bottom - bBox.top + 'px';\n\n    // In RTL mode block fields and LTR input fields the left edge moves,\n    // whereas the right edge is fixed.  Reposition the editor.\n    const x = this.sourceBlock_.RTL ? bBox.right - div.offsetWidth : bBox.left;\n    const xy = new Coordinate(x, bBox.top);\n\n    div.style.left = xy.x + 'px';\n    div.style.top = xy.y + 'px';\n  }\n\n  /**\n   * Returns whether or not the field is tab navigable.\n   * @return {boolean} True if the field is tab navigable.\n   * @override\n   */\n  isTabNavigable() {\n    return true;\n  }\n\n  /**\n   * Use the `getText_` developer hook to override the field's text\n   * representation. When we're currently editing, return the current HTML value\n   * instead. Otherwise, return null which tells the field to use the default\n   * behaviour (which is a string cast of the field's value).\n   * @return {?string} The HTML value if we're editing, otherwise null.\n   * @protected\n   * @override\n   */\n  getText_() {\n    if (this.isBeingEdited_ && this.htmlInput_) {\n      // We are currently editing, return the HTML input value instead.\n      return this.htmlInput_.value;\n    }\n    return null;\n  }\n\n  /**\n   * Transform the provided value into a text to show in the HTML input.\n   * Override this method if the field's HTML input representation is different\n   * than the field's value. This should be coupled with an override of\n   * `getValueFromEditorText_`.\n   * @param {*} value The value stored in this field.\n   * @return {string} The text to show on the HTML input.\n   * @protected\n   */\n  getEditorText_(value) {\n    return String(value);\n  }\n\n  /**\n   * Transform the text received from the HTML input into a value to store\n   * in this field.\n   * Override this method if the field's HTML input representation is different\n   * than the field's value. This should be coupled with an override of\n   * `getEditorText_`.\n   * @param {string} text Text received from the HTML input.\n   * @return {*} The value to store.\n   * @protected\n   */\n  getValueFromEditorText_(text) {\n    return text;\n  }\n\n  /**\n   * Construct a FieldTextInput from a JSON arg object,\n   * dereferencing any string table references.\n   * @param {!Object} options A JSON object with options (text, and spellcheck).\n   * @return {!FieldTextInput} The new field instance.\n   * @package\n   * @nocollapse\n   */\n  static fromJson(options) {\n    const text = parsing.replaceMessageReferences(options['text']);\n    // `this` might be a subclass of FieldTextInput if that class doesn't\n    // override the static fromJson method.\n    return new this(text, undefined, options);\n  }\n}\n\n/**\n * The default value for this field.\n * @type {*}\n * @protected\n */\nFieldTextInput.prototype.DEFAULT_VALUE = '';\n\n/**\n * Pixel size of input border radius.\n * Should match blocklyText's border-radius in CSS.\n */\nFieldTextInput.BORDERRADIUS = 4;\n\nfieldRegistry.register('field_input', FieldTextInput);\n\nexports.FieldTextInput = FieldTextInput;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/field_textinput.js?")},
"./core/field_variable.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/variables.js\");\n__webpack_require__(\"./core/xml.js\");\n__webpack_require__(\"./core/field_registry.js\");\n__webpack_require__(\"./core/internal_constants.js\");\n__webpack_require__(\"./core/utils/parsing.js\");\n__webpack_require__(\"./core/field.js\");\n__webpack_require__(\"./core/field_dropdown.js\");\n__webpack_require__(\"./core/msg.js\");\n__webpack_require__(\"./core/utils/size.js\");\n__webpack_require__(\"./core/variable_model.js\");\n__webpack_require__(\"./core/events/events_block_change.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Variable input field.\n */\n\n\n/**\n * Variable input field.\n * @class\n */\ngoog.module('Blockly.FieldVariable');\n\nconst Variables = goog.require('Blockly.Variables');\nconst Xml = goog.require('Blockly.Xml');\nconst fieldRegistry = goog.require('Blockly.fieldRegistry');\nconst internalConstants = goog.require('Blockly.internalConstants');\nconst parsing = goog.require('Blockly.utils.parsing');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\nconst {Field} = goog.require('Blockly.Field');\nconst {FieldDropdown} = goog.require('Blockly.FieldDropdown');\n/* eslint-disable-next-line no-unused-vars */\nconst {MenuItem} = goog.requireType('Blockly.MenuItem');\n/* eslint-disable-next-line no-unused-vars */\nconst {Menu} = goog.requireType('Blockly.Menu');\nconst {Msg} = goog.require('Blockly.Msg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Sentinel} = goog.requireType('Blockly.utils.Sentinel');\nconst {Size} = goog.require('Blockly.utils.Size');\nconst {VariableModel} = goog.require('Blockly.VariableModel');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockChange');\n\n\n/**\n * Class for a variable's dropdown field.\n * @extends {FieldDropdown}\n * @alias Blockly.FieldVariable\n */\nclass FieldVariable extends FieldDropdown {\n  /**\n   * @param {?string|!Sentinel} varName The default name for the variable.\n   *     If null, a unique variable name will be generated.\n   *     Also accepts Field.SKIP_SETUP if you wish to skip setup (only used by\n   *     subclasses that want to handle configuration and setting the field\n   *     value after their own constructors have run).\n   * @param {Function=} opt_validator A function that is called to validate\n   *    changes to the field's value. Takes in a variable ID  & returns a\n   *    validated variable ID, or null to abort the change.\n   * @param {Array<string>=} opt_variableTypes A list of the types of variables\n   *     to include in the dropdown. Will only be used if opt_config is not\n   *     provided.\n   * @param {string=} opt_defaultType The type of variable to create if this\n   *     field's value is not explicitly set.  Defaults to ''. Will only be used\n   *     if opt_config is not provided.\n   * @param {Object=} opt_config A map of options used to configure the field.\n   *    See the [field creation documentation]{@link\n   *    https://developers.google.com/blockly/guides/create-custom-blocks/fields/built-in-fields/variable#creation}\n   *    for a list of properties this parameter supports.\n   */\n  constructor(\n      varName, opt_validator, opt_variableTypes, opt_defaultType, opt_config) {\n    super(Field.SKIP_SETUP);\n\n    /**\n     * An array of options for a dropdown list,\n     * or a function which generates these options.\n     * @type {(!Array<!Array>|\n     *    !function(this:FieldDropdown): !Array<!Array>)}\n     * @protected\n     */\n    this.menuGenerator_ = FieldVariable.dropdownCreate;\n\n    /**\n     * The initial variable name passed to this field's constructor, or an\n     * empty string if a name wasn't provided. Used to create the initial\n     * variable.\n     * @type {string}\n     */\n    this.defaultVariableName = typeof varName === 'string' ? varName : '';\n\n    /**\n     * The type of the default variable for this field.\n     * @type {string}\n     * @private\n     */\n    this.defaultType_ = '';\n\n    /**\n     * All of the types of variables that will be available in this field's\n     * dropdown.\n     * @type {?Array<string>}\n     */\n    this.variableTypes = [];\n\n    /**\n     * The size of the area rendered by the field.\n     * @type {Size}\n     * @protected\n     * @override\n     */\n    this.size_ = new Size(0, 0);\n\n    /**\n     * The variable model associated with this field.\n     * @type {?VariableModel}\n     * @private\n     */\n    this.variable_ = null;\n\n    /**\n     * Serializable fields are saved by the serializer, non-serializable fields\n     * are not. Editable fields should also be serializable.\n     * @type {boolean}\n     */\n    this.SERIALIZABLE = true;\n\n    if (varName === Field.SKIP_SETUP) return;\n\n    if (opt_config) {\n      this.configure_(opt_config);\n    } else {\n      this.setTypes_(opt_variableTypes, opt_defaultType);\n    }\n    if (opt_validator) this.setValidator(opt_validator);\n  }\n\n  /**\n   * Configure the field based on the given map of options.\n   * @param {!Object} config A map of options to configure the field based on.\n   * @protected\n   */\n  configure_(config) {\n    super.configure_(config);\n    this.setTypes_(config['variableTypes'], config['defaultType']);\n  }\n\n  /**\n   * Initialize the model for this field if it has not already been initialized.\n   * If the value has not been set to a variable by the first render, we make up\n   * a variable rather than let the value be invalid.\n   * @package\n   */\n  initModel() {\n    if (this.variable_) {\n      return;  // Initialization already happened.\n    }\n    const variable = Variables.getOrCreateVariablePackage(\n        this.sourceBlock_.workspace, null, this.defaultVariableName,\n        this.defaultType_);\n\n    // Don't call setValue because we don't want to cause a rerender.\n    this.doValueUpdate_(variable.getId());\n  }\n\n  /**\n   * @override\n   */\n  shouldAddBorderRect_() {\n    return super.shouldAddBorderRect_() &&\n        (!this.getConstants().FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW ||\n         this.sourceBlock_.type !== 'variables_get');\n  }\n\n  /**\n   * Initialize this field based on the given XML.\n   * @param {!Element} fieldElement The element containing information about the\n   *    variable field's state.\n   */\n  fromXml(fieldElement) {\n    const id = fieldElement.getAttribute('id');\n    const variableName = fieldElement.textContent;\n    // 'variabletype' should be lowercase, but until July 2019 it was sometimes\n    // recorded as 'variableType'.  Thus we need to check for both.\n    const variableType = fieldElement.getAttribute('variabletype') ||\n        fieldElement.getAttribute('variableType') || '';\n\n    const variable = Variables.getOrCreateVariablePackage(\n        this.sourceBlock_.workspace, id, variableName, variableType);\n\n    // This should never happen :)\n    if (variableType !== null && variableType !== variable.type) {\n      throw Error(\n          'Serialized variable type with id \\'' + variable.getId() +\n          '\\' had type ' + variable.type + ', and ' +\n          'does not match variable field that references it: ' +\n          Xml.domToText(fieldElement) + '.');\n    }\n\n    this.setValue(variable.getId());\n  }\n\n  /**\n   * Serialize this field to XML.\n   * @param {!Element} fieldElement The element to populate with info about the\n   *    field's state.\n   * @return {!Element} The element containing info about the field's state.\n   */\n  toXml(fieldElement) {\n    // Make sure the variable is initialized.\n    this.initModel();\n\n    fieldElement.id = this.variable_.getId();\n    fieldElement.textContent = this.variable_.name;\n    if (this.variable_.type) {\n      fieldElement.setAttribute('variabletype', this.variable_.type);\n    }\n    return fieldElement;\n  }\n\n  /**\n   * Saves this field's value.\n   * @param {boolean=} doFullSerialization If true, the variable field will\n   *     serialize the full state of the field being referenced (ie ID, name,\n   *     and type) rather than just a reference to it (ie ID).\n   * @return {*} The state of the variable field.\n   * @override\n   * @package\n   */\n  saveState(doFullSerialization) {\n    const legacyState = this.saveLegacyState(FieldVariable);\n    if (legacyState !== null) {\n      return legacyState;\n    }\n    // Make sure the variable is initialized.\n    this.initModel();\n    const state = {'id': this.variable_.getId()};\n    if (doFullSerialization) {\n      state['name'] = this.variable_.name;\n      state['type'] = this.variable_.type;\n    }\n    return state;\n  }\n\n  /**\n   * Sets the field's value based on the given state.\n   * @param {*} state The state of the variable to assign to this variable\n   *     field.\n   * @override\n   * @package\n   */\n  loadState(state) {\n    if (this.loadLegacyState(FieldVariable, state)) {\n      return;\n    }\n    // This is necessary so that blocks in the flyout can have custom var names.\n    const variable = Variables.getOrCreateVariablePackage(\n        this.sourceBlock_.workspace, state['id'] || null, state['name'],\n        state['type'] || '');\n    this.setValue(variable.getId());\n  }\n\n  /**\n   * Attach this field to a block.\n   * @param {!Block} block The block containing this field.\n   */\n  setSourceBlock(block) {\n    if (block.isShadow()) {\n      throw Error('Variable fields are not allowed to exist on shadow blocks.');\n    }\n    super.setSourceBlock(block);\n  }\n\n  /**\n   * Get the variable's ID.\n   * @return {?string} Current variable's ID.\n   */\n  getValue() {\n    return this.variable_ ? this.variable_.getId() : null;\n  }\n\n  /**\n   * Get the text from this field, which is the selected variable's name.\n   * @return {string} The selected variable's name, or the empty string if no\n   *     variable is selected.\n   */\n  getText() {\n    return this.variable_ ? this.variable_.name : '';\n  }\n\n  /**\n   * Get the variable model for the selected variable.\n   * Not guaranteed to be in the variable map on the workspace (e.g. if accessed\n   * after the variable has been deleted).\n   * @return {?VariableModel} The selected variable, or null if none was\n   *     selected.\n   * @package\n   */\n  getVariable() {\n    return this.variable_;\n  }\n\n  /**\n   * Gets the validation function for this field, or null if not set.\n   * Returns null if the variable is not set, because validators should not\n   * run on the initial setValue call, because the field won't be attached to\n   * a block and workspace at that point.\n   * @return {?Function} Validation function, or null.\n   */\n  getValidator() {\n    // Validators shouldn't operate on the initial setValue call.\n    // Normally this is achieved by calling setValidator after setValue, but\n    // this is not a possibility with variable fields.\n    if (this.variable_) {\n      return this.validator_;\n    }\n    return null;\n  }\n\n  /**\n   * Ensure that the ID belongs to a valid variable of an allowed type.\n   * @param {*=} opt_newValue The ID of the new variable to set.\n   * @return {?string} The validated ID, or null if invalid.\n   * @protected\n   */\n  doClassValidation_(opt_newValue) {\n    if (opt_newValue === null) {\n      return null;\n    }\n    const newId = /** @type {string} */ (opt_newValue);\n    const variable = Variables.getVariable(this.sourceBlock_.workspace, newId);\n    if (!variable) {\n      console.warn(\n          'Variable id doesn\\'t point to a real variable! ' +\n          'ID was ' + newId);\n      return null;\n    }\n    // Type Checks.\n    const type = variable.type;\n    if (!this.typeIsAllowed_(type)) {\n      console.warn(\n          'Variable type doesn\\'t match this field!  Type was ' + type);\n      return null;\n    }\n    return newId;\n  }\n\n  /**\n   * Update the value of this variable field, as well as its variable and text.\n   *\n   * The variable ID should be valid at this point, but if a variable field\n   * validator returns a bad ID, this could break.\n   * @param {*} newId The value to be saved.\n   * @protected\n   */\n  doValueUpdate_(newId) {\n    this.variable_ = Variables.getVariable(\n        this.sourceBlock_.workspace, /** @type {string} */ (newId));\n    super.doValueUpdate_(newId);\n  }\n\n  /**\n   * Check whether the given variable type is allowed on this field.\n   * @param {string} type The type to check.\n   * @return {boolean} True if the type is in the list of allowed types.\n   * @private\n   */\n  typeIsAllowed_(type) {\n    const typeList = this.getVariableTypes_();\n    if (!typeList) {\n      return true;  // If it's null, all types are valid.\n    }\n    for (let i = 0; i < typeList.length; i++) {\n      if (type === typeList[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Return a list of variable types to include in the dropdown.\n   * @return {!Array<string>} Array of variable types.\n   * @throws {Error} if variableTypes is an empty array.\n   * @private\n   */\n  getVariableTypes_() {\n    // TODO (#1513): Try to avoid calling this every time the field is edited.\n    let variableTypes = this.variableTypes;\n    if (variableTypes === null) {\n      // If variableTypes is null, return all variable types.\n      if (this.sourceBlock_ && this.sourceBlock_.workspace) {\n        return this.sourceBlock_.workspace.getVariableTypes();\n      }\n    }\n    variableTypes = variableTypes || [''];\n    if (variableTypes.length === 0) {\n      // Throw an error if variableTypes is an empty list.\n      const name = this.getText();\n      throw Error(\n          '\\'variableTypes\\' of field variable ' + name + ' was an empty list');\n    }\n    return variableTypes;\n  }\n\n  /**\n   * Parse the optional arguments representing the allowed variable types and\n   * the default variable type.\n   * @param {Array<string>=} opt_variableTypes A list of the types of variables\n   *     to include in the dropdown.  If null or undefined, variables of all\n   * types will be displayed in the dropdown.\n   * @param {string=} opt_defaultType The type of the variable to create if this\n   *     field's value is not explicitly set.  Defaults to ''.\n   * @private\n   */\n  setTypes_(opt_variableTypes, opt_defaultType) {\n    // If you expected that the default type would be the same as the only entry\n    // in the variable types array, tell the Blockly team by commenting on\n    // #1499.\n    const defaultType = opt_defaultType || '';\n    let variableTypes;\n    // Set the allowable variable types.  Null means all types on the workspace.\n    if (opt_variableTypes === null || opt_variableTypes === undefined) {\n      variableTypes = null;\n    } else if (Array.isArray(opt_variableTypes)) {\n      variableTypes = opt_variableTypes;\n      // Make sure the default type is valid.\n      let isInArray = false;\n      for (let i = 0; i < variableTypes.length; i++) {\n        if (variableTypes[i] === defaultType) {\n          isInArray = true;\n        }\n      }\n      if (!isInArray) {\n        throw Error(\n            'Invalid default type \\'' + defaultType + '\\' in ' +\n            'the definition of a FieldVariable');\n      }\n    } else {\n      throw Error(\n          '\\'variableTypes\\' was not an array in the definition of ' +\n          'a FieldVariable');\n    }\n    // Only update the field once all checks pass.\n    this.defaultType_ = defaultType;\n    this.variableTypes = variableTypes;\n  }\n\n  /**\n   * Refreshes the name of the variable by grabbing the name of the model.\n   * Used when a variable gets renamed, but the ID stays the same. Should only\n   * be called by the block.\n   * @override\n   * @package\n   */\n  refreshVariableName() {\n    this.forceRerender();\n  }\n\n  /**\n   * Handle the selection of an item in the variable dropdown menu.\n   * Special case the 'Rename variable...' and 'Delete variable...' options.\n   * In the rename case, prompt the user for a new name.\n   * @param {!Menu} menu The Menu component clicked.\n   * @param {!MenuItem} menuItem The MenuItem selected within menu.\n   * @protected\n   */\n  onItemSelected_(menu, menuItem) {\n    const id = menuItem.getValue();\n    // Handle special cases.\n    if (this.sourceBlock_ && this.sourceBlock_.workspace) {\n      if (id === internalConstants.RENAME_VARIABLE_ID) {\n        // Rename variable.\n        Variables.renameVariable(\n            this.sourceBlock_.workspace,\n            /** @type {!VariableModel} */ (this.variable_));\n        return;\n      } else if (id === internalConstants.DELETE_VARIABLE_ID) {\n        // Delete variable.\n        this.sourceBlock_.workspace.deleteVariableById(this.variable_.getId());\n        return;\n      }\n    }\n    // Handle unspecial case.\n    this.setValue(id);\n  }\n\n  /**\n   * Overrides referencesVariables(), indicating this field refers to a\n   * variable.\n   * @return {boolean} True.\n   * @package\n   * @override\n   */\n  referencesVariables() {\n    return true;\n  }\n\n  /**\n   * Construct a FieldVariable from a JSON arg object,\n   * dereferencing any string table references.\n   * @param {!Object} options A JSON object with options (variable,\n   *                          variableTypes, and defaultType).\n   * @return {!FieldVariable} The new field instance.\n   * @package\n   * @nocollapse\n   * @override\n   */\n  static fromJson(options) {\n    const varName = parsing.replaceMessageReferences(options['variable']);\n    // `this` might be a subclass of FieldVariable if that class doesn't\n    // override the static fromJson method.\n    return new this(varName, undefined, undefined, undefined, options);\n  }\n\n  /**\n   * Return a sorted list of variable names for variable dropdown menus.\n   * Include a special option at the end for creating a new variable name.\n   * @return {!Array<!Array>} Array of variable names/id tuples.\n   * @this {FieldVariable}\n   */\n  static dropdownCreate() {\n    if (!this.variable_) {\n      throw Error(\n          'Tried to call dropdownCreate on a variable field with no' +\n          ' variable selected.');\n    }\n    const name = this.getText();\n    let variableModelList = [];\n    if (this.sourceBlock_ && this.sourceBlock_.workspace) {\n      const variableTypes = this.getVariableTypes_();\n      // Get a copy of the list, so that adding rename and new variable options\n      // doesn't modify the workspace's list.\n      for (let i = 0; i < variableTypes.length; i++) {\n        const variableType = variableTypes[i];\n        const variables =\n            this.sourceBlock_.workspace.getVariablesOfType(variableType);\n        variableModelList = variableModelList.concat(variables);\n      }\n    }\n    variableModelList.sort(VariableModel.compareByName);\n\n    const options = [];\n    for (let i = 0; i < variableModelList.length; i++) {\n      // Set the UUID as the internal representation of the variable.\n      options[i] = [variableModelList[i].name, variableModelList[i].getId()];\n    }\n    options.push(\n        [Msg['RENAME_VARIABLE'], internalConstants.RENAME_VARIABLE_ID]);\n    if (Msg['DELETE_VARIABLE']) {\n      options.push([\n        Msg['DELETE_VARIABLE'].replace('%1', name),\n        internalConstants.DELETE_VARIABLE_ID,\n      ]);\n    }\n\n    return options;\n  }\n}\n\nfieldRegistry.register('field_variable', FieldVariable);\n\nexports.FieldVariable = FieldVariable;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/field_variable.js?")},
"./core/flyout_base.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/tooltip.js\");\n__webpack_require__(\"./core/variables.js\");\n__webpack_require__(\"./core/xml.js\");\n__webpack_require__(\"./core/serialization/blocks.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/utils/idgenerator.js\");\n__webpack_require__(\"./core/utils/toolbox.js\");\n__webpack_require__(\"./core/component_manager.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/delete_area.js\");\n__webpack_require__(\"./core/flyout_metrics_manager.js\");\n__webpack_require__(\"./core/interfaces/i_flyout.js\");\n__webpack_require__(\"./core/utils/rect.js\");\n__webpack_require__(\"./core/scrollbar_pair.js\");\n__webpack_require__(\"./core/utils/svg.js\");\n__webpack_require__(\"./core/workspace_svg.js\");\n__webpack_require__(\"./core/events/events_block_create.js\");\n__webpack_require__(\"./core/events/events_var_create.js\");\n__webpack_require__(\"./core/gesture.js\");\n__webpack_require__(\"./core/touch.js\");\n__webpack_require__(\"./core/renderers/common/block_rendering.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2011 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Flyout tray containing blocks which may be created.\n */\n\n\n/**\n * Flyout tray containing blocks which may be created.\n * @class\n */\ngoog.module('Blockly.Flyout');\n\nconst Tooltip = goog.require('Blockly.Tooltip');\nconst Variables = goog.require('Blockly.Variables');\nconst Xml = goog.require('Blockly.Xml');\nconst blocks = goog.require('Blockly.serialization.blocks');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst common = goog.require('Blockly.common');\nconst dom = goog.require('Blockly.utils.dom');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst idGenerator = goog.require('Blockly.utils.idGenerator');\nconst toolbox = goog.require('Blockly.utils.toolbox');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\nconst {ComponentManager} = goog.require('Blockly.ComponentManager');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\nconst {DeleteArea} = goog.require('Blockly.DeleteArea');\n/* eslint-disable-next-line no-unused-vars */\nconst {FlyoutButton} = goog.requireType('Blockly.FlyoutButton');\nconst {FlyoutMetricsManager} = goog.require('Blockly.FlyoutMetricsManager');\n/* eslint-disable-next-line no-unused-vars */\nconst {IFlyout} = goog.require('Blockly.IFlyout');\n/* eslint-disable-next-line no-unused-vars */\nconst {Options} = goog.requireType('Blockly.Options');\n/* eslint-disable-next-line no-unused-vars */\nconst {Rect} = goog.require('Blockly.utils.Rect');\nconst {ScrollbarPair} = goog.require('Blockly.ScrollbarPair');\nconst {Svg} = goog.require('Blockly.utils.Svg');\nconst {WorkspaceSvg} = goog.require('Blockly.WorkspaceSvg');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockCreate');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.VarCreate');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Gesture');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Touch');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.blockRendering');\n\n\n/**\n * Class for a flyout.\n * @abstract\n * @implements {IFlyout}\n * @extends {DeleteArea}\n * @alias Blockly.Flyout\n */\nclass Flyout extends DeleteArea {\n  /**\n   * @param {!Options} workspaceOptions Dictionary of options for the\n   *     workspace.\n   */\n  constructor(workspaceOptions) {\n    super();\n    workspaceOptions.setMetrics = this.setMetrics_.bind(this);\n\n    /**\n     * @type {!WorkspaceSvg}\n     * @protected\n     */\n    this.workspace_ = new WorkspaceSvg(workspaceOptions);\n    this.workspace_.setMetricsManager(\n        new FlyoutMetricsManager(this.workspace_, this));\n\n    this.workspace_.isFlyout = true;\n    // Keep the workspace visibility consistent with the flyout's visibility.\n    this.workspace_.setVisible(this.isVisible_);\n\n    /**\n     * The unique id for this component that is used to register with the\n     * ComponentManager.\n     * @type {string}\n     */\n    this.id = idGenerator.genUid();\n\n    /**\n     * Is RTL vs LTR.\n     * @type {boolean}\n     */\n    this.RTL = !!workspaceOptions.RTL;\n\n    /**\n     * Whether the flyout should be laid out horizontally or not.\n     * @type {boolean}\n     * @package\n     */\n    this.horizontalLayout = false;\n\n    /**\n     * Position of the toolbox and flyout relative to the workspace.\n     * @type {number}\n     * @protected\n     */\n    this.toolboxPosition_ = workspaceOptions.toolboxPosition;\n\n    /**\n     * Opaque data that can be passed to Blockly.unbindEvent_.\n     * @type {!Array<!Array>}\n     * @private\n     */\n    this.eventWrappers_ = [];\n\n    /**\n     * Function that will be registered as a change listener on the workspace\n     * to reflow when blocks in the flyout workspace change.\n     * @type {?Function}\n     * @private\n     */\n    this.reflowWrapper_ = null;\n\n    /**\n     * Function that disables blocks in the flyout based on max block counts\n     * allowed in the target workspace. Registered as a change listener on the\n     * target workspace.\n     * @type {?Function}\n     * @private\n     */\n    this.filterWrapper_ = null;\n\n    /**\n     * List of background mats that lurk behind each block to catch clicks\n     * landing in the blocks' lakes and bays.\n     * @type {!Array<!SVGElement>}\n     * @private\n     */\n    this.mats_ = [];\n\n    /**\n     * List of visible buttons.\n     * @type {!Array<!FlyoutButton>}\n     * @protected\n     */\n    this.buttons_ = [];\n\n    /**\n     * List of event listeners.\n     * @type {!Array<!Array>}\n     * @private\n     */\n    this.listeners_ = [];\n\n    /**\n     * List of blocks that should always be disabled.\n     * @type {!Array<!Block>}\n     * @private\n     */\n    this.permanentlyDisabled_ = [];\n\n    /**\n     * Width of output tab.\n     * @type {number}\n     * @protected\n     * @const\n     */\n    this.tabWidth_ = this.workspace_.getRenderer().getConstants().TAB_WIDTH;\n\n    /**\n     * The target workspace\n     * @type {?WorkspaceSvg}\n     * @package\n     */\n    this.targetWorkspace = null;\n\n    /**\n     * A list of blocks that can be reused.\n     * @type {!Array<!BlockSvg>}\n     * @private\n     */\n    this.recycledBlocks_ = [];\n\n    /**\n     * Does the flyout automatically close when a block is created?\n     * @type {boolean}\n     */\n    this.autoClose = true;\n\n    /**\n     * Whether the flyout is visible.\n     * @type {boolean}\n     * @private\n     */\n    this.isVisible_ = false;\n\n    /**\n     * Whether the workspace containing this flyout is visible.\n     * @type {boolean}\n     * @private\n     */\n    this.containerVisible_ = true;\n\n    /**\n     * A map from blocks to the rects which are beneath them to act as input\n     * targets.\n     * @type {!WeakMap<!BlockSvg, !SVGElement>}\n     * @private\n     */\n    this.rectMap_ = new WeakMap();\n\n    /**\n     * Corner radius of the flyout background.\n     * @type {number}\n     * @const\n     */\n    this.CORNER_RADIUS = 8;\n\n    /**\n     * Margin around the edges of the blocks in the flyout.\n     * @type {number}\n     * @const\n     */\n    this.MARGIN = this.CORNER_RADIUS;\n\n    // TODO: Move GAP_X and GAP_Y to their appropriate files.\n\n    /**\n     * Gap between items in horizontal flyouts. Can be overridden with the \"sep\"\n     * element.\n     * @const {number}\n     */\n    this.GAP_X = this.MARGIN * 3;\n\n    /**\n     * Gap between items in vertical flyouts. Can be overridden with the \"sep\"\n     * element.\n     * @const {number}\n     */\n    this.GAP_Y = this.MARGIN * 3;\n\n    /**\n     * Top/bottom padding between scrollbar and edge of flyout background.\n     * @type {number}\n     * @const\n     */\n    this.SCROLLBAR_MARGIN = 2.5;\n\n    /**\n     * Width of flyout.\n     * @type {number}\n     * @protected\n     */\n    this.width_ = 0;\n\n    /**\n     * Height of flyout.\n     * @type {number}\n     * @protected\n     */\n    this.height_ = 0;\n\n    // clang-format off\n    /**\n     * Range of a drag angle from a flyout considered \"dragging toward\n     * workspace\". Drags that are within the bounds of this many degrees from\n     * the orthogonal line to the flyout edge are considered to be \"drags toward\n     * the workspace\".\n     * Example:\n     * Flyout                                                 Edge   Workspace\n     * [block] /  <-within this angle, drags \"toward workspace\" |\n     * [block] ---- orthogonal to flyout boundary ----          |\n     * [block] \\                                                |\n     * The angle is given in degrees from the orthogonal.\n     *\n     * This is used to know when to create a new block and when to scroll the\n     * flyout. Setting it to 360 means that all drags create a new block.\n     * @type {number}\n     * @protected\n     */\n    // clang-format on\n    this.dragAngleRange_ = 70;\n\n    /**\n     * The path around the background of the flyout, which will be filled with a\n     * background colour.\n     * @type {?SVGPathElement}\n     * @protected\n     */\n    this.svgBackground_ = null;\n\n    /**\n     * The root SVG group for the button or label.\n     * @type {?SVGGElement}\n     * @protected\n     */\n    this.svgGroup_ = null;\n  }\n\n  /**\n   * Creates the flyout's DOM.  Only needs to be called once.  The flyout can\n   * either exist as its own SVG element or be a g element nested inside a\n   * separate SVG element.\n   * @param {string|\n   * !Svg<!SVGSVGElement>|\n   * !Svg<!SVGGElement>} tagName The type of tag to\n   *     put the flyout in. This should be <svg> or <g>.\n   * @return {!SVGElement} The flyout's SVG group.\n   */\n  createDom(tagName) {\n    /*\n    <svg | g>\n      <path class=\"blocklyFlyoutBackground\"/>\n      <g class=\"blocklyFlyout\"></g>\n    </ svg | g>\n    */\n    // Setting style to display:none to start. The toolbox and flyout\n    // hide/show code will set up proper visibility and size later.\n    this.svgGroup_ = dom.createSvgElement(\n        tagName, {'class': 'blocklyFlyout', 'style': 'display: none'}, null);\n    this.svgBackground_ = dom.createSvgElement(\n        Svg.PATH, {'class': 'blocklyFlyoutBackground'}, this.svgGroup_);\n    this.svgGroup_.appendChild(this.workspace_.createDom());\n    this.workspace_.getThemeManager().subscribe(\n        this.svgBackground_, 'flyoutBackgroundColour', 'fill');\n    this.workspace_.getThemeManager().subscribe(\n        this.svgBackground_, 'flyoutOpacity', 'fill-opacity');\n    return this.svgGroup_;\n  }\n\n  /**\n   * Initializes the flyout.\n   * @param {!WorkspaceSvg} targetWorkspace The workspace in which to\n   *     create new blocks.\n   */\n  init(targetWorkspace) {\n    this.targetWorkspace = targetWorkspace;\n    this.workspace_.targetWorkspace = targetWorkspace;\n\n    this.workspace_.scrollbar = new ScrollbarPair(\n        this.workspace_, this.horizontalLayout, !this.horizontalLayout,\n        'blocklyFlyoutScrollbar', this.SCROLLBAR_MARGIN);\n\n    this.hide();\n\n    Array.prototype.push.apply(\n        this.eventWrappers_,\n        browserEvents.conditionalBind(\n            /** @type {!SVGGElement} */ (this.svgGroup_), 'wheel', this,\n            this.wheel_));\n    if (!this.autoClose) {\n      this.filterWrapper_ = this.filterForCapacity_.bind(this);\n      this.targetWorkspace.addChangeListener(this.filterWrapper_);\n    }\n\n    // Dragging the flyout up and down.\n    Array.prototype.push.apply(\n        this.eventWrappers_,\n        browserEvents.conditionalBind(\n            /** @type {!SVGPathElement} */ (this.svgBackground_), 'mousedown',\n            this, this.onMouseDown_));\n\n    // A flyout connected to a workspace doesn't have its own current gesture.\n    this.workspace_.getGesture =\n        this.targetWorkspace.getGesture.bind(this.targetWorkspace);\n\n    // Get variables from the main workspace rather than the target workspace.\n    this.workspace_.setVariableMap(this.targetWorkspace.getVariableMap());\n\n    this.workspace_.createPotentialVariableMap();\n\n    targetWorkspace.getComponentManager().addComponent({\n      component: this,\n      weight: 1,\n      capabilities: [\n        ComponentManager.Capability.DELETE_AREA,\n        ComponentManager.Capability.DRAG_TARGET,\n      ],\n    });\n  }\n\n  /**\n   * Dispose of this flyout.\n   * Unlink from all DOM elements to prevent memory leaks.\n   * @suppress {checkTypes}\n   */\n  dispose() {\n    this.hide();\n    this.workspace_.getComponentManager().removeComponent(this.id);\n    browserEvents.unbind(this.eventWrappers_);\n    if (this.filterWrapper_) {\n      this.targetWorkspace.removeChangeListener(this.filterWrapper_);\n      this.filterWrapper_ = null;\n    }\n    if (this.workspace_) {\n      this.workspace_.getThemeManager().unsubscribe(this.svgBackground_);\n      this.workspace_.targetWorkspace = null;\n      this.workspace_.dispose();\n      this.workspace_ = null;\n    }\n    if (this.svgGroup_) {\n      dom.removeNode(this.svgGroup_);\n      this.svgGroup_ = null;\n    }\n    this.svgBackground_ = null;\n    this.targetWorkspace = null;\n  }\n\n  /**\n   * Get the width of the flyout.\n   * @return {number} The width of the flyout.\n   */\n  getWidth() {\n    return this.width_;\n  }\n\n  /**\n   * Get the height of the flyout.\n   * @return {number} The width of the flyout.\n   */\n  getHeight() {\n    return this.height_;\n  }\n\n  /**\n   * Get the scale (zoom level) of the flyout. By default,\n   * this matches the target workspace scale, but this can be overridden.\n   * @return {number} Flyout workspace scale.\n   */\n  getFlyoutScale() {\n    return this.targetWorkspace.scale;\n  }\n\n  /**\n   * Get the workspace inside the flyout.\n   * @return {!WorkspaceSvg} The workspace inside the flyout.\n   * @package\n   */\n  getWorkspace() {\n    return this.workspace_;\n  }\n\n  /**\n   * Is the flyout visible?\n   * @return {boolean} True if visible.\n   */\n  isVisible() {\n    return this.isVisible_;\n  }\n\n  /**\n   * Set whether the flyout is visible. A value of true does not necessarily\n   * mean that the flyout is shown. It could be hidden because its container is\n   * hidden.\n   * @param {boolean} visible True if visible.\n   */\n  setVisible(visible) {\n    const visibilityChanged = (visible !== this.isVisible());\n\n    this.isVisible_ = visible;\n    if (visibilityChanged) {\n      if (!this.autoClose) {\n        // Auto-close flyouts are ignored as drag targets, so only non\n        // auto-close flyouts need to have their drag target updated.\n        this.workspace_.recordDragTargets();\n      }\n      this.updateDisplay_();\n    }\n  }\n\n  /**\n   * Set whether this flyout's container is visible.\n   * @param {boolean} visible Whether the container is visible.\n   */\n  setContainerVisible(visible) {\n    const visibilityChanged = (visible !== this.containerVisible_);\n    this.containerVisible_ = visible;\n    if (visibilityChanged) {\n      this.updateDisplay_();\n    }\n  }\n\n  /**\n   * Update the display property of the flyout based whether it thinks it should\n   * be visible and whether its containing workspace is visible.\n   * @private\n   */\n  updateDisplay_() {\n    let show = true;\n    if (!this.containerVisible_) {\n      show = false;\n    } else {\n      show = this.isVisible();\n    }\n    this.svgGroup_.style.display = show ? 'block' : 'none';\n    // Update the scrollbar's visibility too since it should mimic the\n    // flyout's visibility.\n    this.workspace_.scrollbar.setContainerVisible(show);\n  }\n\n  /**\n   * Update the view based on coordinates calculated in position().\n   * @param {number} width The computed width of the flyout's SVG group\n   * @param {number} height The computed height of the flyout's SVG group.\n   * @param {number} x The computed x origin of the flyout's SVG group.\n   * @param {number} y The computed y origin of the flyout's SVG group.\n   * @protected\n   */\n  positionAt_(width, height, x, y) {\n    this.svgGroup_.setAttribute('width', width);\n    this.svgGroup_.setAttribute('height', height);\n    this.workspace_.setCachedParentSvgSize(width, height);\n\n    if (this.svgGroup_.tagName === 'svg') {\n      const transform = 'translate(' + x + 'px,' + y + 'px)';\n      dom.setCssTransform(this.svgGroup_, transform);\n    } else {\n      // IE and Edge don't support CSS transforms on SVG elements so\n      // it's important to set the transform on the SVG element itself\n      const transform = 'translate(' + x + ',' + y + ')';\n      this.svgGroup_.setAttribute('transform', transform);\n    }\n\n    // Update the scrollbar (if one exists).\n    const scrollbar = this.workspace_.scrollbar;\n    if (scrollbar) {\n      // Set the scrollbars origin to be the top left of the flyout.\n      scrollbar.setOrigin(x, y);\n      scrollbar.resize();\n      // If origin changed and metrics haven't changed enough to trigger\n      // reposition in resize, we need to call setPosition. See issue #4692.\n      if (scrollbar.hScroll) {\n        scrollbar.hScroll.setPosition(\n            scrollbar.hScroll.position.x, scrollbar.hScroll.position.y);\n      }\n      if (scrollbar.vScroll) {\n        scrollbar.vScroll.setPosition(\n            scrollbar.vScroll.position.x, scrollbar.vScroll.position.y);\n      }\n    }\n  }\n\n  /**\n   * Hide and empty the flyout.\n   */\n  hide() {\n    if (!this.isVisible()) {\n      return;\n    }\n    this.setVisible(false);\n    // Delete all the event listeners.\n    for (let i = 0, listen; (listen = this.listeners_[i]); i++) {\n      browserEvents.unbind(listen);\n    }\n    this.listeners_.length = 0;\n    if (this.reflowWrapper_) {\n      this.workspace_.removeChangeListener(this.reflowWrapper_);\n      this.reflowWrapper_ = null;\n    }\n    // Do NOT delete the blocks here.  Wait until Flyout.show.\n    // https://neil.fraser.name/news/2014/08/09/\n  }\n\n  /**\n   * Show and populate the flyout.\n   * @param {!toolbox.FlyoutDefinition|string} flyoutDef Contents to display\n   *     in the flyout. This is either an array of Nodes, a NodeList, a\n   *     toolbox definition, or a string with the name of the dynamic category.\n   */\n  show(flyoutDef) {\n    this.workspace_.setResizesEnabled(false);\n    this.hide();\n    this.clearOldBlocks_();\n\n    // Handle dynamic categories, represented by a name instead of a list.\n    if (typeof flyoutDef === 'string') {\n      flyoutDef = this.getDynamicCategoryContents_(flyoutDef);\n    }\n    this.setVisible(true);\n\n    // Parse the Array, Node or NodeList into a a list of flyout items.\n    const parsedContent = toolbox.convertFlyoutDefToJsonArray(flyoutDef);\n    const flyoutInfo =\n        /** @type {{contents:!Array<!Object>, gaps:!Array<number>}} */ (\n            this.createFlyoutInfo_(parsedContent));\n\n    this.layout_(flyoutInfo.contents, flyoutInfo.gaps);\n\n    // IE 11 is an incompetent browser that fails to fire mouseout events.\n    // When the mouse is over the background, deselect all blocks.\n    const deselectAll =\n        /** @this {Flyout} */\n        function() {\n          const topBlocks = this.workspace_.getTopBlocks(false);\n          for (let i = 0, block; (block = topBlocks[i]); i++) {\n            block.removeSelect();\n          }\n        };\n\n    this.listeners_.push(browserEvents.conditionalBind(\n        /** @type {!SVGPathElement} */ (this.svgBackground_), 'mouseover', this,\n        deselectAll));\n\n    if (this.horizontalLayout) {\n      this.height_ = 0;\n    } else {\n      this.width_ = 0;\n    }\n    this.workspace_.setResizesEnabled(true);\n    this.reflow();\n\n    this.filterForCapacity_();\n\n    // Correctly position the flyout's scrollbar when it opens.\n    this.position();\n\n    this.reflowWrapper_ = this.reflow.bind(this);\n    this.workspace_.addChangeListener(this.reflowWrapper_);\n    this.emptyRecycledBlocks_();\n  }\n\n  /**\n   * Create the contents array and gaps array necessary to create the layout for\n   * the flyout.\n   * @param {!toolbox.FlyoutItemInfoArray} parsedContent The array\n   *     of objects to show in the flyout.\n   * @return {{contents:Array<Object>, gaps:Array<number>}} The list of contents\n   *     and gaps needed to lay out the flyout.\n   * @private\n   */\n  createFlyoutInfo_(parsedContent) {\n    const contents = [];\n    const gaps = [];\n    this.permanentlyDisabled_.length = 0;\n    const defaultGap = this.horizontalLayout ? this.GAP_X : this.GAP_Y;\n    for (let i = 0, contentInfo; (contentInfo = parsedContent[i]); i++) {\n      if (contentInfo['custom']) {\n        const customInfo =\n            /** @type {!toolbox.DynamicCategoryInfo} */ (contentInfo);\n        const categoryName = customInfo['custom'];\n        const flyoutDef = this.getDynamicCategoryContents_(categoryName);\n        const parsedDynamicContent = /** @type {!toolbox.FlyoutItemInfoArray} */\n            (toolbox.convertFlyoutDefToJsonArray(flyoutDef));\n        // Replace the element at i with the dynamic content it represents.\n        parsedContent.splice.apply(\n            parsedContent, [i, 1].concat(parsedDynamicContent));\n        contentInfo = parsedContent[i];\n      }\n\n      switch (contentInfo['kind'].toUpperCase()) {\n        case 'BLOCK': {\n          const blockInfo = /** @type {!toolbox.BlockInfo} */ (contentInfo);\n          const block = this.createFlyoutBlock_(blockInfo);\n          contents.push({type: 'block', block: block});\n          this.addBlockGap_(blockInfo, gaps, defaultGap);\n          break;\n        }\n        case 'SEP': {\n          const sepInfo = /** @type {!toolbox.SeparatorInfo} */ (contentInfo);\n          this.addSeparatorGap_(sepInfo, gaps, defaultGap);\n          break;\n        }\n        case 'LABEL': {\n          const labelInfo = /** @type {!toolbox.LabelInfo} */ (contentInfo);\n          // A label is a button with different styling.\n          const label = this.createButton_(labelInfo, /** isLabel */ true);\n          contents.push({type: 'button', button: label});\n          gaps.push(defaultGap);\n          break;\n        }\n        case 'BUTTON': {\n          const buttonInfo = /** @type {!toolbox.ButtonInfo} */ (contentInfo);\n          const button = this.createButton_(buttonInfo, /** isLabel */ false);\n          contents.push({type: 'button', button: button});\n          gaps.push(defaultGap);\n          break;\n        }\n      }\n    }\n    return {contents: contents, gaps: gaps};\n  }\n\n  /**\n   * Gets the flyout definition for the dynamic category.\n   * @param {string} categoryName The name of the dynamic category.\n   * @return {!toolbox.FlyoutDefinition} The definition of the\n   *     flyout in one of its many forms.\n   * @private\n   */\n  getDynamicCategoryContents_(categoryName) {\n    // Look up the correct category generation function and call that to get a\n    // valid XML list.\n    const fnToApply =\n        this.workspace_.targetWorkspace.getToolboxCategoryCallback(\n            categoryName);\n    if (typeof fnToApply !== 'function') {\n      throw TypeError(\n          'Couldn\\'t find a callback function when opening' +\n          ' a toolbox category.');\n    }\n    return fnToApply(this.workspace_.targetWorkspace);\n  }\n\n  /**\n   * Creates a flyout button or a flyout label.\n   * @param {!toolbox.ButtonOrLabelInfo} btnInfo\n   *    The object holding information about a button or a label.\n   * @param {boolean} isLabel True if the button is a label, false otherwise.\n   * @return {!FlyoutButton} The object used to display the button in the\n   *    flyout.\n   * @private\n   */\n  createButton_(btnInfo, isLabel) {\n    const {FlyoutButton} = goog.module.get('Blockly.FlyoutButton');\n    if (!FlyoutButton) {\n      throw Error('Missing require for Blockly.FlyoutButton');\n    }\n    const curButton = new FlyoutButton(\n        this.workspace_,\n        /** @type {!WorkspaceSvg} */ (this.targetWorkspace), btnInfo, isLabel);\n    return curButton;\n  }\n\n  /**\n   * Create a block from the xml and permanently disable any blocks that were\n   * defined as disabled.\n   * @param {!toolbox.BlockInfo} blockInfo The info of the block.\n   * @return {!BlockSvg} The block created from the blockInfo.\n   * @private\n   */\n  createFlyoutBlock_(blockInfo) {\n    let block;\n    if (blockInfo['blockxml']) {\n      const xml = typeof blockInfo['blockxml'] === 'string' ?\n          Xml.textToDom(blockInfo['blockxml']) :\n          blockInfo['blockxml'];\n      block = this.getRecycledBlock_(xml.getAttribute('type'));\n      if (!block) {\n        block = Xml.domToBlock(xml, this.workspace_);\n      }\n    } else {\n      block = this.getRecycledBlock_(blockInfo['type']);\n      if (!block) {\n        if (blockInfo['enabled'] === undefined) {\n          blockInfo['enabled'] = blockInfo['disabled'] !== 'true' &&\n              blockInfo['disabled'] !== true;\n        }\n        block = blocks.append(\n            /** @type {blocks.State} */ (blockInfo), this.workspace_);\n      }\n    }\n\n    if (!block.isEnabled()) {\n      // Record blocks that were initially disabled.\n      // Do not enable these blocks as a result of capacity filtering.\n      this.permanentlyDisabled_.push(block);\n    }\n    return /** @type {!BlockSvg} */ (block);\n  }\n\n  /**\n   * Returns a block from the array of recycled blocks with the given type, or\n   * undefined if one cannot be found.\n   * @param {string} blockType The type of the block to try to recycle.\n   * @return {(!BlockSvg|undefined)} The recycled block, or undefined if\n   *     one could not be recycled.\n   * @private\n   */\n  getRecycledBlock_(blockType) {\n    let index = -1;\n    for (let i = 0; i < this.recycledBlocks_.length; i++) {\n      if (this.recycledBlocks_[i].type === blockType) {\n        index = i;\n        break;\n      }\n    }\n    return index === -1 ? undefined : this.recycledBlocks_.splice(index, 1)[0];\n  }\n\n  /**\n   * Adds a gap in the flyout based on block info.\n   * @param {!toolbox.BlockInfo} blockInfo Information about a block.\n   * @param {!Array<number>} gaps The list of gaps between items in the flyout.\n   * @param {number} defaultGap The default gap between one element and the\n   *     next.\n   * @private\n   */\n  addBlockGap_(blockInfo, gaps, defaultGap) {\n    let gap;\n    if (blockInfo['gap']) {\n      gap = parseInt(blockInfo['gap'], 10);\n    } else if (blockInfo['blockxml']) {\n      const xml = typeof blockInfo['blockxml'] === 'string' ?\n          Xml.textToDom(blockInfo['blockxml']) :\n          blockInfo['blockxml'];\n      gap = parseInt(xml.getAttribute('gap'), 10);\n    }\n    gaps.push(isNaN(gap) ? defaultGap : gap);\n  }\n\n  /**\n   * Add the necessary gap in the flyout for a separator.\n   * @param {!toolbox.SeparatorInfo} sepInfo The object holding\n   *    information about a separator.\n   * @param {!Array<number>} gaps The list gaps between items in the flyout.\n   * @param {number} defaultGap The default gap between the button and next\n   *     element.\n   * @private\n   */\n  addSeparatorGap_(sepInfo, gaps, defaultGap) {\n    // Change the gap between two toolbox elements.\n    // <sep gap=\"36\"></sep>\n    // The default gap is 24, can be set larger or smaller.\n    // This overwrites the gap attribute on the previous element.\n    const newGap = parseInt(sepInfo['gap'], 10);\n    // Ignore gaps before the first block.\n    if (!isNaN(newGap) && gaps.length > 0) {\n      gaps[gaps.length - 1] = newGap;\n    } else {\n      gaps.push(defaultGap);\n    }\n  }\n\n  /**\n   * Delete blocks, mats and buttons from a previous showing of the flyout.\n   * @private\n   */\n  clearOldBlocks_() {\n    // Delete any blocks from a previous showing.\n    const oldBlocks = this.workspace_.getTopBlocks(false);\n    for (let i = 0, block; (block = oldBlocks[i]); i++) {\n      if (this.blockIsRecyclable_(block)) {\n        this.recycleBlock_(block);\n      } else {\n        block.dispose(false, false);\n      }\n    }\n    // Delete any mats from a previous showing.\n    for (let j = 0; j < this.mats_.length; j++) {\n      const rect = this.mats_[j];\n      if (rect) {\n        Tooltip.unbindMouseEvents(rect);\n        dom.removeNode(rect);\n      }\n    }\n    this.mats_.length = 0;\n    // Delete any buttons from a previous showing.\n    for (let i = 0, button; (button = this.buttons_[i]); i++) {\n      button.dispose();\n    }\n    this.buttons_.length = 0;\n\n    // Clear potential variables from the previous showing.\n    this.workspace_.getPotentialVariableMap().clear();\n  }\n\n  /**\n   * Empties all of the recycled blocks, properly disposing of them.\n   * @private\n   */\n  emptyRecycledBlocks_() {\n    for (let i = 0; i < this.recycledBlocks_.length; i++) {\n      this.recycledBlocks_[i].dispose();\n    }\n    this.recycledBlocks_ = [];\n  }\n\n  /**\n   * Returns whether the given block can be recycled or not.\n   * @param {!BlockSvg} _block The block to check for recyclability.\n   * @return {boolean} True if the block can be recycled. False otherwise.\n   * @protected\n   */\n  blockIsRecyclable_(_block) {\n    // By default, recycling is disabled.\n    return false;\n  }\n\n  /**\n   * Puts a previously created block into the recycle bin and moves it to the\n   * top of the workspace. Used during large workspace swaps to limit the number\n   * of new DOM elements we need to create.\n   * @param {!BlockSvg} block The block to recycle.\n   * @private\n   */\n  recycleBlock_(block) {\n    const xy = block.getRelativeToSurfaceXY();\n    block.moveBy(-xy.x, -xy.y);\n    this.recycledBlocks_.push(block);\n  }\n\n  /**\n   * Add listeners to a block that has been added to the flyout.\n   * @param {!SVGElement} root The root node of the SVG group the block is in.\n   * @param {!BlockSvg} block The block to add listeners for.\n   * @param {!SVGElement} rect The invisible rectangle under the block that acts\n   *     as a mat for that block.\n   * @protected\n   */\n  addBlockListeners_(root, block, rect) {\n    this.listeners_.push(browserEvents.conditionalBind(\n        root, 'mousedown', null, this.blockMouseDown_(block)));\n    this.listeners_.push(browserEvents.conditionalBind(\n        rect, 'mousedown', null, this.blockMouseDown_(block)));\n    this.listeners_.push(\n        browserEvents.bind(root, 'mouseenter', block, block.addSelect));\n    this.listeners_.push(\n        browserEvents.bind(root, 'mouseleave', block, block.removeSelect));\n    this.listeners_.push(\n        browserEvents.bind(rect, 'mouseenter', block, block.addSelect));\n    this.listeners_.push(\n        browserEvents.bind(rect, 'mouseleave', block, block.removeSelect));\n  }\n\n  /**\n   * Handle a mouse-down on an SVG block in a non-closing flyout.\n   * @param {!BlockSvg} block The flyout block to copy.\n   * @return {!Function} Function to call when block is clicked.\n   * @private\n   */\n  blockMouseDown_(block) {\n    const flyout = this;\n    return function(e) {\n      const gesture = flyout.targetWorkspace.getGesture(e);\n      if (gesture) {\n        gesture.setStartBlock(block);\n        gesture.handleFlyoutStart(e, flyout);\n      }\n    };\n  }\n\n  /**\n   * Mouse down on the flyout background.  Start a vertical scroll drag.\n   * @param {!Event} e Mouse down event.\n   * @private\n   */\n  onMouseDown_(e) {\n    const gesture = this.targetWorkspace.getGesture(e);\n    if (gesture) {\n      gesture.handleFlyoutStart(e, this);\n    }\n  }\n\n  /**\n   * Does this flyout allow you to create a new instance of the given block?\n   * Used for deciding if a block can be \"dragged out of\" the flyout.\n   * @param {!BlockSvg} block The block to copy from the flyout.\n   * @return {boolean} True if you can create a new instance of the block, false\n   *    otherwise.\n   * @package\n   */\n  isBlockCreatable_(block) {\n    return block.isEnabled();\n  }\n\n  /**\n   * Create a copy of this block on the workspace.\n   * @param {!BlockSvg} originalBlock The block to copy from the flyout.\n   * @return {!BlockSvg} The newly created block.\n   * @throws {Error} if something went wrong with deserialization.\n   * @package\n   */\n  createBlock(originalBlock) {\n    let newBlock = null;\n    eventUtils.disable();\n    const variablesBeforeCreation = this.targetWorkspace.getAllVariables();\n    this.targetWorkspace.setResizesEnabled(false);\n    try {\n      newBlock = this.placeNewBlock_(originalBlock);\n    } finally {\n      eventUtils.enable();\n    }\n\n    // Close the flyout.\n    this.targetWorkspace.hideChaff();\n\n    const newVariables = Variables.getAddedVariables(\n        this.targetWorkspace, variablesBeforeCreation);\n\n    if (eventUtils.isEnabled()) {\n      eventUtils.setGroup(true);\n      // Fire a VarCreate event for each (if any) new variable created.\n      for (let i = 0; i < newVariables.length; i++) {\n        const thisVariable = newVariables[i];\n        eventUtils.fire(\n            new (eventUtils.get(eventUtils.VAR_CREATE))(thisVariable));\n      }\n\n      // Block events come after var events, in case they refer to newly created\n      // variables.\n      eventUtils.fire(new (eventUtils.get(eventUtils.BLOCK_CREATE))(newBlock));\n    }\n    if (this.autoClose) {\n      this.hide();\n    } else {\n      this.filterForCapacity_();\n    }\n    return newBlock;\n  }\n\n  /**\n   * Initialize the given button: move it to the correct location,\n   * add listeners, etc.\n   * @param {!FlyoutButton} button The button to initialize and place.\n   * @param {number} x The x position of the cursor during this layout pass.\n   * @param {number} y The y position of the cursor during this layout pass.\n   * @protected\n   */\n  initFlyoutButton_(button, x, y) {\n    const buttonSvg = button.createDom();\n    button.moveTo(x, y);\n    button.show();\n    // Clicking on a flyout button or label is a lot like clicking on the\n    // flyout background.\n    this.listeners_.push(browserEvents.conditionalBind(\n        buttonSvg, 'mousedown', this, this.onMouseDown_));\n\n    this.buttons_.push(button);\n  }\n\n  /**\n   * Create and place a rectangle corresponding to the given block.\n   * @param {!BlockSvg} block The block to associate the rect to.\n   * @param {number} x The x position of the cursor during this layout pass.\n   * @param {number} y The y position of the cursor during this layout pass.\n   * @param {!{height: number, width: number}} blockHW The height and width of\n   *     the block.\n   * @param {number} index The index into the mats list where this rect should\n   *     be placed.\n   * @return {!SVGElement} Newly created SVG element for the rectangle behind\n   *     the block.\n   * @protected\n   */\n  createRect_(block, x, y, blockHW, index) {\n    // Create an invisible rectangle under the block to act as a button.  Just\n    // using the block as a button is poor, since blocks have holes in them.\n    const rect = dom.createSvgElement(\n        Svg.RECT, {\n          'fill-opacity': 0,\n          'x': x,\n          'y': y,\n          'height': blockHW.height,\n          'width': blockHW.width,\n        },\n        null);\n    rect.tooltip = block;\n    Tooltip.bindMouseEvents(rect);\n    // Add the rectangles under the blocks, so that the blocks' tooltips work.\n    this.workspace_.getCanvas().insertBefore(rect, block.getSvgRoot());\n\n    this.rectMap_.set(block, rect);\n    this.mats_[index] = rect;\n    return rect;\n  }\n\n  /**\n   * Move a rectangle to sit exactly behind a block, taking into account tabs,\n   * hats, and any other protrusions we invent.\n   * @param {!SVGElement} rect The rectangle to move directly behind the block.\n   * @param {!BlockSvg} block The block the rectangle should be behind.\n   * @protected\n   */\n  moveRectToBlock_(rect, block) {\n    const blockHW = block.getHeightWidth();\n    rect.setAttribute('width', blockHW.width);\n    rect.setAttribute('height', blockHW.height);\n\n    const blockXY = block.getRelativeToSurfaceXY();\n    rect.setAttribute('y', blockXY.y);\n    rect.setAttribute('x', this.RTL ? blockXY.x - blockHW.width : blockXY.x);\n  }\n\n  /**\n   * Filter the blocks on the flyout to disable the ones that are above the\n   * capacity limit.  For instance, if the user may only place two more blocks\n   * on the workspace, an \"a + b\" block that has two shadow blocks would be\n   * disabled.\n   * @private\n   */\n  filterForCapacity_() {\n    const blocks = this.workspace_.getTopBlocks(false);\n    for (let i = 0, block; (block = blocks[i]); i++) {\n      if (this.permanentlyDisabled_.indexOf(block) === -1) {\n        const enable = this.targetWorkspace.isCapacityAvailable(\n            common.getBlockTypeCounts(block));\n        while (block) {\n          block.setEnabled(enable);\n          block = block.getNextBlock();\n        }\n      }\n    }\n  }\n\n  /**\n   * Reflow blocks and their mats.\n   */\n  reflow() {\n    if (this.reflowWrapper_) {\n      this.workspace_.removeChangeListener(this.reflowWrapper_);\n    }\n    this.reflowInternal_();\n    if (this.reflowWrapper_) {\n      this.workspace_.addChangeListener(this.reflowWrapper_);\n    }\n  }\n\n  /**\n   * @return {boolean} True if this flyout may be scrolled with a scrollbar or\n   *     by dragging.\n   * @package\n   */\n  isScrollable() {\n    return this.workspace_.scrollbar ? this.workspace_.scrollbar.isVisible() :\n                                       false;\n  }\n\n  /**\n   * Copy a block from the flyout to the workspace and position it correctly.\n   * @param {!BlockSvg} oldBlock The flyout block to copy.\n   * @return {!BlockSvg} The new block in the main workspace.\n   * @private\n   */\n  placeNewBlock_(oldBlock) {\n    const targetWorkspace = this.targetWorkspace;\n    const svgRootOld = oldBlock.getSvgRoot();\n    if (!svgRootOld) {\n      throw Error('oldBlock is not rendered.');\n    }\n\n    // Clone the block.\n    const json = /** @type {!blocks.State} */ (blocks.save(oldBlock));\n    // Normallly this resizes leading to weird jumps. Save it for terminateDrag.\n    targetWorkspace.setResizesEnabled(false);\n    const block =\n        /** @type {!BlockSvg} */ (blocks.append(json, targetWorkspace));\n\n    this.positionNewBlock_(oldBlock, block);\n\n    return block;\n  }\n\n  /**\n   * Positions a block on the target workspace.\n   * @param {!BlockSvg} oldBlock The flyout block being copied.\n   * @param {!BlockSvg} block The block to posiiton.\n   * @private\n   */\n  positionNewBlock_(oldBlock, block) {\n    const targetWorkspace = this.targetWorkspace;\n\n    // The offset in pixels between the main workspace's origin and the upper\n    // left corner of the injection div.\n    const mainOffsetPixels = targetWorkspace.getOriginOffsetInPixels();\n\n    // The offset in pixels between the flyout workspace's origin and the upper\n    // left corner of the injection div.\n    const flyoutOffsetPixels = this.workspace_.getOriginOffsetInPixels();\n\n    // The position of the old block in flyout workspace coordinates.\n    const oldBlockPos = oldBlock.getRelativeToSurfaceXY();\n    // The position of the old block in pixels relative to the flyout\n    // workspace's origin.\n    oldBlockPos.scale(this.workspace_.scale);\n\n    // The position of the old block in pixels relative to the upper left corner\n    // of the injection div.\n    const oldBlockOffsetPixels =\n        Coordinate.sum(flyoutOffsetPixels, oldBlockPos);\n\n    // The position of the old block in pixels relative to the origin of the\n    // main workspace.\n    const finalOffset =\n        Coordinate.difference(oldBlockOffsetPixels, mainOffsetPixels);\n    // The position of the old block in main workspace coordinates.\n    finalOffset.scale(1 / targetWorkspace.scale);\n\n    block.moveTo(new Coordinate(finalOffset.x, finalOffset.y));\n  }\n}\n\n/**\n * Returns the bounding rectangle of the drag target area in pixel units\n * relative to viewport.\n * @return {Rect} The component's bounding box.\n */\nFlyout.prototype.getClientRect;\n\n/**\n * Position the flyout.\n * @return {void}\n */\nFlyout.prototype.position;\n\n/**\n * Determine if a drag delta is toward the workspace, based on the position\n * and orientation of the flyout. This is used in determineDragIntention_ to\n * determine if a new block should be created or if the flyout should scroll.\n * @param {!Coordinate} currentDragDeltaXY How far the pointer has\n *     moved from the position at mouse down, in pixel units.\n * @return {boolean} True if the drag is toward the workspace.\n * @package\n */\nFlyout.prototype.isDragTowardWorkspace;\n\n/**\n * Sets the translation of the flyout to match the scrollbars.\n * @param {!{x:number,y:number}} xyRatio Contains a y property which is a float\n *     between 0 and 1 specifying the degree of scrolling and a\n *     similar x property.\n * @protected\n */\nFlyout.prototype.setMetrics_;\n\n/**\n * Lay out the blocks in the flyout.\n * @param {!Array<!Object>} contents The blocks and buttons to lay out.\n * @param {!Array<number>} gaps The visible gaps between blocks.\n * @protected\n */\nFlyout.prototype.layout_;\n\n/**\n * Scroll the flyout.\n * @param {!Event} e Mouse wheel scroll event.\n * @protected\n */\nFlyout.prototype.wheel_;\n\n/**\n * Compute height of flyout.  Position mat under each block.\n * For RTL: Lay out the blocks right-aligned.\n * @return {void}\n * @protected\n */\nFlyout.prototype.reflowInternal_;\n\n/**\n * Calculates the x coordinate for the flyout position.\n * @return {number} X coordinate.\n */\nFlyout.prototype.getX;\n\n/**\n * Calculates the y coordinate for the flyout position.\n * @return {number} Y coordinate.\n */\nFlyout.prototype.getY;\n\nexports.Flyout = Flyout;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/flyout_base.js?")},
"./core/flyout_button.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/css.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/utils/style.js\");\n__webpack_require__(\"./core/utils/parsing.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class for a button in the flyout.\n */\n\n\n/**\n * Class for a button in the flyout.\n * @class\n */\ngoog.module('Blockly.FlyoutButton');\n\nconst Css = goog.require('Blockly.Css');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst dom = goog.require('Blockly.utils.dom');\nconst style = goog.require('Blockly.utils.style');\n/* eslint-disable-next-line no-unused-vars */\nconst toolbox = goog.requireType('Blockly.utils.toolbox');\nconst parsing = goog.require('Blockly.utils.parsing');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * Class for a button or label in the flyout.\n * @alias Blockly.FlyoutButton\n */\nclass FlyoutButton {\n  /**\n   * @param {!WorkspaceSvg} workspace The workspace in which to place this\n   *     button.\n   * @param {!WorkspaceSvg} targetWorkspace The flyout's target workspace.\n   * @param {!toolbox.ButtonOrLabelInfo} json\n   *    The JSON specifying the label/button.\n   * @param {boolean} isLabel Whether this button should be styled as a label.\n   * @package\n   */\n  constructor(workspace, targetWorkspace, json, isLabel) {\n    /**\n     * @type {!WorkspaceSvg}\n     * @private\n     */\n    this.workspace_ = workspace;\n\n    /**\n     * @type {!WorkspaceSvg}\n     * @private\n     */\n    this.targetWorkspace_ = targetWorkspace;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.text_ = json['text'];\n\n    /**\n     * @type {!Coordinate}\n     * @private\n     */\n    this.position_ = new Coordinate(0, 0);\n\n    /**\n     * Whether this button should be styled as a label.\n     * Labels behave the same as buttons, but are styled differently.\n     * @type {boolean}\n     * @private\n     */\n    this.isLabel_ = isLabel;\n\n    /**\n     * The key to the function called when this button is clicked.\n     * @type {string}\n     * @private\n     */\n    this.callbackKey_ = json['callbackKey'] ||\n        /* Check the lower case version too to satisfy IE */\n        json['callbackkey'];\n\n    /**\n     * If specified, a CSS class to add to this button.\n     * @type {?string}\n     * @private\n     */\n    this.cssClass_ = json['web-class'] || null;\n\n    /**\n     * Mouse up event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onMouseUpWrapper_ = null;\n\n    /**\n     * The JSON specifying the label / button.\n     * @type {!toolbox.ButtonOrLabelInfo}\n     */\n    this.info = json;\n\n    /**\n     * The width of the button's rect.\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     * The height of the button's rect.\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * The root SVG group for the button or label.\n     * @type {?SVGGElement}\n     * @private\n     */\n    this.svgGroup_ = null;\n\n    /**\n     * The SVG element with the text of the label or button.\n     * @type {?SVGTextElement}\n     * @private\n     */\n    this.svgText_ = null;\n  }\n\n  /**\n   * Create the button elements.\n   * @return {!SVGElement} The button's SVG group.\n   */\n  createDom() {\n    let cssClass = this.isLabel_ ? 'blocklyFlyoutLabel' : 'blocklyFlyoutButton';\n    if (this.cssClass_) {\n      cssClass += ' ' + this.cssClass_;\n    }\n\n    this.svgGroup_ = dom.createSvgElement(\n        Svg.G, {'class': cssClass}, this.workspace_.getCanvas());\n\n    let shadow;\n    if (!this.isLabel_) {\n      // Shadow rectangle (light source does not mirror in RTL).\n      shadow = dom.createSvgElement(\n          Svg.RECT, {\n            'class': 'blocklyFlyoutButtonShadow',\n            'rx': 4,\n            'ry': 4,\n            'x': 1,\n            'y': 1,\n          },\n          this.svgGroup_);\n    }\n    // Background rectangle.\n    const rect = dom.createSvgElement(\n        Svg.RECT, {\n          'class': this.isLabel_ ? 'blocklyFlyoutLabelBackground' :\n                                   'blocklyFlyoutButtonBackground',\n          'rx': 4,\n          'ry': 4,\n        },\n        this.svgGroup_);\n\n    const svgText = dom.createSvgElement(\n        Svg.TEXT, {\n          'class': this.isLabel_ ? 'blocklyFlyoutLabelText' : 'blocklyText',\n          'x': 0,\n          'y': 0,\n          'text-anchor': 'middle',\n        },\n        this.svgGroup_);\n    let text = parsing.replaceMessageReferences(this.text_);\n    if (this.workspace_.RTL) {\n      // Force text to be RTL by adding an RLM.\n      text += '\\u200F';\n    }\n    svgText.textContent = text;\n    if (this.isLabel_) {\n      this.svgText_ = svgText;\n      this.workspace_.getThemeManager().subscribe(\n          this.svgText_, 'flyoutForegroundColour', 'fill');\n    }\n\n    const fontSize = style.getComputedStyle(svgText, 'fontSize');\n    const fontWeight = style.getComputedStyle(svgText, 'fontWeight');\n    const fontFamily = style.getComputedStyle(svgText, 'fontFamily');\n    this.width = dom.getFastTextWidthWithSizeString(\n        svgText, fontSize, fontWeight, fontFamily);\n    const fontMetrics =\n        dom.measureFontMetrics(text, fontSize, fontWeight, fontFamily);\n    this.height = fontMetrics.height;\n\n    if (!this.isLabel_) {\n      this.width += 2 * FlyoutButton.TEXT_MARGIN_X;\n      this.height += 2 * FlyoutButton.TEXT_MARGIN_Y;\n      shadow.setAttribute('width', this.width);\n      shadow.setAttribute('height', this.height);\n    }\n    rect.setAttribute('width', this.width);\n    rect.setAttribute('height', this.height);\n\n    svgText.setAttribute('x', this.width / 2);\n    svgText.setAttribute(\n        'y', this.height / 2 - fontMetrics.height / 2 + fontMetrics.baseline);\n\n    this.updateTransform_();\n\n    this.onMouseUpWrapper_ = browserEvents.conditionalBind(\n        this.svgGroup_, 'mouseup', this, this.onMouseUp_);\n    return this.svgGroup_;\n  }\n\n  /**\n   * Correctly position the flyout button and make it visible.\n   */\n  show() {\n    this.updateTransform_();\n    this.svgGroup_.setAttribute('display', 'block');\n  }\n\n  /**\n   * Update SVG attributes to match internal state.\n   * @private\n   */\n  updateTransform_() {\n    this.svgGroup_.setAttribute(\n        'transform',\n        'translate(' + this.position_.x + ',' + this.position_.y + ')');\n  }\n\n  /**\n   * Move the button to the given x, y coordinates.\n   * @param {number} x The new x coordinate.\n   * @param {number} y The new y coordinate.\n   */\n  moveTo(x, y) {\n    this.position_.x = x;\n    this.position_.y = y;\n    this.updateTransform_();\n  }\n\n  /**\n   * @return {boolean} Whether or not the button is a label.\n   */\n  isLabel() {\n    return this.isLabel_;\n  }\n\n  /**\n   * Location of the button.\n   * @return {!Coordinate} x, y coordinates.\n   * @package\n   */\n  getPosition() {\n    return this.position_;\n  }\n\n  /**\n   * @return {string} Text of the button.\n   */\n  getButtonText() {\n    return this.text_;\n  }\n\n  /**\n   * Get the button's target workspace.\n   * @return {!WorkspaceSvg} The target workspace of the flyout where this\n   *     button resides.\n   */\n  getTargetWorkspace() {\n    return this.targetWorkspace_;\n  }\n\n  /**\n   * Dispose of this button.\n   */\n  dispose() {\n    if (this.onMouseUpWrapper_) {\n      browserEvents.unbind(this.onMouseUpWrapper_);\n    }\n    if (this.svgGroup_) {\n      dom.removeNode(this.svgGroup_);\n    }\n    if (this.svgText_) {\n      this.workspace_.getThemeManager().unsubscribe(this.svgText_);\n    }\n  }\n\n  /**\n   * Do something when the button is clicked.\n   * @param {!Event} e Mouse up event.\n   * @private\n   */\n  onMouseUp_(e) {\n    const gesture = this.targetWorkspace_.getGesture(e);\n    if (gesture) {\n      gesture.cancel();\n    }\n\n    if (this.isLabel_ && this.callbackKey_) {\n      console.warn(\n          'Labels should not have callbacks. Label text: ' + this.text_);\n    } else if (\n        !this.isLabel_ &&\n        !(this.callbackKey_ &&\n          this.targetWorkspace_.getButtonCallback(this.callbackKey_))) {\n      console.warn('Buttons should have callbacks. Button text: ' + this.text_);\n    } else if (!this.isLabel_) {\n      this.targetWorkspace_.getButtonCallback(this.callbackKey_)(this);\n    }\n  }\n}\n\n/**\n * The horizontal margin around the text in the button.\n */\nFlyoutButton.TEXT_MARGIN_X = 5;\n\n/**\n * The vertical margin around the text in the button.\n */\nFlyoutButton.TEXT_MARGIN_Y = 2;\n\n/**\n * CSS for buttons and labels. See css.js for use.\n */\nCss.register(`\n.blocklyFlyoutButton {\n  fill: #888;\n  cursor: default;\n}\n\n.blocklyFlyoutButtonShadow {\n  fill: #666;\n}\n\n.blocklyFlyoutButton:hover {\n  fill: #aaa;\n}\n\n.blocklyFlyoutLabel {\n  cursor: default;\n}\n\n.blocklyFlyoutLabelBackground {\n  opacity: 0;\n}\n`);\n\nexports.FlyoutButton = FlyoutButton;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/flyout_button.js?")},
"./core/flyout_horizontal.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/widgetdiv.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/dropdowndiv.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/utils/toolbox.js\");\n__webpack_require__(\"./core/flyout_base.js\");\n__webpack_require__(\"./core/utils/rect.js\");\n__webpack_require__(\"./core/scrollbar.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Horizontal flyout tray containing blocks which may be created.\n */\n\n\n/**\n * Horizontal flyout tray containing blocks which may be created.\n * @class\n */\ngoog.module('Blockly.HorizontalFlyout');\n\nconst WidgetDiv = goog.require('Blockly.WidgetDiv');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst dropDownDiv = goog.require('Blockly.dropDownDiv');\nconst registry = goog.require('Blockly.registry');\nconst toolbox = goog.require('Blockly.utils.toolbox');\n/* eslint-disable-next-line no-unused-vars */\nconst {Coordinate} = goog.requireType('Blockly.utils.Coordinate');\nconst {Flyout} = goog.require('Blockly.Flyout');\n/* eslint-disable-next-line no-unused-vars */\nconst {Options} = goog.requireType('Blockly.Options');\nconst {Rect} = goog.require('Blockly.utils.Rect');\nconst {Scrollbar} = goog.require('Blockly.Scrollbar');\n\n\n/**\n * Class for a flyout.\n * @extends {Flyout}\n * @alias Blockly.HorizontalFlyout\n */\nclass HorizontalFlyout extends Flyout {\n  /**\n   * @param {!Options} workspaceOptions Dictionary of options for the\n   *     workspace.\n   */\n  constructor(workspaceOptions) {\n    super(workspaceOptions);\n    this.horizontalLayout = true;\n  }\n\n  /**\n   * Sets the translation of the flyout to match the scrollbars.\n   * @param {!{x:number,y:number}} xyRatio Contains a y property which is a\n   *     float between 0 and 1 specifying the degree of scrolling and a similar\n   *     x property.\n   * @protected\n   */\n  setMetrics_(xyRatio) {\n    if (!this.isVisible()) {\n      return;\n    }\n\n    const metricsManager = this.workspace_.getMetricsManager();\n    const scrollMetrics = metricsManager.getScrollMetrics();\n    const viewMetrics = metricsManager.getViewMetrics();\n    const absoluteMetrics = metricsManager.getAbsoluteMetrics();\n\n    if (typeof xyRatio.x === 'number') {\n      this.workspace_.scrollX =\n          -(scrollMetrics.left +\n            (scrollMetrics.width - viewMetrics.width) * xyRatio.x);\n    }\n\n    this.workspace_.translate(\n        this.workspace_.scrollX + absoluteMetrics.left,\n        this.workspace_.scrollY + absoluteMetrics.top);\n  }\n\n  /**\n   * Calculates the x coordinate for the flyout position.\n   * @return {number} X coordinate.\n   */\n  getX() {\n    // X is always 0 since this is a horizontal flyout.\n    return 0;\n  }\n\n  /**\n   * Calculates the y coordinate for the flyout position.\n   * @return {number} Y coordinate.\n   */\n  getY() {\n    if (!this.isVisible()) {\n      return 0;\n    }\n    const metricsManager = this.targetWorkspace.getMetricsManager();\n    const absoluteMetrics = metricsManager.getAbsoluteMetrics();\n    const viewMetrics = metricsManager.getViewMetrics();\n    const toolboxMetrics = metricsManager.getToolboxMetrics();\n\n    let y = 0;\n    const atTop = this.toolboxPosition_ === toolbox.Position.TOP;\n    // If this flyout is not the trashcan flyout (e.g. toolbox or mutator).\n    if (this.targetWorkspace.toolboxPosition === this.toolboxPosition_) {\n      // If there is a category toolbox.\n      if (this.targetWorkspace.getToolbox()) {\n        if (atTop) {\n          y = toolboxMetrics.height;\n        } else {\n          y = viewMetrics.height - this.height_;\n        }\n        // Simple (flyout-only) toolbox.\n      } else {\n        if (atTop) {\n          y = 0;\n        } else {\n          // The simple flyout does not cover the workspace.\n          y = viewMetrics.height;\n        }\n      }\n      // Trashcan flyout is opposite the main flyout.\n    } else {\n      if (atTop) {\n        y = 0;\n      } else {\n        // Because the anchor point of the flyout is on the top, but we want\n        // to align the bottom edge of the flyout with the bottom edge of the\n        // blocklyDiv, we calculate the full height of the div minus the height\n        // of the flyout.\n        y = viewMetrics.height + absoluteMetrics.top - this.height_;\n      }\n    }\n\n    return y;\n  }\n\n  /**\n   * Move the flyout to the edge of the workspace.\n   */\n  position() {\n    if (!this.isVisible() || !this.targetWorkspace.isVisible()) {\n      return;\n    }\n    const metricsManager = this.targetWorkspace.getMetricsManager();\n    const targetWorkspaceViewMetrics = metricsManager.getViewMetrics();\n\n    // Record the width for workspace metrics.\n    this.width_ = targetWorkspaceViewMetrics.width;\n\n    const edgeWidth = targetWorkspaceViewMetrics.width - 2 * this.CORNER_RADIUS;\n    const edgeHeight = this.height_ - this.CORNER_RADIUS;\n    this.setBackgroundPath_(edgeWidth, edgeHeight);\n\n    const x = this.getX();\n    const y = this.getY();\n\n    this.positionAt_(this.width_, this.height_, x, y);\n  }\n\n  /**\n   * Create and set the path for the visible boundaries of the flyout.\n   * @param {number} width The width of the flyout, not including the\n   *     rounded corners.\n   * @param {number} height The height of the flyout, not including\n   *     rounded corners.\n   * @private\n   */\n  setBackgroundPath_(width, height) {\n    const atTop = this.toolboxPosition_ === toolbox.Position.TOP;\n    // Start at top left.\n    const path = ['M 0,' + (atTop ? 0 : this.CORNER_RADIUS)];\n\n    if (atTop) {\n      // Top.\n      path.push('h', width + 2 * this.CORNER_RADIUS);\n      // Right.\n      path.push('v', height);\n      // Bottom.\n      path.push(\n          'a', this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1,\n          -this.CORNER_RADIUS, this.CORNER_RADIUS);\n      path.push('h', -width);\n      // Left.\n      path.push(\n          'a', this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1,\n          -this.CORNER_RADIUS, -this.CORNER_RADIUS);\n      path.push('z');\n    } else {\n      // Top.\n      path.push(\n          'a', this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1,\n          this.CORNER_RADIUS, -this.CORNER_RADIUS);\n      path.push('h', width);\n      // Right.\n      path.push(\n          'a', this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1,\n          this.CORNER_RADIUS, this.CORNER_RADIUS);\n      path.push('v', height);\n      // Bottom.\n      path.push('h', -width - 2 * this.CORNER_RADIUS);\n      // Left.\n      path.push('z');\n    }\n    this.svgBackground_.setAttribute('d', path.join(' '));\n  }\n\n  /**\n   * Scroll the flyout to the top.\n   */\n  scrollToStart() {\n    this.workspace_.scrollbar.setX(this.RTL ? Infinity : 0);\n  }\n\n  /**\n   * Scroll the flyout.\n   * @param {!Event} e Mouse wheel scroll event.\n   * @protected\n   */\n  wheel_(e) {\n    const scrollDelta = browserEvents.getScrollDeltaPixels(e);\n    const delta = scrollDelta.x || scrollDelta.y;\n\n    if (delta) {\n      const metricsManager = this.workspace_.getMetricsManager();\n      const scrollMetrics = metricsManager.getScrollMetrics();\n      const viewMetrics = metricsManager.getViewMetrics();\n\n      const pos = (viewMetrics.left - scrollMetrics.left) + delta;\n      this.workspace_.scrollbar.setX(pos);\n      // When the flyout moves from a wheel event, hide WidgetDiv and\n      // dropDownDiv.\n      WidgetDiv.hide();\n      dropDownDiv.hideWithoutAnimation();\n    }\n\n    // Don't scroll the page.\n    e.preventDefault();\n    // Don't propagate mousewheel event (zooming).\n    e.stopPropagation();\n  }\n\n  /**\n   * Lay out the blocks in the flyout.\n   * @param {!Array<!Object>} contents The blocks and buttons to lay out.\n   * @param {!Array<number>} gaps The visible gaps between blocks.\n   * @protected\n   */\n  layout_(contents, gaps) {\n    this.workspace_.scale = this.targetWorkspace.scale;\n    const margin = this.MARGIN;\n    let cursorX = margin + this.tabWidth_;\n    const cursorY = margin;\n    if (this.RTL) {\n      contents = contents.reverse();\n    }\n\n    for (let i = 0, item; (item = contents[i]); i++) {\n      if (item.type === 'block') {\n        const block = item.block;\n        const allBlocks = block.getDescendants(false);\n        for (let j = 0, child; (child = allBlocks[j]); j++) {\n          // Mark blocks as being inside a flyout.  This is used to detect and\n          // prevent the closure of the flyout if the user right-clicks on such\n          // a block.\n          child.isInFlyout = true;\n        }\n        block.render();\n        const root = block.getSvgRoot();\n        const blockHW = block.getHeightWidth();\n\n        // Figure out where to place the block.\n        const tab = block.outputConnection ? this.tabWidth_ : 0;\n        let moveX;\n        if (this.RTL) {\n          moveX = cursorX + blockHW.width;\n        } else {\n          moveX = cursorX - tab;\n        }\n        block.moveBy(moveX, cursorY);\n\n        const rect = this.createRect_(block, moveX, cursorY, blockHW, i);\n        cursorX += (blockHW.width + gaps[i]);\n\n        this.addBlockListeners_(root, block, rect);\n      } else if (item.type === 'button') {\n        this.initFlyoutButton_(item.button, cursorX, cursorY);\n        cursorX += (item.button.width + gaps[i]);\n      }\n    }\n  }\n\n  /**\n   * Determine if a drag delta is toward the workspace, based on the position\n   * and orientation of the flyout. This is used in determineDragIntention_ to\n   * determine if a new block should be created or if the flyout should scroll.\n   * @param {!Coordinate} currentDragDeltaXY How far the pointer has\n   *     moved from the position at mouse down, in pixel units.\n   * @return {boolean} True if the drag is toward the workspace.\n   * @package\n   */\n  isDragTowardWorkspace(currentDragDeltaXY) {\n    const dx = currentDragDeltaXY.x;\n    const dy = currentDragDeltaXY.y;\n    // Direction goes from -180 to 180, with 0 toward the right and 90 on top.\n    const dragDirection = Math.atan2(dy, dx) / Math.PI * 180;\n\n    const range = this.dragAngleRange_;\n    // Check for up or down dragging.\n    if ((dragDirection < 90 + range && dragDirection > 90 - range) ||\n        (dragDirection > -90 - range && dragDirection < -90 + range)) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Returns the bounding rectangle of the drag target area in pixel units\n   * relative to viewport.\n   * @return {?Rect} The component's bounding box. Null if drag\n   *   target area should be ignored.\n   */\n  getClientRect() {\n    if (!this.svgGroup_ || this.autoClose || !this.isVisible()) {\n      // The bounding rectangle won't compute correctly if the flyout is closed\n      // and auto-close flyouts aren't valid drag targets (or delete areas).\n      return null;\n    }\n\n    const flyoutRect = this.svgGroup_.getBoundingClientRect();\n    // BIG_NUM is offscreen padding so that blocks dragged beyond the shown\n    // flyout area are still deleted.  Must be larger than the largest screen\n    // size, but be smaller than half Number.MAX_SAFE_INTEGER (not available on\n    // IE).\n    const BIG_NUM = 1000000000;\n    const top = flyoutRect.top;\n\n    if (this.toolboxPosition_ === toolbox.Position.TOP) {\n      const height = flyoutRect.height;\n      return new Rect(-BIG_NUM, top + height, -BIG_NUM, BIG_NUM);\n    } else {  // Bottom.\n      return new Rect(top, BIG_NUM, -BIG_NUM, BIG_NUM);\n    }\n  }\n\n  /**\n   * Compute height of flyout.  toolbox.Position mat under each block.\n   * For RTL: Lay out the blocks right-aligned.\n   * @protected\n   */\n  reflowInternal_() {\n    this.workspace_.scale = this.getFlyoutScale();\n    let flyoutHeight = 0;\n    const blocks = this.workspace_.getTopBlocks(false);\n    for (let i = 0, block; (block = blocks[i]); i++) {\n      flyoutHeight = Math.max(flyoutHeight, block.getHeightWidth().height);\n    }\n    const buttons = this.buttons_;\n    for (let i = 0, button; (button = buttons[i]); i++) {\n      flyoutHeight = Math.max(flyoutHeight, button.height);\n    }\n    flyoutHeight += this.MARGIN * 1.5;\n    flyoutHeight *= this.workspace_.scale;\n    flyoutHeight += Scrollbar.scrollbarThickness;\n\n    if (this.height_ !== flyoutHeight) {\n      for (let i = 0, block; (block = blocks[i]); i++) {\n        if (this.rectMap_.has(block)) {\n          this.moveRectToBlock_(this.rectMap_.get(block), block);\n        }\n      }\n\n      if (this.targetWorkspace.toolboxPosition === this.toolboxPosition_ &&\n          this.toolboxPosition_ === toolbox.Position.TOP &&\n          !this.targetWorkspace.getToolbox()) {\n        // This flyout is a simple toolbox. Reposition the workspace so that\n        // (0,0) is in the correct position relative to the new absolute edge\n        // (ie toolbox edge).\n        this.targetWorkspace.translate(\n            this.targetWorkspace.scrollX,\n            this.targetWorkspace.scrollY + flyoutHeight);\n      }\n\n      // Record the height for workspace metrics and .position.\n      this.height_ = flyoutHeight;\n      this.position();\n      this.targetWorkspace.recordDragTargets();\n    }\n  }\n}\n\nregistry.register(\n    registry.Type.FLYOUTS_HORIZONTAL_TOOLBOX, registry.DEFAULT,\n    HorizontalFlyout);\n\nexports.HorizontalFlyout = HorizontalFlyout;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/flyout_horizontal.js?")},
"./core/flyout_metrics_manager.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/metrics_manager.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Calculates and reports flyout workspace metrics.\n */\n\n\n/**\n * Calculates and reports flyout workspace metrics.\n * @class\n */\ngoog.module('Blockly.FlyoutMetricsManager');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {IFlyout} = goog.requireType('Blockly.IFlyout');\nconst {MetricsManager} = goog.require('Blockly.MetricsManager');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * Calculates metrics for a flyout's workspace.\n * The metrics are mainly used to size scrollbars for the flyout.\n * @extends {MetricsManager}\n * @alias Blockly.FlyoutMetricsManager\n */\nclass FlyoutMetricsManager extends MetricsManager {\n  /**\n   * @param {!WorkspaceSvg} workspace The flyout's workspace.\n   * @param {!IFlyout} flyout The flyout.\n   */\n  constructor(workspace, flyout) {\n    super(workspace);\n\n    /**\n     * The flyout that owns the workspace to calculate metrics for.\n     * @type {!IFlyout}\n     * @protected\n     */\n    this.flyout_ = flyout;\n  }\n\n  /**\n   * Gets the bounding box of the blocks on the flyout's workspace.\n   * This is in workspace coordinates.\n   * @return {!SVGRect|{height: number, y: number, width: number, x: number}}\n   *     The bounding box of the blocks on the workspace.\n   * @private\n   */\n  getBoundingBox_() {\n    let blockBoundingBox;\n    try {\n      blockBoundingBox = this.workspace_.getCanvas().getBBox();\n    } catch (e) {\n      // Firefox has trouble with hidden elements (Bug 528969).\n      // 2021 Update: It looks like this was fixed around Firefox 77 released in\n      // 2020.\n      blockBoundingBox = {height: 0, y: 0, width: 0, x: 0};\n    }\n    return blockBoundingBox;\n  }\n\n  /**\n   * @override\n   */\n  getContentMetrics(opt_getWorkspaceCoordinates) {\n    // The bounding box is in workspace coordinates.\n    const blockBoundingBox = this.getBoundingBox_();\n    const scale = opt_getWorkspaceCoordinates ? 1 : this.workspace_.scale;\n\n    return {\n      height: blockBoundingBox.height * scale,\n      width: blockBoundingBox.width * scale,\n      top: blockBoundingBox.y * scale,\n      left: blockBoundingBox.x * scale,\n    };\n  }\n\n  /**\n   * @override\n   */\n  getScrollMetrics(\n      opt_getWorkspaceCoordinates, opt_viewMetrics, opt_contentMetrics) {\n    const contentMetrics = opt_contentMetrics || this.getContentMetrics();\n    const margin = this.flyout_.MARGIN * this.workspace_.scale;\n    const scale = opt_getWorkspaceCoordinates ? this.workspace_.scale : 1;\n\n    // The left padding isn't just the margin. Some blocks are also offset by\n    // tabWidth so that value and statement blocks line up.\n    // The contentMetrics.left value is equivalent to the variable left padding.\n    const leftPadding = contentMetrics.left;\n\n    return {\n      height: (contentMetrics.height + 2 * margin) / scale,\n      width: (contentMetrics.width + leftPadding + margin) / scale,\n      top: 0,\n      left: 0,\n    };\n  }\n}\n\nexports.FlyoutMetricsManager = FlyoutMetricsManager;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/flyout_metrics_manager.js?")},
"./core/flyout_vertical.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/widgetdiv.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/dropdowndiv.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/utils/toolbox.js\");\n__webpack_require__(\"./core/flyout_base.js\");\n__webpack_require__(\"./core/utils/rect.js\");\n__webpack_require__(\"./core/scrollbar.js\");\n__webpack_require__(\"./core/block.js\");\n__webpack_require__(\"./core/constants.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Layout code for a vertical variant of the flyout.\n */\n\n\n/**\n * Layout code for a vertical variant of the flyout.\n * @class\n */\ngoog.module('Blockly.VerticalFlyout');\n\nconst WidgetDiv = goog.require('Blockly.WidgetDiv');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst dropDownDiv = goog.require('Blockly.dropDownDiv');\nconst registry = goog.require('Blockly.registry');\nconst toolbox = goog.require('Blockly.utils.toolbox');\n/* eslint-disable-next-line no-unused-vars */\nconst {Coordinate} = goog.requireType('Blockly.utils.Coordinate');\nconst {Flyout} = goog.require('Blockly.Flyout');\n/* eslint-disable-next-line no-unused-vars */\nconst {Options} = goog.requireType('Blockly.Options');\nconst {Rect} = goog.require('Blockly.utils.Rect');\nconst {Scrollbar} = goog.require('Blockly.Scrollbar');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Block');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.constants');\n\n\n/**\n * Class for a flyout.\n * @extends {Flyout}\n * @alias Blockly.VerticalFlyout\n */\nclass VerticalFlyout extends Flyout {\n  /**\n   * @param {!Options} workspaceOptions Dictionary of options for the\n   *     workspace.\n   */\n  constructor(workspaceOptions) {\n    super(workspaceOptions);\n  }\n\n  /**\n   * Sets the translation of the flyout to match the scrollbars.\n   * @param {!{x:number,y:number}} xyRatio Contains a y property which is a\n   *     float between 0 and 1 specifying the degree of scrolling and a similar\n   *     x property.\n   * @protected\n   */\n  setMetrics_(xyRatio) {\n    if (!this.isVisible()) {\n      return;\n    }\n    const metricsManager = this.workspace_.getMetricsManager();\n    const scrollMetrics = metricsManager.getScrollMetrics();\n    const viewMetrics = metricsManager.getViewMetrics();\n    const absoluteMetrics = metricsManager.getAbsoluteMetrics();\n\n    if (typeof xyRatio.y === 'number') {\n      this.workspace_.scrollY =\n          -(scrollMetrics.top +\n            (scrollMetrics.height - viewMetrics.height) * xyRatio.y);\n    }\n    this.workspace_.translate(\n        this.workspace_.scrollX + absoluteMetrics.left,\n        this.workspace_.scrollY + absoluteMetrics.top);\n  }\n\n  /**\n   * Calculates the x coordinate for the flyout position.\n   * @return {number} X coordinate.\n   */\n  getX() {\n    if (!this.isVisible()) {\n      return 0;\n    }\n    const metricsManager = this.targetWorkspace.getMetricsManager();\n    const absoluteMetrics = metricsManager.getAbsoluteMetrics();\n    const viewMetrics = metricsManager.getViewMetrics();\n    const toolboxMetrics = metricsManager.getToolboxMetrics();\n    let x = 0;\n\n    // If this flyout is not the trashcan flyout (e.g. toolbox or mutator).\n    if (this.targetWorkspace.toolboxPosition === this.toolboxPosition_) {\n      // If there is a category toolbox.\n      if (this.targetWorkspace.getToolbox()) {\n        if (this.toolboxPosition_ === toolbox.Position.LEFT) {\n          x = toolboxMetrics.width;\n        } else {\n          x = viewMetrics.width - this.width_;\n        }\n        // Simple (flyout-only) toolbox.\n      } else {\n        if (this.toolboxPosition_ === toolbox.Position.LEFT) {\n          x = 0;\n        } else {\n          // The simple flyout does not cover the workspace.\n          x = viewMetrics.width;\n        }\n      }\n      // Trashcan flyout is opposite the main flyout.\n    } else {\n      if (this.toolboxPosition_ === toolbox.Position.LEFT) {\n        x = 0;\n      } else {\n        // Because the anchor point of the flyout is on the left, but we want\n        // to align the right edge of the flyout with the right edge of the\n        // blocklyDiv, we calculate the full width of the div minus the width\n        // of the flyout.\n        x = viewMetrics.width + absoluteMetrics.left - this.width_;\n      }\n    }\n\n    return x;\n  }\n\n  /**\n   * Calculates the y coordinate for the flyout position.\n   * @return {number} Y coordinate.\n   */\n  getY() {\n    // Y is always 0 since this is a vertical flyout.\n    return 0;\n  }\n\n  /**\n   * Move the flyout to the edge of the workspace.\n   */\n  position() {\n    if (!this.isVisible() || !this.targetWorkspace.isVisible()) {\n      return;\n    }\n    const metricsManager = this.targetWorkspace.getMetricsManager();\n    const targetWorkspaceViewMetrics = metricsManager.getViewMetrics();\n\n    // Record the height for workspace metrics.\n    this.height_ = targetWorkspaceViewMetrics.height;\n\n    const edgeWidth = this.width_ - this.CORNER_RADIUS;\n    const edgeHeight =\n        targetWorkspaceViewMetrics.height - 2 * this.CORNER_RADIUS;\n    this.setBackgroundPath_(edgeWidth, edgeHeight);\n\n    const x = this.getX();\n    const y = this.getY();\n\n    this.positionAt_(this.width_, this.height_, x, y);\n  }\n\n  /**\n   * Create and set the path for the visible boundaries of the flyout.\n   * @param {number} width The width of the flyout, not including the\n   *     rounded corners.\n   * @param {number} height The height of the flyout, not including\n   *     rounded corners.\n   * @private\n   */\n  setBackgroundPath_(width, height) {\n    const atRight = this.toolboxPosition_ === toolbox.Position.RIGHT;\n    const totalWidth = width + this.CORNER_RADIUS;\n\n    // Decide whether to start on the left or right.\n    const path = ['M ' + (atRight ? totalWidth : 0) + ',0'];\n    // Top.\n    path.push('h', atRight ? -width : width);\n    // Rounded corner.\n    path.push(\n        'a', this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, atRight ? 0 : 1,\n        atRight ? -this.CORNER_RADIUS : this.CORNER_RADIUS, this.CORNER_RADIUS);\n    // Side closest to workspace.\n    path.push('v', Math.max(0, height));\n    // Rounded corner.\n    path.push(\n        'a', this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, atRight ? 0 : 1,\n        atRight ? this.CORNER_RADIUS : -this.CORNER_RADIUS, this.CORNER_RADIUS);\n    // Bottom.\n    path.push('h', atRight ? width : -width);\n    path.push('z');\n    this.svgBackground_.setAttribute('d', path.join(' '));\n  }\n\n  /**\n   * Scroll the flyout to the top.\n   */\n  scrollToStart() {\n    this.workspace_.scrollbar.setY(0);\n  }\n\n  /**\n   * Scroll the flyout.\n   * @param {!Event} e Mouse wheel scroll event.\n   * @protected\n   */\n  wheel_(e) {\n    const scrollDelta = browserEvents.getScrollDeltaPixels(e);\n\n    if (scrollDelta.y) {\n      const metricsManager = this.workspace_.getMetricsManager();\n      const scrollMetrics = metricsManager.getScrollMetrics();\n      const viewMetrics = metricsManager.getViewMetrics();\n      const pos = (viewMetrics.top - scrollMetrics.top) + scrollDelta.y;\n\n      this.workspace_.scrollbar.setY(pos);\n      // When the flyout moves from a wheel event, hide WidgetDiv and\n      // dropDownDiv.\n      WidgetDiv.hide();\n      dropDownDiv.hideWithoutAnimation();\n    }\n\n    // Don't scroll the page.\n    e.preventDefault();\n    // Don't propagate mousewheel event (zooming).\n    e.stopPropagation();\n  }\n\n  /**\n   * Lay out the blocks in the flyout.\n   * @param {!Array<!Object>} contents The blocks and buttons to lay out.\n   * @param {!Array<number>} gaps The visible gaps between blocks.\n   * @protected\n   */\n  layout_(contents, gaps) {\n    this.workspace_.scale = this.targetWorkspace.scale;\n    const margin = this.MARGIN;\n    const cursorX = this.RTL ? margin : margin + this.tabWidth_;\n    let cursorY = margin;\n\n    for (let i = 0, item; (item = contents[i]); i++) {\n      if (item.type === 'block') {\n        const block = item.block;\n        const allBlocks = block.getDescendants(false);\n        for (let j = 0, child; (child = allBlocks[j]); j++) {\n          // Mark blocks as being inside a flyout.  This is used to detect and\n          // prevent the closure of the flyout if the user right-clicks on such\n          // a block.\n          child.isInFlyout = true;\n        }\n        block.render();\n        const root = block.getSvgRoot();\n        const blockHW = block.getHeightWidth();\n        const moveX =\n            block.outputConnection ? cursorX - this.tabWidth_ : cursorX;\n        block.moveBy(moveX, cursorY);\n\n        const rect = this.createRect_(\n            block, this.RTL ? moveX - blockHW.width : moveX, cursorY, blockHW,\n            i);\n\n        this.addBlockListeners_(root, block, rect);\n\n        cursorY += blockHW.height + gaps[i];\n      } else if (item.type === 'button') {\n        this.initFlyoutButton_(item.button, cursorX, cursorY);\n        cursorY += item.button.height + gaps[i];\n      }\n    }\n  }\n\n  /**\n   * Determine if a drag delta is toward the workspace, based on the position\n   * and orientation of the flyout. This is used in determineDragIntention_ to\n   * determine if a new block should be created or if the flyout should scroll.\n   * @param {!Coordinate} currentDragDeltaXY How far the pointer has\n   *     moved from the position at mouse down, in pixel units.\n   * @return {boolean} True if the drag is toward the workspace.\n   * @package\n   */\n  isDragTowardWorkspace(currentDragDeltaXY) {\n    const dx = currentDragDeltaXY.x;\n    const dy = currentDragDeltaXY.y;\n    // Direction goes from -180 to 180, with 0 toward the right and 90 on top.\n    const dragDirection = Math.atan2(dy, dx) / Math.PI * 180;\n\n    const range = this.dragAngleRange_;\n    // Check for left or right dragging.\n    if ((dragDirection < range && dragDirection > -range) ||\n        (dragDirection < -180 + range || dragDirection > 180 - range)) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Returns the bounding rectangle of the drag target area in pixel units\n   * relative to viewport.\n   * @return {?Rect} The component's bounding box. Null if drag\n   *   target area should be ignored.\n   */\n  getClientRect() {\n    if (!this.svgGroup_ || this.autoClose || !this.isVisible()) {\n      // The bounding rectangle won't compute correctly if the flyout is closed\n      // and auto-close flyouts aren't valid drag targets (or delete areas).\n      return null;\n    }\n\n    const flyoutRect = this.svgGroup_.getBoundingClientRect();\n    // BIG_NUM is offscreen padding so that blocks dragged beyond the shown\n    // flyout area are still deleted.  Must be larger than the largest screen\n    // size, but be smaller than half Number.MAX_SAFE_INTEGER (not available on\n    // IE).\n    const BIG_NUM = 1000000000;\n    const left = flyoutRect.left;\n\n    if (this.toolboxPosition_ === toolbox.Position.LEFT) {\n      const width = flyoutRect.width;\n      return new Rect(-BIG_NUM, BIG_NUM, -BIG_NUM, left + width);\n    } else {  // Right\n      return new Rect(-BIG_NUM, BIG_NUM, left, BIG_NUM);\n    }\n  }\n\n  /**\n   * Compute width of flyout.  toolbox.Position mat under each block.\n   * For RTL: Lay out the blocks and buttons to be right-aligned.\n   * @protected\n   */\n  reflowInternal_() {\n    this.workspace_.scale = this.getFlyoutScale();\n    let flyoutWidth = 0;\n    const blocks = this.workspace_.getTopBlocks(false);\n    for (let i = 0, block; (block = blocks[i]); i++) {\n      let width = block.getHeightWidth().width;\n      if (block.outputConnection) {\n        width -= this.tabWidth_;\n      }\n      flyoutWidth = Math.max(flyoutWidth, width);\n    }\n    for (let i = 0, button; (button = this.buttons_[i]); i++) {\n      flyoutWidth = Math.max(flyoutWidth, button.width);\n    }\n    flyoutWidth += this.MARGIN * 1.5 + this.tabWidth_;\n    flyoutWidth *= this.workspace_.scale;\n    flyoutWidth += Scrollbar.scrollbarThickness;\n\n    if (this.width_ !== flyoutWidth) {\n      for (let i = 0, block; (block = blocks[i]); i++) {\n        if (this.RTL) {\n          // With the flyoutWidth known, right-align the blocks.\n          const oldX = block.getRelativeToSurfaceXY().x;\n          let newX = flyoutWidth / this.workspace_.scale - this.MARGIN;\n          if (!block.outputConnection) {\n            newX -= this.tabWidth_;\n          }\n          block.moveBy(newX - oldX, 0);\n        }\n        if (this.rectMap_.has(block)) {\n          this.moveRectToBlock_(this.rectMap_.get(block), block);\n        }\n      }\n      if (this.RTL) {\n        // With the flyoutWidth known, right-align the buttons.\n        for (let i = 0, button; (button = this.buttons_[i]); i++) {\n          const y = button.getPosition().y;\n          const x = flyoutWidth / this.workspace_.scale - button.width -\n              this.MARGIN - this.tabWidth_;\n          button.moveTo(x, y);\n        }\n      }\n\n      if (this.targetWorkspace.toolboxPosition === this.toolboxPosition_ &&\n          this.toolboxPosition_ === toolbox.Position.LEFT &&\n          !this.targetWorkspace.getToolbox()) {\n        // This flyout is a simple toolbox. Reposition the workspace so that\n        // (0,0) is in the correct position relative to the new absolute edge\n        // (ie toolbox edge).\n        this.targetWorkspace.translate(\n            this.targetWorkspace.scrollX + flyoutWidth,\n            this.targetWorkspace.scrollY);\n      }\n\n      // Record the width for workspace metrics and .position.\n      this.width_ = flyoutWidth;\n      this.position();\n      this.targetWorkspace.recordDragTargets();\n    }\n  }\n}\n\n/**\n * The name of the vertical flyout in the registry.\n * @type {string}\n */\nVerticalFlyout.registryName = 'verticalFlyout';\n\nregistry.register(\n    registry.Type.FLYOUTS_VERTICAL_TOOLBOX, registry.DEFAULT, VerticalFlyout);\n\nexports.VerticalFlyout = VerticalFlyout;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/flyout_vertical.js?")},
"./core/generator.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/utils/deprecation.js\");\n__webpack_require__(\"./core/names.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility functions for generating executable code from\n * Blockly code.\n */\n\n\n/**\n * Utility functions for generating executable code from\n * Blockly code.\n * @class\n */\ngoog.module('Blockly.Generator');\n\nconst common = goog.require('Blockly.common');\nconst deprecation = goog.require('Blockly.utils.deprecation');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\n/* eslint-disable-next-line no-unused-vars */\nconst {Names, NameType} = goog.require('Blockly.Names');\n/* eslint-disable-next-line no-unused-vars */\nconst {Workspace} = goog.requireType('Blockly.Workspace');\n\n\n/**\n * Class for a code generator that translates the blocks into a language.\n * @unrestricted\n * @alias Blockly.Generator\n */\nclass Generator {\n  /**\n   * @param {string} name Language name of this generator.\n   */\n  constructor(name) {\n    this.name_ = name;\n\n    /**\n     * This is used as a placeholder in functions defined using\n     * Generator.provideFunction_.  It must not be legal code that could\n     * legitimately appear in a function definition (or comment), and it must\n     * not confuse the regular expression parser.\n     * @type {string}\n     * @protected\n     */\n    this.FUNCTION_NAME_PLACEHOLDER_ = '{leCUI8hutHZI4480Dc}';\n\n    this.FUNCTION_NAME_PLACEHOLDER_REGEXP_ =\n        new RegExp(this.FUNCTION_NAME_PLACEHOLDER_, 'g');\n\n    /**\n     * Arbitrary code to inject into locations that risk causing infinite loops.\n     * Any instances of '%1' will be replaced by the block ID that failed.\n     * E.g. '  checkTimeout(%1);\\n'\n     * @type {?string}\n     */\n    this.INFINITE_LOOP_TRAP = null;\n\n    /**\n     * Arbitrary code to inject before every statement.\n     * Any instances of '%1' will be replaced by the block ID of the statement.\n     * E.g. 'highlight(%1);\\n'\n     * @type {?string}\n     */\n    this.STATEMENT_PREFIX = null;\n\n    /**\n     * Arbitrary code to inject after every statement.\n     * Any instances of '%1' will be replaced by the block ID of the statement.\n     * E.g. 'highlight(%1);\\n'\n     * @type {?string}\n     */\n    this.STATEMENT_SUFFIX = null;\n\n    /**\n     * The method of indenting.  Defaults to two spaces, but language generators\n     * may override this to increase indent or change to tabs.\n     * @type {string}\n     */\n    this.INDENT = '  ';\n\n    /**\n     * Maximum length for a comment before wrapping.  Does not account for\n     * indenting level.\n     * @type {number}\n     */\n    this.COMMENT_WRAP = 60;\n\n    /**\n     * List of outer-inner pairings that do NOT require parentheses.\n     * @type {!Array<!Array<number>>}\n     */\n    this.ORDER_OVERRIDES = [];\n\n    /**\n     * Whether the init method has been called.\n     * Generators that set this flag to false after creation and true in init\n     * will cause blockToCode to emit a warning if the generator has not been\n     * initialized. If this flag is untouched, it will have no effect.\n     * @type {?boolean}\n     */\n    this.isInitialized = null;\n\n    /**\n     * Comma-separated list of reserved words.\n     * @type {string}\n     * @protected\n     */\n    this.RESERVED_WORDS_ = '';\n\n    /**\n     * A dictionary of definitions to be printed before the code.\n     * @type {!Object|undefined}\n     * @protected\n     */\n    this.definitions_ = undefined;\n\n    /**\n     * A dictionary mapping desired function names in definitions_ to actual\n     * function names (to avoid collisions with user functions).\n     * @type {!Object|undefined}\n     * @protected\n     */\n    this.functionNames_ = undefined;\n\n    /**\n     * A database of variable and procedure names.\n     * @type {!Names|undefined}\n     * @protected\n     */\n    this.nameDB_ = undefined;\n  }\n\n  /**\n   * Generate code for all blocks in the workspace to the specified language.\n   * @param {!Workspace=} workspace Workspace to generate code from.\n   * @return {string} Generated code.\n   */\n  workspaceToCode(workspace) {\n    if (!workspace) {\n      // Backwards compatibility from before there could be multiple workspaces.\n      console.warn(\n          'No workspace specified in workspaceToCode call.  Guessing.');\n      workspace = common.getMainWorkspace();\n    }\n    let code = [];\n    this.init(workspace);\n    const blocks = workspace.getTopBlocks(true);\n    for (let i = 0, block; (block = blocks[i]); i++) {\n      let line = this.blockToCode(block);\n      if (Array.isArray(line)) {\n        // Value blocks return tuples of code and operator order.\n        // Top-level blocks don't care about operator order.\n        line = line[0];\n      }\n      if (line) {\n        if (block.outputConnection) {\n          // This block is a naked value.  Ask the language's code generator if\n          // it wants to append a semicolon, or something.\n          line = this.scrubNakedValue(line);\n          if (this.STATEMENT_PREFIX && !block.suppressPrefixSuffix) {\n            line = this.injectId(this.STATEMENT_PREFIX, block) + line;\n          }\n          if (this.STATEMENT_SUFFIX && !block.suppressPrefixSuffix) {\n            line = line + this.injectId(this.STATEMENT_SUFFIX, block);\n          }\n        }\n        code.push(line);\n      }\n    }\n    code = code.join('\\n');  // Blank line between each section.\n    code = this.finish(code);\n    // Final scrubbing of whitespace.\n    code = code.replace(/^\\s+\\n/, '');\n    code = code.replace(/\\n\\s+$/, '\\n');\n    code = code.replace(/[ \\t]+\\n/g, '\\n');\n    return code;\n  }\n\n  // The following are some helpful functions which can be used by multiple\n\n  // languages.\n\n  /**\n   * Prepend a common prefix onto each line of code.\n   * Intended for indenting code or adding comment markers.\n   * @param {string} text The lines of code.\n   * @param {string} prefix The common prefix.\n   * @return {string} The prefixed lines of code.\n   */\n  prefixLines(text, prefix) {\n    return prefix + text.replace(/(?!\\n$)\\n/g, '\\n' + prefix);\n  }\n\n  /**\n   * Recursively spider a tree of blocks, returning all their comments.\n   * @param {!Block} block The block from which to start spidering.\n   * @return {string} Concatenated list of comments.\n   */\n  allNestedComments(block) {\n    const comments = [];\n    const blocks = block.getDescendants(true);\n    for (let i = 0; i < blocks.length; i++) {\n      const comment = blocks[i].getCommentText();\n      if (comment) {\n        comments.push(comment);\n      }\n    }\n    // Append an empty string to create a trailing line break when joined.\n    if (comments.length) {\n      comments.push('');\n    }\n    return comments.join('\\n');\n  }\n\n  /**\n   * Generate code for the specified block (and attached blocks).\n   * The generator must be initialized before calling this function.\n   * @param {?Block} block The block to generate code for.\n   * @param {boolean=} opt_thisOnly True to generate code for only this\n   *     statement.\n   * @return {string|!Array} For statement blocks, the generated code.\n   *     For value blocks, an array containing the generated code and an\n   *     operator order value.  Returns '' if block is null.\n   */\n  blockToCode(block, opt_thisOnly) {\n    if (this.isInitialized === false) {\n      console.warn(\n          'Generator init was not called before blockToCode was called.');\n    }\n    if (!block) {\n      return '';\n    }\n    if (!block.isEnabled()) {\n      // Skip past this block if it is disabled.\n      return opt_thisOnly ? '' : this.blockToCode(block.getNextBlock());\n    }\n    if (block.isInsertionMarker()) {\n      // Skip past insertion markers.\n      return opt_thisOnly ? '' : this.blockToCode(block.getChildren(false)[0]);\n    }\n\n    const func = this[block.type];\n    if (typeof func !== 'function') {\n      throw Error(\n          'Language \"' + this.name_ + '\" does not know how to generate ' +\n          'code for block type \"' + block.type + '\".');\n    }\n    // First argument to func.call is the value of 'this' in the generator.\n    // Prior to 24 September 2013 'this' was the only way to access the block.\n    // The current preferred method of accessing the block is through the second\n    // argument to func.call, which becomes the first parameter to the\n    // generator.\n    let code = func.call(block, block);\n    if (Array.isArray(code)) {\n      // Value blocks return tuples of code and operator order.\n      if (!block.outputConnection) {\n        throw TypeError('Expecting string from statement block: ' + block.type);\n      }\n      return [this.scrub_(block, code[0], opt_thisOnly), code[1]];\n    } else if (typeof code === 'string') {\n      if (this.STATEMENT_PREFIX && !block.suppressPrefixSuffix) {\n        code = this.injectId(this.STATEMENT_PREFIX, block) + code;\n      }\n      if (this.STATEMENT_SUFFIX && !block.suppressPrefixSuffix) {\n        code = code + this.injectId(this.STATEMENT_SUFFIX, block);\n      }\n      return this.scrub_(block, code, opt_thisOnly);\n    } else if (code === null) {\n      // Block has handled code generation itself.\n      return '';\n    }\n    throw SyntaxError('Invalid code generated: ' + code);\n  }\n\n  /**\n   * Generate code representing the specified value input.\n   * @param {!Block} block The block containing the input.\n   * @param {string} name The name of the input.\n   * @param {number} outerOrder The maximum binding strength (minimum order\n   *     value) of any operators adjacent to \"block\".\n   * @return {string} Generated code or '' if no blocks are connected or the\n   *     specified input does not exist.\n   */\n  valueToCode(block, name, outerOrder) {\n    if (isNaN(outerOrder)) {\n      throw TypeError('Expecting valid order from block: ' + block.type);\n    }\n    const targetBlock = block.getInputTargetBlock(name);\n    if (!targetBlock) {\n      return '';\n    }\n    const tuple = this.blockToCode(targetBlock);\n    if (tuple === '') {\n      // Disabled block.\n      return '';\n    }\n    // Value blocks must return code and order of operations info.\n    // Statement blocks must only return code.\n    if (!Array.isArray(tuple)) {\n      throw TypeError('Expecting tuple from value block: ' + targetBlock.type);\n    }\n    let code = tuple[0];\n    const innerOrder = tuple[1];\n    if (isNaN(innerOrder)) {\n      throw TypeError(\n          'Expecting valid order from value block: ' + targetBlock.type);\n    }\n    if (!code) {\n      return '';\n    }\n\n    // Add parentheses if needed.\n    let parensNeeded = false;\n    const outerOrderClass = Math.floor(outerOrder);\n    const innerOrderClass = Math.floor(innerOrder);\n    if (outerOrderClass <= innerOrderClass) {\n      if (outerOrderClass === innerOrderClass &&\n          (outerOrderClass === 0 || outerOrderClass === 99)) {\n        // Don't generate parens around NONE-NONE and ATOMIC-ATOMIC pairs.\n        // 0 is the atomic order, 99 is the none order.  No parentheses needed.\n        // In all known languages multiple such code blocks are not order\n        // sensitive.  In fact in Python ('a' 'b') 'c' would fail.\n      } else {\n        // The operators outside this code are stronger than the operators\n        // inside this code.  To prevent the code from being pulled apart,\n        // wrap the code in parentheses.\n        parensNeeded = true;\n        // Check for special exceptions.\n        for (let i = 0; i < this.ORDER_OVERRIDES.length; i++) {\n          if (this.ORDER_OVERRIDES[i][0] === outerOrder &&\n              this.ORDER_OVERRIDES[i][1] === innerOrder) {\n            parensNeeded = false;\n            break;\n          }\n        }\n      }\n    }\n    if (parensNeeded) {\n      // Technically, this should be handled on a language-by-language basis.\n      // However all known (sane) languages use parentheses for grouping.\n      code = '(' + code + ')';\n    }\n    return code;\n  }\n\n  /**\n   * Generate a code string representing the blocks attached to the named\n   * statement input. Indent the code.\n   * This is mainly used in generators. When trying to generate code to evaluate\n   * look at using workspaceToCode or blockToCode.\n   * @param {!Block} block The block containing the input.\n   * @param {string} name The name of the input.\n   * @return {string} Generated code or '' if no blocks are connected.\n   */\n  statementToCode(block, name) {\n    const targetBlock = block.getInputTargetBlock(name);\n    let code = this.blockToCode(targetBlock);\n    // Value blocks must return code and order of operations info.\n    // Statement blocks must only return code.\n    if (typeof code !== 'string') {\n      throw TypeError(\n          'Expecting code from statement block: ' +\n          (targetBlock && targetBlock.type));\n    }\n    if (code) {\n      code = this.prefixLines(/** @type {string} */ (code), this.INDENT);\n    }\n    return code;\n  }\n\n  /**\n   * Add an infinite loop trap to the contents of a loop.\n   * Add statement suffix at the start of the loop block (right after the loop\n   * statement executes), and a statement prefix to the end of the loop block\n   * (right before the loop statement executes).\n   * @param {string} branch Code for loop contents.\n   * @param {!Block} block Enclosing block.\n   * @return {string} Loop contents, with infinite loop trap added.\n   */\n  addLoopTrap(branch, block) {\n    if (this.INFINITE_LOOP_TRAP) {\n      branch = this.prefixLines(\n                   this.injectId(this.INFINITE_LOOP_TRAP, block), this.INDENT) +\n          branch;\n    }\n    if (this.STATEMENT_SUFFIX && !block.suppressPrefixSuffix) {\n      branch = this.prefixLines(\n                   this.injectId(this.STATEMENT_SUFFIX, block), this.INDENT) +\n          branch;\n    }\n    if (this.STATEMENT_PREFIX && !block.suppressPrefixSuffix) {\n      branch = branch +\n          this.prefixLines(\n              this.injectId(this.STATEMENT_PREFIX, block), this.INDENT);\n    }\n    return branch;\n  }\n\n  /**\n   * Inject a block ID into a message to replace '%1'.\n   * Used for STATEMENT_PREFIX, STATEMENT_SUFFIX, and INFINITE_LOOP_TRAP.\n   * @param {string} msg Code snippet with '%1'.\n   * @param {!Block} block Block which has an ID.\n   * @return {string} Code snippet with ID.\n   */\n  injectId(msg, block) {\n    const id = block.id.replace(/\\$/g, '$$$$');  // Issue 251.\n    return msg.replace(/%1/g, '\\'' + id + '\\'');\n  }\n\n  /**\n   * Add one or more words to the list of reserved words for this language.\n   * @param {string} words Comma-separated list of words to add to the list.\n   *     No spaces.  Duplicates are ok.\n   */\n  addReservedWords(words) {\n    this.RESERVED_WORDS_ += words + ',';\n  }\n\n  /**\n   * Define a developer-defined function (not a user-defined procedure) to be\n   * included in the generated code.  Used for creating private helper\n   * functions. The first time this is called with a given desiredName, the code\n   * is saved and an actual name is generated.  Subsequent calls with the same\n   * desiredName have no effect but have the same return value.\n   *\n   * It is up to the caller to make sure the same desiredName is not\n   * used for different helper functions (e.g. use \"colourRandom\" and\n   * \"listRandom\", not \"random\").  There is no danger of colliding with reserved\n   * words, or user-defined variable or procedure names.\n   *\n   * The code gets output when Generator.finish() is called.\n   *\n   * @param {string} desiredName The desired name of the function\n   *     (e.g. mathIsPrime).\n   * @param {!Array<string>|string} code A list of statements or one multi-line\n   *     code string.  Use '  ' for indents (they will be replaced).\n   * @return {string} The actual name of the new function.  This may differ\n   *     from desiredName if the former has already been taken by the user.\n   * @protected\n   */\n  provideFunction_(desiredName, code) {\n    if (!this.definitions_[desiredName]) {\n      const functionName =\n          this.nameDB_.getDistinctName(desiredName, NameType.PROCEDURE);\n      this.functionNames_[desiredName] = functionName;\n      if (Array.isArray(code)) {\n        code = code.join('\\n');\n      }\n      let codeText = code.trim().replace(\n          this.FUNCTION_NAME_PLACEHOLDER_REGEXP_, functionName);\n      // Change all '  ' indents into the desired indent.\n      // To avoid an infinite loop of replacements, change all indents to '\\0'\n      // character first, then replace them all with the indent.\n      // We are assuming that no provided functions contain a literal null char.\n      let oldCodeText;\n      while (oldCodeText !== codeText) {\n        oldCodeText = codeText;\n        codeText = codeText.replace(/^(( {2})*) {2}/gm, '$1\\0');\n      }\n      codeText = codeText.replace(/\\0/g, this.INDENT);\n      this.definitions_[desiredName] = codeText;\n    }\n    return this.functionNames_[desiredName];\n  }\n\n  /**\n   * Hook for code to run before code generation starts.\n   * Subclasses may override this, e.g. to initialise the database of variable\n   * names.\n   * @param {!Workspace} _workspace Workspace to generate code from.\n   */\n  init(_workspace) {\n    // Optionally override\n    // Create a dictionary of definitions to be printed before the code.\n    this.definitions_ = Object.create(null);\n    // Create a dictionary mapping desired developer-defined function names in\n    // definitions_ to actual function names (to avoid collisions with\n    // user-defined procedures).\n    this.functionNames_ = Object.create(null);\n  }\n\n  /**\n   * Common tasks for generating code from blocks.  This is called from\n   * blockToCode and is called on every block, not just top level blocks.\n   * Subclasses may override this, e.g. to generate code for statements\n   * following the block, or to handle comments for the specified block and any\n   * connected value blocks.\n   * @param {!Block} _block The current block.\n   * @param {string} code The code created for this block.\n   * @param {boolean=} _opt_thisOnly True to generate code for only this\n   *     statement.\n   * @return {string} Code with comments and subsequent blocks added.\n   * @protected\n   */\n  scrub_(_block, code, _opt_thisOnly) {\n    // Optionally override\n    return code;\n  }\n\n  /**\n   * Hook for code to run at end of code generation.\n   * Subclasses may override this, e.g. to prepend the generated code with\n   * import statements or variable definitions.\n   * @param {string} code Generated code.\n   * @return {string} Completed code.\n   */\n  finish(code) {\n    // Optionally override\n    // Clean up temporary data.\n    delete this.definitions_;\n    delete this.functionNames_;\n    return code;\n  }\n\n  /**\n   * Naked values are top-level blocks with outputs that aren't plugged into\n   * anything.\n   * Subclasses may override this, e.g. if their language does not allow\n   * naked values.\n   * @param {string} line Line of generated code.\n   * @return {string} Legal line of code.\n   */\n  scrubNakedValue(line) {\n    // Optionally override\n    return line;\n  }\n}\n\nObject.defineProperties(Generator.prototype, {\n  /**\n   * A database of variable names.\n   * @name Blockly.Generator.prototype.variableDB_\n   * @type {!Names|undefined}\n   * @protected\n   * @deprecated 'variableDB_' was renamed to 'nameDB_' (May 2021).\n   * @suppress {checkTypes}\n   */\n  variableDB_: {\n    /**\n     * @this {Generator}\n     * @return {!Names|undefined} Name database.\n     */\n    get: function() {\n      deprecation.warn('variableDB_', 'May 2021', 'May 2026', 'nameDB_');\n      return this.nameDB_;\n    },\n    /**\n     * @this {Generator}\n     * @param {!Names|undefined} nameDb New name database.\n     */\n    set: function(nameDb) {\n      deprecation.warn('variableDB_', 'May 2021', 'May 2026', 'nameDB_');\n      this.nameDB_ = nameDb;\n    },\n  },\n});\n\nexports.Generator = Generator;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/generator.js?")},
"./core/gesture.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/tooltip.js\");\n__webpack_require__(\"./core/touch.js\");\n__webpack_require__(\"./core/block_animations.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/internal_constants.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/bubble_dragger.js\");\n__webpack_require__(\"./core/config.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/workspace_dragger.js\");\n__webpack_require__(\"./core/workspace.js\");\n__webpack_require__(\"./core/block_dragger.js\");\n__webpack_require__(\"./core/events/events_click.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing an in-progress gesture, usually a drag\n * or a tap.\n */\n\n\n/**\n * The class representing an in-progress gesture, usually a drag\n * or a tap.\n * @class\n */\ngoog.module('Blockly.Gesture');\n\nconst Tooltip = goog.require('Blockly.Tooltip');\nconst Touch = goog.require('Blockly.Touch');\nconst blockAnimations = goog.require('Blockly.blockAnimations');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst common = goog.require('Blockly.common');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst internalConstants = goog.require('Blockly.internalConstants');\nconst registry = goog.require('Blockly.registry');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {BubbleDragger} = goog.require('Blockly.BubbleDragger');\nconst {config} = goog.require('Blockly.config');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\n/* eslint-disable-next-line no-unused-vars */\nconst {Field} = goog.requireType('Blockly.Field');\n/* eslint-disable-next-line no-unused-vars */\nconst {IBlockDragger} = goog.requireType('Blockly.IBlockDragger');\n/* eslint-disable-next-line no-unused-vars */\nconst {IBubble} = goog.requireType('Blockly.IBubble');\n/* eslint-disable-next-line no-unused-vars */\nconst {IFlyout} = goog.requireType('Blockly.IFlyout');\nconst {WorkspaceDragger} = goog.require('Blockly.WorkspaceDragger');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\nconst {Workspace} = goog.require('Blockly.Workspace');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.BlockDragger');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.Click');\n\n\n/**\n * Note: In this file \"start\" refers to touchstart, mousedown, and pointerstart\n * events.  \"End\" refers to touchend, mouseup, and pointerend events.\n */\n// TODO: Consider touchcancel/pointercancel.\n\n/**\n * Class for one gesture.\n * @alias Blockly.Gesture\n */\nclass Gesture {\n  /**\n   * @param {!Event} e The event that kicked off this gesture.\n   * @param {!WorkspaceSvg} creatorWorkspace The workspace that created\n   *     this gesture and has a reference to it.\n   */\n  constructor(e, creatorWorkspace) {\n    /**\n     * The position of the mouse when the gesture started.  Units are CSS\n     * pixels, with (0, 0) at the top left of the browser window (mouseEvent\n     * clientX/Y).\n     * @type {Coordinate}\n     * @private\n     */\n    this.mouseDownXY_ = null;\n\n    /**\n     * How far the mouse has moved during this drag, in pixel units.\n     * (0, 0) is at this.mouseDownXY_.\n     * @type {!Coordinate}\n     * @private\n     */\n    this.currentDragDeltaXY_ = new Coordinate(0, 0);\n\n    /**\n     * The bubble that the gesture started on, or null if it did not start on a\n     * bubble.\n     * @type {IBubble}\n     * @private\n     */\n    this.startBubble_ = null;\n\n    /**\n     * The field that the gesture started on, or null if it did not start on a\n     * field.\n     * @type {Field}\n     * @private\n     */\n    this.startField_ = null;\n\n    /**\n     * The block that the gesture started on, or null if it did not start on a\n     * block.\n     * @type {BlockSvg}\n     * @private\n     */\n    this.startBlock_ = null;\n\n    /**\n     * The block that this gesture targets.  If the gesture started on a\n     * shadow block, this is the first non-shadow parent of the block.  If the\n     * gesture started in the flyout, this is the root block of the block group\n     * that was clicked or dragged.\n     * @type {BlockSvg}\n     * @private\n     */\n    this.targetBlock_ = null;\n\n    /**\n     * The workspace that the gesture started on.  There may be multiple\n     * workspaces on a page; this is more accurate than using\n     * Blockly.common.getMainWorkspace().\n     * @type {WorkspaceSvg}\n     * @protected\n     */\n    this.startWorkspace_ = null;\n\n    /**\n     * The workspace that created this gesture.  This workspace keeps a\n     * reference to the gesture, which will need to be cleared at deletion. This\n     * may be different from the start workspace.  For instance, a flyout is a\n     * workspace, but its parent workspace manages gestures for it.\n     * @type {!WorkspaceSvg}\n     * @private\n     */\n    this.creatorWorkspace_ = creatorWorkspace;\n\n    /**\n     * Whether the pointer has at any point moved out of the drag radius.\n     * A gesture that exceeds the drag radius is a drag even if it ends exactly\n     * at its start point.\n     * @type {boolean}\n     * @private\n     */\n    this.hasExceededDragRadius_ = false;\n\n    /**\n     * Whether the workspace is currently being dragged.\n     * @type {boolean}\n     * @private\n     */\n    this.isDraggingWorkspace_ = false;\n\n    /**\n     * Whether the block is currently being dragged.\n     * @type {boolean}\n     * @private\n     */\n    this.isDraggingBlock_ = false;\n\n    /**\n     * Whether the bubble is currently being dragged.\n     * @type {boolean}\n     * @private\n     */\n    this.isDraggingBubble_ = false;\n\n    /**\n     * The event that most recently updated this gesture.\n     * @type {!Event}\n     * @private\n     */\n    this.mostRecentEvent_ = e;\n\n    /**\n     * A handle to use to unbind a mouse move listener at the end of a drag.\n     * Opaque data returned from Blockly.bindEventWithChecks_.\n     * @type {?browserEvents.Data}\n     * @protected\n     */\n    this.onMoveWrapper_ = null;\n\n    /**\n     * A handle to use to unbind a mouse up listener at the end of a drag.\n     * Opaque data returned from Blockly.bindEventWithChecks_.\n     * @type {?browserEvents.Data}\n     * @protected\n     */\n    this.onUpWrapper_ = null;\n\n    /**\n     * The object tracking a bubble drag, or null if none is in progress.\n     * @type {BubbleDragger}\n     * @private\n     */\n    this.bubbleDragger_ = null;\n\n    /**\n     * The object tracking a block drag, or null if none is in progress.\n     * @type {?IBlockDragger}\n     * @private\n     */\n    this.blockDragger_ = null;\n\n    /**\n     * The object tracking a workspace or flyout workspace drag, or null if none\n     * is in progress.\n     * @type {WorkspaceDragger}\n     * @private\n     */\n    this.workspaceDragger_ = null;\n\n    /**\n     * The flyout a gesture started in, if any.\n     * @type {IFlyout}\n     * @private\n     */\n    this.flyout_ = null;\n\n    /**\n     * Boolean for sanity-checking that some code is only called once.\n     * @type {boolean}\n     * @private\n     */\n    this.calledUpdateIsDragging_ = false;\n\n    /**\n     * Boolean for sanity-checking that some code is only called once.\n     * @type {boolean}\n     * @private\n     */\n    this.hasStarted_ = false;\n\n    /**\n     * Boolean used internally to break a cycle in disposal.\n     * @type {boolean}\n     * @protected\n     */\n    this.isEnding_ = false;\n\n    /**\n     * Boolean used to indicate whether or not to heal the stack after\n     * disconnecting a block.\n     * @type {boolean}\n     * @private\n     */\n    this.healStack_ = !internalConstants.DRAG_STACK;\n  }\n\n  /**\n   * Sever all links from this object.\n   * @package\n   */\n  dispose() {\n    Touch.clearTouchIdentifier();\n    Tooltip.unblock();\n    // Clear the owner's reference to this gesture.\n    this.creatorWorkspace_.clearGesture();\n\n    if (this.onMoveWrapper_) {\n      browserEvents.unbind(this.onMoveWrapper_);\n    }\n    if (this.onUpWrapper_) {\n      browserEvents.unbind(this.onUpWrapper_);\n    }\n\n    if (this.blockDragger_) {\n      this.blockDragger_.dispose();\n    }\n    if (this.workspaceDragger_) {\n      this.workspaceDragger_.dispose();\n    }\n    if (this.bubbleDragger_) {\n      this.bubbleDragger_.dispose();\n    }\n  }\n\n  /**\n   * Update internal state based on an event.\n   * @param {!Event} e The most recent mouse or touch event.\n   * @private\n   */\n  updateFromEvent_(e) {\n    const currentXY = new Coordinate(e.clientX, e.clientY);\n    const changed = this.updateDragDelta_(currentXY);\n    // Exceeded the drag radius for the first time.\n    if (changed) {\n      this.updateIsDragging_();\n      Touch.longStop();\n    }\n    this.mostRecentEvent_ = e;\n  }\n\n  /**\n   * DO MATH to set currentDragDeltaXY_ based on the most recent mouse position.\n   * @param {!Coordinate} currentXY The most recent mouse/pointer\n   *     position, in pixel units, with (0, 0) at the window's top left corner.\n   * @return {boolean} True if the drag just exceeded the drag radius for the\n   *     first time.\n   * @private\n   */\n  updateDragDelta_(currentXY) {\n    this.currentDragDeltaXY_ = Coordinate.difference(\n        currentXY,\n        /** @type {!Coordinate} */ (this.mouseDownXY_));\n\n    if (!this.hasExceededDragRadius_) {\n      const currentDragDelta = Coordinate.magnitude(this.currentDragDeltaXY_);\n\n      // The flyout has a different drag radius from the rest of Blockly.\n      const limitRadius =\n          this.flyout_ ? config.flyoutDragRadius : config.dragRadius;\n\n      this.hasExceededDragRadius_ = currentDragDelta > limitRadius;\n      return this.hasExceededDragRadius_;\n    }\n    return false;\n  }\n\n  /**\n   * Update this gesture to record whether a block is being dragged from the\n   * flyout.\n   * This function should be called on a mouse/touch move event the first time\n   * the drag radius is exceeded.  It should be called no more than once per\n   * gesture. If a block should be dragged from the flyout this function creates\n   * the new block on the main workspace and updates targetBlock_ and\n   * startWorkspace_.\n   * @return {boolean} True if a block is being dragged from the flyout.\n   * @private\n   */\n  updateIsDraggingFromFlyout_() {\n    if (!this.targetBlock_) {\n      return false;\n    }\n    if (!this.flyout_.isBlockCreatable_(this.targetBlock_)) {\n      return false;\n    }\n    if (!this.flyout_.isScrollable() ||\n        this.flyout_.isDragTowardWorkspace(this.currentDragDeltaXY_)) {\n      this.startWorkspace_ = this.flyout_.targetWorkspace;\n      this.startWorkspace_.updateScreenCalculationsIfScrolled();\n      // Start the event group now, so that the same event group is used for\n      // block creation and block dragging.\n      if (!eventUtils.getGroup()) {\n        eventUtils.setGroup(true);\n      }\n      // The start block is no longer relevant, because this is a drag.\n      this.startBlock_ = null;\n      this.targetBlock_ = this.flyout_.createBlock(this.targetBlock_);\n      this.targetBlock_.select();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Update this gesture to record whether a bubble is being dragged.\n   * This function should be called on a mouse/touch move event the first time\n   * the drag radius is exceeded.  It should be called no more than once per\n   * gesture. If a bubble should be dragged this function creates the necessary\n   * BubbleDragger and starts the drag.\n   * @return {boolean} True if a bubble is being dragged.\n   * @private\n   */\n  updateIsDraggingBubble_() {\n    if (!this.startBubble_) {\n      return false;\n    }\n\n    this.isDraggingBubble_ = true;\n    this.startDraggingBubble_();\n    return true;\n  }\n\n  /**\n   * Update this gesture to record whether a block is being dragged.\n   * This function should be called on a mouse/touch move event the first time\n   * the drag radius is exceeded.  It should be called no more than once per\n   * gesture. If a block should be dragged, either from the flyout or in the\n   * workspace, this function creates the necessary BlockDragger and starts the\n   * drag.\n   * @return {boolean} True if a block is being dragged.\n   * @private\n   */\n  updateIsDraggingBlock_() {\n    if (!this.targetBlock_) {\n      return false;\n    }\n\n    if (this.flyout_) {\n      this.isDraggingBlock_ = this.updateIsDraggingFromFlyout_();\n    } else if (this.targetBlock_.isMovable()) {\n      this.isDraggingBlock_ = true;\n    }\n\n    if (this.isDraggingBlock_) {\n      this.startDraggingBlock_();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Update this gesture to record whether a workspace is being dragged.\n   * This function should be called on a mouse/touch move event the first time\n   * the drag radius is exceeded.  It should be called no more than once per\n   * gesture. If a workspace is being dragged this function creates the\n   * necessary WorkspaceDragger and starts the drag.\n   * @private\n   */\n  updateIsDraggingWorkspace_() {\n    const wsMovable = this.flyout_ ?\n        this.flyout_.isScrollable() :\n        this.startWorkspace_ && this.startWorkspace_.isDraggable();\n\n    if (!wsMovable) {\n      return;\n    }\n\n    this.workspaceDragger_ = new WorkspaceDragger(\n        /** @type {!WorkspaceSvg} */ (this.startWorkspace_));\n\n    this.isDraggingWorkspace_ = true;\n    this.workspaceDragger_.startDrag();\n  }\n\n  /**\n   * Update this gesture to record whether anything is being dragged.\n   * This function should be called on a mouse/touch move event the first time\n   * the drag radius is exceeded.  It should be called no more than once per\n   * gesture.\n   * @private\n   */\n  updateIsDragging_() {\n    // Sanity check.\n    if (this.calledUpdateIsDragging_) {\n      throw Error('updateIsDragging_ should only be called once per gesture.');\n    }\n    this.calledUpdateIsDragging_ = true;\n\n    // First check if it was a bubble drag.  Bubbles always sit on top of\n    // blocks.\n    if (this.updateIsDraggingBubble_()) {\n      return;\n    }\n    // Then check if it was a block drag.\n    if (this.updateIsDraggingBlock_()) {\n      return;\n    }\n    // Then check if it's a workspace drag.\n    this.updateIsDraggingWorkspace_();\n  }\n\n  /**\n   * Create a block dragger and start dragging the selected block.\n   * @private\n   */\n  startDraggingBlock_() {\n    const BlockDraggerClass = registry.getClassFromOptions(\n        registry.Type.BLOCK_DRAGGER, this.creatorWorkspace_.options, true);\n\n    this.blockDragger_ = new BlockDraggerClass(\n        /** @type {!BlockSvg} */ (this.targetBlock_),\n        /** @type {!WorkspaceSvg} */ (this.startWorkspace_));\n    this.blockDragger_.startDrag(this.currentDragDeltaXY_, this.healStack_);\n    this.blockDragger_.drag(this.mostRecentEvent_, this.currentDragDeltaXY_);\n  }\n\n  // TODO (fenichel): Possibly combine this and startDraggingBlock_.\n  /**\n   * Create a bubble dragger and start dragging the selected bubble.\n   * @private\n   */\n  startDraggingBubble_() {\n    this.bubbleDragger_ = new BubbleDragger(\n        /** @type {!IBubble} */ (this.startBubble_),\n        /** @type {!WorkspaceSvg} */ (this.startWorkspace_));\n    this.bubbleDragger_.startBubbleDrag();\n    this.bubbleDragger_.dragBubble(\n        this.mostRecentEvent_, this.currentDragDeltaXY_);\n  }\n\n  /**\n   * Start a gesture: update the workspace to indicate that a gesture is in\n   * progress and bind mousemove and mouseup handlers.\n   * @param {!Event} e A mouse down or touch start event.\n   * @package\n   */\n  doStart(e) {\n    if (browserEvents.isTargetInput(e)) {\n      this.cancel();\n      return;\n    }\n    this.hasStarted_ = true;\n\n    blockAnimations.disconnectUiStop();\n    this.startWorkspace_.updateScreenCalculationsIfScrolled();\n    if (this.startWorkspace_.isMutator) {\n      // Mutator's coordinate system could be out of date because the bubble was\n      // dragged, the block was moved, the parent workspace zoomed, etc.\n      this.startWorkspace_.resize();\n    }\n\n    // Hide chaff also hides the flyout, so don't do it if the click is in a\n    // flyout.\n    this.startWorkspace_.hideChaff(!!this.flyout_);\n\n    this.startWorkspace_.markFocused();\n    this.mostRecentEvent_ = e;\n\n    Tooltip.block();\n\n    if (this.targetBlock_) {\n      this.targetBlock_.select();\n    }\n\n    if (browserEvents.isRightButton(e)) {\n      this.handleRightClick(e);\n      return;\n    }\n\n    if ((e.type.toLowerCase() === 'touchstart' ||\n         e.type.toLowerCase() === 'pointerdown') &&\n        e.pointerType !== 'mouse') {\n      Touch.longStart(e, this);\n    }\n\n    this.mouseDownXY_ = new Coordinate(e.clientX, e.clientY);\n    this.healStack_ = e.altKey || e.ctrlKey || e.metaKey;\n\n    this.bindMouseEvents(e);\n  }\n\n  /**\n   * Bind gesture events.\n   * @param {!Event} e A mouse down or touch start event.\n   * @package\n   */\n  bindMouseEvents(e) {\n    this.onMoveWrapper_ = browserEvents.conditionalBind(\n        document, 'mousemove', null, this.handleMove.bind(this));\n    this.onUpWrapper_ = browserEvents.conditionalBind(\n        document, 'mouseup', null, this.handleUp.bind(this));\n\n    e.preventDefault();\n    e.stopPropagation();\n  }\n\n  /**\n   * Handle a mouse move or touch move event.\n   * @param {!Event} e A mouse move or touch move event.\n   * @package\n   */\n  handleMove(e) {\n    this.updateFromEvent_(e);\n    if (this.isDraggingWorkspace_) {\n      this.workspaceDragger_.drag(this.currentDragDeltaXY_);\n    } else if (this.isDraggingBlock_) {\n      this.blockDragger_.drag(this.mostRecentEvent_, this.currentDragDeltaXY_);\n    } else if (this.isDraggingBubble_) {\n      this.bubbleDragger_.dragBubble(\n          this.mostRecentEvent_, this.currentDragDeltaXY_);\n    }\n    e.preventDefault();\n    e.stopPropagation();\n  }\n\n  /**\n   * Handle a mouse up or touch end event.\n   * @param {!Event} e A mouse up or touch end event.\n   * @package\n   */\n  handleUp(e) {\n    this.updateFromEvent_(e);\n    Touch.longStop();\n\n    if (this.isEnding_) {\n      console.log('Trying to end a gesture recursively.');\n      return;\n    }\n    this.isEnding_ = true;\n    // The ordering of these checks is important: drags have higher priority\n    // than clicks.  Fields have higher priority than blocks; blocks have higher\n    // priority than workspaces.\n    // The ordering within drags does not matter, because the three types of\n    // dragging are exclusive.\n    if (this.isDraggingBubble_) {\n      this.bubbleDragger_.endBubbleDrag(e, this.currentDragDeltaXY_);\n    } else if (this.isDraggingBlock_) {\n      this.blockDragger_.endDrag(e, this.currentDragDeltaXY_);\n    } else if (this.isDraggingWorkspace_) {\n      this.workspaceDragger_.endDrag(this.currentDragDeltaXY_);\n    } else if (this.isBubbleClick_()) {\n      // Bubbles are in front of all fields and blocks.\n      this.doBubbleClick_();\n    } else if (this.isFieldClick_()) {\n      this.doFieldClick_();\n    } else if (this.isBlockClick_()) {\n      this.doBlockClick_();\n    } else if (this.isWorkspaceClick_()) {\n      this.doWorkspaceClick_(e);\n    }\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    this.dispose();\n  }\n\n  /**\n   * Cancel an in-progress gesture.  If a workspace or block drag is in\n   * progress, end the drag at the most recent location.\n   * @package\n   */\n  cancel() {\n    // Disposing of a block cancels in-progress drags, but dragging to a delete\n    // area disposes of a block and leads to recursive disposal. Break that\n    // cycle.\n    if (this.isEnding_) {\n      return;\n    }\n    Touch.longStop();\n    if (this.isDraggingBubble_) {\n      this.bubbleDragger_.endBubbleDrag(\n          this.mostRecentEvent_, this.currentDragDeltaXY_);\n    } else if (this.isDraggingBlock_) {\n      this.blockDragger_.endDrag(\n          this.mostRecentEvent_, this.currentDragDeltaXY_);\n    } else if (this.isDraggingWorkspace_) {\n      this.workspaceDragger_.endDrag(this.currentDragDeltaXY_);\n    }\n    this.dispose();\n  }\n\n  /**\n   * Handle a real or faked right-click event by showing a context menu.\n   * @param {!Event} e A mouse move or touch move event.\n   * @package\n   */\n  handleRightClick(e) {\n    if (this.targetBlock_) {\n      this.bringBlockToFront_();\n      this.targetBlock_.workspace.hideChaff(!!this.flyout_);\n      this.targetBlock_.showContextMenu(e);\n    } else if (this.startBubble_) {\n      this.startBubble_.showContextMenu(e);\n    } else if (this.startWorkspace_ && !this.flyout_) {\n      this.startWorkspace_.hideChaff();\n      this.startWorkspace_.showContextMenu(e);\n    }\n\n    // TODO: Handle right-click on a bubble.\n    e.preventDefault();\n    e.stopPropagation();\n\n    this.dispose();\n  }\n\n  /**\n   * Handle a mousedown/touchstart event on a workspace.\n   * @param {!Event} e A mouse down or touch start event.\n   * @param {!WorkspaceSvg} ws The workspace the event hit.\n   * @package\n   */\n  handleWsStart(e, ws) {\n    if (this.hasStarted_) {\n      throw Error(\n          'Tried to call gesture.handleWsStart, ' +\n          'but the gesture had already been started.');\n    }\n    this.setStartWorkspace_(ws);\n    this.mostRecentEvent_ = e;\n    this.doStart(e);\n  }\n\n  /**\n   * Fires a workspace click event.\n   * @param {!WorkspaceSvg} ws The workspace that a user clicks on.\n   * @private\n   */\n  fireWorkspaceClick_(ws) {\n    eventUtils.fire(\n        new (eventUtils.get(eventUtils.CLICK))(null, ws.id, 'workspace'));\n  }\n\n  /**\n   * Handle a mousedown/touchstart event on a flyout.\n   * @param {!Event} e A mouse down or touch start event.\n   * @param {!IFlyout} flyout The flyout the event hit.\n   * @package\n   */\n  handleFlyoutStart(e, flyout) {\n    if (this.hasStarted_) {\n      throw Error(\n          'Tried to call gesture.handleFlyoutStart, ' +\n          'but the gesture had already been started.');\n    }\n    this.setStartFlyout_(flyout);\n    this.handleWsStart(e, flyout.getWorkspace());\n  }\n\n  /**\n   * Handle a mousedown/touchstart event on a block.\n   * @param {!Event} e A mouse down or touch start event.\n   * @param {!BlockSvg} block The block the event hit.\n   * @package\n   */\n  handleBlockStart(e, block) {\n    if (this.hasStarted_) {\n      throw Error(\n          'Tried to call gesture.handleBlockStart, ' +\n          'but the gesture had already been started.');\n    }\n    this.setStartBlock(block);\n    this.mostRecentEvent_ = e;\n  }\n\n  /**\n   * Handle a mousedown/touchstart event on a bubble.\n   * @param {!Event} e A mouse down or touch start event.\n   * @param {!IBubble} bubble The bubble the event hit.\n   * @package\n   */\n  handleBubbleStart(e, bubble) {\n    if (this.hasStarted_) {\n      throw Error(\n          'Tried to call gesture.handleBubbleStart, ' +\n          'but the gesture had already been started.');\n    }\n    this.setStartBubble(bubble);\n    this.mostRecentEvent_ = e;\n  }\n\n  /* Begin functions defining what actions to take to execute clicks on each\n   * type of target.  Any developer wanting to add behaviour on clicks should\n   * modify only this code. */\n\n  /**\n   * Execute a bubble click.\n   * @private\n   */\n  doBubbleClick_() {\n    // TODO (#1673): Consistent handling of single clicks.\n    this.startBubble_.setFocus && this.startBubble_.setFocus();\n    this.startBubble_.select && this.startBubble_.select();\n  }\n\n  /**\n   * Execute a field click.\n   * @private\n   */\n  doFieldClick_() {\n    this.startField_.showEditor(this.mostRecentEvent_);\n    this.bringBlockToFront_();\n  }\n\n  /**\n   * Execute a block click.\n   * @private\n   */\n  doBlockClick_() {\n    // Block click in an autoclosing flyout.\n    if (this.flyout_ && this.flyout_.autoClose) {\n      if (this.targetBlock_.isEnabled()) {\n        if (!eventUtils.getGroup()) {\n          eventUtils.setGroup(true);\n        }\n        const newBlock = this.flyout_.createBlock(this.targetBlock_);\n        newBlock.scheduleSnapAndBump();\n      }\n    } else {\n      // Clicks events are on the start block, even if it was a shadow.\n      const event = new (eventUtils.get(eventUtils.CLICK))(\n          this.startBlock_, this.startWorkspace_.id, 'block');\n      eventUtils.fire(event);\n    }\n    this.bringBlockToFront_();\n    eventUtils.setGroup(false);\n  }\n\n  /**\n   * Execute a workspace click. When in accessibility mode shift clicking will\n   * move the cursor.\n   * @param {!Event} _e A mouse up or touch end event.\n   * @private\n   */\n  doWorkspaceClick_(_e) {\n    const ws = this.creatorWorkspace_;\n    if (common.getSelected()) {\n      common.getSelected().unselect();\n    }\n    this.fireWorkspaceClick_(this.startWorkspace_ || ws);\n  }\n\n  /* End functions defining what actions to take to execute clicks on each type\n   * of target. */\n\n  // TODO (fenichel): Move bubbles to the front.\n\n  /**\n   * Move the dragged/clicked block to the front of the workspace so that it is\n   * not occluded by other blocks.\n   * @private\n   */\n  bringBlockToFront_() {\n    // Blocks in the flyout don't overlap, so skip the work.\n    if (this.targetBlock_ && !this.flyout_) {\n      this.targetBlock_.bringToFront();\n    }\n  }\n\n  /* Begin functions for populating a gesture at mouse down. */\n\n  /**\n   * Record the field that a gesture started on.\n   * @param {Field} field The field the gesture started on.\n   * @package\n   */\n  setStartField(field) {\n    if (this.hasStarted_) {\n      throw Error(\n          'Tried to call gesture.setStartField, ' +\n          'but the gesture had already been started.');\n    }\n    if (!this.startField_) {\n      this.startField_ = field;\n    }\n  }\n\n  /**\n   * Record the bubble that a gesture started on\n   * @param {IBubble} bubble The bubble the gesture started on.\n   * @package\n   */\n  setStartBubble(bubble) {\n    if (!this.startBubble_) {\n      this.startBubble_ = bubble;\n    }\n  }\n\n  /**\n   * Record the block that a gesture started on, and set the target block\n   * appropriately.\n   * @param {BlockSvg} block The block the gesture started on.\n   * @package\n   */\n  setStartBlock(block) {\n    // If the gesture already went through a bubble, don't set the start block.\n    if (!this.startBlock_ && !this.startBubble_) {\n      this.startBlock_ = block;\n      if (block.isInFlyout && block !== block.getRootBlock()) {\n        this.setTargetBlock_(block.getRootBlock());\n      } else {\n        this.setTargetBlock_(block);\n      }\n    }\n  }\n\n  /**\n   * Record the block that a gesture targets, meaning the block that will be\n   * dragged if this turns into a drag.  If this block is a shadow, that will be\n   * its first non-shadow parent.\n   * @param {BlockSvg} block The block the gesture targets.\n   * @private\n   */\n  setTargetBlock_(block) {\n    if (block.isShadow()) {\n      this.setTargetBlock_(block.getParent());\n    } else {\n      this.targetBlock_ = block;\n    }\n  }\n\n  /**\n   * Record the workspace that a gesture started on.\n   * @param {WorkspaceSvg} ws The workspace the gesture started on.\n   * @private\n   */\n  setStartWorkspace_(ws) {\n    if (!this.startWorkspace_) {\n      this.startWorkspace_ = ws;\n    }\n  }\n\n  /**\n   * Record the flyout that a gesture started on.\n   * @param {IFlyout} flyout The flyout the gesture started on.\n   * @private\n   */\n  setStartFlyout_(flyout) {\n    if (!this.flyout_) {\n      this.flyout_ = flyout;\n    }\n  }\n\n  /* End functions for populating a gesture at mouse down. */\n\n  /* Begin helper functions defining types of clicks.  Any developer wanting\n   * to change the definition of a click should modify only this code. */\n\n  /**\n   * Whether this gesture is a click on a bubble.  This should only be called\n   * when ending a gesture (mouse up, touch end).\n   * @return {boolean} Whether this gesture was a click on a bubble.\n   * @private\n   */\n  isBubbleClick_() {\n    // A bubble click starts on a bubble and never escapes the drag radius.\n    const hasStartBubble = !!this.startBubble_;\n    return hasStartBubble && !this.hasExceededDragRadius_;\n  }\n\n  /**\n   * Whether this gesture is a click on a block.  This should only be called\n   * when ending a gesture (mouse up, touch end).\n   * @return {boolean} Whether this gesture was a click on a block.\n   * @private\n   */\n  isBlockClick_() {\n    // A block click starts on a block, never escapes the drag radius, and is\n    // not a field click.\n    const hasStartBlock = !!this.startBlock_;\n    return hasStartBlock && !this.hasExceededDragRadius_ &&\n        !this.isFieldClick_();\n  }\n\n  /**\n   * Whether this gesture is a click on a field.  This should only be called\n   * when ending a gesture (mouse up, touch end).\n   * @return {boolean} Whether this gesture was a click on a field.\n   * @private\n   */\n  isFieldClick_() {\n    const fieldClickable =\n        this.startField_ ? this.startField_.isClickable() : false;\n    return fieldClickable && !this.hasExceededDragRadius_ &&\n        (!this.flyout_ || !this.flyout_.autoClose);\n  }\n\n  /**\n   * Whether this gesture is a click on a workspace.  This should only be called\n   * when ending a gesture (mouse up, touch end).\n   * @return {boolean} Whether this gesture was a click on a workspace.\n   * @private\n   */\n  isWorkspaceClick_() {\n    const onlyTouchedWorkspace =\n        !this.startBlock_ && !this.startBubble_ && !this.startField_;\n    return onlyTouchedWorkspace && !this.hasExceededDragRadius_;\n  }\n\n  /* End helper functions defining types of clicks. */\n\n  /**\n   * Whether this gesture is a drag of either a workspace or block.\n   * This function is called externally to block actions that cannot be taken\n   * mid-drag (e.g. using the keyboard to delete the selected blocks).\n   * @return {boolean} True if this gesture is a drag of a workspace or block.\n   * @package\n   */\n  isDragging() {\n    return this.isDraggingWorkspace_ || this.isDraggingBlock_ ||\n        this.isDraggingBubble_;\n  }\n\n  /**\n   * Whether this gesture has already been started.  In theory every mouse down\n   * has a corresponding mouse up, but in reality it is possible to lose a\n   * mouse up, leaving an in-process gesture hanging.\n   * @return {boolean} Whether this gesture was a click on a workspace.\n   * @package\n   */\n  hasStarted() {\n    return this.hasStarted_;\n  }\n\n  /**\n   * Get a list of the insertion markers that currently exist.  Block drags have\n   * 0, 1, or 2 insertion markers.\n   * @return {!Array<!BlockSvg>} A possibly empty list of insertion\n   *     marker blocks.\n   * @package\n   */\n  getInsertionMarkers() {\n    if (this.blockDragger_) {\n      return this.blockDragger_.getInsertionMarkers();\n    }\n    return [];\n  }\n\n  /**\n   * Gets the current dragger if an item is being dragged. Null if nothing is\n   * being dragged.\n   * @return {!WorkspaceDragger|!BubbleDragger|!IBlockDragger|null}\n   *    The dragger that is currently in use or null if no drag is in progress.\n   */\n  getCurrentDragger() {\n    if (this.isDraggingBlock_) {\n      return this.blockDragger_;\n    } else if (this.isDraggingWorkspace_) {\n      return this.workspaceDragger_;\n    } else if (this.isDraggingBubble_) {\n      return this.bubbleDragger_;\n    }\n    return null;\n  }\n\n  /**\n   * Is a drag or other gesture currently in progress on any workspace?\n   * @return {boolean} True if gesture is occurring.\n   */\n  static inProgress() {\n    const workspaces = Workspace.getAll();\n    for (let i = 0, workspace; (workspace = workspaces[i]); i++) {\n      // Not actually necessarily a WorkspaceSvg, but it doesn't matter b/c\n      // we're just checking if the property exists. Theoretically we would\n      // want to use instanceof, but that causes a circular dependency.\n      if (/** @type {!WorkspaceSvg} */ (workspace).currentGesture_) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nexports.Gesture = Gesture;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/gesture.js?")},
"./core/grid.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object for configuring and updating a workspace grid in\n * Blockly.\n */\n\n\n/**\n * Object for configuring and updating a workspace grid in\n * Blockly.\n * @class\n */\ngoog.module('Blockly.Grid');\n\nconst dom = goog.require('Blockly.utils.dom');\nconst userAgent = goog.require('Blockly.utils.userAgent');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n\n\n/**\n * Class for a workspace's grid.\n * @alias Blockly.Grid\n */\nclass Grid {\n  /**\n   * @param {!SVGElement} pattern The grid's SVG pattern, created during\n   *     injection.\n   * @param {!Object} options A dictionary of normalized options for the grid.\n   *     See grid documentation:\n   *     https://developers.google.com/blockly/guides/configure/web/grid\n   */\n  constructor(pattern, options) {\n    /**\n     * The scale of the grid, used to set stroke width on grid lines.\n     * This should always be the same as the workspace scale.\n     * @type {number}\n     * @private\n     */\n    this.scale_ = 1;\n\n    /**\n     * The grid's SVG pattern, created during injection.\n     * @type {!SVGElement}\n     * @private\n     */\n    this.gridPattern_ = pattern;\n\n    /**\n     * The spacing of the grid lines (in px).\n     * @type {number}\n     * @private\n     */\n    this.spacing_ = options['spacing'];\n\n    /**\n     * How long the grid lines should be (in px).\n     * @type {number}\n     * @private\n     */\n    this.length_ = options['length'];\n\n    /**\n     * The horizontal grid line, if it exists.\n     * @type {SVGElement}\n     * @private\n     */\n    this.line1_ = /** @type {SVGElement} */ (pattern.firstChild);\n\n    /**\n     * The vertical grid line, if it exists.\n     * @type {SVGElement}\n     * @private\n     */\n    this.line2_ =\n        this.line1_ && (/** @type {SVGElement} */ (this.line1_.nextSibling));\n\n    /**\n     * Whether blocks should snap to the grid.\n     * @type {boolean}\n     * @private\n     */\n    this.snapToGrid_ = options['snap'];\n  }\n\n  /**\n   * Dispose of this grid and unlink from the DOM.\n   * @package\n   * @suppress {checkTypes}\n   */\n  dispose() {\n    this.gridPattern_ = null;\n  }\n\n  /**\n   * Whether blocks should snap to the grid, based on the initial configuration.\n   * @return {boolean} True if blocks should snap, false otherwise.\n   * @package\n   */\n  shouldSnap() {\n    return this.snapToGrid_;\n  }\n\n  /**\n   * Get the spacing of the grid points (in px).\n   * @return {number} The spacing of the grid points.\n   * @package\n   */\n  getSpacing() {\n    return this.spacing_;\n  }\n\n  /**\n   * Get the ID of the pattern element, which should be randomized to avoid\n   * conflicts with other Blockly instances on the page.\n   * @return {string} The pattern ID.\n   * @package\n   */\n  getPatternId() {\n    return this.gridPattern_.id;\n  }\n\n  /**\n   * Update the grid with a new scale.\n   * @param {number} scale The new workspace scale.\n   * @package\n   */\n  update(scale) {\n    this.scale_ = scale;\n    // MSIE freaks if it sees a 0x0 pattern, so set empty patterns to 100x100.\n    const safeSpacing = (this.spacing_ * scale) || 100;\n\n    this.gridPattern_.setAttribute('width', safeSpacing);\n    this.gridPattern_.setAttribute('height', safeSpacing);\n\n    let half = Math.floor(this.spacing_ / 2) + 0.5;\n    let start = half - this.length_ / 2;\n    let end = half + this.length_ / 2;\n\n    half *= scale;\n    start *= scale;\n    end *= scale;\n\n    this.setLineAttributes_(this.line1_, scale, start, end, half, half);\n    this.setLineAttributes_(this.line2_, scale, half, half, start, end);\n  }\n\n  /**\n   * Set the attributes on one of the lines in the grid.  Use this to update the\n   * length and stroke width of the grid lines.\n   * @param {SVGElement} line Which line to update.\n   * @param {number} width The new stroke size (in px).\n   * @param {number} x1 The new x start position of the line (in px).\n   * @param {number} x2 The new x end position of the line (in px).\n   * @param {number} y1 The new y start position of the line (in px).\n   * @param {number} y2 The new y end position of the line (in px).\n   * @private\n   */\n  setLineAttributes_(line, width, x1, x2, y1, y2) {\n    if (line) {\n      line.setAttribute('stroke-width', width);\n      line.setAttribute('x1', x1);\n      line.setAttribute('y1', y1);\n      line.setAttribute('x2', x2);\n      line.setAttribute('y2', y2);\n    }\n  }\n\n  /**\n   * Move the grid to a new x and y position, and make sure that change is\n   * visible.\n   * @param {number} x The new x position of the grid (in px).\n   * @param {number} y The new y position of the grid (in px).\n   * @package\n   */\n  moveTo(x, y) {\n    this.gridPattern_.setAttribute('x', x);\n    this.gridPattern_.setAttribute('y', y);\n\n    if (userAgent.IE || userAgent.EDGE) {\n      // IE/Edge doesn't notice that the x/y offsets have changed.\n      // Force an update.\n      this.update(this.scale_);\n    }\n  }\n\n  /**\n   * Create the DOM for the grid described by options.\n   * @param {string} rnd A random ID to append to the pattern's ID.\n   * @param {!Object} gridOptions The object containing grid configuration.\n   * @param {!SVGElement} defs The root SVG element for this workspace's defs.\n   * @return {!SVGElement} The SVG element for the grid pattern.\n   * @package\n   */\n  static createDom(rnd, gridOptions, defs) {\n    /*\n      <pattern id=\"blocklyGridPattern837493\" patternUnits=\"userSpaceOnUse\">\n        <rect stroke=\"#888\" />\n        <rect stroke=\"#888\" />\n      </pattern>\n    */\n    const gridPattern = dom.createSvgElement(\n        Svg.PATTERN,\n        {'id': 'blocklyGridPattern' + rnd, 'patternUnits': 'userSpaceOnUse'},\n        defs);\n    if (gridOptions['length'] > 0 && gridOptions['spacing'] > 0) {\n      dom.createSvgElement(\n          Svg.LINE, {'stroke': gridOptions['colour']}, gridPattern);\n      if (gridOptions['length'] > 1) {\n        dom.createSvgElement(\n            Svg.LINE, {'stroke': gridOptions['colour']}, gridPattern);\n      }\n      // x1, y1, x1, x2 properties will be set later in update.\n    } else {\n      // Edge 16 doesn't handle empty patterns\n      dom.createSvgElement(Svg.LINE, {}, gridPattern);\n    }\n    return gridPattern;\n  }\n}\n\nexports.Grid = Grid;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/grid.js?")},
"./core/icon.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/utils/svg_math.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/utils/size.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2013 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing an icon on a block.\n */\n\n\n/**\n * Object representing an icon on a block.\n * @class\n */\ngoog.module('Blockly.Icon');\n\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst dom = goog.require('Blockly.utils.dom');\nconst svgMath = goog.require('Blockly.utils.svgMath');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Bubble} = goog.requireType('Blockly.Bubble');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\nconst {Size} = goog.require('Blockly.utils.Size');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n\n\n/**\n * Class for an icon.\n * @abstract\n * @alias Blockly.Icon\n */\nclass Icon {\n  /**\n   * @param {BlockSvg} block The block associated with this icon.\n   */\n  constructor(block) {\n    /**\n     * The block this icon is attached to.\n     * @type {BlockSvg}\n     * @protected\n     */\n    this.block_ = block;\n\n    /**\n     * The icon SVG group.\n     * @type {?SVGGElement}\n     */\n    this.iconGroup_ = null;\n\n    /**\n     * Whether this icon gets hidden when the block is collapsed.\n     * @type {boolean}\n     */\n    this.collapseHidden = true;\n\n    /**\n     * Height and width of icons.\n     * @const\n     */\n    this.SIZE = 17;\n\n    /**\n     * Bubble UI (if visible).\n     * @type {?Bubble}\n     * @protected\n     */\n    this.bubble_ = null;\n\n    /**\n     * Absolute coordinate of icon's center.\n     * @type {?Coordinate}\n     * @protected\n     */\n    this.iconXY_ = null;\n  }\n\n  /**\n   * Create the icon on the block.\n   */\n  createIcon() {\n    if (this.iconGroup_) {\n      // Icon already exists.\n      return;\n    }\n    /* Here's the markup that will be generated:\n    <g class=\"blocklyIconGroup\">\n      ...\n    </g>\n    */\n    this.iconGroup_ =\n        dom.createSvgElement(Svg.G, {'class': 'blocklyIconGroup'}, null);\n    if (this.block_.isInFlyout) {\n      dom.addClass(\n          /** @type {!Element} */ (this.iconGroup_),\n          'blocklyIconGroupReadonly');\n    }\n    this.drawIcon_(this.iconGroup_);\n\n    this.block_.getSvgRoot().appendChild(this.iconGroup_);\n    browserEvents.conditionalBind(\n        this.iconGroup_, 'mouseup', this, this.iconClick_);\n    this.updateEditable();\n  }\n\n  /**\n   * Dispose of this icon.\n   */\n  dispose() {\n    // Dispose of and unlink the icon.\n    dom.removeNode(this.iconGroup_);\n    this.iconGroup_ = null;\n    // Dispose of and unlink the bubble.\n    this.setVisible(false);\n    this.block_ = null;\n  }\n\n  /**\n   * Add or remove the UI indicating if this icon may be clicked or not.\n   */\n  updateEditable() {\n    // No-op on the base class.\n  }\n\n  /**\n   * Is the associated bubble visible?\n   * @return {boolean} True if the bubble is visible.\n   */\n  isVisible() {\n    return !!this.bubble_;\n  }\n\n  /**\n   * Clicking on the icon toggles if the bubble is visible.\n   * @param {!Event} e Mouse click event.\n   * @protected\n   */\n  iconClick_(e) {\n    if (this.block_.workspace.isDragging()) {\n      // Drag operation is concluding.  Don't open the editor.\n      return;\n    }\n    if (!this.block_.isInFlyout && !browserEvents.isRightButton(e)) {\n      this.setVisible(!this.isVisible());\n    }\n  }\n\n  /**\n   * Change the colour of the associated bubble to match its block.\n   */\n  applyColour() {\n    if (this.isVisible()) {\n      this.bubble_.setColour(this.block_.style.colourPrimary);\n    }\n  }\n\n  /**\n   * Notification that the icon has moved.  Update the arrow accordingly.\n   * @param {!Coordinate} xy Absolute location in workspace coordinates.\n   */\n  setIconLocation(xy) {\n    this.iconXY_ = xy;\n    if (this.isVisible()) {\n      this.bubble_.setAnchorLocation(xy);\n    }\n  }\n\n  /**\n   * Notification that the icon has moved, but we don't really know where.\n   * Recompute the icon's location from scratch.\n   */\n  computeIconLocation() {\n    // Find coordinates for the centre of the icon and update the arrow.\n    const blockXY = this.block_.getRelativeToSurfaceXY();\n    const iconXY = svgMath.getRelativeXY(\n        /** @type {!SVGElement} */ (this.iconGroup_));\n    const newXY = new Coordinate(\n        blockXY.x + iconXY.x + this.SIZE / 2,\n        blockXY.y + iconXY.y + this.SIZE / 2);\n    if (!Coordinate.equals(this.getIconLocation(), newXY)) {\n      this.setIconLocation(newXY);\n    }\n  }\n\n  /**\n   * Returns the center of the block's icon relative to the surface.\n   * @return {?Coordinate} Object with x and y properties in\n   *     workspace coordinates.\n   */\n  getIconLocation() {\n    return this.iconXY_;\n  }\n\n  /**\n   * Get the size of the icon as used for rendering.\n   * This differs from the actual size of the icon, because it bulges slightly\n   * out of its row rather than increasing the height of its row.\n   * @return {!Size} Height and width.\n   */\n  getCorrectedSize() {\n    // TODO (#2562): Remove getCorrectedSize.\n    return new Size(this.SIZE, this.SIZE - 2);\n  }\n\n  /**\n   * Draw the icon.\n   * @param {!Element} _group The icon group.\n   * @protected\n   */\n  drawIcon_(_group) {\n    // No-op on base class.\n  }\n\n  /**\n   * Show or hide the icon.\n   * @param {boolean} _visible True if the icon should be visible.\n   */\n  setVisible(_visible) {\n    // No-op on base class\n  }\n}\n\nexports.Icon = Icon;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/icon.js?")},
"./core/inject.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/css.js\");\n__webpack_require__(\"./core/tooltip.js\");\n__webpack_require__(\"./core/touch.js\");\n__webpack_require__(\"./core/widgetdiv.js\");\n__webpack_require__(\"./core/utils/aria.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/bump_objects.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/dropdowndiv.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\n__webpack_require__(\"./core/block_drag_surface.js\");\n__webpack_require__(\"./core/grid.js\");\n__webpack_require__(\"./core/msg.js\");\n__webpack_require__(\"./core/options.js\");\n__webpack_require__(\"./core/scrollbar_pair.js\");\n__webpack_require__(\"./core/shortcut_registry.js\");\n__webpack_require__(\"./core/utils/svg.js\");\n__webpack_require__(\"./core/workspace_drag_surface_svg.js\");\n__webpack_require__(\"./core/workspace_svg.js\");\n__webpack_require__(\"./core/workspace.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2011 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Functions for injecting Blockly into a web page.\n */\n\n\n/**\n * Functions for injecting Blockly into a web page.\n * @namespace Blockly.inject\n */\ngoog.module('Blockly.inject');\n\nconst Css = goog.require('Blockly.Css');\nconst Tooltip = goog.require('Blockly.Tooltip');\nconst Touch = goog.require('Blockly.Touch');\nconst WidgetDiv = goog.require('Blockly.WidgetDiv');\nconst aria = goog.require('Blockly.utils.aria');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst bumpObjects = goog.require('Blockly.bumpObjects');\nconst common = goog.require('Blockly.common');\nconst dom = goog.require('Blockly.utils.dom');\nconst dropDownDiv = goog.require('Blockly.dropDownDiv');\nconst userAgent = goog.require('Blockly.utils.userAgent');\nconst {BlockDragSurfaceSvg} = goog.require('Blockly.BlockDragSurfaceSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlocklyOptions} = goog.requireType('Blockly.BlocklyOptions');\nconst {Grid} = goog.require('Blockly.Grid');\nconst {Msg} = goog.require('Blockly.Msg');\nconst {Options} = goog.require('Blockly.Options');\nconst {ScrollbarPair} = goog.require('Blockly.ScrollbarPair');\nconst {ShortcutRegistry} = goog.require('Blockly.ShortcutRegistry');\nconst {Svg} = goog.require('Blockly.utils.Svg');\nconst {WorkspaceDragSurfaceSvg} = goog.require('Blockly.WorkspaceDragSurfaceSvg');\nconst {WorkspaceSvg} = goog.require('Blockly.WorkspaceSvg');\nconst {Workspace} = goog.require('Blockly.Workspace');\n\n\n/**\n * Inject a Blockly editor into the specified container element (usually a div).\n * @param {Element|string} container Containing element, or its ID,\n *     or a CSS selector.\n * @param {BlocklyOptions=} opt_options Optional dictionary of options.\n * @return {!WorkspaceSvg} Newly created main workspace.\n * @alias Blockly.inject\n */\nconst inject = function(container, opt_options) {\n  if (typeof container === 'string') {\n    container =\n        document.getElementById(container) || document.querySelector(container);\n  }\n  // Verify that the container is in document.\n  if (!container || !dom.containsNode(document, container)) {\n    throw Error('Error: container is not in current document.');\n  }\n  const options =\n      new Options(opt_options || (/** @type {!BlocklyOptions} */ ({})));\n  const subContainer =\n      /** @type {!HTMLDivElement} */ (document.createElement('div'));\n  subContainer.className = 'injectionDiv';\n  subContainer.tabIndex = 0;\n  aria.setState(subContainer, aria.State.LABEL, Msg['WORKSPACE_ARIA_LABEL']);\n\n  container.appendChild(subContainer);\n  const svg = createDom(subContainer, options);\n\n  // Create surfaces for dragging things. These are optimizations\n  // so that the browser does not repaint during the drag.\n  const blockDragSurface = new BlockDragSurfaceSvg(subContainer);\n\n  const workspaceDragSurface = new WorkspaceDragSurfaceSvg(subContainer);\n\n  const workspace =\n      createMainWorkspace(svg, options, blockDragSurface, workspaceDragSurface);\n\n  init(workspace);\n\n  // Keep focus on the first workspace so entering keyboard navigation looks\n  // correct.\n  common.setMainWorkspace(workspace);\n\n  common.svgResize(workspace);\n\n  subContainer.addEventListener('focusin', function() {\n    common.setMainWorkspace(workspace);\n  });\n\n  return workspace;\n};\n\n/**\n * Create the SVG image.\n * @param {!Element} container Containing element.\n * @param {!Options} options Dictionary of options.\n * @return {!Element} Newly created SVG image.\n */\nconst createDom = function(container, options) {\n  // Sadly browsers (Chrome vs Firefox) are currently inconsistent in laying\n  // out content in RTL mode.  Therefore Blockly forces the use of LTR,\n  // then manually positions content in RTL as needed.\n  container.setAttribute('dir', 'LTR');\n\n  // Load CSS.\n  Css.inject(options.hasCss, options.pathToMedia);\n\n  // Build the SVG DOM.\n  /*\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    xmlns:html=\"http://www.w3.org/1999/xhtml\"\n    xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n    version=\"1.1\"\n    class=\"blocklySvg\">\n    ...\n  </svg>\n  */\n  const svg = dom.createSvgElement(\n      Svg.SVG, {\n        'xmlns': dom.SVG_NS,\n        'xmlns:html': dom.HTML_NS,\n        'xmlns:xlink': dom.XLINK_NS,\n        'version': '1.1',\n        'class': 'blocklySvg',\n        'tabindex': '0',\n      },\n      container);\n  /*\n  <defs>\n    ... filters go here ...\n  </defs>\n  */\n  const defs = dom.createSvgElement(Svg.DEFS, {}, svg);\n  // Each filter/pattern needs a unique ID for the case of multiple Blockly\n  // instances on a page.  Browser behaviour becomes undefined otherwise.\n  // https://neil.fraser.name/news/2015/11/01/\n  const rnd = String(Math.random()).substring(2);\n\n  options.gridPattern = Grid.createDom(rnd, options.gridOptions, defs);\n  return svg;\n};\n\n/**\n * Create a main workspace and add it to the SVG.\n * @param {!Element} svg SVG element with pattern defined.\n * @param {!Options} options Dictionary of options.\n * @param {!BlockDragSurfaceSvg} blockDragSurface Drag surface SVG\n *     for the blocks.\n * @param {!WorkspaceDragSurfaceSvg} workspaceDragSurface Drag surface\n *     SVG for the workspace.\n * @return {!WorkspaceSvg} Newly created main workspace.\n */\nconst createMainWorkspace = function(\n    svg, options, blockDragSurface, workspaceDragSurface) {\n  options.parentWorkspace = null;\n  const mainWorkspace =\n      new WorkspaceSvg(options, blockDragSurface, workspaceDragSurface);\n  const wsOptions = mainWorkspace.options;\n  mainWorkspace.scale = wsOptions.zoomOptions.startScale;\n  svg.appendChild(mainWorkspace.createDom('blocklyMainBackground'));\n\n  // Set the theme name and renderer name onto the injection div.\n  dom.addClass(\n      mainWorkspace.getInjectionDiv(),\n      mainWorkspace.getRenderer().getClassName());\n  dom.addClass(\n      mainWorkspace.getInjectionDiv(), mainWorkspace.getTheme().getClassName());\n\n  if (!wsOptions.hasCategories && wsOptions.languageTree) {\n    // Add flyout as an <svg> that is a sibling of the workspace SVG.\n    const flyout = mainWorkspace.addFlyout(Svg.SVG);\n    dom.insertAfter(flyout, svg);\n  }\n  if (wsOptions.hasTrashcan) {\n    mainWorkspace.addTrashcan();\n  }\n  if (wsOptions.zoomOptions && wsOptions.zoomOptions.controls) {\n    mainWorkspace.addZoomControls();\n  }\n  // Register the workspace svg as a UI component.\n  mainWorkspace.getThemeManager().subscribe(\n      svg, 'workspaceBackgroundColour', 'background-color');\n\n  // A null translation will also apply the correct initial scale.\n  mainWorkspace.translate(0, 0);\n\n  mainWorkspace.addChangeListener(\n      bumpObjects.bumpIntoBoundsHandler(mainWorkspace));\n\n  // The SVG is now fully assembled.\n  common.svgResize(mainWorkspace);\n  WidgetDiv.createDom();\n  dropDownDiv.createDom();\n  Tooltip.createDom();\n  return mainWorkspace;\n};\n\n/**\n * Initialize Blockly with various handlers.\n * @param {!WorkspaceSvg} mainWorkspace Newly created main workspace.\n */\nconst init = function(mainWorkspace) {\n  const options = mainWorkspace.options;\n  const svg = mainWorkspace.getParentSvg();\n\n  // Suppress the browser's context menu.\n  browserEvents.conditionalBind(\n      /** @type {!Element} */ (svg.parentNode), 'contextmenu', null,\n      function(e) {\n        if (!browserEvents.isTargetInput(e)) {\n          e.preventDefault();\n        }\n      });\n\n  const workspaceResizeHandler =\n      browserEvents.conditionalBind(window, 'resize', null, function() {\n        mainWorkspace.hideChaff(true);\n        common.svgResize(mainWorkspace);\n        goog.module.get('Blockly.bumpObjects')\n            .bumpTopObjectsIntoBounds(mainWorkspace);\n      });\n  mainWorkspace.setResizeHandlerWrapper(workspaceResizeHandler);\n\n  bindDocumentEvents();\n\n  if (options.languageTree) {\n    const toolbox = mainWorkspace.getToolbox();\n    const flyout = mainWorkspace.getFlyout(true);\n    if (toolbox) {\n      toolbox.init();\n    } else if (flyout) {\n      // Build a fixed flyout with the root blocks.\n      flyout.init(mainWorkspace);\n      flyout.show(options.languageTree);\n      if (typeof flyout.scrollToStart === 'function') {\n        flyout.scrollToStart();\n      }\n    }\n  }\n\n  if (options.hasTrashcan) {\n    mainWorkspace.trashcan.init();\n  }\n  if (options.zoomOptions && options.zoomOptions.controls) {\n    mainWorkspace.zoomControls_.init();\n  }\n\n  if (options.moveOptions && options.moveOptions.scrollbars) {\n    const horizontalScroll = options.moveOptions.scrollbars === true ||\n        !!options.moveOptions.scrollbars.horizontal;\n    const verticalScroll = options.moveOptions.scrollbars === true ||\n        !!options.moveOptions.scrollbars.vertical;\n    mainWorkspace.scrollbar = new ScrollbarPair(\n        mainWorkspace, horizontalScroll, verticalScroll,\n        'blocklyMainWorkspaceScrollbar');\n    mainWorkspace.scrollbar.resize();\n  } else {\n    mainWorkspace.setMetrics({x: 0.5, y: 0.5});\n  }\n\n  // Load the sounds.\n  if (options.hasSounds) {\n    loadSounds(options.pathToMedia, mainWorkspace);\n  }\n};\n\n/**\n * Handle a key-down on SVG drawing surface. Does nothing if the main workspace\n * is not visible.\n * @param {!KeyboardEvent} e Key down event.\n */\n// TODO (https://github.com/google/blockly/issues/1998) handle cases where there\n// are multiple workspaces and non-main workspaces are able to accept input.\nconst onKeyDown = function(e) {\n  const mainWorkspace =\n      /** @type {!WorkspaceSvg} */ (common.getMainWorkspace());\n  if (!mainWorkspace) {\n    return;\n  }\n\n  if (browserEvents.isTargetInput(e) ||\n      (mainWorkspace.rendered && !mainWorkspace.isVisible())) {\n    // When focused on an HTML text input widget, don't trap any keys.\n    // Ignore keypresses on rendered workspaces that have been explicitly\n    // hidden.\n    return;\n  }\n  ShortcutRegistry.registry.onKeyDown(mainWorkspace, e);\n};\n\n/**\n * Whether event handlers have been bound. Document event handlers will only\n * be bound once, even if Blockly is destroyed and reinjected.\n * @type {boolean}\n */\nlet documentEventsBound = false;\n\n/**\n * Bind document events, but only once.  Destroying and reinjecting Blockly\n * should not bind again.\n * Bind events for scrolling the workspace.\n * Most of these events should be bound to the SVG's surface.\n * However, 'mouseup' has to be on the whole document so that a block dragged\n * out of bounds and released will know that it has been released.\n * Also, 'keydown' has to be on the whole document since the browser doesn't\n * understand a concept of focus on the SVG image.\n */\nconst bindDocumentEvents = function() {\n  if (!documentEventsBound) {\n    browserEvents.conditionalBind(document, 'scroll', null, function() {\n      const workspaces = Workspace.getAll();\n      for (let i = 0, workspace; (workspace = workspaces[i]); i++) {\n        if (workspace.updateInverseScreenCTM) {\n          workspace.updateInverseScreenCTM();\n        }\n      }\n    });\n    browserEvents.conditionalBind(document, 'keydown', null, onKeyDown);\n    // longStop needs to run to stop the context menu from showing up.  It\n    // should run regardless of what other touch event handlers have run.\n    browserEvents.bind(document, 'touchend', null, Touch.longStop);\n    browserEvents.bind(document, 'touchcancel', null, Touch.longStop);\n    // Some iPad versions don't fire resize after portrait to landscape change.\n    if (userAgent.IPAD) {\n      browserEvents.conditionalBind(\n          window, 'orientationchange', document, function() {\n            // TODO (#397): Fix for multiple Blockly workspaces.\n            common.svgResize(/** @type {!WorkspaceSvg} */\n                             (common.getMainWorkspace()));\n          });\n    }\n  }\n  documentEventsBound = true;\n};\n\n/**\n * Load sounds for the given workspace.\n * @param {string} pathToMedia The path to the media directory.\n * @param {!WorkspaceSvg} workspace The workspace to load sounds for.\n */\nconst loadSounds = function(pathToMedia, workspace) {\n  const audioMgr = workspace.getAudioManager();\n  audioMgr.load(\n      [\n        pathToMedia + 'click.mp3',\n        pathToMedia + 'click.wav',\n        pathToMedia + 'click.ogg',\n      ],\n      'click');\n  audioMgr.load(\n      [\n        pathToMedia + 'disconnect.wav',\n        pathToMedia + 'disconnect.mp3',\n        pathToMedia + 'disconnect.ogg',\n      ],\n      'disconnect');\n  audioMgr.load(\n      [\n        pathToMedia + 'delete.mp3',\n        pathToMedia + 'delete.ogg',\n        pathToMedia + 'delete.wav',\n      ],\n      'delete');\n\n  // Bind temporary hooks that preload the sounds.\n  const soundBinds = [];\n  const unbindSounds = function() {\n    while (soundBinds.length) {\n      browserEvents.unbind(soundBinds.pop());\n    }\n    audioMgr.preload();\n  };\n\n  // These are bound on mouse/touch events with\n  // Blockly.browserEvents.conditionalBind, so they restrict the touch\n  // identifier that will be recognized.  But this is really something that\n  // happens on a click, not a drag, so that's not necessary.\n\n  // Android ignores any sound not loaded as a result of a user action.\n  soundBinds.push(browserEvents.conditionalBind(\n      document, 'mousemove', null, unbindSounds, true));\n  soundBinds.push(browserEvents.conditionalBind(\n      document, 'touchstart', null, unbindSounds, true));\n};\n\nexports.inject = inject;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/inject.js?")},
"./core/input.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/field_registry.js\");\n__webpack_require__(\"./core/input_types.js\");\n__webpack_require__(\"./core/field_label.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing an input (value, statement, or dummy).\n */\n\n\n/**\n * Object representing an input (value, statement, or dummy).\n * @class\n */\ngoog.module('Blockly.Input');\n\nconst fieldRegistry = goog.require('Blockly.fieldRegistry');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\n/* eslint-disable-next-line no-unused-vars */\nconst {Connection} = goog.requireType('Blockly.Connection');\n/* eslint-disable-next-line no-unused-vars */\nconst {Field} = goog.requireType('Blockly.Field');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderedConnection} = goog.requireType('Blockly.RenderedConnection');\nconst {inputTypes} = goog.require('Blockly.inputTypes');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.FieldLabel');\n\n\n/**\n * Class for an input with an optional field.\n * @alias Blockly.Input\n */\nclass Input {\n  /**\n   * @param {number} type The type of the input.\n   * @param {string} name Language-neutral identifier which may used to find\n   *     this input again.\n   * @param {!Block} block The block containing this input.\n   * @param {Connection} connection Optional connection for this input.\n   */\n  constructor(type, name, block, connection) {\n    if (type !== inputTypes.DUMMY && !name) {\n      throw Error(\n          'Value inputs and statement inputs must have non-empty name.');\n    }\n    /** @type {number} */\n    this.type = type;\n    /** @type {string} */\n    this.name = name;\n    /**\n     * @type {!Block}\n     * @private\n     */\n    this.sourceBlock_ = block;\n    /** @type {Connection} */\n    this.connection = connection;\n    /** @type {!Array<!Field>} */\n    this.fieldRow = [];\n\n    /**\n     * Alignment of input's fields (left, right or centre).\n     * @type {number}\n     */\n    this.align = Align.LEFT;\n\n    /**\n     * Is the input visible?\n     * @type {boolean}\n     * @private\n     */\n    this.visible_ = true;\n  }\n\n  /**\n   * Get the source block for this input.\n   * @return {?Block} The source block, or null if there is none.\n   */\n  getSourceBlock() {\n    return this.sourceBlock_;\n  }\n\n  /**\n   * Add a field (or label from string), and all prefix and suffix fields, to\n   * the end of the input's field row.\n   * @param {string|!Field} field Something to add as a field.\n   * @param {string=} opt_name Language-neutral identifier which may used to\n   *     find this field again.  Should be unique to the host block.\n   * @return {!Input} The input being append to (to allow chaining).\n   */\n  appendField(field, opt_name) {\n    this.insertFieldAt(this.fieldRow.length, field, opt_name);\n    return this;\n  }\n\n  /**\n   * Inserts a field (or label from string), and all prefix and suffix fields,\n   * at the location of the input's field row.\n   * @param {number} index The index at which to insert field.\n   * @param {string|!Field} field Something to add as a field.\n   * @param {string=} opt_name Language-neutral identifier which may used to\n   *     find this field again.  Should be unique to the host block.\n   * @return {number} The index following the last inserted field.\n   */\n  insertFieldAt(index, field, opt_name) {\n    if (index < 0 || index > this.fieldRow.length) {\n      throw Error('index ' + index + ' out of bounds.');\n    }\n    // Falsy field values don't generate a field, unless the field is an empty\n    // string and named.\n    if (!field && !(field === '' && opt_name)) {\n      return index;\n    }\n\n    // Generate a FieldLabel when given a plain text field.\n    if (typeof field === 'string') {\n      field = /** @type {!Field} **/ (fieldRegistry.fromJson({\n        'type': 'field_label',\n        'text': field,\n      }));\n    }\n\n    field.setSourceBlock(this.sourceBlock_);\n    if (this.sourceBlock_.rendered) {\n      field.init();\n      field.applyColour();\n    }\n    field.name = opt_name;\n    field.setVisible(this.isVisible());\n\n    if (field.prefixField) {\n      // Add any prefix.\n      index = this.insertFieldAt(index, field.prefixField);\n    }\n    // Add the field to the field row.\n    this.fieldRow.splice(index, 0, field);\n    index++;\n    if (field.suffixField) {\n      // Add any suffix.\n      index = this.insertFieldAt(index, field.suffixField);\n    }\n\n    if (this.sourceBlock_.rendered) {\n      this.sourceBlock_ = /** @type {!BlockSvg} */ (this.sourceBlock_);\n      this.sourceBlock_.render();\n      // Adding a field will cause the block to change shape.\n      this.sourceBlock_.bumpNeighbours();\n    }\n    return index;\n  }\n\n  /**\n   * Remove a field from this input.\n   * @param {string} name The name of the field.\n   * @param {boolean=} opt_quiet True to prevent an error if field is not\n   *     present.\n   * @return {boolean} True if operation succeeds, false if field is not present\n   *     and opt_quiet is true.\n   * @throws {Error} if the field is not present and opt_quiet is false.\n   */\n  removeField(name, opt_quiet) {\n    for (let i = 0, field; (field = this.fieldRow[i]); i++) {\n      if (field.name === name) {\n        field.dispose();\n        this.fieldRow.splice(i, 1);\n        if (this.sourceBlock_.rendered) {\n          this.sourceBlock_ = /** @type {!BlockSvg} */ (this.sourceBlock_);\n          this.sourceBlock_.render();\n          // Removing a field will cause the block to change shape.\n          this.sourceBlock_.bumpNeighbours();\n        }\n        return true;\n      }\n    }\n    if (opt_quiet) {\n      return false;\n    }\n    throw Error('Field \"' + name + '\" not found.');\n  }\n\n  /**\n   * Gets whether this input is visible or not.\n   * @return {boolean} True if visible.\n   */\n  isVisible() {\n    return this.visible_;\n  }\n\n  /**\n   * Sets whether this input is visible or not.\n   * Should only be used to collapse/uncollapse a block.\n   * @param {boolean} visible True if visible.\n   * @return {!Array<!BlockSvg>} List of blocks to render.\n   * @package\n   */\n  setVisible(visible) {\n    // Note: Currently there are only unit tests for block.setCollapsed()\n    // because this function is package. If this function goes back to being a\n    // public API tests (lots of tests) should be added.\n    let renderList = [];\n    if (this.visible_ === visible) {\n      return renderList;\n    }\n    this.visible_ = visible;\n\n    for (let y = 0, field; (field = this.fieldRow[y]); y++) {\n      field.setVisible(visible);\n    }\n    if (this.connection) {\n      this.connection =\n          /** @type {!RenderedConnection} */ (this.connection);\n      // Has a connection.\n      if (visible) {\n        renderList = this.connection.startTrackingAll();\n      } else {\n        this.connection.stopTrackingAll();\n      }\n      const child = this.connection.targetBlock();\n      if (child) {\n        child.getSvgRoot().style.display = visible ? 'block' : 'none';\n      }\n    }\n    return renderList;\n  }\n\n  /**\n   * Mark all fields on this input as dirty.\n   * @package\n   */\n  markDirty() {\n    for (let y = 0, field; (field = this.fieldRow[y]); y++) {\n      field.markDirty();\n    }\n  }\n\n  /**\n   * Change a connection's compatibility.\n   * @param {string|Array<string>|null} check Compatible value type or\n   *     list of value types.  Null if all types are compatible.\n   * @return {!Input} The input being modified (to allow chaining).\n   */\n  setCheck(check) {\n    if (!this.connection) {\n      throw Error('This input does not have a connection.');\n    }\n    this.connection.setCheck(check);\n    return this;\n  }\n\n  /**\n   * Change the alignment of the connection's field(s).\n   * @param {number} align One of the values of Align\n   *   In RTL mode directions are reversed, and Align.RIGHT aligns to the left.\n   * @return {!Input} The input being modified (to allow chaining).\n   */\n  setAlign(align) {\n    this.align = align;\n    if (this.sourceBlock_.rendered) {\n      this.sourceBlock_ = /** @type {!BlockSvg} */ (this.sourceBlock_);\n      this.sourceBlock_.render();\n    }\n    return this;\n  }\n\n  /**\n   * Changes the connection's shadow block.\n   * @param {?Element} shadow DOM representation of a block or null.\n   * @return {!Input} The input being modified (to allow chaining).\n   */\n  setShadowDom(shadow) {\n    if (!this.connection) {\n      throw Error('This input does not have a connection.');\n    }\n    this.connection.setShadowDom(shadow);\n    return this;\n  }\n\n  /**\n   * Returns the XML representation of the connection's shadow block.\n   * @return {?Element} Shadow DOM representation of a block or null.\n   */\n  getShadowDom() {\n    if (!this.connection) {\n      throw Error('This input does not have a connection.');\n    }\n    return this.connection.getShadowDom();\n  }\n\n  /**\n   * Initialize the fields on this input.\n   */\n  init() {\n    if (!this.sourceBlock_.workspace.rendered) {\n      return;  // Headless blocks don't need fields initialized.\n    }\n    for (let i = 0; i < this.fieldRow.length; i++) {\n      this.fieldRow[i].init();\n    }\n  }\n\n  /**\n   * Sever all links to this input.\n   * @suppress {checkTypes}\n   */\n  dispose() {\n    for (let i = 0, field; (field = this.fieldRow[i]); i++) {\n      field.dispose();\n    }\n    if (this.connection) {\n      this.connection.dispose();\n    }\n    this.sourceBlock_ = null;\n  }\n}\n\n/**\n * Enum for alignment of inputs.\n * @enum {number}\n * @alias Blockly.Input.Align\n */\nconst Align = {\n  LEFT: -1,\n  CENTRE: 0,\n  RIGHT: 1,\n};\nexports.Align = Align;\n\n// Add Align to Input so that `Blockly.Input.Align` is publicly accessible.\nInput.Align = Align;\n\nexports.Input = Input;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/input.js?")},
"./core/input_types.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/connection_type.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview An enum for the possible types of inputs.\n */\n\n\n\n/**\n * An enum for the possible types of inputs.\n * @namespace Blockly.inputTypes\n */\ngoog.module('Blockly.inputTypes');\n\nconst {ConnectionType} = goog.require('Blockly.ConnectionType');\n\n\n/**\n * Enum for the type of a connection or input.\n * @enum {number}\n * @alias Blockly.inputTypes\n */\nconst inputTypes = {\n  // A right-facing value input.  E.g. 'set item to' or 'return'.\n  VALUE: ConnectionType.INPUT_VALUE,\n  // A down-facing block stack.  E.g. 'if-do' or 'else'.\n  STATEMENT: ConnectionType.NEXT_STATEMENT,\n  // A dummy input.  Used to add field(s) with no input.\n  DUMMY: 5,\n};\n\nexports.inputTypes = inputTypes;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/input_types.js?")},
"./core/insertion_marker_manager.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/block_animations.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/constants.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/component_manager.js\");\n__webpack_require__(\"./core/config.js\");\n__webpack_require__(\"./core/connection_type.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class that controls updates to connections during drags.\n */\n\n\n/**\n * Class that controls updates to connections during drags.\n * @class\n */\ngoog.module('Blockly.InsertionMarkerManager');\n\nconst blockAnimations = goog.require('Blockly.blockAnimations');\nconst common = goog.require('Blockly.common');\nconst constants = goog.require('Blockly.constants');\nconst eventUtils = goog.require('Blockly.Events.utils');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {ComponentManager} = goog.require('Blockly.ComponentManager');\nconst {config} = goog.require('Blockly.config');\nconst {ConnectionType} = goog.require('Blockly.ConnectionType');\n/* eslint-disable-next-line no-unused-vars */\nconst {Coordinate} = goog.requireType('Blockly.utils.Coordinate');\n/* eslint-disable-next-line no-unused-vars */\nconst {IDeleteArea} = goog.requireType('Blockly.IDeleteArea');\n/* eslint-disable-next-line no-unused-vars */\nconst {IDragTarget} = goog.requireType('Blockly.IDragTarget');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderedConnection} = goog.requireType('Blockly.RenderedConnection');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * An error message to throw if the block created by createMarkerBlock_ is\n * missing any components.\n * @type {string}\n * @const\n */\nconst DUPLICATE_BLOCK_ERROR = 'The insertion marker ' +\n    'manager tried to create a marker but the result is missing %1. If ' +\n    'you are using a mutator, make sure your domToMutation method is ' +\n    'properly defined.';\n\n\n/**\n * Class that controls updates to connections during drags.  It is primarily\n * responsible for finding the closest eligible connection and highlighting or\n * unhighlighting it as needed during a drag.\n * @alias Blockly.InsertionMarkerManager\n */\nclass InsertionMarkerManager {\n  /**\n   * @param {!BlockSvg} block The top block in the stack being dragged.\n   */\n  constructor(block) {\n    common.setSelected(block);\n\n    /**\n     * The top block in the stack being dragged.\n     * Does not change during a drag.\n     * @type {!BlockSvg}\n     * @private\n     */\n    this.topBlock_ = block;\n\n    /**\n     * The workspace on which these connections are being dragged.\n     * Does not change during a drag.\n     * @type {!WorkspaceSvg}\n     * @private\n     */\n    this.workspace_ = block.workspace;\n\n    /**\n     * The last connection on the stack, if it's not the last connection on the\n     * first block.\n     * Set in initAvailableConnections, if at all.\n     * @type {RenderedConnection}\n     * @private\n     */\n    this.lastOnStack_ = null;\n\n    /**\n     * The insertion marker corresponding to the last block in the stack, if\n     * that's not the same as the first block in the stack.\n     * Set in initAvailableConnections, if at all\n     * @type {BlockSvg}\n     * @private\n     */\n    this.lastMarker_ = null;\n\n    /**\n     * The insertion marker that shows up between blocks to show where a block\n     * would go if dropped immediately.\n     * @type {BlockSvg}\n     * @private\n     */\n    this.firstMarker_ = this.createMarkerBlock_(this.topBlock_);\n\n    /**\n     * The connection that this block would connect to if released immediately.\n     * Updated on every mouse move.\n     * This is not on any of the blocks that are being dragged.\n     * @type {RenderedConnection}\n     * @private\n     */\n    this.closestConnection_ = null;\n\n    /**\n     * The connection that would connect to this.closestConnection_ if this\n     * block were released immediately. Updated on every mouse move. This is on\n     * the top block that is being dragged or the last block in the dragging\n     * stack.\n     * @type {RenderedConnection}\n     * @private\n     */\n    this.localConnection_ = null;\n\n    /**\n     * Whether the block would be deleted if it were dropped immediately.\n     * Updated on every mouse move.\n     * @type {boolean}\n     * @private\n     */\n    this.wouldDeleteBlock_ = false;\n\n    /**\n     * Connection on the insertion marker block that corresponds to\n     * this.localConnection_ on the currently dragged block.\n     * @type {RenderedConnection}\n     * @private\n     */\n    this.markerConnection_ = null;\n\n    /**\n     * The block that currently has an input being highlighted, or null.\n     * @type {BlockSvg}\n     * @private\n     */\n    this.highlightedBlock_ = null;\n\n    /**\n     * The block being faded to indicate replacement, or null.\n     * @type {BlockSvg}\n     * @private\n     */\n    this.fadedBlock_ = null;\n\n    /**\n     * The connections on the dragging blocks that are available to connect to\n     * other blocks.  This includes all open connections on the top block, as\n     * well as the last connection on the block stack. Does not change during a\n     * drag.\n     * @type {!Array<!RenderedConnection>}\n     * @private\n     */\n    this.availableConnections_ = this.initAvailableConnections_();\n  }\n\n  /**\n   * Sever all links from this object.\n   * @package\n   */\n  dispose() {\n    this.availableConnections_.length = 0;\n\n    eventUtils.disable();\n    try {\n      if (this.firstMarker_) {\n        this.firstMarker_.dispose();\n      }\n      if (this.lastMarker_) {\n        this.lastMarker_.dispose();\n      }\n    } finally {\n      eventUtils.enable();\n    }\n  }\n\n  /**\n   * Update the available connections for the top block. These connections can\n   * change if a block is unplugged and the stack is healed.\n   * @package\n   */\n  updateAvailableConnections() {\n    this.availableConnections_ = this.initAvailableConnections_();\n  }\n\n  /**\n   * Return whether the block would be deleted if dropped immediately, based on\n   * information from the most recent move event.\n   * @return {boolean} True if the block would be deleted if dropped\n   *     immediately.\n   * @package\n   */\n  wouldDeleteBlock() {\n    return this.wouldDeleteBlock_;\n  }\n\n  /**\n   * Return whether the block would be connected if dropped immediately, based\n   * on information from the most recent move event.\n   * @return {boolean} True if the block would be connected if dropped\n   *   immediately.\n   * @package\n   */\n  wouldConnectBlock() {\n    return !!this.closestConnection_;\n  }\n\n  /**\n   * Connect to the closest connection and render the results.\n   * This should be called at the end of a drag.\n   * @package\n   */\n  applyConnections() {\n    if (this.closestConnection_) {\n      // Don't fire events for insertion markers.\n      eventUtils.disable();\n      this.hidePreview_();\n      eventUtils.enable();\n      // Connect two blocks together.\n      this.localConnection_.connect(this.closestConnection_);\n      if (this.topBlock_.rendered) {\n        // Trigger a connection animation.\n        // Determine which connection is inferior (lower in the source stack).\n        const inferiorConnection = this.localConnection_.isSuperior() ?\n            this.closestConnection_ :\n            this.localConnection_;\n        blockAnimations.connectionUiEffect(inferiorConnection.getSourceBlock());\n        // Bring the just-edited stack to the front.\n        const rootBlock = this.topBlock_.getRootBlock();\n        rootBlock.bringToFront();\n      }\n    }\n  }\n\n  /**\n   * Update connections based on the most recent move location.\n   * @param {!Coordinate} dxy Position relative to drag start,\n   *     in workspace units.\n   * @param {?IDragTarget} dragTarget The drag target that the block is\n   *     currently over.\n   * @package\n   */\n  update(dxy, dragTarget) {\n    const candidate = this.getCandidate_(dxy);\n\n    this.wouldDeleteBlock_ = this.shouldDelete_(candidate, dragTarget);\n\n    const shouldUpdate =\n        this.wouldDeleteBlock_ || this.shouldUpdatePreviews_(candidate, dxy);\n\n    if (shouldUpdate) {\n      // Don't fire events for insertion marker creation or movement.\n      eventUtils.disable();\n      this.maybeHidePreview_(candidate);\n      this.maybeShowPreview_(candidate);\n      eventUtils.enable();\n    }\n  }\n\n  /**\n   * Create an insertion marker that represents the given block.\n   * @param {!BlockSvg} sourceBlock The block that the insertion marker\n   *     will represent.\n   * @return {!BlockSvg} The insertion marker that represents the given\n   *     block.\n   * @private\n   */\n  createMarkerBlock_(sourceBlock) {\n    const imType = sourceBlock.type;\n\n    eventUtils.disable();\n    let result;\n    try {\n      result = this.workspace_.newBlock(imType);\n      result.setInsertionMarker(true);\n      if (sourceBlock.saveExtraState) {\n        const state = sourceBlock.saveExtraState();\n        if (state) {\n          result.loadExtraState(state);\n        }\n      } else if (sourceBlock.mutationToDom) {\n        const oldMutationDom = sourceBlock.mutationToDom();\n        if (oldMutationDom) {\n          result.domToMutation(oldMutationDom);\n        }\n      }\n      // Copy field values from the other block.  These values may impact the\n      // rendered size of the insertion marker.  Note that we do not care about\n      // child blocks here.\n      for (let i = 0; i < sourceBlock.inputList.length; i++) {\n        const sourceInput = sourceBlock.inputList[i];\n        if (sourceInput.name === constants.COLLAPSED_INPUT_NAME) {\n          continue;  // Ignore the collapsed input.\n        }\n        const resultInput = result.inputList[i];\n        if (!resultInput) {\n          throw new Error(DUPLICATE_BLOCK_ERROR.replace('%1', 'an input'));\n        }\n        for (let j = 0; j < sourceInput.fieldRow.length; j++) {\n          const sourceField = sourceInput.fieldRow[j];\n          const resultField = resultInput.fieldRow[j];\n          if (!resultField) {\n            throw new Error(DUPLICATE_BLOCK_ERROR.replace('%1', 'a field'));\n          }\n          resultField.setValue(sourceField.getValue());\n        }\n      }\n\n      result.setCollapsed(sourceBlock.isCollapsed());\n      result.setInputsInline(sourceBlock.getInputsInline());\n\n      result.initSvg();\n      result.getSvgRoot().setAttribute('visibility', 'hidden');\n    } finally {\n      eventUtils.enable();\n    }\n\n    return result;\n  }\n\n  /**\n   * Populate the list of available connections on this block stack.  This\n   * should only be called once, at the beginning of a drag. If the stack has\n   * more than one block, this function will populate lastOnStack_ and create\n   * the corresponding insertion marker.\n   * @return {!Array<!RenderedConnection>} A list of available\n   *     connections.\n   * @private\n   */\n  initAvailableConnections_() {\n    const available = this.topBlock_.getConnections_(false);\n    // Also check the last connection on this stack\n    const lastOnStack = this.topBlock_.lastConnectionInStack(true);\n    if (lastOnStack && lastOnStack !== this.topBlock_.nextConnection) {\n      available.push(lastOnStack);\n      this.lastOnStack_ = lastOnStack;\n      if (this.lastMarker_) {\n        eventUtils.disable();\n        try {\n          this.lastMarker_.dispose();\n        } finally {\n          eventUtils.enable();\n        }\n      }\n      this.lastMarker_ = this.createMarkerBlock_(lastOnStack.getSourceBlock());\n    }\n    return available;\n  }\n\n  /**\n   * Whether the previews (insertion marker and replacement marker) should be\n   * updated based on the closest candidate and the current drag distance.\n   * @param {!Object} candidate An object containing a local connection, a\n   *     closest connection, and a radius.  Returned by getCandidate_.\n   * @param {!Coordinate} dxy Position relative to drag start,\n   *     in workspace units.\n   * @return {boolean} Whether the preview should be updated.\n   * @private\n   */\n  shouldUpdatePreviews_(candidate, dxy) {\n    const candidateLocal = candidate.local;\n    const candidateClosest = candidate.closest;\n    const radius = candidate.radius;\n\n    // Found a connection!\n    if (candidateLocal && candidateClosest) {\n      // We're already showing an insertion marker.\n      // Decide whether the new connection has higher priority.\n      if (this.localConnection_ && this.closestConnection_) {\n        // The connection was the same as the current connection.\n        if (this.closestConnection_ === candidateClosest &&\n            this.localConnection_ === candidateLocal) {\n          return false;\n        }\n        const xDiff =\n            this.localConnection_.x + dxy.x - this.closestConnection_.x;\n        const yDiff =\n            this.localConnection_.y + dxy.y - this.closestConnection_.y;\n        const curDistance = Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n        // Slightly prefer the existing preview over a new preview.\n        return !(\n            candidateClosest &&\n            radius > curDistance - config.currentConnectionPreference);\n      } else if (!this.localConnection_ && !this.closestConnection_) {\n        // We weren't showing a preview before, but we should now.\n        return true;\n      } else {\n        console.error(\n            'Only one of localConnection_ and closestConnection_ was set.');\n      }\n    } else {  // No connection found.\n      // Only need to update if we were showing a preview before.\n      return !!(this.localConnection_ && this.closestConnection_);\n    }\n\n    console.error(\n        'Returning true from shouldUpdatePreviews, but it\\'s not clear why.');\n    return true;\n  }\n\n  /**\n   * Find the nearest valid connection, which may be the same as the current\n   * closest connection.\n   * @param {!Coordinate} dxy Position relative to drag start,\n   *     in workspace units.\n   * @return {!Object} An object containing a local connection, a closest\n   *     connection, and a radius.\n   * @private\n   */\n  getCandidate_(dxy) {\n    let radius = this.getStartRadius_();\n    let candidateClosest = null;\n    let candidateLocal = null;\n\n    // It's possible that a block has added or removed connections during a\n    // drag, (e.g. in a drag/move event handler), so let's update the available\n    // connections. Note that this will be called on every move while dragging,\n    // so it might cause slowness, especially if the block stack is large.  If\n    // so, maybe it could be made more efficient. Also note that we won't update\n    // the connections if we've already connected the insertion marker to a\n    // block.\n    if (!this.markerConnection_ || !this.markerConnection_.isConnected()) {\n      this.updateAvailableConnections();\n    }\n\n    for (let i = 0; i < this.availableConnections_.length; i++) {\n      const myConnection = this.availableConnections_[i];\n      const neighbour = myConnection.closest(radius, dxy);\n      if (neighbour.connection) {\n        candidateClosest = neighbour.connection;\n        candidateLocal = myConnection;\n        radius = neighbour.radius;\n      }\n    }\n    return {closest: candidateClosest, local: candidateLocal, radius: radius};\n  }\n\n  /**\n   * Decide the radius at which to start searching for the closest connection.\n   * @return {number} The radius at which to start the search for the closest\n   *     connection.\n   * @private\n   */\n  getStartRadius_() {\n    // If there is already a connection highlighted,\n    // increase the radius we check for making new connections.\n    // Why? When a connection is highlighted, blocks move around when the\n    // insertion marker is created, which could cause the connection became out\n    // of range. By increasing radiusConnection when a connection already\n    // exists, we never \"lose\" the connection from the offset.\n    if (this.closestConnection_ && this.localConnection_) {\n      return config.connectingSnapRadius;\n    }\n    return config.snapRadius;\n  }\n\n  /**\n   * Whether ending the drag would delete the block.\n   * @param {!Object} candidate An object containing a local connection, a\n   *     closest\n   *    connection, and a radius.\n   * @param {?IDragTarget} dragTarget The drag target that the block is\n   *     currently over.\n   * @return {boolean} Whether dropping the block immediately would delete the\n   *    block.\n   * @private\n   */\n  shouldDelete_(candidate, dragTarget) {\n    if (dragTarget) {\n      const componentManager = this.workspace_.getComponentManager();\n      const isDeleteArea = componentManager.hasCapability(\n          dragTarget.id, ComponentManager.Capability.DELETE_AREA);\n      if (isDeleteArea) {\n        return (\n                   /** @type {!IDeleteArea} */ (dragTarget))\n            .wouldDelete(this.topBlock_, candidate && !!candidate.closest);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Show an insertion marker or replacement highlighting during a drag, if\n   * needed.\n   * At the beginning of this function, this.localConnection_ and\n   * this.closestConnection_ should both be null.\n   * @param {!Object} candidate An object containing a local connection, a\n   *     closest connection, and a radius.\n   * @private\n   */\n  maybeShowPreview_(candidate) {\n    // Nope, don't add a marker.\n    if (this.wouldDeleteBlock_) {\n      return;\n    }\n    const closest = candidate.closest;\n    const local = candidate.local;\n\n    // Nothing to connect to.\n    if (!closest) {\n      return;\n    }\n\n    // Something went wrong and we're trying to connect to an invalid\n    // connection.\n    if (closest === this.closestConnection_ ||\n        closest.getSourceBlock().isInsertionMarker()) {\n      console.log('Trying to connect to an insertion marker');\n      return;\n    }\n    // Add an insertion marker or replacement marker.\n    this.closestConnection_ = closest;\n    this.localConnection_ = local;\n    this.showPreview_();\n  }\n\n  /**\n   * A preview should be shown.  This function figures out if it should be a\n   * block highlight or an insertion marker, and shows the appropriate one.\n   * @private\n   */\n  showPreview_() {\n    const closest = this.closestConnection_;\n    const renderer = this.workspace_.getRenderer();\n    const method = renderer.getConnectionPreviewMethod(\n        /** @type {!RenderedConnection} */ (closest),\n        /** @type {!RenderedConnection} */ (this.localConnection_),\n        this.topBlock_);\n\n    switch (method) {\n      case InsertionMarkerManager.PREVIEW_TYPE.INPUT_OUTLINE:\n        this.showInsertionInputOutline_();\n        break;\n      case InsertionMarkerManager.PREVIEW_TYPE.INSERTION_MARKER:\n        this.showInsertionMarker_();\n        break;\n      case InsertionMarkerManager.PREVIEW_TYPE.REPLACEMENT_FADE:\n        this.showReplacementFade_();\n        break;\n    }\n\n    // Optionally highlight the actual connection, as a nod to previous\n    // behaviour.\n    if (closest && renderer.shouldHighlightConnection(closest)) {\n      closest.highlight();\n    }\n  }\n\n  /**\n   * Show an insertion marker or replacement highlighting during a drag, if\n   * needed.\n   * At the end of this function, this.localConnection_ and\n   * this.closestConnection_ should both be null.\n   * @param {!Object} candidate An object containing a local connection, a\n   *     closest connection, and a radius.\n   * @private\n   */\n  maybeHidePreview_(candidate) {\n    // If there's no new preview, remove the old one but don't bother deleting\n    // it. We might need it later, and this saves disposing of it and recreating\n    // it.\n    if (!candidate.closest) {\n      this.hidePreview_();\n    } else {\n      // If there's a new preview and there was an preview before, and either\n      // connection has changed, remove the old preview.\n      const hadPreview = this.closestConnection_ && this.localConnection_;\n      const closestChanged = this.closestConnection_ !== candidate.closest;\n      const localChanged = this.localConnection_ !== candidate.local;\n\n      // Also hide if we had a preview before but now we're going to delete\n      // instead.\n      if (hadPreview &&\n          (closestChanged || localChanged || this.wouldDeleteBlock_)) {\n        this.hidePreview_();\n      }\n    }\n\n    // Either way, clear out old state.\n    this.markerConnection_ = null;\n    this.closestConnection_ = null;\n    this.localConnection_ = null;\n  }\n\n  /**\n   * A preview should be hidden.  This function figures out if it is a block\n   *  highlight or an insertion marker, and hides the appropriate one.\n   * @private\n   */\n  hidePreview_() {\n    if (this.closestConnection_ && this.closestConnection_.targetBlock() &&\n        this.workspace_.getRenderer().shouldHighlightConnection(\n            this.closestConnection_)) {\n      this.closestConnection_.unhighlight();\n    }\n    if (this.fadedBlock_) {\n      this.hideReplacementFade_();\n    } else if (this.highlightedBlock_) {\n      this.hideInsertionInputOutline_();\n    } else if (this.markerConnection_) {\n      this.hideInsertionMarker_();\n    }\n  }\n\n  /**\n   * Shows an insertion marker connected to the appropriate blocks (based on\n   * manager state).\n   * @private\n   */\n  showInsertionMarker_() {\n    const local = this.localConnection_;\n    const closest = this.closestConnection_;\n\n    const isLastInStack = this.lastOnStack_ && local === this.lastOnStack_;\n    let imBlock = isLastInStack ? this.lastMarker_ : this.firstMarker_;\n    let imConn;\n    try {\n      imConn = imBlock.getMatchingConnection(local.getSourceBlock(), local);\n    } catch (e) {\n      // It's possible that the number of connections on the local block has\n      // changed since the insertion marker was originally created.  Let's\n      // recreate the insertion marker and try again. In theory we could\n      // probably recreate the marker block (e.g. in getCandidate_), which is\n      // called more often during the drag, but creating a block that often\n      // might be too slow, so we only do it if necessary.\n      this.firstMarker_ = this.createMarkerBlock_(this.topBlock_);\n      imBlock = isLastInStack ? this.lastMarker_ : this.firstMarker_;\n      imConn = imBlock.getMatchingConnection(local.getSourceBlock(), local);\n    }\n\n    if (imConn === this.markerConnection_) {\n      throw Error(\n          'Made it to showInsertionMarker_ even though the marker isn\\'t ' +\n          'changing');\n    }\n\n    // Render disconnected from everything else so that we have a valid\n    // connection location.\n    imBlock.render();\n    imBlock.rendered = true;\n    imBlock.getSvgRoot().setAttribute('visibility', 'visible');\n\n    if (imConn && closest) {\n      // Position so that the existing block doesn't move.\n      imBlock.positionNearConnection(imConn, closest);\n    }\n    if (closest) {\n      // Connect() also renders the insertion marker.\n      imConn.connect(closest);\n    }\n\n    this.markerConnection_ = imConn;\n  }\n\n  /**\n   * Disconnects and hides the current insertion marker. Should return the\n   * blocks to their original state.\n   * @private\n   */\n  hideInsertionMarker_() {\n    if (!this.markerConnection_) {\n      console.log('No insertion marker connection to disconnect');\n      return;\n    }\n\n    const imConn = this.markerConnection_;\n    const imBlock = imConn.getSourceBlock();\n    const markerNext = imBlock.nextConnection;\n    const markerPrev = imBlock.previousConnection;\n    const markerOutput = imBlock.outputConnection;\n\n    const isFirstInStatementStack =\n        (imConn === markerNext && !(markerPrev && markerPrev.targetConnection));\n\n    const isFirstInOutputStack = imConn.type === ConnectionType.INPUT_VALUE &&\n        !(markerOutput && markerOutput.targetConnection);\n    // The insertion marker is the first block in a stack.  Unplug won't do\n    // anything in that case.  Instead, unplug the following block.\n    if (isFirstInStatementStack || isFirstInOutputStack) {\n      imConn.targetBlock().unplug(false);\n    } else if (\n        imConn.type === ConnectionType.NEXT_STATEMENT &&\n        imConn !== markerNext) {\n      // Inside of a C-block, first statement connection.\n      const innerConnection = imConn.targetConnection;\n      innerConnection.getSourceBlock().unplug(false);\n\n      const previousBlockNextConnection =\n          markerPrev ? markerPrev.targetConnection : null;\n\n      imBlock.unplug(true);\n      if (previousBlockNextConnection) {\n        previousBlockNextConnection.connect(innerConnection);\n      }\n    } else {\n      imBlock.unplug(true /* healStack */);\n    }\n\n    if (imConn.targetConnection) {\n      throw Error(\n          'markerConnection_ still connected at the end of ' +\n          'disconnectInsertionMarker');\n    }\n\n    this.markerConnection_ = null;\n    const svg = imBlock.getSvgRoot();\n    if (svg) {\n      svg.setAttribute('visibility', 'hidden');\n    }\n  }\n\n  /**\n   * Shows an outline around the input the closest connection belongs to.\n   * @private\n   */\n  showInsertionInputOutline_() {\n    const closest = this.closestConnection_;\n    this.highlightedBlock_ = closest.getSourceBlock();\n    this.highlightedBlock_.highlightShapeForInput(closest, true);\n  }\n\n  /**\n   * Hides any visible input outlines.\n   * @private\n   */\n  hideInsertionInputOutline_() {\n    this.highlightedBlock_.highlightShapeForInput(\n        this.closestConnection_, false);\n    this.highlightedBlock_ = null;\n  }\n\n  /**\n   * Shows a replacement fade affect on the closest connection's target block\n   * (the block that is currently connected to it).\n   * @private\n   */\n  showReplacementFade_() {\n    this.fadedBlock_ = this.closestConnection_.targetBlock();\n    this.fadedBlock_.fadeForReplacement(true);\n  }\n\n  /**\n   * Hides/Removes any visible fade affects.\n   * @private\n   */\n  hideReplacementFade_() {\n    this.fadedBlock_.fadeForReplacement(false);\n    this.fadedBlock_ = null;\n  }\n\n  /**\n   * Get a list of the insertion markers that currently exist.  Drags have 0, 1,\n   * or 2 insertion markers.\n   * @return {!Array<!BlockSvg>} A possibly empty list of insertion\n   *     marker blocks.\n   * @package\n   */\n  getInsertionMarkers() {\n    const result = [];\n    if (this.firstMarker_) {\n      result.push(this.firstMarker_);\n    }\n    if (this.lastMarker_) {\n      result.push(this.lastMarker_);\n    }\n    return result;\n  }\n}\n\n/**\n * An enum describing different kinds of previews the InsertionMarkerManager\n * could display.\n * @enum {number}\n */\nInsertionMarkerManager.PREVIEW_TYPE = {\n  INSERTION_MARKER: 0,\n  INPUT_OUTLINE: 1,\n  REPLACEMENT_FADE: 2,\n};\n\nexports.InsertionMarkerManager = InsertionMarkerManager;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/insertion_marker_manager.js?")},
"./core/interfaces/i_ast_node_location.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for an AST node location.\n */\n\n\n\n/**\n * The interface for an AST node location.\n * @namespace Blockly.IASTNodeLocation\n */\ngoog.module('Blockly.IASTNodeLocation');\n\n/**\n * An AST node location interface.\n * @interface\n * @alias Blockly.IASTNodeLocation\n */\nconst IASTNodeLocation = function() {};\n\nexports.IASTNodeLocation = IASTNodeLocation;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_ast_node_location.js?")},
"./core/interfaces/i_ast_node_location_svg.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/interfaces/i_ast_node_location.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for an AST node location SVG.\n */\n\n\n\n/**\n * The interface for an AST node location SVG.\n * @namespace Blockly.IASTNodeLocationSvg\n */\ngoog.module('Blockly.IASTNodeLocationSvg');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {IASTNodeLocation} = goog.require('Blockly.IASTNodeLocation');\n\n\n/**\n * An AST node location SVG interface.\n * @interface\n * @extends {IASTNodeLocation}\n * @alias Blockly.IASTNodeLocationSvg\n */\nconst IASTNodeLocationSvg = function() {};\n\n/**\n * Add the marker SVG to this node's SVG group.\n * @param {SVGElement} markerSvg The SVG root of the marker to be added to the\n *     SVG group.\n */\nIASTNodeLocationSvg.prototype.setMarkerSvg;\n\n/**\n * Add the cursor SVG to this node's SVG group.\n * @param {SVGElement} cursorSvg The SVG root of the cursor to be added to the\n *     SVG group.\n */\nIASTNodeLocationSvg.prototype.setCursorSvg;\n\nexports.IASTNodeLocationSvg = IASTNodeLocationSvg;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_ast_node_location_svg.js?")},
"./core/interfaces/i_ast_node_location_with_block.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/interfaces/i_ast_node_location.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for an AST node location that has an associated\n * block.\n */\n\n\n\n/**\n * The interface for an AST node location that has an associated\n * block.\n * @namespace Blockly.IASTNodeLocationWithBlock\n */\ngoog.module('Blockly.IASTNodeLocationWithBlock');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\n/* eslint-disable-next-line no-unused-vars */\nconst {IASTNodeLocation} = goog.require('Blockly.IASTNodeLocation');\n\n\n/**\n * An AST node location that has an associated block.\n * @interface\n * @extends {IASTNodeLocation}\n * @alias Blockly.IASTNodeLocationWithBlock\n */\nconst IASTNodeLocationWithBlock = function() {};\n\n/**\n * Get the source block associated with this node.\n * @return {Block} The source block.\n */\nIASTNodeLocationWithBlock.prototype.getSourceBlock;\n\nexports.IASTNodeLocationWithBlock = IASTNodeLocationWithBlock;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_ast_node_location_with_block.js?")},
"./core/interfaces/i_autohideable.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/interfaces/i_component.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for a component that is automatically hidden\n * when WorkspaceSvg.hideChaff is called.\n */\n\n\n\n/**\n * The interface for a component that is automatically hidden\n * when WorkspaceSvg.hideChaff is called.\n * @namespace Blockly.IAutoHideable\n */\ngoog.module('Blockly.IAutoHideable');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {IComponent} = goog.require('Blockly.IComponent');\n\n\n/**\n * Interface for a component that can be automatically hidden.\n * @extends {IComponent}\n * @interface\n * @alias Blockly.IAutoHideable\n */\nconst IAutoHideable = function() {};\n\n/**\n * Hides the component. Called in WorkspaceSvg.hideChaff.\n * @param {boolean} onlyClosePopups Whether only popups should be closed.\n *   Flyouts should not be closed if this is true.\n */\nIAutoHideable.prototype.autoHide;\n\nexports.IAutoHideable = IAutoHideable;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_autohideable.js?")},
"./core/interfaces/i_block_dragger.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for a block dragger.\n */\n\n\n\n/**\n * The interface for a block dragger.\n * @namespace Blockly.IBlockDragger\n */\ngoog.module('Blockly.IBlockDragger');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Coordinate} = goog.requireType('Blockly.utils.Coordinate');\n\n\n/**\n * A block dragger interface.\n * @interface\n * @alias Blockly.IBlockDragger\n */\nconst IBlockDragger = function() {};\n\n/**\n * Start dragging a block.  This includes moving it to the drag surface.\n * @param {!Coordinate} currentDragDeltaXY How far the pointer has\n *     moved from the position at mouse down, in pixel units.\n * @param {boolean} healStack Whether or not to heal the stack after\n *     disconnecting.\n */\nIBlockDragger.prototype.startDrag;\n\n/**\n * Execute a step of block dragging, based on the given event.  Update the\n * display accordingly.\n * @param {!Event} e The most recent move event.\n * @param {!Coordinate} currentDragDeltaXY How far the pointer has\n *     moved from the position at the start of the drag, in pixel units.\n */\nIBlockDragger.prototype.drag;\n\n/**\n * Finish a block drag and put the block back on the workspace.\n * @param {!Event} e The mouseup/touchend event.\n * @param {!Coordinate} currentDragDeltaXY How far the pointer has\n *     moved from the position at the start of the drag, in pixel units.\n */\nIBlockDragger.prototype.endDrag;\n\n/**\n * Get a list of the insertion markers that currently exist.  Drags have 0, 1,\n * or 2 insertion markers.\n * @return {!Array.<!BlockSvg>} A possibly empty list of insertion\n *     marker blocks.\n */\nIBlockDragger.prototype.getInsertionMarkers;\n\nexports.IBlockDragger = IBlockDragger;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_block_dragger.js?")},
"./core/interfaces/i_bounded_element.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for a bounded element.\n */\n\n\n\n/**\n * The interface for a bounded element.\n * @namespace Blockly.IBoundedElement\n */\ngoog.module('Blockly.IBoundedElement');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {Rect} = goog.requireType('Blockly.utils.Rect');\n\n\n/**\n * A bounded element interface.\n * @interface\n * @alias Blockly.IBoundedElement\n */\nconst IBoundedElement = function() {};\n\n/**\n * Returns the coordinates of a bounded element describing the dimensions of the\n * element.\n * Coordinate system: workspace coordinates.\n * @return {!Rect} Object with coordinates of the bounded element.\n */\nIBoundedElement.prototype.getBoundingRectangle;\n\n/**\n * Move the element by a relative offset.\n * @param {number} dx Horizontal offset in workspace units.\n * @param {number} dy Vertical offset in workspace units.\n */\nIBoundedElement.prototype.moveBy;\n\nexports.IBoundedElement = IBoundedElement;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_bounded_element.js?")},
"./core/interfaces/i_bubble.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/interfaces/i_contextmenu.js\");\n__webpack_require__(\"./core/interfaces/i_draggable.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for a bubble.\n */\n\n\n\n/**\n * The interface for a bubble.\n * @namespace Blockly.IBubble\n */\ngoog.module('Blockly.IBubble');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockDragSurfaceSvg} = goog.requireType('Blockly.BlockDragSurfaceSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Coordinate} = goog.requireType('Blockly.utils.Coordinate');\n/* eslint-disable-next-line no-unused-vars */\nconst {IContextMenu} = goog.require('Blockly.IContextMenu');\n/* eslint-disable-next-line no-unused-vars */\nconst {IDraggable} = goog.require('Blockly.IDraggable');\n\n\n/**\n * A bubble interface.\n * @interface\n * @extends {IDraggable}\n * @extends {IContextMenu}\n * @alias Blockly.IBubble\n */\nconst IBubble = function() {};\n\n/**\n * Return the coordinates of the top-left corner of this bubble's body relative\n * to the drawing surface's origin (0,0), in workspace units.\n * @return {!Coordinate} Object with .x and .y properties.\n */\nIBubble.prototype.getRelativeToSurfaceXY;\n\n/**\n * Return the root node of the bubble's SVG group.\n * @return {!SVGElement} The root SVG node of the bubble's group.\n */\nIBubble.prototype.getSvgRoot;\n\n/**\n * Set whether auto-layout of this bubble is enabled.  The first time a bubble\n * is shown it positions itself to not cover any blocks.  Once a user has\n * dragged it to reposition, it renders where the user put it.\n * @param {boolean} enable True if auto-layout should be enabled, false\n *     otherwise.\n */\nIBubble.prototype.setAutoLayout;\n\n/**\n * Triggers a move callback if one exists at the end of a drag.\n * @param {boolean} adding True if adding, false if removing.\n */\nIBubble.prototype.setDragging;\n\n/**\n * Move this bubble during a drag, taking into account whether or not there is\n * a drag surface.\n * @param {?BlockDragSurfaceSvg} dragSurface The surface that carries\n *     rendered items during a drag, or null if no drag surface is in use.\n * @param {!Coordinate} newLoc The location to translate to, in\n *     workspace coordinates.\n */\nIBubble.prototype.moveDuringDrag;\n\n/**\n * Move the bubble to the specified location in workspace coordinates.\n * @param {number} x The x position to move to.\n * @param {number} y The y position to move to.\n */\nIBubble.prototype.moveTo;\n\n/**\n * Update the style of this bubble when it is dragged over a delete area.\n * @param {boolean} enable True if the bubble is about to be deleted, false\n *     otherwise.\n */\nIBubble.prototype.setDeleteStyle;\n\n/**\n * Dispose of this bubble.\n */\nIBubble.prototype.dispose;\n\nexports.IBubble = IBubble;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_bubble.js?")},
"./core/interfaces/i_collapsible_toolbox_item.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/interfaces/i_selectable_toolbox_item.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for a collapsible toolbox item.\n */\n\n\n\n/**\n * The interface for a collapsible toolbox item.\n * @namespace Blockly.ICollapsibleToolboxItem\n */\ngoog.module('Blockly.ICollapsibleToolboxItem');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ISelectableToolboxItem} = goog.require('Blockly.ISelectableToolboxItem');\n/* eslint-disable-next-line no-unused-vars */\nconst {IToolboxItem} = goog.requireType('Blockly.IToolboxItem');\n\n\n/**\n * Interface for an item in the toolbox that can be collapsed.\n * @extends {ISelectableToolboxItem}\n * @interface\n * @alias Blockly.ICollapsibleToolboxItem\n */\nconst ICollapsibleToolboxItem = function() {};\n\n/**\n * Gets any children toolbox items. (ex. Gets the subcategories)\n * @return {!Array<!IToolboxItem>} The child toolbox items.\n */\nICollapsibleToolboxItem.prototype.getChildToolboxItems;\n\n/**\n * Whether the toolbox item is expanded to show its child subcategories.\n * @return {boolean} True if the toolbox item shows its children, false if it\n *     is collapsed.\n * @public\n */\nICollapsibleToolboxItem.prototype.isExpanded;\n\n/**\n * Toggles whether or not the toolbox item is expanded.\n * @public\n */\nICollapsibleToolboxItem.prototype.toggleExpanded;\n\nexports.ICollapsibleToolboxItem = ICollapsibleToolboxItem;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_collapsible_toolbox_item.js?")},
"./core/interfaces/i_component.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Interface for a workspace component that can be registered with\n * the ComponentManager.\n */\n\n\n\n/**\n * Interface for a workspace component that can be registered with\n * the ComponentManager.\n * @namespace Blockly.IComponent\n */\ngoog.module('Blockly.IComponent');\n\n\n/**\n * The interface for a workspace component that can be registered with the\n * ComponentManager.\n * @interface\n * @alias Blockly.IComponent\n */\nconst IComponent = function() {};\n\n/**\n * The unique id for this component that is used to register with the\n * ComponentManager.\n * @type {string}\n */\nIComponent.id;\n\nexports.IComponent = IComponent;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_component.js?")},
"./core/interfaces/i_connection_checker.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for an object that encapsulates logic for\n * checking whether a potential connection is safe and valid.\n */\n\n\n/**\n * The interface for an object that encapsulates logic for\n * checking whether a potential connection is safe and valid.\n * @namespace Blockly.IConnectionChecker\n */\ngoog.module('Blockly.IConnectionChecker');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {Connection} = goog.requireType('Blockly.Connection');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderedConnection} = goog.requireType('Blockly.RenderedConnection');\n\n\n/**\n * Class for connection type checking logic.\n * @interface\n * @alias Blockly.IConnectionChecker\n */\nconst IConnectionChecker = function() {};\n\n/**\n * Check whether the current connection can connect with the target\n * connection.\n * @param {Connection} a Connection to check compatibility with.\n * @param {Connection} b Connection to check compatibility with.\n * @param {boolean} isDragging True if the connection is being made by dragging\n *     a block.\n * @param {number=} opt_distance The max allowable distance between the\n *     connections for drag checks.\n * @return {boolean} Whether the connection is legal.\n * @public\n */\nIConnectionChecker.prototype.canConnect;\n\n/**\n * Checks whether the current connection can connect with the target\n * connection, and return an error code if there are problems.\n * @param {Connection} a Connection to check compatibility with.\n * @param {Connection} b Connection to check compatibility with.\n * @param {boolean} isDragging True if the connection is being made by dragging\n *     a block.\n * @param {number=} opt_distance The max allowable distance between the\n *     connections for drag checks.\n * @return {number} Connection.CAN_CONNECT if the connection is legal,\n *    an error code otherwise.\n * @public\n */\nIConnectionChecker.prototype.canConnectWithReason;\n\n/**\n * Helper method that translates a connection error code into a string.\n * @param {number} errorCode The error code.\n * @param {Connection} a One of the two connections being checked.\n * @param {Connection} b The second of the two connections being\n *     checked.\n * @return {string} A developer-readable error string.\n * @public\n */\nIConnectionChecker.prototype.getErrorMessage;\n\n/**\n * Check that connecting the given connections is safe, meaning that it would\n * not break any of Blockly's basic assumptions (e.g. no self connections).\n * @param {Connection} a The first of the connections to check.\n * @param {Connection} b The second of the connections to check.\n * @return {number} An enum with the reason this connection is safe or unsafe.\n * @public\n */\nIConnectionChecker.prototype.doSafetyChecks;\n\n/**\n * Check whether this connection is compatible with another connection with\n * respect to the value type system.  E.g. square_root(\"Hello\") is not\n * compatible.\n * @param {!Connection} a Connection to compare.\n * @param {!Connection} b Connection to compare against.\n * @return {boolean} True if the connections share a type.\n * @public\n */\nIConnectionChecker.prototype.doTypeChecks;\n\n/**\n * Check whether this connection can be made by dragging.\n * @param {!RenderedConnection} a Connection to compare.\n * @param {!RenderedConnection} b Connection to compare against.\n * @param {number} distance The maximum allowable distance between connections.\n * @return {boolean} True if the connection is allowed during a drag.\n * @public\n */\nIConnectionChecker.prototype.doDragChecks;\n\nexports.IConnectionChecker = IConnectionChecker;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_connection_checker.js?")},
"./core/interfaces/i_contextmenu.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for an object that supports a right-click.\n */\n\n\n\n/**\n * The interface for an object that supports a right-click.\n * @namespace Blockly.IContextMenu\n */\ngoog.module('Blockly.IContextMenu');\n\n\n/**\n * @interface\n * @alias Blockly.IContextMenu\n */\nconst IContextMenu = function() {};\n\n/**\n * Show the context menu for this object.\n * @param {!Event} e Mouse event.\n */\nIContextMenu.prototype.showContextMenu;\n\nexports.IContextMenu = IContextMenu;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_contextmenu.js?")},
"./core/interfaces/i_copyable.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/interfaces/i_selectable.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for an object that is copyable.\n */\n\n\n\n/**\n * The interface for an object that is copyable.\n * @namespace Blockly.ICopyable\n */\ngoog.module('Blockly.ICopyable');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ISelectable} = goog.require('Blockly.ISelectable');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * @extends {ISelectable}\n * @interface\n * @alias Blockly.ICopyable\n */\nconst ICopyable = function() {};\n\n/**\n * Encode for copying.\n * @return {?ICopyable.CopyData} Copy metadata.\n * @package\n */\nICopyable.prototype.toCopyData;\n\n/**\n * Copy Metadata.\n * @typedef {{\n *            saveInfo:(!Object|!Element),\n *            source:WorkspaceSvg,\n *            typeCounts:?Object\n *          }}\n */\nICopyable.CopyData;\n\nexports.ICopyable = ICopyable;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_copyable.js?")},
"./core/interfaces/i_deletable.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for an object that is deletable.\n */\n\n\n\n/**\n * The interface for an object that is deletable.\n * @namespace Blockly.IDeletable\n */\ngoog.module('Blockly.IDeletable');\n\n\n/**\n * The interface for an object that can be deleted.\n * @interface\n * @alias Blockly.IDeletable\n */\nconst IDeletable = function() {};\n\n/**\n * Get whether this object is deletable or not.\n * @return {boolean} True if deletable.\n */\nIDeletable.prototype.isDeletable;\n\nexports.IDeletable = IDeletable;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_deletable.js?")},
"./core/interfaces/i_delete_area.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/interfaces/i_drag_target.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for a component that can delete a block or bubble\n * that is dropped on top of it.\n */\n\n\n\n/**\n * The interface for a component that can delete a block or bubble\n * that is dropped on top of it.\n * @namespace Blockly.IDeleteArea\n */\ngoog.module('Blockly.IDeleteArea');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {IDragTarget} = goog.require('Blockly.IDragTarget');\n/* eslint-disable-next-line no-unused-vars */\nconst {IDraggable} = goog.requireType('Blockly.IDraggable');\n\n\n/**\n * Interface for a component that can delete a block or bubble that is dropped\n * on top of it.\n * @extends {IDragTarget}\n * @interface\n * @alias Blockly.IDeleteArea\n */\nconst IDeleteArea = function() {};\n\n/**\n * Returns whether the provided block or bubble would be deleted if dropped on\n * this area.\n * This method should check if the element is deletable and is always called\n * before onDragEnter/onDragOver/onDragExit.\n * @param {!IDraggable} element The block or bubble currently being\n *   dragged.\n * @param {boolean} couldConnect Whether the element could could connect to\n *     another.\n * @return {boolean} Whether the element provided would be deleted if dropped on\n *     this area.\n */\nIDeleteArea.prototype.wouldDelete;\n\nexports.IDeleteArea = IDeleteArea;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_delete_area.js?")},
"./core/interfaces/i_drag_target.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/interfaces/i_component.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for a component that has a handler for when a\n * block is dropped on top of it.\n */\n\n\n\n/**\n * The interface for a component that has a handler for when a\n * block is dropped on top of it.\n * @namespace Blockly.IDragTarget\n */\ngoog.module('Blockly.IDragTarget');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {IComponent} = goog.require('Blockly.IComponent');\n/* eslint-disable-next-line no-unused-vars */\nconst {IDraggable} = goog.requireType('Blockly.IDraggable');\n/* eslint-disable-next-line no-unused-vars */\nconst {Rect} = goog.requireType('Blockly.utils.Rect');\n\n\n/**\n * Interface for a component with custom behaviour when a block or bubble is\n * dragged over or dropped on top of it.\n * @extends {IComponent}\n * @interface\n * @alias Blockly.IDragTarget\n */\nconst IDragTarget = function() {};\n\n/**\n * Returns the bounding rectangle of the drag target area in pixel units\n * relative to viewport.\n * @return {?Rect} The component's bounding box. Null if drag\n *   target area should be ignored.\n */\nIDragTarget.prototype.getClientRect;\n\n/**\n * Handles when a cursor with a block or bubble enters this drag target.\n * @param {!IDraggable} dragElement The block or bubble currently being\n *   dragged.\n */\nIDragTarget.prototype.onDragEnter;\n\n/**\n * Handles when a cursor with a block or bubble is dragged over this drag\n * target.\n * @param {!IDraggable} dragElement The block or bubble currently being\n *   dragged.\n */\nIDragTarget.prototype.onDragOver;\n\n\n/**\n * Handles when a cursor with a block or bubble exits this drag target.\n * @param {!IDraggable} dragElement The block or bubble currently being\n *   dragged.\n */\nIDragTarget.prototype.onDragExit;\n\n/**\n * Handles when a block or bubble is dropped on this component.\n * Should not handle delete here.\n * @param {!IDraggable} dragElement The block or bubble currently being\n *   dragged.\n */\nIDragTarget.prototype.onDrop;\n\n/**\n * Returns whether the provided block or bubble should not be moved after being\n * dropped on this component. If true, the element will return to where it was\n * when the drag started.\n * @param {!IDraggable} dragElement The block or bubble currently being\n *   dragged.\n * @return {boolean} Whether the block or bubble provided should be returned to\n *     drag start.\n */\nIDragTarget.prototype.shouldPreventMove;\n\nexports.IDragTarget = IDragTarget;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_drag_target.js?")},
"./core/interfaces/i_draggable.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/interfaces/i_deletable.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for an object that is draggable.\n */\n\n\n\n/**\n * The interface for an object that is draggable.\n * @namespace Blockly.IDraggable\n */\ngoog.module('Blockly.IDraggable');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {IDeletable} = goog.require('Blockly.IDeletable');\n\n\n/**\n * The interface for an object that can be dragged.\n * @extends {IDeletable}\n * @interface\n * @alias Blockly.IDraggable\n */\nconst IDraggable = function() {};\n\nexports.IDraggable = IDraggable;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_draggable.js?")},
"./core/interfaces/i_flyout.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/interfaces/i_registrable.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for a flyout.\n */\n\n\n\n/**\n * The interface for a flyout.\n * @namespace Blockly.IFlyout\n */\ngoog.module('Blockly.IFlyout');\n\n/* eslint-disable-next-line no-unused-vars */\nconst toolbox = goog.requireType('Blockly.utils.toolbox');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Coordinate} = goog.requireType('Blockly.utils.Coordinate');\n/* eslint-disable-next-line no-unused-vars */\nconst {IRegistrable} = goog.require('Blockly.IRegistrable');\n/* eslint-disable-next-line no-unused-vars */\nconst {Svg} = goog.requireType('Blockly.utils.Svg');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * Interface for a flyout.\n * @extends {IRegistrable}\n * @interface\n * @alias Blockly.IFlyout\n */\nconst IFlyout = function() {};\n\n/**\n * Whether the flyout is laid out horizontally or not.\n * @type {boolean}\n */\nIFlyout.prototype.horizontalLayout;\n\n/**\n * Is RTL vs LTR.\n * @type {boolean}\n */\nIFlyout.prototype.RTL;\n\n/**\n * The target workspace\n * @type {?WorkspaceSvg}\n */\nIFlyout.prototype.targetWorkspace;\n\n/**\n * Margin around the edges of the blocks in the flyout.\n * @type {number}\n * @const\n */\nIFlyout.prototype.MARGIN;\n\n/**\n * Does the flyout automatically close when a block is created?\n * @type {boolean}\n */\nIFlyout.prototype.autoClose;\n\n/**\n * Corner radius of the flyout background.\n * @type {number}\n * @const\n */\nIFlyout.prototype.CORNER_RADIUS;\n\n/**\n * Creates the flyout's DOM.  Only needs to be called once.  The flyout can\n * either exist as its own svg element or be a g element nested inside a\n * separate svg element.\n * @param {string|\n * !Svg<!SVGSVGElement>|\n * !Svg<!SVGGElement>} tagName The type of tag to\n *     put the flyout in. This should be <svg> or <g>.\n * @return {!SVGElement} The flyout's SVG group.\n */\nIFlyout.prototype.createDom;\n\n/**\n * Initializes the flyout.\n * @param {!WorkspaceSvg} targetWorkspace The workspace in which to\n *     create new blocks.\n */\nIFlyout.prototype.init;\n\n/**\n * Dispose of this flyout.\n * Unlink from all DOM elements to prevent memory leaks.\n */\nIFlyout.prototype.dispose;\n\n/**\n * Get the width of the flyout.\n * @return {number} The width of the flyout.\n */\nIFlyout.prototype.getWidth;\n\n/**\n * Get the height of the flyout.\n * @return {number} The width of the flyout.\n */\nIFlyout.prototype.getHeight;\n\n/**\n * Get the workspace inside the flyout.\n * @return {!WorkspaceSvg} The workspace inside the flyout.\n */\nIFlyout.prototype.getWorkspace;\n\n/**\n * Is the flyout visible?\n * @return {boolean} True if visible.\n */\nIFlyout.prototype.isVisible;\n\n/**\n * Set whether the flyout is visible. A value of true does not necessarily mean\n * that the flyout is shown. It could be hidden because its container is hidden.\n * @param {boolean} visible True if visible.\n */\nIFlyout.prototype.setVisible;\n\n/**\n * Set whether this flyout's container is visible.\n * @param {boolean} visible Whether the container is visible.\n */\nIFlyout.prototype.setContainerVisible;\n\n/**\n * Hide and empty the flyout.\n */\nIFlyout.prototype.hide;\n\n/**\n * Show and populate the flyout.\n * @param {!toolbox.FlyoutDefinition|string} flyoutDef Contents to\n *     display in the flyout. This is either an array of Nodes, a NodeList, a\n *     toolbox definition, or a string with the name of the dynamic category.\n */\nIFlyout.prototype.show;\n\n/**\n * Create a copy of this block on the workspace.\n * @param {!BlockSvg} originalBlock The block to copy from the flyout.\n * @return {!BlockSvg} The newly created block.\n * @throws {Error} if something went wrong with deserialization.\n */\nIFlyout.prototype.createBlock;\n\n/**\n * Reflow blocks and their mats.\n */\nIFlyout.prototype.reflow;\n\n/**\n * @return {boolean} True if this flyout may be scrolled with a scrollbar or by\n *     dragging.\n */\nIFlyout.prototype.isScrollable;\n\n/**\n * Calculates the x coordinate for the flyout position.\n * @return {number} X coordinate.\n */\nIFlyout.prototype.getX;\n\n/**\n * Calculates the y coordinate for the flyout position.\n * @return {number} Y coordinate.\n */\nIFlyout.prototype.getY;\n\n/**\n * Position the flyout.\n * @return {void}\n */\nIFlyout.prototype.position;\n\n/**\n * Determine if a drag delta is toward the workspace, based on the position\n * and orientation of the flyout. This is used in determineDragIntention_ to\n * determine if a new block should be created or if the flyout should scroll.\n * @param {!Coordinate} currentDragDeltaXY How far the pointer has\n *     moved from the position at mouse down, in pixel units.\n * @return {boolean} True if the drag is toward the workspace.\n */\nIFlyout.prototype.isDragTowardWorkspace;\n\nexports.IFlyout = IFlyout;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_flyout.js?")},
"./core/interfaces/i_keyboard_accessible.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for objects that handle keyboard shortcuts.\n */\n\n\n\n/**\n * The interface for objects that handle keyboard shortcuts.\n * @namespace Blockly.IKeyboardAccessible\n */\ngoog.module('Blockly.IKeyboardAccessible');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ShortcutRegistry} = goog.requireType('Blockly.ShortcutRegistry');\n\n\n/**\n * An interface for an object that handles keyboard shortcuts.\n * @interface\n * @alias Blockly.IKeyboardAccessible\n */\nconst IKeyboardAccessible = function() {};\n\n/**\n * Handles the given keyboard shortcut.\n * @param {!ShortcutRegistry.KeyboardShortcut} shortcut The shortcut to be\n *     handled.\n * @return {boolean} True if the shortcut has been handled, false otherwise.\n */\nIKeyboardAccessible.prototype.onShortcut;\n\nexports.IKeyboardAccessible = IKeyboardAccessible;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_keyboard_accessible.js?")},
"./core/interfaces/i_metrics_manager.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for a metrics manager.\n */\n\n\n\n/**\n * The interface for a metrics manager.\n * @namespace Blockly.IMetricsManager\n */\ngoog.module('Blockly.IMetricsManager');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {MetricsManager} = goog.requireType('Blockly.MetricsManager');\n/* eslint-disable-next-line no-unused-vars */\nconst {Metrics} = goog.requireType('Blockly.utils.Metrics');\n/* eslint-disable-next-line no-unused-vars */\nconst {Size} = goog.requireType('Blockly.utils.Size');\n\n\n/**\n * Interface for a metrics manager.\n * @interface\n * @alias Blockly.IMetricsManager\n */\nconst IMetricsManager = function() {};\n\n/**\n * Returns whether the scroll area has fixed edges.\n * @return {boolean} Whether the scroll area has fixed edges.\n * @package\n */\nIMetricsManager.prototype.hasFixedEdges;\n\n/**\n * Returns the metrics for the scroll area of the workspace.\n * @param {boolean=} opt_getWorkspaceCoordinates True to get the scroll metrics\n *     in workspace coordinates, false to get them in pixel coordinates.\n * @param {!MetricsManager.ContainerRegion=} opt_viewMetrics The view\n *     metrics if they have been previously computed. Passing in null may cause\n *     the view metrics to be computed again, if it is needed.\n * @param {!MetricsManager.ContainerRegion=} opt_contentMetrics The\n *     content metrics if they have been previously computed. Passing in null\n *     may cause the content metrics to be computed again, if it is needed.\n * @return {!MetricsManager.ContainerRegion} The metrics for the scroll\n *    container\n */\nIMetricsManager.prototype.getScrollMetrics;\n\n/**\n * Gets the width and the height of the flyout on the workspace in pixel\n * coordinates. Returns 0 for the width and height if the workspace has a\n * category toolbox instead of a simple toolbox.\n * @param {boolean=} opt_own Whether to only return the workspace's own flyout.\n * @return {!MetricsManager.ToolboxMetrics} The width and height of the\n *     flyout.\n * @public\n */\nIMetricsManager.prototype.getFlyoutMetrics;\n\n/**\n * Gets the width, height and position of the toolbox on the workspace in pixel\n * coordinates. Returns 0 for the width and height if the workspace has a simple\n * toolbox instead of a category toolbox. To get the width and height of a\n * simple toolbox @see {@link getFlyoutMetrics}.\n * @return {!MetricsManager.ToolboxMetrics} The object with the width,\n *     height and position of the toolbox.\n * @public\n */\nIMetricsManager.prototype.getToolboxMetrics;\n\n/**\n * Gets the width and height of the workspace's parent SVG element in pixel\n * coordinates. This area includes the toolbox and the visible workspace area.\n * @return {!Size} The width and height of the workspace's parent\n *     SVG element.\n * @public\n */\nIMetricsManager.prototype.getSvgMetrics;\n\n/**\n * Gets the absolute left and absolute top in pixel coordinates.\n * This is where the visible workspace starts in relation to the SVG container.\n * @return {!MetricsManager.AbsoluteMetrics} The absolute metrics for\n *     the workspace.\n * @public\n */\nIMetricsManager.prototype.getAbsoluteMetrics;\n\n/**\n * Gets the metrics for the visible workspace in either pixel or workspace\n * coordinates. The visible workspace does not include the toolbox or flyout.\n * @param {boolean=} opt_getWorkspaceCoordinates True to get the view metrics in\n *     workspace coordinates, false to get them in pixel coordinates.\n * @return {!MetricsManager.ContainerRegion} The width, height, top and\n *     left of the viewport in either workspace coordinates or pixel\n *     coordinates.\n * @public\n */\nIMetricsManager.prototype.getViewMetrics;\n\n/**\n * Gets content metrics in either pixel or workspace coordinates.\n * The content area is a rectangle around all the top bounded elements on the\n * workspace (workspace comments and blocks).\n * @param {boolean=} opt_getWorkspaceCoordinates True to get the content metrics\n *     in workspace coordinates, false to get them in pixel coordinates.\n * @return {!MetricsManager.ContainerRegion} The\n *     metrics for the content container.\n * @public\n */\nIMetricsManager.prototype.getContentMetrics;\n\n/**\n * Returns an object with all the metrics required to size scrollbars for a\n * top level workspace.  The following properties are computed:\n * Coordinate system: pixel coordinates, -left, -up, +right, +down\n * .viewHeight: Height of the visible portion of the workspace.\n * .viewWidth: Width of the visible portion of the workspace.\n * .contentHeight: Height of the content.\n * .contentWidth: Width of the content.\n * .svgHeight: Height of the Blockly div (the view + the toolbox,\n *    simple or otherwise),\n * .svgWidth: Width of the Blockly div (the view + the toolbox,\n *    simple or otherwise),\n * .viewTop: Top-edge of the visible portion of the workspace, relative to\n *     the workspace origin.\n * .viewLeft: Left-edge of the visible portion of the workspace, relative to\n *     the workspace origin.\n * .contentTop: Top-edge of the content, relative to the workspace origin.\n * .contentLeft: Left-edge of the content relative to the workspace origin.\n * .absoluteTop: Top-edge of the visible portion of the workspace, relative\n *     to the blocklyDiv.\n * .absoluteLeft: Left-edge of the visible portion of the workspace, relative\n *     to the blocklyDiv.\n * .toolboxWidth: Width of the toolbox, if it exists.  Otherwise zero.\n * .toolboxHeight: Height of the toolbox, if it exists.  Otherwise zero.\n * .flyoutWidth: Width of the flyout if it is always open.  Otherwise zero.\n * .flyoutHeight: Height of the flyout if it is always open.  Otherwise zero.\n * .toolboxPosition: Top, bottom, left or right. Use TOOLBOX_AT constants to\n *     compare.\n * @return {!Metrics} Contains size and position metrics of a top\n *     level workspace.\n * @public\n */\nIMetricsManager.prototype.getMetrics;\n\nexports.IMetricsManager = IMetricsManager;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_metrics_manager.js?")},
"./core/interfaces/i_movable.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for an object that is movable.\n */\n\n\n\n/**\n * The interface for an object that is movable.\n * @namespace Blockly.IMovable\n */\ngoog.module('Blockly.IMovable');\n\n\n/**\n * The interface for an object that is movable.\n * @interface\n * @alias Blockly.IMovable\n */\nconst IMovable = function() {};\n\n/**\n * Get whether this is movable or not.\n * @return {boolean} True if movable.\n */\nIMovable.prototype.isMovable;\n\nexports.IMovable = IMovable;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_movable.js?")},
"./core/interfaces/i_positionable.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/interfaces/i_component.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for a positionable UI element.\n */\n\n\n\n/**\n * The interface for a positionable UI element.\n * @namespace Blockly.IPositionable\n */\ngoog.module('Blockly.IPositionable');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {IComponent} = goog.require('Blockly.IComponent');\n/* eslint-disable-next-line no-unused-vars */\nconst {MetricsManager} = goog.requireType('Blockly.MetricsManager');\n/* eslint-disable-next-line no-unused-vars */\nconst {Rect} = goog.requireType('Blockly.utils.Rect');\n\n\n/**\n * Interface for a component that is positioned on top of the workspace.\n * @extends {IComponent}\n * @interface\n * @alias Blockly.IPositionable\n */\nconst IPositionable = function() {};\n\n/**\n * Positions the element. Called when the window is resized.\n * @param {!MetricsManager.UiMetrics} metrics The workspace metrics.\n * @param {!Array<!Rect>} savedPositions List of rectangles that\n *     are already on the workspace.\n */\nIPositionable.prototype.position;\n\n/**\n * Returns the bounding rectangle of the UI element in pixel units relative to\n * the Blockly injection div.\n * @return {?Rect} The UI elements's bounding box. Null if\n *   bounding box should be ignored by other UI elements.\n */\nIPositionable.prototype.getBoundingRectangle;\n\nexports.IPositionable = IPositionable;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_positionable.js?")},
"./core/interfaces/i_registrable.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for a Blockly component that can be registered.\n *    (Ex. Toolbox, Fields, Renderers)\n */\n\n\n\n/**\n * The interface for a Blockly component that can be registered.\n *    (Ex. Toolbox, Fields, Renderers)\n * @namespace Blockly.IRegistrable\n */\ngoog.module('Blockly.IRegistrable');\n\n\n/**\n * The interface for a Blockly component that can be registered.\n * @interface\n * @alias Blockly.IRegistrable\n */\nconst IRegistrable = function() {};\n\nexports.IRegistrable = IRegistrable;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_registrable.js?")},
"./core/interfaces/i_registrable_field.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for a Blockly field that can be registered.\n */\n\n\n\n/**\n * The interface for a Blockly field that can be registered.\n * @namespace Blockly.IRegistrableField\n */\ngoog.module('Blockly.IRegistrableField');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {Field} = goog.requireType('Blockly.Field');\n\n\n/**\n * A registrable field.\n * Note: We are not using an interface here as we are interested in defining the\n * static methods of a field rather than the instance methods.\n * @typedef {{\n *     fromJson:IRegistrableField.fromJson\n * }}\n * @alias Blockly.IRegistrableField\n */\nconst IRegistrableField = {};\n\n/**\n * @typedef {function(!Object): Field}\n */\nIRegistrableField.fromJson;\n\nexports.IRegistrableField = IRegistrableField;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_registrable_field.js?")},
"./core/interfaces/i_selectable.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/interfaces/i_deletable.js\");\n__webpack_require__(\"./core/interfaces/i_movable.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for an object that is selectable.\n */\n\n\n\n/**\n * The interface for an object that is selectable.\n * @namespace Blockly.ISelectable\n */\ngoog.module('Blockly.ISelectable');\n\n// eslint-disable-next-line no-unused-vars\nconst {IDeletable} = goog.require('Blockly.IDeletable');\n// eslint-disable-next-line no-unused-vars\nconst {IMovable} = goog.require('Blockly.IMovable');\n\n\n/**\n * The interface for an object that is selectable.\n * @extends {IDeletable}\n * @extends {IMovable}\n * @interface\n * @alias Blockly.ISelectable\n */\nconst ISelectable = function() {};\n\n/**\n * @type {string}\n */\nISelectable.prototype.id;\n\n/**\n * Select this.  Highlight it visually.\n * @return {void}\n */\nISelectable.prototype.select;\n\n/**\n * Unselect this.  Unhighlight it visually.\n * @return {void}\n */\nISelectable.prototype.unselect;\n\nexports.ISelectable = ISelectable;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_selectable.js?")},
"./core/interfaces/i_selectable_toolbox_item.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/interfaces/i_toolbox_item.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for a selectable toolbox item.\n */\n\n\n\n/**\n * The interface for a selectable toolbox item.\n * @namespace Blockly.ISelectableToolboxItem\n */\ngoog.module('Blockly.ISelectableToolboxItem');\n\n/* eslint-disable-next-line no-unused-vars */\nconst toolbox = goog.requireType('Blockly.utils.toolbox');\n/* eslint-disable-next-line no-unused-vars */\nconst {IToolboxItem} = goog.require('Blockly.IToolboxItem');\n\n\n/**\n * Interface for an item in the toolbox that can be selected.\n * @extends {IToolboxItem}\n * @interface\n * @alias Blockly.ISelectableToolboxItem\n */\nconst ISelectableToolboxItem = function() {};\n\n/**\n * Gets the name of the toolbox item. Used for emitting events.\n * @return {string} The name of the toolbox item.\n * @public\n */\nISelectableToolboxItem.prototype.getName;\n\n/**\n * Gets the contents of the toolbox item. These are items that are meant to be\n * displayed in the flyout.\n * @return {!toolbox.FlyoutItemInfoArray|string} The definition\n *     of items to be displayed in the flyout.\n * @public\n */\nISelectableToolboxItem.prototype.getContents;\n\n/**\n * Sets the current toolbox item as selected.\n * @param {boolean} _isSelected True if this category is selected, false\n *     otherwise.\n * @public\n */\nISelectableToolboxItem.prototype.setSelected;\n\n/**\n * Gets the HTML element that is clickable.\n * The parent toolbox element receives clicks. The parent toolbox will add an ID\n * to this element so it can pass the onClick event to the correct toolboxItem.\n * @return {!Element} The HTML element that receives clicks.\n * @public\n */\nISelectableToolboxItem.prototype.getClickTarget;\n\n/**\n * Handles when the toolbox item is clicked.\n * @param {!Event} _e Click event to handle.\n * @public\n */\nISelectableToolboxItem.prototype.onClick;\n\nexports.ISelectableToolboxItem = ISelectableToolboxItem;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_selectable_toolbox_item.js?")},
"./core/interfaces/i_serializer.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The record type for an object containing functions for\n * serializing part of the workspace.\n */\n\n\n\n/**\n * The record type for an object containing functions for\n *     serializing part of the workspace.\n * @namespace Blockly.serialization.ISerializer\n */\ngoog.module('Blockly.serialization.ISerializer');\n\n// eslint-disable-next-line no-unused-vars\nconst {Workspace} = goog.requireType('Blockly.Workspace');\n\n\n/**\n * Serializes and deserializes a plugin or system.\n * @interface\n * @alias Blockly.serialization.ISerializer.ISerializer\n */\nclass ISerializer {\n  /* eslint-disable-next-line require-jsdoc */\n  constructor() {\n    /**\n     * A priority value used to determine the order of deserializing state.\n     * More positive priorities are deserialized before less positive\n     * priorities. Eg if you have priorities (0, -10, 10, 100) the order of\n     * deserialiation will be (100, 10, 0, -10).\n     * If two serializers have the same priority, they are deserialized in an\n     * arbitrary order relative to each other.\n     * @type {number}\n     */\n    this.priority;\n  }\n\n  /* eslint-disable no-unused-vars, valid-jsdoc */\n\n  /**\n   * Saves the state of the plugin or system.\n   * @param {!Workspace} workspace The workspace the system to serialize is\n   *     associated with.\n   * @return {?} A JS object containing the system's state, or null if\n   *     there is no state to record.\n   */\n  save(workspace) {}\n\n  /* eslint-enable valid-jsdoc */\n\n  /**\n   * Loads the state of the plugin or system.\n   * @param {?} state The state of the system to deserialize. This will always\n   *     be non-null.\n   * @param {!Workspace} workspace The workspace the system to deserialize is\n   *     associated with.\n   */\n  load(state, workspace) {}\n\n  /**\n   * Clears the state of the plugin or system.\n   * @param {!Workspace} workspace The workspace the system to clear the state\n   *     of is associated with.\n   */\n  clear(workspace) {}\n\n  /* eslint-enable no-unused-vars */\n}\n\nexports.ISerializer = ISerializer;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_serializer.js?")},
"./core/interfaces/i_styleable.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for an object that a style can be added to.\n */\n\n\n\n/**\n * The interface for an object that a style can be added to.\n * @namespace Blockly.IStyleable\n */\ngoog.module('Blockly.IStyleable');\n\n\n/**\n * Interface for an object that a style can be added to.\n * @interface\n * @alias Blockly.IStyleable\n */\nconst IStyleable = function() {};\n\n/**\n * Adds a style on the toolbox. Usually used to change the cursor.\n * @param {string} style The name of the class to add.\n */\nIStyleable.prototype.addStyle;\n\n/**\n * Removes a style from the toolbox. Usually used to change the cursor.\n * @param {string} style The name of the class to remove.\n */\nIStyleable.prototype.removeStyle;\n\nexports.IStyleable = IStyleable;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_styleable.js?")},
"./core/interfaces/i_toolbox.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/interfaces/i_registrable.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for a toolbox.\n */\n\n\n\n/**\n * The interface for a toolbox.\n * @namespace Blockly.IToolbox\n */\ngoog.module('Blockly.IToolbox');\n\n/* eslint-disable-next-line no-unused-vars */\nconst toolbox = goog.requireType('Blockly.utils.toolbox');\n/* eslint-disable-next-line no-unused-vars */\nconst {IFlyout} = goog.requireType('Blockly.IFlyout');\n/* eslint-disable-next-line no-unused-vars */\nconst {IRegistrable} = goog.require('Blockly.IRegistrable');\n/* eslint-disable-next-line no-unused-vars */\nconst {IToolboxItem} = goog.requireType('Blockly.IToolboxItem');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * Interface for a toolbox.\n * @extends {IRegistrable}\n * @interface\n * @alias Blockly.IToolbox\n */\nconst IToolbox = function() {};\n\n/**\n * Initializes the toolbox.\n * @return {void}\n */\nIToolbox.prototype.init;\n\n/**\n * Fills the toolbox with new toolbox items and removes any old contents.\n * @param {!toolbox.ToolboxInfo} toolboxDef Object holding information\n *     for creating a toolbox.\n */\nIToolbox.prototype.render;\n\n/**\n * Gets the width of the toolbox.\n * @return {number} The width of the toolbox.\n */\nIToolbox.prototype.getWidth;\n\n/**\n * Gets the height of the toolbox.\n * @return {number} The width of the toolbox.\n */\nIToolbox.prototype.getHeight;\n\n/**\n * Gets the toolbox flyout.\n * @return {?IFlyout} The toolbox flyout.\n */\nIToolbox.prototype.getFlyout;\n\n/**\n * Gets the workspace for the toolbox.\n * @return {!WorkspaceSvg} The parent workspace for the toolbox.\n */\nIToolbox.prototype.getWorkspace;\n\n/**\n * Gets whether or not the toolbox is horizontal.\n * @return {boolean} True if the toolbox is horizontal, false if the toolbox is\n *     vertical.\n */\nIToolbox.prototype.isHorizontal;\n\n/**\n * Positions the toolbox based on whether it is a horizontal toolbox and whether\n * the workspace is in rtl.\n * @return {void}\n */\nIToolbox.prototype.position;\n\n/**\n * Handles resizing the toolbox when a toolbox item resizes.\n * @return {void}\n */\nIToolbox.prototype.handleToolboxItemResize;\n\n/**\n * Unhighlights any previously selected item.\n * @return {void}\n */\nIToolbox.prototype.clearSelection;\n\n/**\n * Updates the category colours and background colour of selected categories.\n * @return {void}\n */\nIToolbox.prototype.refreshTheme;\n\n/**\n * Updates the flyout's content without closing it.  Should be used in response\n * to a change in one of the dynamic categories, such as variables or\n * procedures.\n * @return {void}\n */\nIToolbox.prototype.refreshSelection;\n\n/**\n * Sets the visibility of the toolbox.\n * @param {boolean} isVisible True if toolbox should be visible.\n */\nIToolbox.prototype.setVisible;\n\n/**\n * Selects the toolbox item by it's position in the list of toolbox items.\n * @param {number} position The position of the item to select.\n * @return {void}\n */\nIToolbox.prototype.selectItemByPosition;\n\n/**\n * Gets the selected item.\n * @return {?IToolboxItem} The selected item, or null if no item is\n *     currently selected.\n */\nIToolbox.prototype.getSelectedItem;\n\n/**\n * Disposes of this toolbox.\n * @return {void}\n */\nIToolbox.prototype.dispose;\n\nexports.IToolbox = IToolbox;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_toolbox.js?")},
"./core/interfaces/i_toolbox_item.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for a toolbox item.\n */\n\n\n\n/**\n * The interface for a toolbox item.\n * @namespace Blockly.IToolboxItem\n */\ngoog.module('Blockly.IToolboxItem');\n\n\n/**\n * Interface for an item in the toolbox.\n * @interface\n * @alias Blockly.IToolboxItem\n */\nconst IToolboxItem = function() {};\n\n/**\n * Initializes the toolbox item.\n * This includes creating the DOM and updating the state of any items based\n * on the info object.\n * @return {void}\n * @public\n */\nIToolboxItem.prototype.init;\n\n/**\n * Gets the div for the toolbox item.\n * @return {?Element} The div for the toolbox item.\n * @public\n */\nIToolboxItem.prototype.getDiv;\n\n/**\n * Gets a unique identifier for this toolbox item.\n * @return {string} The ID for the toolbox item.\n * @public\n */\nIToolboxItem.prototype.getId;\n\n/**\n * Gets the parent if the toolbox item is nested.\n * @return {?IToolboxItem} The parent toolbox item, or null if\n *     this toolbox item is not nested.\n * @public\n */\nIToolboxItem.prototype.getParent;\n\n/**\n * Gets the nested level of the category.\n * @return {number} The nested level of the category.\n * @package\n */\nIToolboxItem.prototype.getLevel;\n\n/**\n * Whether the toolbox item is selectable.\n * @return {boolean} True if the toolbox item can be selected.\n * @public\n */\nIToolboxItem.prototype.isSelectable;\n\n/**\n * Whether the toolbox item is collapsible.\n * @return {boolean} True if the toolbox item is collapsible.\n * @public\n */\nIToolboxItem.prototype.isCollapsible;\n\n/**\n * Dispose of this toolbox item. No-op by default.\n * @public\n */\nIToolboxItem.prototype.dispose;\n\nexports.IToolboxItem = IToolboxItem;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/interfaces/i_toolbox_item.js?")},
"./core/internal_constants.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/connection_type.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Module that provides constants for use inside Blockly. Do not\n * use these constants outside of the core library.\n * @package\n */\n\n\n/**\n * Module that provides constants for use inside Blockly. Do not\n * use these constants outside of the core library.\n * @namespace Blockly.internalConstants\n */\ngoog.module('Blockly.internalConstants');\n\nconst {ConnectionType} = goog.require('Blockly.ConnectionType');\n\n\n/**\n * Number of characters to truncate a collapsed block to.\n * @alias Blockly.internalConstants.COLLAPSE_CHARS\n */\nconst COLLAPSE_CHARS = 30;\nexports.COLLAPSE_CHARS = COLLAPSE_CHARS;\n\n/**\n * When dragging a block out of a stack, split the stack in two (true), or drag\n * out the block healing the stack (false).\n * @alias Blockly.internalConstants.DRAG_STACK\n */\nconst DRAG_STACK = true;\nexports.DRAG_STACK = DRAG_STACK;\n\n/**\n * Lookup table for determining the opposite type of a connection.\n * @const\n * @alias Blockly.internalConstants.OPPOSITE_TYPE\n */\nconst OPPOSITE_TYPE = [];\nOPPOSITE_TYPE[ConnectionType.INPUT_VALUE] = ConnectionType.OUTPUT_VALUE;\nOPPOSITE_TYPE[ConnectionType.OUTPUT_VALUE] = ConnectionType.INPUT_VALUE;\nOPPOSITE_TYPE[ConnectionType.NEXT_STATEMENT] =\n    ConnectionType.PREVIOUS_STATEMENT;\nOPPOSITE_TYPE[ConnectionType.PREVIOUS_STATEMENT] =\n    ConnectionType.NEXT_STATEMENT;\n\nexports.OPPOSITE_TYPE = OPPOSITE_TYPE;\n\n/**\n * String for use in the dropdown created in field_variable.\n * This string indicates that this option in the dropdown is 'Rename\n * variable...' and if selected, should trigger the prompt to rename a variable.\n * @const {string}\n * @alias Blockly.internalConstants.RENAME_VARIABLE_ID\n */\nconst RENAME_VARIABLE_ID = 'RENAME_VARIABLE_ID';\nexports.RENAME_VARIABLE_ID = RENAME_VARIABLE_ID;\n\n/**\n * String for use in the dropdown created in field_variable.\n * This string indicates that this option in the dropdown is 'Delete the \"%1\"\n * variable' and if selected, should trigger the prompt to delete a variable.\n * @const {string}\n * @alias Blockly.internalConstants.DELETE_VARIABLE_ID\n */\nconst DELETE_VARIABLE_ID = 'DELETE_VARIABLE_ID';\nexports.DELETE_VARIABLE_ID = DELETE_VARIABLE_ID;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/internal_constants.js?")},
"./core/keyboard_nav/ast_node.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/connection_type.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing an AST node.\n * Used to traverse the Blockly AST.\n */\n\n\n/**\n * The class representing an AST node.\n * Used to traverse the Blockly AST.\n * @class\n */\ngoog.module('Blockly.ASTNode');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\nconst {ConnectionType} = goog.require('Blockly.ConnectionType');\n/* eslint-disable-next-line no-unused-vars */\nconst {Connection} = goog.requireType('Blockly.Connection');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\n/* eslint-disable-next-line no-unused-vars */\nconst {Field} = goog.requireType('Blockly.Field');\n/* eslint-disable-next-line no-unused-vars */\nconst {IASTNodeLocationWithBlock} = goog.requireType('Blockly.IASTNodeLocationWithBlock');\n/* eslint-disable-next-line no-unused-vars */\nconst {IASTNodeLocation} = goog.requireType('Blockly.IASTNodeLocation');\n/* eslint-disable-next-line no-unused-vars */\nconst {Input} = goog.requireType('Blockly.Input');\n/* eslint-disable-next-line no-unused-vars */\nconst {Workspace} = goog.requireType('Blockly.Workspace');\n\n\n/**\n * Class for an AST node.\n * It is recommended that you use one of the createNode methods instead of\n * creating a node directly.\n * @alias Blockly.ASTNode\n */\nclass ASTNode {\n  /**\n   * @param {string} type The type of the location.\n   *     Must be in ASTNode.types.\n   * @param {!IASTNodeLocation} location The position in the AST.\n   * @param {!ASTNode.Params=} opt_params Optional dictionary of options.\n   * @alias Blockly.ASTNode\n   */\n  constructor(type, location, opt_params) {\n    if (!location) {\n      throw Error('Cannot create a node without a location.');\n    }\n\n    /**\n     * The type of the location.\n     * One of ASTNode.types\n     * @type {string}\n     * @private\n     */\n    this.type_ = type;\n\n    /**\n     * Whether the location points to a connection.\n     * @type {boolean}\n     * @private\n     */\n    this.isConnection_ = ASTNode.isConnectionType_(type);\n\n    /**\n     * The location of the AST node.\n     * @type {!IASTNodeLocation}\n     * @private\n     */\n    this.location_ = location;\n\n    /**\n     * The coordinate on the workspace.\n     * @type {Coordinate}\n     * @private\n     */\n    this.wsCoordinate_ = null;\n\n    this.processParams_(opt_params || null);\n  }\n\n  /**\n   * Parse the optional parameters.\n   * @param {?ASTNode.Params} params The user specified parameters.\n   * @private\n   */\n  processParams_(params) {\n    if (!params) {\n      return;\n    }\n    if (params.wsCoordinate) {\n      this.wsCoordinate_ = params.wsCoordinate;\n    }\n  }\n\n  /**\n   * Gets the value pointed to by this node.\n   * It is the callers responsibility to check the node type to figure out what\n   * type of object they get back from this.\n   * @return {!IASTNodeLocation} The current field, connection, workspace, or\n   *     block the cursor is on.\n   */\n  getLocation() {\n    return this.location_;\n  }\n\n  /**\n   * The type of the current location.\n   * One of ASTNode.types\n   * @return {string} The type of the location.\n   */\n  getType() {\n    return this.type_;\n  }\n\n  /**\n   * The coordinate on the workspace.\n   * @return {Coordinate} The workspace coordinate or null if the\n   *     location is not a workspace.\n   */\n  getWsCoordinate() {\n    return this.wsCoordinate_;\n  }\n\n  /**\n   * Whether the node points to a connection.\n   * @return {boolean} [description]\n   * @package\n   */\n  isConnection() {\n    return this.isConnection_;\n  }\n\n  /**\n   * Given an input find the next editable field or an input with a non null\n   * connection in the same block. The current location must be an input\n   * connection.\n   * @return {ASTNode} The AST node holding the next field or connection\n   *     or null if there is no editable field or input connection after the\n   * given input.\n   * @private\n   */\n  findNextForInput_() {\n    const location = /** @type {!Connection} */ (this.location_);\n    const parentInput = location.getParentInput();\n    const block = parentInput.getSourceBlock();\n    const curIdx = block.inputList.indexOf(parentInput);\n    for (let i = curIdx + 1; i < block.inputList.length; i++) {\n      const input = block.inputList[i];\n      const fieldRow = input.fieldRow;\n      for (let j = 0; j < fieldRow.length; j++) {\n        const field = fieldRow[j];\n        if (field.isClickable() || ASTNode.NAVIGATE_ALL_FIELDS) {\n          return ASTNode.createFieldNode(field);\n        }\n      }\n      if (input.connection) {\n        return ASTNode.createInputNode(input);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Given a field find the next editable field or an input with a non null\n   * connection in the same block. The current location must be a field.\n   * @return {ASTNode} The AST node pointing to the next field or\n   *     connection or null if there is no editable field or input connection\n   *     after the given input.\n   * @private\n   */\n  findNextForField_() {\n    const location = /** @type {!Field} */ (this.location_);\n    const input = location.getParentInput();\n    const block = location.getSourceBlock();\n    const curIdx = block.inputList.indexOf(/** @type {!Input} */ (input));\n    let fieldIdx = input.fieldRow.indexOf(location) + 1;\n    for (let i = curIdx; i < block.inputList.length; i++) {\n      const newInput = block.inputList[i];\n      const fieldRow = newInput.fieldRow;\n      while (fieldIdx < fieldRow.length) {\n        if (fieldRow[fieldIdx].isClickable() || ASTNode.NAVIGATE_ALL_FIELDS) {\n          return ASTNode.createFieldNode(fieldRow[fieldIdx]);\n        }\n        fieldIdx++;\n      }\n      fieldIdx = 0;\n      if (newInput.connection) {\n        return ASTNode.createInputNode(newInput);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Given an input find the previous editable field or an input with a non null\n   * connection in the same block. The current location must be an input\n   * connection.\n   * @return {ASTNode} The AST node holding the previous field or\n   *     connection.\n   * @private\n   */\n  findPrevForInput_() {\n    const location = /** @type {!Connection} */ (this.location_);\n    const parentInput = location.getParentInput();\n    const block = parentInput.getSourceBlock();\n    const curIdx = block.inputList.indexOf(parentInput);\n    for (let i = curIdx; i >= 0; i--) {\n      const input = block.inputList[i];\n      if (input.connection && input !== parentInput) {\n        return ASTNode.createInputNode(input);\n      }\n      const fieldRow = input.fieldRow;\n      for (let j = fieldRow.length - 1; j >= 0; j--) {\n        const field = fieldRow[j];\n        if (field.isClickable() || ASTNode.NAVIGATE_ALL_FIELDS) {\n          return ASTNode.createFieldNode(field);\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Given a field find the previous editable field or an input with a non null\n   * connection in the same block. The current location must be a field.\n   * @return {ASTNode} The AST node holding the previous input or field.\n   * @private\n   */\n  findPrevForField_() {\n    const location = /** @type {!Field} */ (this.location_);\n    const parentInput = location.getParentInput();\n    const block = location.getSourceBlock();\n    const curIdx = block.inputList.indexOf(\n        /** @type {!Input} */ (parentInput));\n    let fieldIdx = parentInput.fieldRow.indexOf(location) - 1;\n    for (let i = curIdx; i >= 0; i--) {\n      const input = block.inputList[i];\n      if (input.connection && input !== parentInput) {\n        return ASTNode.createInputNode(input);\n      }\n      const fieldRow = input.fieldRow;\n      while (fieldIdx > -1) {\n        if (fieldRow[fieldIdx].isClickable() || ASTNode.NAVIGATE_ALL_FIELDS) {\n          return ASTNode.createFieldNode(fieldRow[fieldIdx]);\n        }\n        fieldIdx--;\n      }\n      // Reset the fieldIdx to the length of the field row of the previous\n      // input.\n      if (i - 1 >= 0) {\n        fieldIdx = block.inputList[i - 1].fieldRow.length - 1;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Navigate between stacks of blocks on the workspace.\n   * @param {boolean} forward True to go forward. False to go backwards.\n   * @return {ASTNode} The first block of the next stack or null if there\n   * are no blocks on the workspace.\n   * @private\n   */\n  navigateBetweenStacks_(forward) {\n    let curLocation = this.getLocation();\n    if (curLocation.getSourceBlock) {\n      curLocation = /** @type {!IASTNodeLocationWithBlock} */ (curLocation)\n                        .getSourceBlock();\n    }\n    if (!curLocation || !curLocation.workspace) {\n      return null;\n    }\n    const curRoot = curLocation.getRootBlock();\n    const topBlocks = curRoot.workspace.getTopBlocks(true);\n    for (let i = 0; i < topBlocks.length; i++) {\n      const topBlock = topBlocks[i];\n      if (curRoot.id === topBlock.id) {\n        const offset = forward ? 1 : -1;\n        const resultIndex = i + offset;\n        if (resultIndex === -1 || resultIndex === topBlocks.length) {\n          return null;\n        }\n        return ASTNode.createStackNode(topBlocks[resultIndex]);\n      }\n    }\n    throw Error(\n        'Couldn\\'t find ' + (forward ? 'next' : 'previous') + ' stack?!');\n  }\n\n  /**\n   * Finds the top most AST node for a given block.\n   * This is either the previous connection, output connection or block\n   * depending on what kind of connections the block has.\n   * @param {!Block} block The block that we want to find the top\n   *     connection on.\n   * @return {!ASTNode} The AST node containing the top connection.\n   * @private\n   */\n  findTopASTNodeForBlock_(block) {\n    const topConnection = getParentConnection(block);\n    if (topConnection) {\n      return /** @type {!ASTNode} */ (\n          ASTNode.createConnectionNode(topConnection));\n    } else {\n      return /** @type {!ASTNode} */ (ASTNode.createBlockNode(block));\n    }\n  }\n\n  /**\n   * Get the AST node pointing to the input that the block is nested under or if\n   * the block is not nested then get the stack AST node.\n   * @param {Block} block The source block of the current location.\n   * @return {ASTNode} The AST node pointing to the input connection or\n   *     the top block of the stack this block is in.\n   * @private\n   */\n  getOutAstNodeForBlock_(block) {\n    if (!block) {\n      return null;\n    }\n    // If the block doesn't have a previous connection then it is the top of the\n    // substack.\n    const topBlock = block.getTopStackBlock();\n    const topConnection = getParentConnection(topBlock);\n    // If the top connection has a parentInput, create an AST node pointing to\n    // that input.\n    if (topConnection && topConnection.targetConnection &&\n        topConnection.targetConnection.getParentInput()) {\n      return ASTNode.createInputNode(\n          topConnection.targetConnection.getParentInput());\n    } else {\n      // Go to stack level if you are not underneath an input.\n      return ASTNode.createStackNode(topBlock);\n    }\n  }\n\n  /**\n   * Find the first editable field or input with a connection on a given block.\n   * @param {!Block} block The source block of the current location.\n   * @return {ASTNode} An AST node pointing to the first field or input.\n   * Null if there are no editable fields or inputs with connections on the\n   * block.\n   * @private\n   */\n  findFirstFieldOrInput_(block) {\n    const inputs = block.inputList;\n    for (let i = 0; i < inputs.length; i++) {\n      const input = inputs[i];\n      const fieldRow = input.fieldRow;\n      for (let j = 0; j < fieldRow.length; j++) {\n        const field = fieldRow[j];\n        if (field.isClickable() || ASTNode.NAVIGATE_ALL_FIELDS) {\n          return ASTNode.createFieldNode(field);\n        }\n      }\n      if (input.connection) {\n        return ASTNode.createInputNode(input);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Finds the source block of the location of this node.\n   * @return {Block} The source block of the location, or null if the node\n   * is of type workspace.\n   */\n  getSourceBlock() {\n    if (this.getType() === ASTNode.types.BLOCK) {\n      return /** @type {Block} */ (this.getLocation());\n    } else if (this.getType() === ASTNode.types.STACK) {\n      return /** @type {Block} */ (this.getLocation());\n    } else if (this.getType() === ASTNode.types.WORKSPACE) {\n      return null;\n    } else {\n      return /** @type {IASTNodeLocationWithBlock} */ (this.getLocation())\n          .getSourceBlock();\n    }\n  }\n\n  /**\n   * Find the element to the right of the current element in the AST.\n   * @return {ASTNode} An AST node that wraps the next field, connection,\n   *     block, or workspace. Or null if there is no node to the right.\n   */\n  next() {\n    switch (this.type_) {\n      case ASTNode.types.STACK:\n        return this.navigateBetweenStacks_(true);\n\n      case ASTNode.types.OUTPUT: {\n        const connection = /** @type {!Connection} */ (this.location_);\n        return ASTNode.createBlockNode(connection.getSourceBlock());\n      }\n      case ASTNode.types.FIELD:\n        return this.findNextForField_();\n\n      case ASTNode.types.INPUT:\n        return this.findNextForInput_();\n\n      case ASTNode.types.BLOCK: {\n        const block = /** @type {!Block} */ (this.location_);\n        const nextConnection = block.nextConnection;\n        return ASTNode.createConnectionNode(nextConnection);\n      }\n      case ASTNode.types.PREVIOUS: {\n        const connection = /** @type {!Connection} */ (this.location_);\n        return ASTNode.createBlockNode(connection.getSourceBlock());\n      }\n      case ASTNode.types.NEXT: {\n        const connection = /** @type {!Connection} */ (this.location_);\n        const targetConnection = connection.targetConnection;\n        return ASTNode.createConnectionNode(targetConnection);\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Find the element one level below and all the way to the left of the current\n   * location.\n   * @return {ASTNode} An AST node that wraps the next field, connection,\n   * workspace, or block. Or null if there is nothing below this node.\n   */\n  in() {\n    switch (this.type_) {\n      case ASTNode.types.WORKSPACE: {\n        const workspace = /** @type {!Workspace} */ (this.location_);\n        const topBlocks = workspace.getTopBlocks(true);\n        if (topBlocks.length > 0) {\n          return ASTNode.createStackNode(topBlocks[0]);\n        }\n        break;\n      }\n      case ASTNode.types.STACK: {\n        const block = /** @type {!Block} */ (this.location_);\n        return this.findTopASTNodeForBlock_(block);\n      }\n      case ASTNode.types.BLOCK: {\n        const block = /** @type {!Block} */ (this.location_);\n        return this.findFirstFieldOrInput_(block);\n      }\n      case ASTNode.types.INPUT: {\n        const connection = /** @type {!Connection} */ (this.location_);\n        const targetConnection = connection.targetConnection;\n        return ASTNode.createConnectionNode(targetConnection);\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Find the element to the left of the current element in the AST.\n   * @return {ASTNode} An AST node that wraps the previous field,\n   * connection, workspace or block. Or null if no node exists to the left.\n   * null.\n   */\n  prev() {\n    switch (this.type_) {\n      case ASTNode.types.STACK:\n        return this.navigateBetweenStacks_(false);\n\n      case ASTNode.types.OUTPUT:\n        return null;\n\n      case ASTNode.types.FIELD:\n        return this.findPrevForField_();\n\n      case ASTNode.types.INPUT:\n        return this.findPrevForInput_();\n\n      case ASTNode.types.BLOCK: {\n        const block = /** @type {!Block} */ (this.location_);\n        const topConnection = getParentConnection(block);\n        return ASTNode.createConnectionNode(topConnection);\n      }\n      case ASTNode.types.PREVIOUS: {\n        const connection = /** @type {!Connection} */ (this.location_);\n        const targetConnection = connection.targetConnection;\n        if (targetConnection && !targetConnection.getParentInput()) {\n          return ASTNode.createConnectionNode(targetConnection);\n        }\n        break;\n      }\n      case ASTNode.types.NEXT: {\n        const connection = /** @type {!Connection} */ (this.location_);\n        return ASTNode.createBlockNode(connection.getSourceBlock());\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Find the next element that is one position above and all the way to the\n   * left of the current location.\n   * @return {ASTNode} An AST node that wraps the next field, connection,\n   *     workspace or block. Or null if we are at the workspace level.\n   */\n  out() {\n    switch (this.type_) {\n      case ASTNode.types.STACK: {\n        const block = /** @type {!Block} */ (this.location_);\n        const blockPos = block.getRelativeToSurfaceXY();\n        // TODO: Make sure this is in the bounds of the workspace.\n        const wsCoordinate =\n            new Coordinate(blockPos.x, blockPos.y + ASTNode.DEFAULT_OFFSET_Y);\n        return ASTNode.createWorkspaceNode(block.workspace, wsCoordinate);\n      }\n      case ASTNode.types.OUTPUT: {\n        const connection = /** @type {!Connection} */ (this.location_);\n        const target = connection.targetConnection;\n        if (target) {\n          return ASTNode.createConnectionNode(target);\n        }\n        return ASTNode.createStackNode(connection.getSourceBlock());\n      }\n      case ASTNode.types.FIELD: {\n        const field = /** @type {!Field} */ (this.location_);\n        return ASTNode.createBlockNode(field.getSourceBlock());\n      }\n      case ASTNode.types.INPUT: {\n        const connection = /** @type {!Connection} */ (this.location_);\n        return ASTNode.createBlockNode(connection.getSourceBlock());\n      }\n      case ASTNode.types.BLOCK: {\n        const block = /** @type {!Block} */ (this.location_);\n        return this.getOutAstNodeForBlock_(block);\n      }\n      case ASTNode.types.PREVIOUS: {\n        const connection = /** @type {!Connection} */ (this.location_);\n        return this.getOutAstNodeForBlock_(connection.getSourceBlock());\n      }\n      case ASTNode.types.NEXT: {\n        const connection = /** @type {!Connection} */ (this.location_);\n        return this.getOutAstNodeForBlock_(connection.getSourceBlock());\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Whether an AST node of the given type points to a connection.\n   * @param {string} type The type to check.  One of ASTNode.types.\n   * @return {boolean} True if a node of the given type points to a connection.\n   * @private\n   */\n  static isConnectionType_(type) {\n    switch (type) {\n      case ASTNode.types.PREVIOUS:\n      case ASTNode.types.NEXT:\n      case ASTNode.types.INPUT:\n      case ASTNode.types.OUTPUT:\n        return true;\n    }\n    return false;\n  }\n\n  /**\n   * Create an AST node pointing to a field.\n   * @param {Field} field The location of the AST node.\n   * @return {ASTNode} An AST node pointing to a field.\n   */\n  static createFieldNode(field) {\n    if (!field) {\n      return null;\n    }\n    return new ASTNode(ASTNode.types.FIELD, field);\n  }\n\n  /**\n   * Creates an AST node pointing to a connection. If the connection has a\n   * parent input then create an AST node of type input that will hold the\n   * connection.\n   * @param {Connection} connection This is the connection the node will\n   *     point to.\n   * @return {ASTNode} An AST node pointing to a connection.\n   */\n  static createConnectionNode(connection) {\n    if (!connection) {\n      return null;\n    }\n    const type = connection.type;\n    if (type === ConnectionType.INPUT_VALUE) {\n      return ASTNode.createInputNode(connection.getParentInput());\n    } else if (\n        type === ConnectionType.NEXT_STATEMENT && connection.getParentInput()) {\n      return ASTNode.createInputNode(connection.getParentInput());\n    } else if (type === ConnectionType.NEXT_STATEMENT) {\n      return new ASTNode(ASTNode.types.NEXT, connection);\n    } else if (type === ConnectionType.OUTPUT_VALUE) {\n      return new ASTNode(ASTNode.types.OUTPUT, connection);\n    } else if (type === ConnectionType.PREVIOUS_STATEMENT) {\n      return new ASTNode(ASTNode.types.PREVIOUS, connection);\n    }\n    return null;\n  }\n\n  /**\n   * Creates an AST node pointing to an input. Stores the input connection as\n   * the location.\n   * @param {Input} input The input used to create an AST node.\n   * @return {ASTNode} An AST node pointing to a input.\n   */\n  static createInputNode(input) {\n    if (!input || !input.connection) {\n      return null;\n    }\n    return new ASTNode(ASTNode.types.INPUT, input.connection);\n  }\n\n  /**\n   * Creates an AST node pointing to a block.\n   * @param {Block} block The block used to create an AST node.\n   * @return {ASTNode} An AST node pointing to a block.\n   */\n  static createBlockNode(block) {\n    if (!block) {\n      return null;\n    }\n    return new ASTNode(ASTNode.types.BLOCK, block);\n  }\n\n  /**\n   * Create an AST node of type stack. A stack, represented by its top block, is\n   *     the set of all blocks connected to a top block, including the top\n   * block.\n   * @param {Block} topBlock A top block has no parent and can be found\n   *     in the list returned by workspace.getTopBlocks().\n   * @return {ASTNode} An AST node of type stack that points to the top\n   *     block on the stack.\n   */\n  static createStackNode(topBlock) {\n    if (!topBlock) {\n      return null;\n    }\n    return new ASTNode(ASTNode.types.STACK, topBlock);\n  }\n\n  /**\n   * Creates an AST node pointing to a workspace.\n   * @param {!Workspace} workspace The workspace that we are on.\n   * @param {Coordinate} wsCoordinate The position on the workspace\n   *     for this node.\n   * @return {ASTNode} An AST node pointing to a workspace and a position\n   *     on the workspace.\n   */\n  static createWorkspaceNode(workspace, wsCoordinate) {\n    if (!wsCoordinate || !workspace) {\n      return null;\n    }\n    const params = {wsCoordinate: wsCoordinate};\n    return new ASTNode(ASTNode.types.WORKSPACE, workspace, params);\n  }\n\n  /**\n   * Creates an AST node for the top position on a block.\n   * This is either an output connection, previous connection, or block.\n   * @param {!Block} block The block to find the top most AST node on.\n   * @return {ASTNode} The AST node holding the top most position on the\n   *     block.\n   */\n  static createTopNode(block) {\n    let astNode;\n    const topConnection = getParentConnection(block);\n    if (topConnection) {\n      astNode = ASTNode.createConnectionNode(topConnection);\n    } else {\n      astNode = ASTNode.createBlockNode(block);\n    }\n    return astNode;\n  }\n}\n\n/**\n * @typedef {{\n *     wsCoordinate: Coordinate\n * }}\n */\nASTNode.Params;\n\n/**\n * Object holding different types for an AST node.\n * @enum {string}\n */\nASTNode.types = {\n  FIELD: 'field',\n  BLOCK: 'block',\n  INPUT: 'input',\n  OUTPUT: 'output',\n  NEXT: 'next',\n  PREVIOUS: 'previous',\n  STACK: 'stack',\n  WORKSPACE: 'workspace',\n};\n\n/**\n * True to navigate to all fields. False to only navigate to clickable fields.\n * @type {boolean}\n */\nASTNode.NAVIGATE_ALL_FIELDS = false;\n\n/**\n * The default y offset to use when moving the cursor from a stack to the\n * workspace.\n * @type {number}\n * @private\n */\nASTNode.DEFAULT_OFFSET_Y = -20;\n\n/**\n * Gets the parent connection on a block.\n * This is either an output connection, previous connection or undefined.\n * If both connections exist return the one that is actually connected\n * to another block.\n * @param {!Block} block The block to find the parent connection on.\n * @return {Connection} The connection connecting to the parent of the\n *     block.\n * @private\n */\nconst getParentConnection = function(block) {\n  let topConnection = block.outputConnection;\n  if (!topConnection ||\n      (block.previousConnection && block.previousConnection.isConnected())) {\n    topConnection = block.previousConnection;\n  }\n  return topConnection;\n};\n\nexports.ASTNode = ASTNode;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/keyboard_nav/ast_node.js?")},
"./core/keyboard_nav/basic_cursor.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/keyboard_nav/ast_node.js\");\n__webpack_require__(\"./core/keyboard_nav/cursor.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing a basic cursor.\n * Used to demo switching between different cursors.\n */\n\n\n/**\n * The class representing a basic cursor.\n * Used to demo switching between different cursors.\n * @class\n */\ngoog.module('Blockly.BasicCursor');\n\nconst registry = goog.require('Blockly.registry');\nconst {ASTNode} = goog.require('Blockly.ASTNode');\nconst {Cursor} = goog.require('Blockly.Cursor');\n\n\n/**\n * Class for a basic cursor.\n * This will allow the user to get to all nodes in the AST by hitting next or\n * previous.\n * @extends {Cursor}\n * @alias Blockly.BasicCursor\n */\nclass BasicCursor extends Cursor {\n  /**\n   * @alias Blockly.BasicCursor\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Find the next node in the pre order traversal.\n   * @return {?ASTNode} The next node, or null if the current node is\n   *     not set or there is no next value.\n   * @override\n   */\n  next() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = this.getNextNode_(curNode, this.validNode_);\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * For a basic cursor we only have the ability to go next and previous, so\n   * in will also allow the user to get to the next node in the pre order\n   * traversal.\n   * @return {?ASTNode} The next node, or null if the current node is\n   *     not set or there is no next value.\n   * @override\n   */\n  in() {\n    return this.next();\n  }\n\n  /**\n   * Find the previous node in the pre order traversal.\n   * @return {?ASTNode} The previous node, or null if the current node\n   *     is not set or there is no previous value.\n   * @override\n   */\n  prev() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = this.getPreviousNode_(curNode, this.validNode_);\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * For a basic cursor we only have the ability to go next and previous, so\n   * out will allow the user to get to the previous node in the pre order\n   * traversal.\n   * @return {?ASTNode} The previous node, or null if the current node is\n   *     not set or there is no previous value.\n   * @override\n   */\n  out() {\n    return this.prev();\n  }\n\n  /**\n   * Uses pre order traversal to navigate the Blockly AST. This will allow\n   * a user to easily navigate the entire Blockly AST without having to go in\n   * and out levels on the tree.\n   * @param {?ASTNode} node The current position in the AST.\n   * @param {!function(ASTNode) : boolean} isValid A function true/false\n   *     depending on whether the given node should be traversed.\n   * @return {?ASTNode} The next node in the traversal.\n   * @protected\n   */\n  getNextNode_(node, isValid) {\n    if (!node) {\n      return null;\n    }\n    const newNode = node.in() || node.next();\n    if (isValid(newNode)) {\n      return newNode;\n    } else if (newNode) {\n      return this.getNextNode_(newNode, isValid);\n    }\n    const siblingOrParent = this.findSiblingOrParent_(node.out());\n    if (isValid(siblingOrParent)) {\n      return siblingOrParent;\n    } else if (siblingOrParent) {\n      return this.getNextNode_(siblingOrParent, isValid);\n    }\n    return null;\n  }\n\n  /**\n   * Reverses the pre order traversal in order to find the previous node. This\n   * will allow a user to easily navigate the entire Blockly AST without having\n   * to go in and out levels on the tree.\n   * @param {?ASTNode} node The current position in the AST.\n   * @param {!function(ASTNode) : boolean} isValid A function true/false\n   *     depending on whether the given node should be traversed.\n   * @return {?ASTNode} The previous node in the traversal or null if no\n   *     previous node exists.\n   * @protected\n   */\n  getPreviousNode_(node, isValid) {\n    if (!node) {\n      return null;\n    }\n    let newNode = node.prev();\n\n    if (newNode) {\n      newNode = this.getRightMostChild_(newNode);\n    } else {\n      newNode = node.out();\n    }\n    if (isValid(newNode)) {\n      return newNode;\n    } else if (newNode) {\n      return this.getPreviousNode_(newNode, isValid);\n    }\n    return null;\n  }\n\n  /**\n   * Decides what nodes to traverse and which ones to skip. Currently, it\n   * skips output, stack and workspace nodes.\n   * @param {?ASTNode} node The AST node to check whether it is valid.\n   * @return {boolean} True if the node should be visited, false otherwise.\n   * @protected\n   */\n  validNode_(node) {\n    let isValid = false;\n    const type = node && node.getType();\n    if (type === ASTNode.types.OUTPUT || type === ASTNode.types.INPUT ||\n        type === ASTNode.types.FIELD || type === ASTNode.types.NEXT ||\n        type === ASTNode.types.PREVIOUS || type === ASTNode.types.WORKSPACE) {\n      isValid = true;\n    }\n    return isValid;\n  }\n\n  /**\n   * From the given node find either the next valid sibling or parent.\n   * @param {?ASTNode} node The current position in the AST.\n   * @return {?ASTNode} The parent AST node or null if there are no\n   *     valid parents.\n   * @private\n   */\n  findSiblingOrParent_(node) {\n    if (!node) {\n      return null;\n    }\n    const nextNode = node.next();\n    if (nextNode) {\n      return nextNode;\n    }\n    return this.findSiblingOrParent_(node.out());\n  }\n\n  /**\n   * Get the right most child of a node.\n   * @param {?ASTNode} node The node to find the right most child of.\n   * @return {?ASTNode} The right most child of the given node, or the node\n   *     if no child exists.\n   * @private\n   */\n  getRightMostChild_(node) {\n    if (!node.in()) {\n      return node;\n    }\n    let newNode = node.in();\n    while (newNode.next()) {\n      newNode = newNode.next();\n    }\n    return this.getRightMostChild_(newNode);\n  }\n}\n\n/**\n * Name used for registering a basic cursor.\n * @const {string}\n */\nBasicCursor.registrationName = 'basicCursor';\n\nregistry.register(\n    registry.Type.CURSOR, BasicCursor.registrationName, BasicCursor);\n\nexports.BasicCursor = BasicCursor;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/keyboard_nav/basic_cursor.js?")},
"./core/keyboard_nav/cursor.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/keyboard_nav/ast_node.js\");\n__webpack_require__(\"./core/keyboard_nav/marker.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing a cursor.\n * Used primarily for keyboard navigation.\n */\n\n\n/**\n * The class representing a cursor.\n * Used primarily for keyboard navigation.\n * @class\n */\ngoog.module('Blockly.Cursor');\n\nconst registry = goog.require('Blockly.registry');\nconst {ASTNode} = goog.require('Blockly.ASTNode');\nconst {Marker} = goog.require('Blockly.Marker');\n\n/**\n * Class for a cursor.\n * A cursor controls how a user navigates the Blockly AST.\n * @extends {Marker}\n * @alias Blockly.Cursor\n */\nclass Cursor extends Marker {\n  /**\n   * @alias Blockly.Cursor\n   */\n  constructor() {\n    super();\n\n    /**\n     * @override\n     */\n    this.type = 'cursor';\n  }\n\n  /**\n   * Find the next connection, field, or block.\n   * @return {ASTNode} The next element, or null if the current node is\n   *     not set or there is no next value.\n   * @public\n   */\n  next() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n\n    let newNode = curNode.next();\n    while (newNode && newNode.next() &&\n           (newNode.getType() === ASTNode.types.NEXT ||\n            newNode.getType() === ASTNode.types.BLOCK)) {\n      newNode = newNode.next();\n    }\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * Find the in connection or field.\n   * @return {ASTNode} The in element, or null if the current node is\n   *     not set or there is no in value.\n   * @public\n   */\n  in() {\n    let curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    // If we are on a previous or output connection, go to the block level\n    // before performing next operation.\n    if (curNode.getType() === ASTNode.types.PREVIOUS ||\n        curNode.getType() === ASTNode.types.OUTPUT) {\n      curNode = curNode.next();\n    }\n    const newNode = curNode.in();\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * Find the previous connection, field, or block.\n   * @return {ASTNode} The previous element, or null if the current node\n   *     is not set or there is no previous value.\n   * @public\n   */\n  prev() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    let newNode = curNode.prev();\n\n    while (newNode && newNode.prev() &&\n           (newNode.getType() === ASTNode.types.NEXT ||\n            newNode.getType() === ASTNode.types.BLOCK)) {\n      newNode = newNode.prev();\n    }\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * Find the out connection, field, or block.\n   * @return {ASTNode} The out element, or null if the current node is\n   *     not set or there is no out value.\n   * @public\n   */\n  out() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    let newNode = curNode.out();\n\n    if (newNode && newNode.getType() === ASTNode.types.BLOCK) {\n      newNode = newNode.prev() || newNode;\n    }\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n}\n\nregistry.register(registry.Type.CURSOR, registry.DEFAULT, Cursor);\n\nexports.Cursor = Cursor;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/keyboard_nav/cursor.js?")},
"./core/keyboard_nav/marker.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing a marker.\n * Used primarily for keyboard navigation to show a marked location.\n */\n\n\n/**\n * The class representing a marker.\n * Used primarily for keyboard navigation to show a marked location.\n * @class\n */\ngoog.module('Blockly.Marker');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ASTNode} = goog.requireType('Blockly.ASTNode');\n/* eslint-disable-next-line no-unused-vars */\nconst {MarkerSvg} = goog.requireType('Blockly.blockRendering.MarkerSvg');\n\n\n/**\n * Class for a marker.\n * This is used in keyboard navigation to save a location in the Blockly AST.\n * @alias Blockly.Marker\n */\nclass Marker {\n  /**\n   * Constructs a new Marker instance.\n   */\n  constructor() {\n    /**\n     * The colour of the marker.\n     * @type {?string}\n     */\n    this.colour = null;\n\n    /**\n     * The current location of the marker.\n     * @type {ASTNode}\n     * @private\n     */\n    this.curNode_ = null;\n\n    /**\n     * The object in charge of drawing the visual representation of the current\n     * node.\n     * @type {MarkerSvg}\n     * @private\n     */\n    this.drawer_ = null;\n\n    /**\n     * The type of the marker.\n     * @type {string}\n     */\n    this.type = 'marker';\n  }\n\n  /**\n   * Sets the object in charge of drawing the marker.\n   * @param {MarkerSvg} drawer The object in charge of\n   *     drawing the marker.\n   */\n  setDrawer(drawer) {\n    this.drawer_ = drawer;\n  }\n\n  /**\n   * Get the current drawer for the marker.\n   * @return {MarkerSvg} The object in charge of drawing\n   *     the marker.\n   */\n  getDrawer() {\n    return this.drawer_;\n  }\n\n  /**\n   * Gets the current location of the marker.\n   * @return {ASTNode} The current field, connection, or block the marker\n   *     is on.\n   */\n  getCurNode() {\n    return this.curNode_;\n  }\n\n  /**\n   * Set the location of the marker and call the update method.\n   * Setting isStack to true will only work if the newLocation is the top most\n   * output or previous connection on a stack.\n   * @param {ASTNode} newNode The new location of the marker.\n   */\n  setCurNode(newNode) {\n    const oldNode = this.curNode_;\n    this.curNode_ = newNode;\n    if (this.drawer_) {\n      this.drawer_.draw(oldNode, this.curNode_);\n    }\n  }\n\n  /**\n   * Redraw the current marker.\n   * @package\n   */\n  draw() {\n    if (this.drawer_) {\n      this.drawer_.draw(this.curNode_, this.curNode_);\n    }\n  }\n\n  /**\n   * Hide the marker SVG.\n   */\n  hide() {\n    if (this.drawer_) {\n      this.drawer_.hide();\n    }\n  }\n\n  /**\n   * Dispose of this marker.\n   */\n  dispose() {\n    if (this.getDrawer()) {\n      this.getDrawer().dispose();\n    }\n  }\n}\n\nexports.Marker = Marker;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/keyboard_nav/marker.js?")},
"./core/keyboard_nav/tab_navigate_cursor.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/keyboard_nav/ast_node.js\");\n__webpack_require__(\"./core/keyboard_nav/basic_cursor.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing a cursor that is used to navigate\n * between tab navigable fields.\n */\n\n\n/**\n * The class representing a cursor that is used to navigate\n * between tab navigable fields.\n * @class\n */\ngoog.module('Blockly.TabNavigateCursor');\n\nconst {ASTNode} = goog.require('Blockly.ASTNode');\nconst {BasicCursor} = goog.require('Blockly.BasicCursor');\n/* eslint-disable-next-line no-unused-vars */\nconst {Field} = goog.requireType('Blockly.Field');\n\n\n/**\n * A cursor for navigating between tab navigable fields.\n * @extends {BasicCursor}\n * @alias Blockly.TabNavigateCursor\n */\nclass TabNavigateCursor extends BasicCursor {\n  /**\n   * Skip all nodes except for tab navigable fields.\n   * @param {?ASTNode} node The AST node to check whether it is valid.\n   * @return {boolean} True if the node should be visited, false otherwise.\n   * @override\n   */\n  validNode_(node) {\n    let isValid = false;\n    const type = node && node.getType();\n    if (node) {\n      const location = /** @type {Field} */ (node.getLocation());\n      if (type === ASTNode.types.FIELD && location &&\n          location.isTabNavigable() && location.isClickable()) {\n        isValid = true;\n      }\n    }\n    return isValid;\n  }\n}\n\nexports.TabNavigateCursor = TabNavigateCursor;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/keyboard_nav/tab_navigate_cursor.js?")},
"./core/marker_manager.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object in charge of managing markers and the cursor.\n */\n\n\n/**\n * Object in charge of managing markers and the cursor.\n * @class\n */\ngoog.module('Blockly.MarkerManager');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {Cursor} = goog.requireType('Blockly.Cursor');\n/* eslint-disable-next-line no-unused-vars */\nconst {Marker} = goog.requireType('Blockly.Marker');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * Class to manage the multiple markers and the cursor on a workspace.\n * @alias Blockly.MarkerManager\n */\nclass MarkerManager {\n  /**\n   * @param {!WorkspaceSvg} workspace The workspace for the marker manager.\n   * @package\n   */\n  constructor(workspace) {\n    /**\n     * The cursor.\n     * @type {?Cursor}\n     * @private\n     */\n    this.cursor_ = null;\n\n    /**\n     * The cursor's SVG element.\n     * @type {?SVGElement}\n     * @private\n     */\n    this.cursorSvg_ = null;\n\n    /**\n     * The map of markers for the workspace.\n     * @type {!Object<string, !Marker>}\n     * @private\n     */\n    this.markers_ = Object.create(null);\n\n    /**\n     * The workspace this marker manager is associated with.\n     * @type {!WorkspaceSvg}\n     * @private\n     */\n    this.workspace_ = workspace;\n\n    /**\n     * The marker's SVG element.\n     * @type {?SVGElement}\n     * @private\n     */\n    this.markerSvg_ = null;\n  }\n\n  /**\n   * Register the marker by adding it to the map of markers.\n   * @param {string} id A unique identifier for the marker.\n   * @param {!Marker} marker The marker to register.\n   */\n  registerMarker(id, marker) {\n    if (this.markers_[id]) {\n      this.unregisterMarker(id);\n    }\n    marker.setDrawer(this.workspace_.getRenderer().makeMarkerDrawer(\n        this.workspace_, marker));\n    this.setMarkerSvg(marker.getDrawer().createDom());\n    this.markers_[id] = marker;\n  }\n\n  /**\n   * Unregister the marker by removing it from the map of markers.\n   * @param {string} id The ID of the marker to unregister.\n   */\n  unregisterMarker(id) {\n    const marker = this.markers_[id];\n    if (marker) {\n      marker.dispose();\n      delete this.markers_[id];\n    } else {\n      throw Error(\n          'Marker with ID ' + id + ' does not exist. ' +\n          'Can only unregister markers that exist.');\n    }\n  }\n\n  /**\n   * Get the cursor for the workspace.\n   * @return {?Cursor} The cursor for this workspace.\n   */\n  getCursor() {\n    return this.cursor_;\n  }\n\n  /**\n   * Get a single marker that corresponds to the given ID.\n   * @param {string} id A unique identifier for the marker.\n   * @return {?Marker} The marker that corresponds to the given ID,\n   *     or null if none exists.\n   */\n  getMarker(id) {\n    return this.markers_[id] || null;\n  }\n\n  /**\n   * Sets the cursor and initializes the drawer for use with keyboard\n   * navigation.\n   * @param {Cursor} cursor The cursor used to move around this workspace.\n   */\n  setCursor(cursor) {\n    if (this.cursor_ && this.cursor_.getDrawer()) {\n      this.cursor_.getDrawer().dispose();\n    }\n    this.cursor_ = cursor;\n    if (this.cursor_) {\n      const drawer = this.workspace_.getRenderer().makeMarkerDrawer(\n          this.workspace_, this.cursor_);\n      this.cursor_.setDrawer(drawer);\n      this.setCursorSvg(this.cursor_.getDrawer().createDom());\n    }\n  }\n\n  /**\n   * Add the cursor SVG to this workspace SVG group.\n   * @param {?SVGElement} cursorSvg The SVG root of the cursor to be added to\n   *     the workspace SVG group.\n   * @package\n   */\n  setCursorSvg(cursorSvg) {\n    if (!cursorSvg) {\n      this.cursorSvg_ = null;\n      return;\n    }\n\n    this.workspace_.getBlockCanvas().appendChild(cursorSvg);\n    this.cursorSvg_ = cursorSvg;\n  }\n\n  /**\n   * Add the marker SVG to this workspaces SVG group.\n   * @param {?SVGElement} markerSvg The SVG root of the marker to be added to\n   *     the workspace SVG group.\n   * @package\n   */\n  setMarkerSvg(markerSvg) {\n    if (!markerSvg) {\n      this.markerSvg_ = null;\n      return;\n    }\n\n    if (this.workspace_.getBlockCanvas()) {\n      if (this.cursorSvg_) {\n        this.workspace_.getBlockCanvas().insertBefore(\n            markerSvg, this.cursorSvg_);\n      } else {\n        this.workspace_.getBlockCanvas().appendChild(markerSvg);\n      }\n    }\n  }\n\n  /**\n   * Redraw the attached cursor SVG if needed.\n   * @package\n   */\n  updateMarkers() {\n    if (this.workspace_.keyboardAccessibilityMode && this.cursorSvg_) {\n      this.workspace_.getCursor().draw();\n    }\n  }\n\n  /**\n   * Dispose of the marker manager.\n   * Go through and delete all markers associated with this marker manager.\n   * @suppress {checkTypes}\n   * @package\n   */\n  dispose() {\n    const markerIds = Object.keys(this.markers_);\n    for (let i = 0, markerId; (markerId = markerIds[i]); i++) {\n      this.unregisterMarker(markerId);\n    }\n    this.markers_ = null;\n    if (this.cursor_) {\n      this.cursor_.dispose();\n      this.cursor_ = null;\n    }\n  }\n}\n\n/**\n * The name of the local marker.\n * @type {string}\n * @const\n */\nMarkerManager.LOCAL_MARKER = 'local_marker_1';\n\nexports.MarkerManager = MarkerManager;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/marker_manager.js?")},
"./core/menu.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/aria.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/utils/style.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/utils/keycodes.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Blockly menu similar to Closure's goog.ui.Menu\n */\n\n\n/**\n * Blockly menu similar to Closure's goog.ui.Menu\n * @class\n */\ngoog.module('Blockly.Menu');\n\nconst aria = goog.require('Blockly.utils.aria');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst dom = goog.require('Blockly.utils.dom');\nconst style = goog.require('Blockly.utils.style');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\nconst {KeyCodes} = goog.require('Blockly.utils.KeyCodes');\n/* eslint-disable-next-line no-unused-vars */\nconst {MenuItem} = goog.requireType('Blockly.MenuItem');\n/* eslint-disable-next-line no-unused-vars */\nconst {Size} = goog.requireType('Blockly.utils.Size');\n\n\n/**\n * A basic menu class.\n * @alias Blockly.Menu\n */\nconst Menu = class {\n  /**\n   * Constructs a new Menu instance.\n   */\n  constructor() {\n    /**\n     * Array of menu items.\n     * (Nulls are never in the array, but typing the array as nullable prevents\n     * the compiler from objecting to .indexOf(null))\n     * @type {!Array<MenuItem>}\n     * @private\n     */\n    this.menuItems_ = [];\n\n    /**\n     * Coordinates of the mousedown event that caused this menu to open. Used to\n     * prevent the consequent mouseup event due to a simple click from\n     * activating a menu item immediately.\n     * @type {?Coordinate}\n     * @package\n     */\n    this.openingCoords = null;\n\n    /**\n     * This is the element that we will listen to the real focus events on.\n     * A value of null means no menu item is highlighted.\n     * @type {?MenuItem}\n     * @private\n     */\n    this.highlightedItem_ = null;\n\n    /**\n     * Mouse over event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.mouseOverHandler_ = null;\n\n    /**\n     * Click event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.clickHandler_ = null;\n\n    /**\n     * Mouse enter event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.mouseEnterHandler_ = null;\n\n    /**\n     * Mouse leave event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.mouseLeaveHandler_ = null;\n\n    /**\n     * Key down event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onKeyDownHandler_ = null;\n\n    /**\n     * The menu's root DOM element.\n     * @type {?HTMLDivElement}\n     * @private\n     */\n    this.element_ = null;\n\n    /**\n     * ARIA name for this menu.\n     * @type {?aria.Role}\n     * @private\n     */\n    this.roleName_ = null;\n  }\n\n  /**\n   * Add a new menu item to the bottom of this menu.\n   * @param {!MenuItem} menuItem Menu item to append.\n   */\n  addChild(menuItem) {\n    this.menuItems_.push(menuItem);\n  }\n\n  /**\n   * Creates the menu DOM.\n   * @param {!Element} container Element upon which to append this menu.\n   */\n  render(container) {\n    const element =\n        /** @type {!HTMLDivElement} */ (document.createElement('div'));\n    // goog-menu is deprecated, use blocklyMenu.  May 2020.\n    element.className = 'blocklyMenu goog-menu blocklyNonSelectable';\n    element.tabIndex = 0;\n    if (this.roleName_) {\n      aria.setRole(element, this.roleName_);\n    }\n    this.element_ = element;\n\n    // Add menu items.\n    for (let i = 0, menuItem; (menuItem = this.menuItems_[i]); i++) {\n      element.appendChild(menuItem.createDom());\n    }\n\n    // Add event handlers.\n    this.mouseOverHandler_ = browserEvents.conditionalBind(\n        element, 'mouseover', this, this.handleMouseOver_, true);\n    this.clickHandler_ = browserEvents.conditionalBind(\n        element, 'click', this, this.handleClick_, true);\n    this.mouseEnterHandler_ = browserEvents.conditionalBind(\n        element, 'mouseenter', this, this.handleMouseEnter_, true);\n    this.mouseLeaveHandler_ = browserEvents.conditionalBind(\n        element, 'mouseleave', this, this.handleMouseLeave_, true);\n    this.onKeyDownHandler_ = browserEvents.conditionalBind(\n        element, 'keydown', this, this.handleKeyEvent_);\n\n    container.appendChild(element);\n  }\n\n  /**\n   * Gets the menu's element.\n   * @return {?Element} The DOM element.\n   * @package\n   */\n  getElement() {\n    return this.element_;\n  }\n\n  /**\n   * Focus the menu element.\n   * @package\n   */\n  focus() {\n    const el = this.getElement();\n    if (el) {\n      el.focus({preventScroll: true});\n      dom.addClass(el, 'blocklyFocused');\n    }\n  }\n\n  /**\n   * Blur the menu element.\n   * @private\n   */\n  blur_() {\n    const el = this.getElement();\n    if (el) {\n      el.blur();\n      dom.removeClass(el, 'blocklyFocused');\n    }\n  }\n\n  /**\n   * Set the menu accessibility role.\n   * @param {!aria.Role} roleName role name.\n   * @package\n   */\n  setRole(roleName) {\n    this.roleName_ = roleName;\n  }\n\n  /**\n   * Dispose of this menu.\n   */\n  dispose() {\n    // Remove event handlers.\n    if (this.mouseOverHandler_) {\n      browserEvents.unbind(this.mouseOverHandler_);\n      this.mouseOverHandler_ = null;\n    }\n    if (this.clickHandler_) {\n      browserEvents.unbind(this.clickHandler_);\n      this.clickHandler_ = null;\n    }\n    if (this.mouseEnterHandler_) {\n      browserEvents.unbind(this.mouseEnterHandler_);\n      this.mouseEnterHandler_ = null;\n    }\n    if (this.mouseLeaveHandler_) {\n      browserEvents.unbind(this.mouseLeaveHandler_);\n      this.mouseLeaveHandler_ = null;\n    }\n    if (this.onKeyDownHandler_) {\n      browserEvents.unbind(this.onKeyDownHandler_);\n      this.onKeyDownHandler_ = null;\n    }\n\n    // Remove menu items.\n    for (let i = 0, menuItem; (menuItem = this.menuItems_[i]); i++) {\n      menuItem.dispose();\n    }\n    this.element_ = null;\n  }\n\n  // Child component management.\n\n  /**\n   * Returns the child menu item that owns the given DOM element,\n   * or null if no such menu item is found.\n   * @param {Element} elem DOM element whose owner is to be returned.\n   * @return {?MenuItem} Menu item for which the DOM element belongs to.\n   * @private\n   */\n  getMenuItem_(elem) {\n    const menuElem = this.getElement();\n    // Node might be the menu border (resulting in no associated menu item), or\n    // a menu item's div, or some element within the menu item.\n    // Walk up parents until one meets either the menu's root element, or\n    // a menu item's div.\n    while (elem && elem !== menuElem) {\n      if (dom.hasClass(elem, 'blocklyMenuItem')) {\n        // Having found a menu item's div, locate that menu item in this menu.\n        for (let i = 0, menuItem; (menuItem = this.menuItems_[i]); i++) {\n          if (menuItem.getElement() === elem) {\n            return menuItem;\n          }\n        }\n      }\n      elem = elem.parentElement;\n    }\n    return null;\n  }\n\n  // Highlight management.\n\n  /**\n   * Highlights the given menu item, or clears highlighting if null.\n   * @param {?MenuItem} item Item to highlight, or null.\n   * @package\n   */\n  setHighlighted(item) {\n    const currentHighlighted = this.highlightedItem_;\n    if (currentHighlighted) {\n      currentHighlighted.setHighlighted(false);\n      this.highlightedItem_ = null;\n    }\n    if (item) {\n      item.setHighlighted(true);\n      this.highlightedItem_ = item;\n      // Bring the highlighted item into view. This has no effect if the menu is\n      // not scrollable.\n      const el = /** @type {!Element} */ (this.getElement());\n      style.scrollIntoContainerView(\n          /** @type {!Element} */ (item.getElement()), el);\n\n      aria.setState(el, aria.State.ACTIVEDESCENDANT, item.getId());\n    }\n  }\n\n  /**\n   * Highlights the next highlightable item (or the first if nothing is\n   * currently highlighted).\n   * @package\n   */\n  highlightNext() {\n    const index = this.menuItems_.indexOf(this.highlightedItem_);\n    this.highlightHelper_(index, 1);\n  }\n\n  /**\n   * Highlights the previous highlightable item (or the last if nothing is\n   * currently highlighted).\n   * @package\n   */\n  highlightPrevious() {\n    const index = this.menuItems_.indexOf(this.highlightedItem_);\n    this.highlightHelper_(index < 0 ? this.menuItems_.length : index, -1);\n  }\n\n  /**\n   * Highlights the first highlightable item.\n   * @private\n   */\n  highlightFirst_() {\n    this.highlightHelper_(-1, 1);\n  }\n\n  /**\n   * Highlights the last highlightable item.\n   * @private\n   */\n  highlightLast_() {\n    this.highlightHelper_(this.menuItems_.length, -1);\n  }\n\n  /**\n   * Helper function that manages the details of moving the highlight among\n   * child menuitems in response to keyboard events.\n   * @param {number} startIndex Start index.\n   * @param {number} delta Step direction: 1 to go down, -1 to go up.\n   * @private\n   */\n  highlightHelper_(startIndex, delta) {\n    let index = startIndex + delta;\n    let menuItem;\n    while ((menuItem = this.menuItems_[index])) {\n      if (menuItem.isEnabled()) {\n        this.setHighlighted(menuItem);\n        break;\n      }\n      index += delta;\n    }\n  }\n\n  // Mouse events.\n\n  /**\n   * Handles mouseover events. Highlight menuitems as the user hovers over them.\n   * @param {!Event} e Mouse event to handle.\n   * @private\n   */\n  handleMouseOver_(e) {\n    const menuItem = this.getMenuItem_(/** @type {Element} */ (e.target));\n\n    if (menuItem) {\n      if (menuItem.isEnabled()) {\n        if (this.highlightedItem_ !== menuItem) {\n          this.setHighlighted(menuItem);\n        }\n      } else {\n        this.setHighlighted(null);\n      }\n    }\n  }\n\n  /**\n   * Handles click events. Pass the event onto the child menuitem to handle.\n   * @param {!Event} e Click event to handle.\n   * @private\n   */\n  handleClick_(e) {\n    const oldCoords = this.openingCoords;\n    // Clear out the saved opening coords immediately so they're not used twice.\n    this.openingCoords = null;\n    if (oldCoords && typeof e.clientX === 'number') {\n      const newCoords = new Coordinate(e.clientX, e.clientY);\n      if (Coordinate.distance(oldCoords, newCoords) < 1) {\n        // This menu was opened by a mousedown and we're handling the consequent\n        // click event. The coords haven't changed, meaning this was the same\n        // opening event. Don't do the usual behavior because the menu just\n        // popped up under the mouse and the user didn't mean to activate this\n        // item.\n        return;\n      }\n    }\n\n    const menuItem = this.getMenuItem_(/** @type {Element} */ (e.target));\n    if (menuItem) {\n      menuItem.performAction();\n    }\n  }\n\n  /**\n   * Handles mouse enter events. Focus the element.\n   * @param {!Event} _e Mouse event to handle.\n   * @private\n   */\n  handleMouseEnter_(_e) {\n    this.focus();\n  }\n\n  /**\n   * Handles mouse leave events. Blur and clear highlight.\n   * @param {!Event} _e Mouse event to handle.\n   * @private\n   */\n  handleMouseLeave_(_e) {\n    if (this.getElement()) {\n      this.blur_();\n      this.setHighlighted(null);\n    }\n  }\n\n  // Keyboard events.\n\n  /**\n   * Attempts to handle a keyboard event, if the menu item is enabled, by\n   * calling\n   * {@link handleKeyEventInternal_}.\n   * @param {!Event} e Key event to handle.\n   * @private\n   */\n  handleKeyEvent_(e) {\n    if (!this.menuItems_.length) {\n      // Empty menu.\n      return;\n    }\n    if (e.shiftKey || e.ctrlKey || e.metaKey || e.altKey) {\n      // Do not handle the key event if any modifier key is pressed.\n      return;\n    }\n\n    const highlighted = this.highlightedItem_;\n    switch (e.keyCode) {\n      case KeyCodes.ENTER:\n      case KeyCodes.SPACE:\n        if (highlighted) {\n          highlighted.performAction();\n        }\n        break;\n\n      case KeyCodes.UP:\n        this.highlightPrevious();\n        break;\n\n      case KeyCodes.DOWN:\n        this.highlightNext();\n        break;\n\n      case KeyCodes.PAGE_UP:\n      case KeyCodes.HOME:\n        this.highlightFirst_();\n        break;\n\n      case KeyCodes.PAGE_DOWN:\n      case KeyCodes.END:\n        this.highlightLast_();\n        break;\n\n      default:\n        // Not a key the menu is interested in.\n        return;\n    }\n    // The menu used this key, don't let it have secondary effects.\n    e.preventDefault();\n    e.stopPropagation();\n  }\n\n  /**\n   * Get the size of a rendered menu.\n   * @return {!Size} Object with width and height properties.\n   * @package\n   */\n  getSize() {\n    const menuDom = this.getElement();\n    const menuSize = style.getSize(/** @type {!Element} */\n                                   (menuDom));\n    // Recalculate height for the total content, not only box height.\n    menuSize.height = menuDom.scrollHeight;\n    return menuSize;\n  }\n};\n\nexports.Menu = Menu;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/menu.js?")},
"./core/menuitem.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/aria.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/utils/idgenerator.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Blockly menu item similar to Closure's goog.ui.MenuItem\n */\n\n\n/**\n * Blockly menu item similar to Closure's goog.ui.MenuItem\n * @class\n */\ngoog.module('Blockly.MenuItem');\n\nconst aria = goog.require('Blockly.utils.aria');\nconst dom = goog.require('Blockly.utils.dom');\nconst idGenerator = goog.require('Blockly.utils.idGenerator');\n\n\n/**\n * Class representing an item in a menu.\n * @alias Blockly.MenuItem\n */\nconst MenuItem = class {\n  /**\n   * @param {string|!HTMLElement} content Text caption to display as the content\n   *     of the item, or a HTML element to display.\n   * @param {string=} opt_value Data/model associated with the menu item.\n   */\n  constructor(content, opt_value) {\n    /**\n     * Human-readable text of this menu item, or the HTML element to display.\n     * @type {string|!HTMLElement}\n     * @private\n     */\n    this.content_ = content;\n\n    /**\n     * Machine-readable value of this menu item.\n     * @type {string|undefined}\n     * @private\n     */\n    this.value_ = opt_value;\n\n    /**\n     * Is the menu item clickable, as opposed to greyed-out.\n     * @type {boolean}\n     * @private\n     */\n    this.enabled_ = true;\n\n    /**\n     * The DOM element for the menu item.\n     * @type {?HTMLDivElement}\n     * @private\n     */\n    this.element_ = null;\n\n    /**\n     * Whether the menu item is rendered right-to-left.\n     * @type {boolean}\n     * @private\n     */\n    this.rightToLeft_ = false;\n\n    /**\n     * ARIA name for this menu.\n     * @type {?aria.Role}\n     * @private\n     */\n    this.roleName_ = null;\n\n    /**\n     * Is this menu item checkable.\n     * @type {boolean}\n     * @private\n     */\n    this.checkable_ = false;\n\n    /**\n     * Is this menu item currently checked.\n     * @type {boolean}\n     * @private\n     */\n    this.checked_ = false;\n\n    /**\n     * Is this menu item currently highlighted.\n     * @type {boolean}\n     * @private\n     */\n    this.highlight_ = false;\n\n    /**\n     * Bound function to call when this menu item is clicked.\n     * @type {?Function}\n     * @private\n     */\n    this.actionHandler_ = null;\n  }\n\n  /**\n   * Creates the menuitem's DOM.\n   * @return {!Element} Completed DOM.\n   */\n  createDom() {\n    const element =\n        /** @type {!HTMLDivElement} */ (document.createElement('div'));\n    element.id = idGenerator.getNextUniqueId();\n    this.element_ = element;\n\n    // Set class and style\n    // goog-menuitem* is deprecated, use blocklyMenuItem*.  May 2020.\n    element.className = 'blocklyMenuItem goog-menuitem ' +\n        (this.enabled_ ? '' :\n                         'blocklyMenuItemDisabled goog-menuitem-disabled ') +\n        (this.checked_ ? 'blocklyMenuItemSelected goog-option-selected ' : '') +\n        (this.highlight_ ? 'blocklyMenuItemHighlight goog-menuitem-highlight ' :\n                           '') +\n        (this.rightToLeft_ ? 'blocklyMenuItemRtl goog-menuitem-rtl ' : '');\n\n    const content =\n        /** @type {!HTMLDivElement} */ (document.createElement('div'));\n    content.className = 'blocklyMenuItemContent goog-menuitem-content';\n    // Add a checkbox for checkable menu items.\n    if (this.checkable_) {\n      const checkbox =\n          /** @type {!HTMLDivElement} */ (document.createElement('div'));\n      checkbox.className = 'blocklyMenuItemCheckbox goog-menuitem-checkbox';\n      content.appendChild(checkbox);\n    }\n\n    let contentDom = /** @type {!HTMLElement} */ (this.content_);\n    if (typeof this.content_ === 'string') {\n      contentDom = document.createTextNode(this.content_);\n    }\n    content.appendChild(contentDom);\n    element.appendChild(content);\n\n    // Initialize ARIA role and state.\n    if (this.roleName_) {\n      aria.setRole(element, this.roleName_);\n    }\n    aria.setState(\n        element, aria.State.SELECTED,\n        (this.checkable_ && this.checked_) || false);\n    aria.setState(element, aria.State.DISABLED, !this.enabled_);\n\n    return element;\n  }\n\n  /**\n   * Dispose of this menu item.\n   */\n  dispose() {\n    this.element_ = null;\n  }\n\n  /**\n   * Gets the menu item's element.\n   * @return {?Element} The DOM element.\n   * @package\n   */\n  getElement() {\n    return this.element_;\n  }\n\n  /**\n   * Gets the unique ID for this menu item.\n   * @return {string} Unique component ID.\n   * @package\n   */\n  getId() {\n    return this.element_.id;\n  }\n\n  /**\n   * Gets the value associated with the menu item.\n   * @return {*} value Value associated with the menu item.\n   * @package\n   */\n  getValue() {\n    return this.value_;\n  }\n\n  /**\n   * Set menu item's rendering direction.\n   * @param {boolean} rtl True if RTL, false if LTR.\n   * @package\n   */\n  setRightToLeft(rtl) {\n    this.rightToLeft_ = rtl;\n  }\n\n  /**\n   * Set the menu item's accessibility role.\n   * @param {!aria.Role} roleName Role name.\n   * @package\n   */\n  setRole(roleName) {\n    this.roleName_ = roleName;\n  }\n\n  /**\n   * Sets the menu item to be checkable or not. Set to true for menu items\n   * that represent checkable options.\n   * @param {boolean} checkable Whether the menu item is checkable.\n   * @package\n   */\n  setCheckable(checkable) {\n    this.checkable_ = checkable;\n  }\n\n  /**\n   * Checks or unchecks the component.\n   * @param {boolean} checked Whether to check or uncheck the component.\n   * @package\n   */\n  setChecked(checked) {\n    this.checked_ = checked;\n  }\n\n  /**\n   * Highlights or unhighlights the component.\n   * @param {boolean} highlight Whether to highlight or unhighlight the\n   *     component.\n   * @package\n   */\n  setHighlighted(highlight) {\n    this.highlight_ = highlight;\n\n    const el = this.getElement();\n    if (el && this.isEnabled()) {\n      // goog-menuitem-highlight is deprecated, use blocklyMenuItemHighlight.\n      // May 2020.\n      const name = 'blocklyMenuItemHighlight';\n      const nameDep = 'goog-menuitem-highlight';\n      if (highlight) {\n        dom.addClass(el, name);\n        dom.addClass(el, nameDep);\n      } else {\n        dom.removeClass(el, name);\n        dom.removeClass(el, nameDep);\n      }\n    }\n  }\n\n  /**\n   * Returns true if the menu item is enabled, false otherwise.\n   * @return {boolean} Whether the menu item is enabled.\n   * @package\n   */\n  isEnabled() {\n    return this.enabled_;\n  }\n\n  /**\n   * Enables or disables the menu item.\n   * @param {boolean} enabled Whether to enable or disable the menu item.\n   * @package\n   */\n  setEnabled(enabled) {\n    this.enabled_ = enabled;\n  }\n\n  /**\n   * Performs the appropriate action when the menu item is activated\n   * by the user.\n   * @package\n   */\n  performAction() {\n    if (this.isEnabled() && this.actionHandler_) {\n      this.actionHandler_(this);\n    }\n  }\n\n  /**\n   * Set the handler that's called when the menu item is activated by the user.\n   * `obj` will be used as the 'this' object in the function when called.\n   * @param {function(!MenuItem)} fn The handler.\n   * @param {!Object} obj Used as the 'this' object in fn when called.\n   * @package\n   */\n  onAction(fn, obj) {\n    this.actionHandler_ = fn.bind(obj);\n  }\n};\n\nexports.MenuItem = MenuItem;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/menuitem.js?")},
"./core/metrics_manager.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/utils/toolbox.js\");\n__webpack_require__(\"./core/interfaces/i_metrics_manager.js\");\n__webpack_require__(\"./core/utils/size.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Calculates and reports workspace metrics.\n */\n\n\n/**\n * Calculates and reports workspace metrics.\n * @class\n */\ngoog.module('Blockly.MetricsManager');\n\nconst registry = goog.require('Blockly.registry');\nconst toolboxUtils = goog.require('Blockly.utils.toolbox');\n/* eslint-disable-next-line no-unused-vars */\nconst {IFlyout} = goog.requireType('Blockly.IFlyout');\n/* eslint-disable-next-line no-unused-vars */\nconst {IMetricsManager} = goog.require('Blockly.IMetricsManager');\n/* eslint-disable-next-line no-unused-vars */\nconst {IToolbox} = goog.requireType('Blockly.IToolbox');\n/* eslint-disable-next-line no-unused-vars */\nconst {Metrics} = goog.requireType('Blockly.utils.Metrics');\nconst {Size} = goog.require('Blockly.utils.Size');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * The manager for all workspace metrics calculations.\n * @implements {IMetricsManager}\n * @alias Blockly.MetricsManager\n */\nclass MetricsManager {\n  /**\n   * @param {!WorkspaceSvg} workspace The workspace to calculate metrics\n   *     for.\n   */\n  constructor(workspace) {\n    /**\n     * The workspace to calculate metrics for.\n     * @type {!WorkspaceSvg}\n     * @protected\n     */\n    this.workspace_ = workspace;\n  }\n\n  /**\n   * Gets the dimensions of the given workspace component, in pixel coordinates.\n   * @param {?IToolbox|?IFlyout} elem The element to get the\n   *     dimensions of, or null.  It should be a toolbox or flyout, and should\n   *     implement getWidth() and getHeight().\n   * @return {!Size} An object containing width and height\n   *     attributes, which will both be zero if elem did not exist.\n   * @protected\n   */\n  getDimensionsPx_(elem) {\n    let width = 0;\n    let height = 0;\n    if (elem) {\n      width = elem.getWidth();\n      height = elem.getHeight();\n    }\n    return new Size(width, height);\n  }\n\n  /**\n   * Gets the width and the height of the flyout on the workspace in pixel\n   * coordinates. Returns 0 for the width and height if the workspace has a\n   * category toolbox instead of a simple toolbox.\n   * @param {boolean=} opt_own Whether to only return the workspace's own\n   *     flyout.\n   * @return {!MetricsManager.ToolboxMetrics} The width and height of the\n   *     flyout.\n   * @public\n   */\n  getFlyoutMetrics(opt_own) {\n    const flyoutDimensions =\n        this.getDimensionsPx_(this.workspace_.getFlyout(opt_own));\n    return {\n      width: flyoutDimensions.width,\n      height: flyoutDimensions.height,\n      position: this.workspace_.toolboxPosition,\n    };\n  }\n\n  /**\n   * Gets the width, height and position of the toolbox on the workspace in\n   * pixel coordinates. Returns 0 for the width and height if the workspace has\n   * a simple toolbox instead of a category toolbox. To get the width and height\n   * of a\n   * simple toolbox @see {@link getFlyoutMetrics}.\n   * @return {!MetricsManager.ToolboxMetrics} The object with the width,\n   *     height and position of the toolbox.\n   * @public\n   */\n  getToolboxMetrics() {\n    const toolboxDimensions =\n        this.getDimensionsPx_(this.workspace_.getToolbox());\n\n    return {\n      width: toolboxDimensions.width,\n      height: toolboxDimensions.height,\n      position: this.workspace_.toolboxPosition,\n    };\n  }\n\n  /**\n   * Gets the width and height of the workspace's parent SVG element in pixel\n   * coordinates. This area includes the toolbox and the visible workspace area.\n   * @return {!Size} The width and height of the workspace's parent\n   *     SVG element.\n   * @public\n   */\n  getSvgMetrics() {\n    return this.workspace_.getCachedParentSvgSize();\n  }\n\n  /**\n   * Gets the absolute left and absolute top in pixel coordinates.\n   * This is where the visible workspace starts in relation to the SVG\n   * container.\n   * @return {!MetricsManager.AbsoluteMetrics} The absolute metrics for\n   *     the workspace.\n   * @public\n   */\n  getAbsoluteMetrics() {\n    let absoluteLeft = 0;\n    const toolboxMetrics = this.getToolboxMetrics();\n    const flyoutMetrics = this.getFlyoutMetrics(true);\n    const doesToolboxExist = !!this.workspace_.getToolbox();\n    const doesFlyoutExist = !!this.workspace_.getFlyout(true);\n    const toolboxPosition =\n        doesToolboxExist ? toolboxMetrics.position : flyoutMetrics.position;\n\n    const atLeft = toolboxPosition === toolboxUtils.Position.LEFT;\n    const atTop = toolboxPosition === toolboxUtils.Position.TOP;\n    if (doesToolboxExist && atLeft) {\n      absoluteLeft = toolboxMetrics.width;\n    } else if (doesFlyoutExist && atLeft) {\n      absoluteLeft = flyoutMetrics.width;\n    }\n    let absoluteTop = 0;\n    if (doesToolboxExist && atTop) {\n      absoluteTop = toolboxMetrics.height;\n    } else if (doesFlyoutExist && atTop) {\n      absoluteTop = flyoutMetrics.height;\n    }\n\n    return {\n      top: absoluteTop,\n      left: absoluteLeft,\n    };\n  }\n\n  /**\n   * Gets the metrics for the visible workspace in either pixel or workspace\n   * coordinates. The visible workspace does not include the toolbox or flyout.\n   * @param {boolean=} opt_getWorkspaceCoordinates True to get the view metrics\n   *     in workspace coordinates, false to get them in pixel coordinates.\n   * @return {!MetricsManager.ContainerRegion} The width, height, top and\n   *     left of the viewport in either workspace coordinates or pixel\n   *     coordinates.\n   * @public\n   */\n  getViewMetrics(opt_getWorkspaceCoordinates) {\n    const scale = opt_getWorkspaceCoordinates ? this.workspace_.scale : 1;\n    const svgMetrics = this.getSvgMetrics();\n    const toolboxMetrics = this.getToolboxMetrics();\n    const flyoutMetrics = this.getFlyoutMetrics(true);\n    const doesToolboxExist = !!this.workspace_.getToolbox();\n    const toolboxPosition =\n        doesToolboxExist ? toolboxMetrics.position : flyoutMetrics.position;\n\n    if (this.workspace_.getToolbox()) {\n      if (toolboxPosition === toolboxUtils.Position.TOP ||\n          toolboxPosition === toolboxUtils.Position.BOTTOM) {\n        svgMetrics.height -= toolboxMetrics.height;\n      } else if (\n          toolboxPosition === toolboxUtils.Position.LEFT ||\n          toolboxPosition === toolboxUtils.Position.RIGHT) {\n        svgMetrics.width -= toolboxMetrics.width;\n      }\n    } else if (this.workspace_.getFlyout(true)) {\n      if (toolboxPosition === toolboxUtils.Position.TOP ||\n          toolboxPosition === toolboxUtils.Position.BOTTOM) {\n        svgMetrics.height -= flyoutMetrics.height;\n      } else if (\n          toolboxPosition === toolboxUtils.Position.LEFT ||\n          toolboxPosition === toolboxUtils.Position.RIGHT) {\n        svgMetrics.width -= flyoutMetrics.width;\n      }\n    }\n    return {\n      height: svgMetrics.height / scale,\n      width: svgMetrics.width / scale,\n      top: -this.workspace_.scrollY / scale,\n      left: -this.workspace_.scrollX / scale,\n    };\n  }\n\n  /**\n   * Gets content metrics in either pixel or workspace coordinates.\n   * The content area is a rectangle around all the top bounded elements on the\n   * workspace (workspace comments and blocks).\n   * @param {boolean=} opt_getWorkspaceCoordinates True to get the content\n   *     metrics in workspace coordinates, false to get them in pixel\n   *     coordinates.\n   * @return {!MetricsManager.ContainerRegion} The\n   *     metrics for the content container.\n   * @public\n   */\n  getContentMetrics(opt_getWorkspaceCoordinates) {\n    const scale = opt_getWorkspaceCoordinates ? 1 : this.workspace_.scale;\n\n    // Block bounding box is in workspace coordinates.\n    const blockBox = this.workspace_.getBlocksBoundingBox();\n\n    return {\n      height: (blockBox.bottom - blockBox.top) * scale,\n      width: (blockBox.right - blockBox.left) * scale,\n      top: blockBox.top * scale,\n      left: blockBox.left * scale,\n    };\n  }\n\n  /**\n   * Returns whether the scroll area has fixed edges.\n   * @return {boolean} Whether the scroll area has fixed edges.\n   * @package\n   */\n  hasFixedEdges() {\n    // This exists for optimization of bump logic.\n    return !this.workspace_.isMovableHorizontally() ||\n        !this.workspace_.isMovableVertically();\n  }\n\n  /**\n   * Computes the fixed edges of the scroll area.\n   * @param {!MetricsManager.ContainerRegion=} opt_viewMetrics The view\n   *     metrics if they have been previously computed. Passing in null may\n   * cause the view metrics to be computed again, if it is needed.\n   * @return {!MetricsManager.FixedEdges} The fixed edges of the scroll\n   *     area.\n   * @protected\n   */\n  getComputedFixedEdges_(opt_viewMetrics) {\n    if (!this.hasFixedEdges()) {\n      // Return early if there are no edges.\n      return {};\n    }\n\n    const hScrollEnabled = this.workspace_.isMovableHorizontally();\n    const vScrollEnabled = this.workspace_.isMovableVertically();\n\n    const viewMetrics = opt_viewMetrics || this.getViewMetrics(false);\n\n    const edges = {};\n    if (!vScrollEnabled) {\n      edges.top = viewMetrics.top;\n      edges.bottom = viewMetrics.top + viewMetrics.height;\n    }\n    if (!hScrollEnabled) {\n      edges.left = viewMetrics.left;\n      edges.right = viewMetrics.left + viewMetrics.width;\n    }\n    return edges;\n  }\n\n  /**\n   * Returns the content area with added padding.\n   * @param {!MetricsManager.ContainerRegion} viewMetrics The view\n   *     metrics.\n   * @param {!MetricsManager.ContainerRegion} contentMetrics The content\n   *     metrics.\n   * @return {{top: number, bottom: number, left: number, right: number}} The\n   *     padded content area.\n   * @protected\n   */\n  getPaddedContent_(viewMetrics, contentMetrics) {\n    const contentBottom = contentMetrics.top + contentMetrics.height;\n    const contentRight = contentMetrics.left + contentMetrics.width;\n\n    const viewWidth = viewMetrics.width;\n    const viewHeight = viewMetrics.height;\n    const halfWidth = viewWidth / 2;\n    const halfHeight = viewHeight / 2;\n\n    // Add a padding around the content that is at least half a screen wide.\n    // Ensure padding is wide enough that blocks can scroll over entire screen.\n    const top =\n        Math.min(contentMetrics.top - halfHeight, contentBottom - viewHeight);\n    const left =\n        Math.min(contentMetrics.left - halfWidth, contentRight - viewWidth);\n    const bottom =\n        Math.max(contentBottom + halfHeight, contentMetrics.top + viewHeight);\n    const right =\n        Math.max(contentRight + halfWidth, contentMetrics.left + viewWidth);\n\n    return {top: top, bottom: bottom, left: left, right: right};\n  }\n\n  /**\n   * Returns the metrics for the scroll area of the workspace.\n   * @param {boolean=} opt_getWorkspaceCoordinates True to get the scroll\n   *     metrics in workspace coordinates, false to get them in pixel\n   *     coordinates.\n   * @param {!MetricsManager.ContainerRegion=} opt_viewMetrics The view\n   *     metrics if they have been previously computed. Passing in null may\n   * cause the view metrics to be computed again, if it is needed.\n   * @param {!MetricsManager.ContainerRegion=} opt_contentMetrics The\n   *     content metrics if they have been previously computed. Passing in null\n   *     may cause the content metrics to be computed again, if it is needed.\n   * @return {!MetricsManager.ContainerRegion} The metrics for the scroll\n   *    container.\n   */\n  getScrollMetrics(\n      opt_getWorkspaceCoordinates, opt_viewMetrics, opt_contentMetrics) {\n    const scale = opt_getWorkspaceCoordinates ? this.workspace_.scale : 1;\n    const viewMetrics = opt_viewMetrics || this.getViewMetrics(false);\n    const contentMetrics = opt_contentMetrics || this.getContentMetrics();\n    const fixedEdges = this.getComputedFixedEdges_(viewMetrics);\n\n    // Add padding around content.\n    const paddedContent = this.getPaddedContent_(viewMetrics, contentMetrics);\n\n    // Use combination of fixed bounds and padded content to make scroll area.\n    const top =\n        fixedEdges.top !== undefined ? fixedEdges.top : paddedContent.top;\n    const left =\n        fixedEdges.left !== undefined ? fixedEdges.left : paddedContent.left;\n    const bottom = fixedEdges.bottom !== undefined ? fixedEdges.bottom :\n                                                     paddedContent.bottom;\n    const right =\n        fixedEdges.right !== undefined ? fixedEdges.right : paddedContent.right;\n\n    return {\n      top: top / scale,\n      left: left / scale,\n      width: (right - left) / scale,\n      height: (bottom - top) / scale,\n    };\n  }\n\n  /**\n   * Returns common metrics used by UI elements.\n   * @return {!MetricsManager.UiMetrics} The UI metrics.\n   */\n  getUiMetrics() {\n    return {\n      viewMetrics: this.getViewMetrics(),\n      absoluteMetrics: this.getAbsoluteMetrics(),\n      toolboxMetrics: this.getToolboxMetrics(),\n    };\n  }\n\n  /**\n   * Returns an object with all the metrics required to size scrollbars for a\n   * top level workspace.  The following properties are computed:\n   * Coordinate system: pixel coordinates, -left, -up, +right, +down\n   * .viewHeight: Height of the visible portion of the workspace.\n   * .viewWidth: Width of the visible portion of the workspace.\n   * .contentHeight: Height of the content.\n   * .contentWidth: Width of the content.\n   * .scrollHeight: Height of the scroll area.\n   * .scrollWidth: Width of the scroll area.\n   * .svgHeight: Height of the Blockly div (the view + the toolbox,\n   *    simple or otherwise),\n   * .svgWidth: Width of the Blockly div (the view + the toolbox,\n   *    simple or otherwise),\n   * .viewTop: Top-edge of the visible portion of the workspace, relative to\n   *     the workspace origin.\n   * .viewLeft: Left-edge of the visible portion of the workspace, relative to\n   *     the workspace origin.\n   * .contentTop: Top-edge of the content, relative to the workspace origin.\n   * .contentLeft: Left-edge of the content relative to the workspace origin.\n   * .scrollTop: Top-edge of the scroll area, relative to the workspace origin.\n   * .scrollLeft: Left-edge of the scroll area relative to the workspace origin.\n   * .absoluteTop: Top-edge of the visible portion of the workspace, relative\n   *     to the blocklyDiv.\n   * .absoluteLeft: Left-edge of the visible portion of the workspace, relative\n   *     to the blocklyDiv.\n   * .toolboxWidth: Width of the toolbox, if it exists.  Otherwise zero.\n   * .toolboxHeight: Height of the toolbox, if it exists.  Otherwise zero.\n   * .flyoutWidth: Width of the flyout if it is always open.  Otherwise zero.\n   * .flyoutHeight: Height of the flyout if it is always open.  Otherwise zero.\n   * .toolboxPosition: Top, bottom, left or right. Use TOOLBOX_AT constants to\n   *     compare.\n   * @return {!Metrics} Contains size and position metrics of a top\n   *     level workspace.\n   * @public\n   */\n  getMetrics() {\n    const toolboxMetrics = this.getToolboxMetrics();\n    const flyoutMetrics = this.getFlyoutMetrics(true);\n    const svgMetrics = this.getSvgMetrics();\n    const absoluteMetrics = this.getAbsoluteMetrics();\n    const viewMetrics = this.getViewMetrics();\n    const contentMetrics = this.getContentMetrics();\n    const scrollMetrics =\n        this.getScrollMetrics(false, viewMetrics, contentMetrics);\n\n    return {\n      contentHeight: contentMetrics.height,\n      contentWidth: contentMetrics.width,\n      contentTop: contentMetrics.top,\n      contentLeft: contentMetrics.left,\n\n      scrollHeight: scrollMetrics.height,\n      scrollWidth: scrollMetrics.width,\n      scrollTop: scrollMetrics.top,\n      scrollLeft: scrollMetrics.left,\n\n      viewHeight: viewMetrics.height,\n      viewWidth: viewMetrics.width,\n      viewTop: viewMetrics.top,\n      viewLeft: viewMetrics.left,\n\n      absoluteTop: absoluteMetrics.top,\n      absoluteLeft: absoluteMetrics.left,\n\n      svgHeight: svgMetrics.height,\n      svgWidth: svgMetrics.width,\n\n      toolboxWidth: toolboxMetrics.width,\n      toolboxHeight: toolboxMetrics.height,\n      toolboxPosition: toolboxMetrics.position,\n\n      flyoutWidth: flyoutMetrics.width,\n      flyoutHeight: flyoutMetrics.height,\n    };\n  }\n}\n\n/**\n * Describes the width, height and location of the toolbox on the main\n * workspace.\n * @typedef {{\n *            width: number,\n *            height: number,\n *            position: !toolboxUtils.Position\n *          }}\n */\nMetricsManager.ToolboxMetrics;\n\n/**\n * Describes where the viewport starts in relation to the workspace SVG.\n * @typedef {{\n *            left: number,\n *            top: number\n *          }}\n */\nMetricsManager.AbsoluteMetrics;\n\n/**\n * All the measurements needed to describe the size and location of a\n * container.\n * @typedef {{\n *            height: number,\n *            width: number,\n *            top: number,\n *            left: number\n *          }}\n */\nMetricsManager.ContainerRegion;\n\n/**\n * Describes fixed edges of the workspace.\n * @typedef {{\n *            top: (number|undefined),\n *            bottom: (number|undefined),\n *            left: (number|undefined),\n *            right: (number|undefined)\n *          }}\n */\nMetricsManager.FixedEdges;\n\n/**\n * Common metrics used for UI elements.\n * @typedef {{\n *            viewMetrics: !MetricsManager.ContainerRegion,\n *            absoluteMetrics: !MetricsManager.AbsoluteMetrics,\n *            toolboxMetrics: !MetricsManager.ToolboxMetrics\n *          }}\n */\nMetricsManager.UiMetrics;\n\nregistry.register(\n    registry.Type.METRICS_MANAGER, registry.DEFAULT, MetricsManager);\n\nexports.MetricsManager = MetricsManager;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/metrics_manager.js?")},
"./core/msg.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2013 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Empty name space for the Message singleton.\n */\n\n\n/**\n * Empty name space for the Message singleton.\n * @namespace Blockly.Msg\n */\ngoog.module('Blockly.Msg');\n\n\n/**\n * A dictionary of localised messages.\n * @type {!Object<string>}\n */\nconst Msg = Object.create(null);\nexports.Msg = Msg;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/msg.js?")},
"./core/mutator.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/utils/toolbox.js\");\n__webpack_require__(\"./core/utils/xml.js\");\n__webpack_require__(\"./core/events/events_block_change.js\");\n__webpack_require__(\"./core/bubble.js\");\n__webpack_require__(\"./core/config.js\");\n__webpack_require__(\"./core/icon.js\");\n__webpack_require__(\"./core/options.js\");\n__webpack_require__(\"./core/utils/svg.js\");\n__webpack_require__(\"./core/workspace_svg.js\");\n__webpack_require__(\"./core/events/events_bubble_open.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing a mutator dialog.  A mutator allows the\n * user to change the shape of a block using a nested blocks editor.\n */\n\n\n/**\n * Object representing a mutator dialog.  A mutator allows the\n * user to change the shape of a block using a nested blocks editor.\n * @class\n */\ngoog.module('Blockly.Mutator');\n\nconst dom = goog.require('Blockly.utils.dom');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst toolbox = goog.require('Blockly.utils.toolbox');\nconst xml = goog.require('Blockly.utils.xml');\n/* eslint-disable-next-line no-unused-vars */\nconst {Abstract} = goog.requireType('Blockly.Events.Abstract');\nconst {BlockChange} = goog.require('Blockly.Events.BlockChange');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlocklyOptions} = goog.requireType('Blockly.BlocklyOptions');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\nconst {Bubble} = goog.require('Blockly.Bubble');\nconst {config} = goog.require('Blockly.config');\n/* eslint-disable-next-line no-unused-vars */\nconst {Connection} = goog.requireType('Blockly.Connection');\n/* eslint-disable-next-line no-unused-vars */\nconst {Coordinate} = goog.requireType('Blockly.utils.Coordinate');\nconst {Icon} = goog.require('Blockly.Icon');\nconst {Options} = goog.require('Blockly.Options');\nconst {Svg} = goog.require('Blockly.utils.Svg');\nconst {WorkspaceSvg} = goog.require('Blockly.WorkspaceSvg');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BubbleOpen');\n\n\n/**\n * Class for a mutator dialog.\n * @extends {Icon}\n * @alias Blockly.Mutator\n */\nclass Mutator extends Icon {\n  /**\n   * @param {!Array<string>} quarkNames List of names of sub-blocks for flyout.\n   */\n  constructor(quarkNames) {\n    super(null);\n    this.quarkNames_ = quarkNames;\n\n    /**\n     * Workspace in the mutator's bubble.\n     * @type {?WorkspaceSvg}\n     * @private\n     */\n    this.workspace_ = null;\n\n    /**\n     * Width of workspace.\n     * @type {number}\n     * @private\n     */\n    this.workspaceWidth_ = 0;\n\n    /**\n     * Height of workspace.\n     * @type {number}\n     * @private\n     */\n    this.workspaceHeight_ = 0;\n\n    /**\n     * The SVG element that is the parent of the mutator workspace, or null if\n     * not created.\n     * @type {?SVGSVGElement}\n     * @private\n     */\n    this.svgDialog_ = null;\n\n    /**\n     * The root block of the mutator workspace, created by decomposing the\n     * source block.\n     * @type {?BlockSvg}\n     * @private\n     */\n    this.rootBlock_ = null;\n\n    /**\n     * Function registered on the main workspace to update the mutator contents\n     * when the main workspace changes.\n     * @type {?Function}\n     * @private\n     */\n    this.sourceListener_ = null;\n  }\n\n  /**\n   * Set the block this mutator is associated with.\n   * @param {!BlockSvg} block The block associated with this mutator.\n   * @package\n   */\n  setBlock(block) {\n    this.block_ = block;\n  }\n\n  /**\n   * Returns the workspace inside this mutator icon's bubble.\n   * @return {?WorkspaceSvg} The workspace inside this mutator icon's\n   *     bubble or null if the mutator isn't open.\n   * @package\n   */\n  getWorkspace() {\n    return this.workspace_;\n  }\n\n  /**\n   * Draw the mutator icon.\n   * @param {!Element} group The icon group.\n   * @protected\n   */\n  drawIcon_(group) {\n    // Square with rounded corners.\n    dom.createSvgElement(\n        Svg.RECT, {\n          'class': 'blocklyIconShape',\n          'rx': '4',\n          'ry': '4',\n          'height': '16',\n          'width': '16',\n        },\n        group);\n    // Gear teeth.\n    dom.createSvgElement(\n        Svg.PATH, {\n          'class': 'blocklyIconSymbol',\n          'd': 'm4.203,7.296 0,1.368 -0.92,0.677 -0.11,0.41 0.9,1.559 0.41,' +\n              '0.11 1.043,-0.457 1.187,0.683 0.127,1.134 0.3,0.3 1.8,0 0.3,' +\n              '-0.299 0.127,-1.138 1.185,-0.682 1.046,0.458 0.409,-0.11 0.9,' +\n              '-1.559 -0.11,-0.41 -0.92,-0.677 0,-1.366 0.92,-0.677 0.11,' +\n              '-0.41 -0.9,-1.559 -0.409,-0.109 -1.046,0.458 -1.185,-0.682 ' +\n              '-0.127,-1.138 -0.3,-0.299 -1.8,0 -0.3,0.3 -0.126,1.135 -1.187,' +\n              '0.682 -1.043,-0.457 -0.41,0.11 -0.899,1.559 0.108,0.409z',\n        },\n        group);\n    // Axle hole.\n    dom.createSvgElement(\n        Svg.CIRCLE,\n        {'class': 'blocklyIconShape', 'r': '2.7', 'cx': '8', 'cy': '8'}, group);\n  }\n\n  /**\n   * Clicking on the icon toggles if the mutator bubble is visible.\n   * Disable if block is uneditable.\n   * @param {!Event} e Mouse click event.\n   * @protected\n   * @override\n   */\n  iconClick_(e) {\n    if (this.block_.isEditable()) {\n      Icon.prototype.iconClick_.call(this, e);\n    }\n  }\n\n  /**\n   * Create the editor for the mutator's bubble.\n   * @return {!SVGElement} The top-level node of the editor.\n   * @private\n   */\n  createEditor_() {\n    /* Create the editor.  Here's the markup that will be generated:\n    <svg>\n      [Workspace]\n    </svg>\n    */\n    this.svgDialog_ = dom.createSvgElement(\n        Svg.SVG, {'x': Bubble.BORDER_WIDTH, 'y': Bubble.BORDER_WIDTH}, null);\n    // Convert the list of names into a list of XML objects for the flyout.\n    let quarkXml;\n    if (this.quarkNames_.length) {\n      quarkXml = xml.createElement('xml');\n      for (let i = 0, quarkName; (quarkName = this.quarkNames_[i]); i++) {\n        const element = xml.createElement('block');\n        element.setAttribute('type', quarkName);\n        quarkXml.appendChild(element);\n      }\n    } else {\n      quarkXml = null;\n    }\n    const workspaceOptions = new Options(\n        /** @type {!BlocklyOptions} */\n        ({\n          // If you want to enable disabling, also remove the\n          // event filter from workspaceChanged_ .\n          'disable': false,\n          'parentWorkspace': this.block_.workspace,\n          'media': this.block_.workspace.options.pathToMedia,\n          'rtl': this.block_.RTL,\n          'horizontalLayout': false,\n          'renderer': this.block_.workspace.options.renderer,\n          'rendererOverrides': this.block_.workspace.options.rendererOverrides,\n        }));\n    workspaceOptions.toolboxPosition =\n        this.block_.RTL ? toolbox.Position.RIGHT : toolbox.Position.LEFT;\n    const hasFlyout = !!quarkXml;\n    if (hasFlyout) {\n      workspaceOptions.languageTree = toolbox.convertToolboxDefToJson(quarkXml);\n    }\n    this.workspace_ = new WorkspaceSvg(workspaceOptions);\n    this.workspace_.isMutator = true;\n    this.workspace_.addChangeListener(eventUtils.disableOrphans);\n\n    // Mutator flyouts go inside the mutator workspace's <g> rather than in\n    // a top level SVG. Instead of handling scale themselves, mutators\n    // inherit scale from the parent workspace.\n    // To fix this, scale needs to be applied at a different level in the DOM.\n    const flyoutSvg = hasFlyout ? this.workspace_.addFlyout(Svg.G) : null;\n    const background = this.workspace_.createDom('blocklyMutatorBackground');\n\n    if (flyoutSvg) {\n      // Insert the flyout after the <rect> but before the block canvas so that\n      // the flyout is underneath in z-order.  This makes blocks layering during\n      // dragging work properly.\n      background.insertBefore(flyoutSvg, this.workspace_.svgBlockCanvas_);\n    }\n    this.svgDialog_.appendChild(background);\n\n    return this.svgDialog_;\n  }\n\n  /**\n   * Add or remove the UI indicating if this icon may be clicked or not.\n   */\n  updateEditable() {\n    super.updateEditable();\n    if (!this.block_.isInFlyout) {\n      if (this.block_.isEditable()) {\n        if (this.iconGroup_) {\n          dom.removeClass(\n              /** @type {!Element} */ (this.iconGroup_),\n              'blocklyIconGroupReadonly');\n        }\n      } else {\n        // Close any mutator bubble.  Icon is not clickable.\n        this.setVisible(false);\n        if (this.iconGroup_) {\n          dom.addClass(\n              /** @type {!Element} */ (this.iconGroup_),\n              'blocklyIconGroupReadonly');\n        }\n      }\n    }\n  }\n\n  /**\n   * Resize the bubble to match the size of the workspace.\n   * @private\n   */\n  resizeBubble_() {\n    const doubleBorderWidth = 2 * Bubble.BORDER_WIDTH;\n    const workspaceSize = this.workspace_.getCanvas().getBBox();\n    let width = workspaceSize.width + workspaceSize.x;\n    let height = workspaceSize.height + doubleBorderWidth * 3;\n    const flyout = this.workspace_.getFlyout();\n    if (flyout) {\n      const flyoutScrollMetrics =\n          flyout.getWorkspace().getMetricsManager().getScrollMetrics();\n      height = Math.max(height, flyoutScrollMetrics.height + 20);\n      width += flyout.getWidth();\n    }\n    if (this.block_.RTL) {\n      width = -workspaceSize.x;\n    }\n    width += doubleBorderWidth * 3;\n    // Only resize if the size difference is significant.  Eliminates\n    // shuddering.\n    if (Math.abs(this.workspaceWidth_ - width) > doubleBorderWidth ||\n        Math.abs(this.workspaceHeight_ - height) > doubleBorderWidth) {\n      // Record some layout information for workspace metrics.\n      this.workspaceWidth_ = width;\n      this.workspaceHeight_ = height;\n      // Resize the bubble.\n      this.bubble_.setBubbleSize(\n          width + doubleBorderWidth, height + doubleBorderWidth);\n      this.svgDialog_.setAttribute('width', this.workspaceWidth_);\n      this.svgDialog_.setAttribute('height', this.workspaceHeight_);\n      this.workspace_.setCachedParentSvgSize(\n          this.workspaceWidth_, this.workspaceHeight_);\n    }\n\n    if (this.block_.RTL) {\n      // Scroll the workspace to always left-align.\n      const translation = 'translate(' + this.workspaceWidth_ + ',0)';\n      this.workspace_.getCanvas().setAttribute('transform', translation);\n    }\n    this.workspace_.resize();\n  }\n\n  /**\n   * A method handler for when the bubble is moved.\n   * @private\n   */\n  onBubbleMove_() {\n    if (this.workspace_) {\n      this.workspace_.recordDragTargets();\n    }\n  }\n\n  /**\n   * Show or hide the mutator bubble.\n   * @param {boolean} visible True if the bubble should be visible.\n   */\n  setVisible(visible) {\n    if (visible === this.isVisible()) {\n      // No change.\n      return;\n    }\n    eventUtils.fire(new (eventUtils.get(eventUtils.BUBBLE_OPEN))(\n        this.block_, visible, 'mutator'));\n    if (visible) {\n      // Create the bubble.\n      this.bubble_ = new Bubble(\n          /** @type {!WorkspaceSvg} */ (this.block_.workspace),\n          this.createEditor_(), this.block_.pathObject.svgPath,\n          /** @type {!Coordinate} */ (this.iconXY_), null, null);\n      // Expose this mutator's block's ID on its top-level SVG group.\n      this.bubble_.setSvgId(this.block_.id);\n      this.bubble_.registerMoveEvent(this.onBubbleMove_.bind(this));\n      const tree = this.workspace_.options.languageTree;\n      const flyout = this.workspace_.getFlyout();\n      if (tree) {\n        flyout.init(this.workspace_);\n        flyout.show(tree);\n      }\n\n      this.rootBlock_ = this.block_.decompose(this.workspace_);\n      const blocks = this.rootBlock_.getDescendants(false);\n      for (let i = 0, child; (child = blocks[i]); i++) {\n        child.render();\n      }\n      // The root block should not be draggable or deletable.\n      this.rootBlock_.setMovable(false);\n      this.rootBlock_.setDeletable(false);\n      let margin;\n      let x;\n      if (flyout) {\n        margin = flyout.CORNER_RADIUS * 2;\n        x = this.rootBlock_.RTL ? flyout.getWidth() + margin : margin;\n      } else {\n        margin = 16;\n        x = margin;\n      }\n      if (this.block_.RTL) {\n        x = -x;\n      }\n      this.rootBlock_.moveBy(x, margin);\n      // Save the initial connections, then listen for further changes.\n      if (this.block_.saveConnections) {\n        const thisRootBlock = this.rootBlock_;\n        this.block_.saveConnections(thisRootBlock);\n        this.sourceListener_ = () => {\n          if (this.block_) {\n            this.block_.saveConnections(thisRootBlock);\n          }\n        };\n        this.block_.workspace.addChangeListener(this.sourceListener_);\n      }\n      this.resizeBubble_();\n      // When the mutator's workspace changes, update the source block.\n      this.workspace_.addChangeListener(this.workspaceChanged_.bind(this));\n      // Update the source block immediately after the bubble becomes visible.\n      this.updateWorkspace_();\n      this.applyColour();\n    } else {\n      // Dispose of the bubble.\n      this.svgDialog_ = null;\n      this.workspace_.dispose();\n      this.workspace_ = null;\n      this.rootBlock_ = null;\n      this.bubble_.dispose();\n      this.bubble_ = null;\n      this.workspaceWidth_ = 0;\n      this.workspaceHeight_ = 0;\n      if (this.sourceListener_) {\n        this.block_.workspace.removeChangeListener(this.sourceListener_);\n        this.sourceListener_ = null;\n      }\n    }\n  }\n\n  /**\n   * Fired whenever a change is made to the mutator's workspace.\n   * @param {!Abstract} e Custom data for event.\n   * @private\n   */\n  workspaceChanged_(e) {\n    if (!(e.isUiEvent ||\n          (e.type === eventUtils.CHANGE &&\n           /** @type {!BlockChange} */ (e).element === 'disabled') ||\n          e.type === eventUtils.CREATE)) {\n      this.updateWorkspace_();\n    }\n  }\n\n  /**\n   * Updates the source block when the mutator's blocks are changed.\n   * Bump down any block that's too high.\n   * @private\n   */\n  updateWorkspace_() {\n    if (!this.workspace_.isDragging()) {\n      const blocks = this.workspace_.getTopBlocks(false);\n      const MARGIN = 20;\n\n      for (let b = 0, block; (block = blocks[b]); b++) {\n        const blockXY = block.getRelativeToSurfaceXY();\n\n        // Bump any block that's above the top back inside.\n        if (blockXY.y < MARGIN) {\n          block.moveBy(0, MARGIN - blockXY.y);\n        }\n        // Bump any block overlapping the flyout back inside.\n        if (block.RTL) {\n          let right = -MARGIN;\n          const flyout = this.workspace_.getFlyout();\n          if (flyout) {\n            right -= flyout.getWidth();\n          }\n          if (blockXY.x > right) {\n            block.moveBy(right - blockXY.x, 0);\n          }\n        } else if (blockXY.x < MARGIN) {\n          block.moveBy(MARGIN - blockXY.x, 0);\n        }\n      }\n    }\n\n    // When the mutator's workspace changes, update the source block.\n    if (this.rootBlock_.workspace === this.workspace_) {\n      const existingGroup = eventUtils.getGroup();\n      if (!existingGroup) {\n        eventUtils.setGroup(true);\n      }\n      const block = /** @type {!BlockSvg} */ (this.block_);\n      const oldExtraState = BlockChange.getExtraBlockState_(block);\n\n      // Switch off rendering while the source block is rebuilt.\n      const savedRendered = block.rendered;\n      // TODO(#4288): We should not be setting the rendered property to false.\n      block.rendered = false;\n\n      // Allow the source block to rebuild itself.\n      block.compose(this.rootBlock_);\n      // Restore rendering and show the changes.\n      block.rendered = savedRendered;\n      // Mutation may have added some elements that need initializing.\n      block.initSvg();\n\n      if (block.rendered) {\n        block.render();\n      }\n\n      const newExtraState = BlockChange.getExtraBlockState_(block);\n      if (oldExtraState !== newExtraState) {\n        eventUtils.fire(new (eventUtils.get(eventUtils.BLOCK_CHANGE))(\n            block, 'mutation', null, oldExtraState, newExtraState));\n        // Ensure that any bump is part of this mutation's event group.\n        const mutationGroup = eventUtils.getGroup();\n        setTimeout(function() {\n          const oldGroup = eventUtils.getGroup();\n          eventUtils.setGroup(mutationGroup);\n          block.bumpNeighbours();\n          eventUtils.setGroup(oldGroup);\n        }, config.bumpDelay);\n      }\n\n      // Don't update the bubble until the drag has ended, to avoid moving\n      // blocks under the cursor.\n      if (!this.workspace_.isDragging()) {\n        this.resizeBubble_();\n      }\n      eventUtils.setGroup(existingGroup);\n    }\n  }\n\n  /**\n   * Dispose of this mutator.\n   */\n  dispose() {\n    this.block_.mutator = null;\n    Icon.prototype.dispose.call(this);\n  }\n\n  /**\n   * Update the styles on all blocks in the mutator.\n   * @public\n   */\n  updateBlockStyle() {\n    const ws = this.workspace_;\n\n    if (ws && ws.getAllBlocks(false)) {\n      const workspaceBlocks = ws.getAllBlocks(false);\n      for (let i = 0, block; (block = workspaceBlocks[i]); i++) {\n        block.setStyle(block.getStyleName());\n      }\n\n      const flyout = ws.getFlyout();\n      if (flyout) {\n        const flyoutBlocks = flyout.workspace_.getAllBlocks(false);\n        for (let i = 0, block; (block = flyoutBlocks[i]); i++) {\n          block.setStyle(block.getStyleName());\n        }\n      }\n    }\n  }\n\n  /**\n   * Reconnect an block to a mutated input.\n   * @param {Connection} connectionChild Connection on child block.\n   * @param {!Block} block Parent block.\n   * @param {string} inputName Name of input on parent block.\n   * @return {boolean} True iff a reconnection was made, false otherwise.\n   */\n  static reconnect(connectionChild, block, inputName) {\n    if (!connectionChild || !connectionChild.getSourceBlock().workspace) {\n      return false;  // No connection or block has been deleted.\n    }\n    const connectionParent = block.getInput(inputName).connection;\n    const currentParent = connectionChild.targetBlock();\n    if ((!currentParent || currentParent === block) &&\n        connectionParent.targetConnection !== connectionChild) {\n      if (connectionParent.isConnected()) {\n        // There's already something connected here.  Get rid of it.\n        connectionParent.disconnect();\n      }\n      connectionParent.connect(connectionChild);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Get the parent workspace of a workspace that is inside a mutator, taking\n   * into account whether it is a flyout.\n   * @param {WorkspaceSvg} workspace The workspace that is inside a mutator.\n   * @return {?WorkspaceSvg} The mutator's parent workspace or null.\n   * @public\n   */\n  static findParentWs(workspace) {\n    let outerWs = null;\n    if (workspace && workspace.options) {\n      const parent = workspace.options.parentWorkspace;\n      // If we were in a flyout in a mutator, need to go up two levels to find\n      // the actual parent.\n      if (workspace.isFlyout) {\n        if (parent && parent.options) {\n          outerWs = parent.options.parentWorkspace;\n        }\n      } else if (parent) {\n        outerWs = parent;\n      }\n    }\n    return outerWs;\n  }\n}\n\nexports.Mutator = Mutator;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/mutator.js?")},
"./core/names.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/variables.js\");\n__webpack_require__(\"./core/msg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility functions for handling variable and procedure names.\n */\n\n\n/**\n * Utility functions for handling variable and procedure names.\n * @class\n */\ngoog.module('Blockly.Names');\n\nconst Variables = goog.require('Blockly.Variables');\nconst {Msg} = goog.require('Blockly.Msg');\n/* eslint-disable-next-line no-unused-vars */\nconst {VariableMap} = goog.requireType('Blockly.VariableMap');\n/* eslint-disable-next-line no-unused-vars */\nconst {Workspace} = goog.requireType('Blockly.Workspace');\n/** @suppress {extraRequire} */\ngoog.requireType('Blockly.Procedures');\n\n\n/**\n * Class for a database of entity names (variables, procedures, etc).\n * @alias Blockly.Names\n */\nconst Names = class {\n  /**\n   * @param {string} reservedWords A comma-separated string of words that are\n   *     illegal for use as names in a language (e.g. 'new,if,this,...').\n   * @param {string=} opt_variablePrefix Some languages need a '$' or a\n   *     namespace before all variable names (but not procedure names).\n   */\n  constructor(reservedWords, opt_variablePrefix) {\n    /**\n     * The prefix to attach to variable names in generated code.\n     * @type {string}\n     * @private\n     */\n    this.variablePrefix_ = opt_variablePrefix || '';\n\n    /**\n     * A dictionary of reserved words.\n     * @type {Object}\n     * @private\n     */\n    this.reservedDict_ = Object.create(null);\n\n    /**\n     * A map from type (e.g. name, procedure) to maps from names to generated\n     * names.\n     * @type {Object<string, Object<string, string>>}\n     * @private\n     */\n    this.db_ = Object.create(null);\n\n    /**\n     * A map from used names to booleans to avoid collisions.\n     * @type {Object<string, boolean>}\n     * @private\n     */\n    this.dbReverse_ = Object.create(null);\n\n    /**\n     * The variable map from the workspace, containing Blockly variable models.\n     * @type {?VariableMap}\n     * @private\n     */\n    this.variableMap_ = null;\n\n    if (reservedWords) {\n      const splitWords = reservedWords.split(',');\n      for (let i = 0; i < splitWords.length; i++) {\n        this.reservedDict_[splitWords[i]] = true;\n      }\n    }\n    this.reset();\n  }\n\n  /**\n   * Empty the database and start from scratch.  The reserved words are kept.\n   */\n  reset() {\n    this.db_ = Object.create(null);\n    this.dbReverse_ = Object.create(null);\n    this.variableMap_ = null;\n  }\n\n  /**\n   * Set the variable map that maps from variable name to variable object.\n   * @param {!VariableMap} map The map to track.\n   */\n  setVariableMap(map) {\n    this.variableMap_ = map;\n  }\n\n  /**\n   * Get the name for a user-defined variable, based on its ID.\n   * This should only be used for variables of NameType VARIABLE.\n   * @param {string} id The ID to look up in the variable map.\n   * @return {?string} The name of the referenced variable, or null if there was\n   *     no variable map or the variable was not found in the map.\n   * @private\n   */\n  getNameForUserVariable_(id) {\n    if (!this.variableMap_) {\n      console.warn(\n          'Deprecated call to Names.prototype.getName without ' +\n          'defining a variable map. To fix, add the following code in your ' +\n          'generator\\'s init() function:\\n' +\n          'Blockly.YourGeneratorName.nameDB_.setVariableMap(' +\n          'workspace.getVariableMap());');\n      return null;\n    }\n    const variable = this.variableMap_.getVariableById(id);\n    if (variable) {\n      return variable.name;\n    }\n    return null;\n  }\n\n  /**\n   * Generate names for user variables, but only ones that are being used.\n   * @param {!Workspace} workspace Workspace to generate variables from.\n   */\n  populateVariables(workspace) {\n    const variables = Variables.allUsedVarModels(workspace);\n    for (let i = 0; i < variables.length; i++) {\n      this.getName(variables[i].getId(), NameType.VARIABLE);\n    }\n  }\n\n  /**\n   * Generate names for procedures.\n   * @param {!Workspace} workspace Workspace to generate procedures from.\n   */\n  populateProcedures(workspace) {\n    let procedures =\n        goog.module.get('Blockly.Procedures').allProcedures(workspace);\n    // Flatten the return vs no-return procedure lists.\n    procedures = procedures[0].concat(procedures[1]);\n    for (let i = 0; i < procedures.length; i++) {\n      this.getName(procedures[i][0], NameType.PROCEDURE);\n    }\n  }\n\n  /**\n   * Convert a Blockly entity name to a legal exportable entity name.\n   * @param {string} nameOrId The Blockly entity name (no constraints) or\n   *     variable ID.\n   * @param {NameType|string} type The type of the name in Blockly\n   *     ('VARIABLE', 'PROCEDURE', 'DEVELOPER_VARIABLE', etc...).\n   * @return {string} An entity name that is legal in the exported language.\n   */\n  getName(nameOrId, type) {\n    let name = nameOrId;\n    if (type === NameType.VARIABLE) {\n      const varName = this.getNameForUserVariable_(nameOrId);\n      if (varName) {\n        // Successful ID lookup.\n        name = varName;\n      }\n    }\n    const normalizedName = name.toLowerCase();\n\n    const isVar =\n        type === NameType.VARIABLE || type === NameType.DEVELOPER_VARIABLE;\n\n    const prefix = isVar ? this.variablePrefix_ : '';\n    if (!(type in this.db_)) {\n      this.db_[type] = Object.create(null);\n    }\n    const typeDb = this.db_[type];\n    if (normalizedName in typeDb) {\n      return prefix + typeDb[normalizedName];\n    }\n    const safeName = this.getDistinctName(name, type);\n    typeDb[normalizedName] = safeName.substr(prefix.length);\n    return safeName;\n  }\n\n  /**\n   * Return a list of all known user-created names of a specified name type.\n   * @param {NameType|string} type The type of entity in Blockly\n   *     ('VARIABLE', 'PROCEDURE', 'DEVELOPER_VARIABLE', etc...).\n   * @return {!Array<string>} A list of Blockly entity names (no constraints).\n   */\n  getUserNames(type) {\n    const typeDb = this.db_[type] || {};\n    return Object.keys(typeDb);\n  }\n\n  /**\n   * Convert a Blockly entity name to a legal exportable entity name.\n   * Ensure that this is a new name not overlapping any previously defined name.\n   * Also check against list of reserved words for the current language and\n   * ensure name doesn't collide.\n   * @param {string} name The Blockly entity name (no constraints).\n   * @param {NameType|string} type The type of entity in Blockly\n   *     ('VARIABLE', 'PROCEDURE', 'DEVELOPER_VARIABLE', etc...).\n   * @return {string} An entity name that is legal in the exported language.\n   */\n  getDistinctName(name, type) {\n    let safeName = this.safeName_(name);\n    let i = '';\n    while (this.dbReverse_[safeName + i] ||\n           (safeName + i) in this.reservedDict_) {\n      // Collision with existing name.  Create a unique name.\n      i = i ? i + 1 : 2;\n    }\n    safeName += i;\n    this.dbReverse_[safeName] = true;\n    const isVar =\n        type === NameType.VARIABLE || type === NameType.DEVELOPER_VARIABLE;\n    const prefix = isVar ? this.variablePrefix_ : '';\n    return prefix + safeName;\n  }\n\n  /**\n   * Given a proposed entity name, generate a name that conforms to the\n   * [_A-Za-z][_A-Za-z0-9]* format that most languages consider legal for\n   * variable and function names.\n   * @param {string} name Potentially illegal entity name.\n   * @return {string} Safe entity name.\n   * @private\n   */\n  safeName_(name) {\n    if (!name) {\n      name = Msg['UNNAMED_KEY'] || 'unnamed';\n    } else {\n      // Unfortunately names in non-latin characters will look like\n      // _E9_9F_B3_E4_B9_90 which is pretty meaningless.\n      // https://github.com/google/blockly/issues/1654\n      name = encodeURI(name.replace(/ /g, '_')).replace(/[^\\w]/g, '_');\n      // Most languages don't allow names with leading numbers.\n      if ('0123456789'.indexOf(name[0]) !== -1) {\n        name = 'my_' + name;\n      }\n    }\n    return name;\n  }\n\n  /**\n   * Do the given two entity names refer to the same entity?\n   * Blockly names are case-insensitive.\n   * @param {string} name1 First name.\n   * @param {string} name2 Second name.\n   * @return {boolean} True if names are the same.\n   */\n  static equals(name1, name2) {\n    // name1.localeCompare(name2) is slower.\n    return name1.toLowerCase() === name2.toLowerCase();\n  }\n};\n\n/**\n * Enum for the type of a name. Different name types may have different rules\n * about collisions.\n * When JavaScript (or most other languages) is generated, variable 'foo' and\n * procedure 'foo' would collide.  However, Blockly has no such problems since\n * variable get 'foo' and procedure call 'foo' are unambiguous.\n * Therefore, Blockly keeps a separate name type to disambiguate.\n * getName('foo', 'VARIABLE') -> 'foo'\n * getName('foo', 'PROCEDURE') -> 'foo2'\n * @enum { string }\n * @alias Blockly.Names.NameType\n */\nconst NameType = {\n  DEVELOPER_VARIABLE: 'DEVELOPER_VARIABLE',\n  VARIABLE: 'VARIABLE',\n  PROCEDURE: 'PROCEDURE',\n};\nexports.NameType = NameType;\n\n// We have to export NameType here so that it is accessible under the old name\n// `Blockly.Names.NameType`\nNames.NameType = NameType;\n\n/**\n * Constant to separate developer variable names from user-defined variable\n * names when running generators.\n * A developer variable will be declared as a global in the generated code, but\n * will never be shown to the user in the workspace or stored in the variable\n * map.\n */\nNames.DEVELOPER_VARIABLE_TYPE = NameType.DEVELOPER_VARIABLE;\n\nexports.Names = Names;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/names.js?")},
"./core/options.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/idgenerator.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/utils/toolbox.js\");\n__webpack_require__(\"./core/theme/classic.js\");\n__webpack_require__(\"./core/theme.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object that controls settings for the workspace.\n */\n\n\n/**\n * Object that controls settings for the workspace.\n * @class\n */\ngoog.module('Blockly.Options');\n\nconst idGenerator = goog.require('Blockly.utils.idGenerator');\nconst registry = goog.require('Blockly.registry');\nconst toolbox = goog.require('Blockly.utils.toolbox');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlocklyOptions} = goog.requireType('Blockly.BlocklyOptions');\nconst {Classic} = goog.require('Blockly.Themes.Classic');\n/* eslint-disable-next-line no-unused-vars */\nconst {Metrics} = goog.requireType('Blockly.utils.Metrics');\nconst {Theme} = goog.require('Blockly.Theme');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * Parse the user-specified options, using reasonable defaults where behaviour\n * is unspecified.\n * @alias Blockly.Options\n */\nclass Options {\n  /**\n   * @param {!BlocklyOptions} options Dictionary of options.\n   *     Specification:\n   * https://developers.google.com/blockly/guides/get-started/web#configuration\n   */\n  constructor(options) {\n    let toolboxJsonDef = null;\n    let hasCategories = false;\n    let hasTrashcan = false;\n    let hasCollapse = false;\n    let hasComments = false;\n    let hasDisable = false;\n    let hasSounds = false;\n    const readOnly = !!options['readOnly'];\n    if (!readOnly) {\n      toolboxJsonDef = toolbox.convertToolboxDefToJson(options['toolbox']);\n      hasCategories = toolbox.hasCategories(toolboxJsonDef);\n      hasTrashcan = options['trashcan'];\n      if (hasTrashcan === undefined) {\n        hasTrashcan = hasCategories;\n      }\n      hasCollapse = options['collapse'];\n      if (hasCollapse === undefined) {\n        hasCollapse = hasCategories;\n      }\n      hasComments = options['comments'];\n      if (hasComments === undefined) {\n        hasComments = hasCategories;\n      }\n      hasDisable = options['disable'];\n      if (hasDisable === undefined) {\n        hasDisable = hasCategories;\n      }\n      hasSounds = options['sounds'];\n      if (hasSounds === undefined) {\n        hasSounds = true;\n      }\n    }\n\n    let maxTrashcanContents = options['maxTrashcanContents'];\n    if (hasTrashcan) {\n      if (maxTrashcanContents === undefined) {\n        maxTrashcanContents = 32;\n      }\n    } else {\n      maxTrashcanContents = 0;\n    }\n    const rtl = !!options['rtl'];\n    let horizontalLayout = options['horizontalLayout'];\n    if (horizontalLayout === undefined) {\n      horizontalLayout = false;\n    }\n    let toolboxAtStart = options['toolboxPosition'];\n    toolboxAtStart = toolboxAtStart !== 'end';\n\n    /** @type {!toolbox.Position} */\n    let toolboxPosition;\n    if (horizontalLayout) {\n      toolboxPosition =\n          toolboxAtStart ? toolbox.Position.TOP : toolbox.Position.BOTTOM;\n    } else {\n      toolboxPosition = (toolboxAtStart === rtl) ? toolbox.Position.RIGHT :\n                                                   toolbox.Position.LEFT;\n    }\n\n    let hasCss = options['css'];\n    if (hasCss === undefined) {\n      hasCss = true;\n    }\n    let pathToMedia = 'https://blockly-demo.appspot.com/static/media/';\n    if (options['media']) {\n      pathToMedia = options['media'];\n    } else if (options['path']) {\n      // 'path' is a deprecated option which has been replaced by 'media'.\n      pathToMedia = options['path'] + 'media/';\n    }\n    let oneBasedIndex;\n    if (options['oneBasedIndex'] === undefined) {\n      oneBasedIndex = true;\n    } else {\n      oneBasedIndex = !!options['oneBasedIndex'];\n    }\n    const renderer = options['renderer'] || 'geras';\n\n    const plugins = options['plugins'] || {};\n\n    /** @type {boolean} */\n    this.RTL = rtl;\n    /** @type {boolean} */\n    this.oneBasedIndex = oneBasedIndex;\n    /** @type {boolean} */\n    this.collapse = hasCollapse;\n    /** @type {boolean} */\n    this.comments = hasComments;\n    /** @type {boolean} */\n    this.disable = hasDisable;\n    /** @type {boolean} */\n    this.readOnly = readOnly;\n    /** @type {number} */\n    this.maxBlocks = options['maxBlocks'] || Infinity;\n    /** @type {?Object<string, number>} */\n    this.maxInstances = options['maxInstances'];\n    /** @type {string} */\n    this.pathToMedia = pathToMedia;\n    /** @type {boolean} */\n    this.hasCategories = hasCategories;\n    /** @type {!Options.MoveOptions} */\n    this.moveOptions = Options.parseMoveOptions_(options, hasCategories);\n    /** @deprecated  January 2019 */\n    this.hasScrollbars = !!this.moveOptions.scrollbars;\n    /** @type {boolean} */\n    this.hasTrashcan = hasTrashcan;\n    /** @type {number} */\n    this.maxTrashcanContents = maxTrashcanContents;\n    /** @type {boolean} */\n    this.hasSounds = hasSounds;\n    /** @type {boolean} */\n    this.hasCss = hasCss;\n    /** @type {boolean} */\n    this.horizontalLayout = horizontalLayout;\n    /** @type {?toolbox.ToolboxInfo} */\n    this.languageTree = toolboxJsonDef;\n    /** @type {!Options.GridOptions} */\n    this.gridOptions = Options.parseGridOptions_(options);\n    /** @type {!Options.ZoomOptions} */\n    this.zoomOptions = Options.parseZoomOptions_(options);\n    /** @type {!toolbox.Position} */\n    this.toolboxPosition = toolboxPosition;\n    /** @type {!Theme} */\n    this.theme = Options.parseThemeOptions_(options);\n    /** @type {string} */\n    this.renderer = renderer;\n    /** @type {?Object} */\n    this.rendererOverrides = options['rendererOverrides'];\n\n    /**\n     * The SVG element for the grid pattern.\n     * Created during injection.\n     * @type {?SVGElement}\n     */\n    this.gridPattern = null;\n\n    /**\n     * The parent of the current workspace, or null if there is no parent\n     * workspace.  We can assert that this is of type WorkspaceSvg as opposed to\n     * Workspace as this is only used in a rendered workspace.\n     * @type {?WorkspaceSvg}\n     */\n    this.parentWorkspace = options['parentWorkspace'];\n\n    /**\n     * Map of plugin type to name of registered plugin or plugin class.\n     * @type {!Object<string, (function(new:?, ...?)|string)>}\n     */\n    this.plugins = plugins;\n\n    /**\n     * If set, sets the translation of the workspace to match the scrollbars.\n     * @type {undefined|function(!{x:number,y:number}):void} A function that\n     *     sets the translation of the workspace to match the scrollbars. The\n     *     argument Contains an x and/or y property which is a float between 0\n     *     and 1 specifying the degree of scrolling.\n     */\n    this.setMetrics = undefined;\n\n    /**\n     * @type {undefined|function():!Metrics} A function that returns a metrics\n     *     object that describes the current workspace.\n     */\n    this.getMetrics = undefined;\n  }\n\n  /**\n   * Parse the user-specified move options, using reasonable defaults where\n   *    behaviour is unspecified.\n   * @param {!Object} options Dictionary of options.\n   * @param {boolean} hasCategories Whether the workspace has categories or not.\n   * @return {!Options.MoveOptions} Normalized move options.\n   * @private\n   */\n  static parseMoveOptions_(options, hasCategories) {\n    const move = options['move'] || {};\n    const moveOptions = {};\n    if (move['scrollbars'] === undefined &&\n        options['scrollbars'] === undefined) {\n      moveOptions.scrollbars = hasCategories;\n    } else if (typeof move['scrollbars'] === 'object') {\n      moveOptions.scrollbars = {};\n      moveOptions.scrollbars.horizontal = !!move['scrollbars']['horizontal'];\n      moveOptions.scrollbars.vertical = !!move['scrollbars']['vertical'];\n      // Convert scrollbars object to boolean if they have the same value.\n      // This allows us to easily check for whether any scrollbars exist using\n      // !!moveOptions.scrollbars.\n      if (moveOptions.scrollbars.horizontal &&\n          moveOptions.scrollbars.vertical) {\n        moveOptions.scrollbars = true;\n      } else if (\n          !moveOptions.scrollbars.horizontal &&\n          !moveOptions.scrollbars.vertical) {\n        moveOptions.scrollbars = false;\n      }\n    } else {\n      moveOptions.scrollbars = !!move['scrollbars'] || !!options['scrollbars'];\n    }\n\n    if (!moveOptions.scrollbars || move['wheel'] === undefined) {\n      // Defaults to true if single-direction scroll is enabled.\n      moveOptions.wheel = typeof moveOptions.scrollbars === 'object';\n    } else {\n      moveOptions.wheel = !!move['wheel'];\n    }\n    if (!moveOptions.scrollbars) {\n      moveOptions.drag = false;\n    } else if (move['drag'] === undefined) {\n      // Defaults to true if scrollbars is true.\n      moveOptions.drag = true;\n    } else {\n      moveOptions.drag = !!move['drag'];\n    }\n    return moveOptions;\n  }\n\n  /**\n   * Parse the user-specified zoom options, using reasonable defaults where\n   * behaviour is unspecified.  See zoom documentation:\n   *   https://developers.google.com/blockly/guides/configure/web/zoom\n   * @param {!Object} options Dictionary of options.\n   * @return {!Options.ZoomOptions} Normalized zoom options.\n   * @private\n   */\n  static parseZoomOptions_(options) {\n    const zoom = options['zoom'] || {};\n    const zoomOptions = {};\n    if (zoom['controls'] === undefined) {\n      zoomOptions.controls = false;\n    } else {\n      zoomOptions.controls = !!zoom['controls'];\n    }\n    if (zoom['wheel'] === undefined) {\n      zoomOptions.wheel = false;\n    } else {\n      zoomOptions.wheel = !!zoom['wheel'];\n    }\n    if (zoom['startScale'] === undefined) {\n      zoomOptions.startScale = 1;\n    } else {\n      zoomOptions.startScale = Number(zoom['startScale']);\n    }\n    if (zoom['maxScale'] === undefined) {\n      zoomOptions.maxScale = 3;\n    } else {\n      zoomOptions.maxScale = Number(zoom['maxScale']);\n    }\n    if (zoom['minScale'] === undefined) {\n      zoomOptions.minScale = 0.3;\n    } else {\n      zoomOptions.minScale = Number(zoom['minScale']);\n    }\n    if (zoom['scaleSpeed'] === undefined) {\n      zoomOptions.scaleSpeed = 1.2;\n    } else {\n      zoomOptions.scaleSpeed = Number(zoom['scaleSpeed']);\n    }\n    if (zoom['pinch'] === undefined) {\n      zoomOptions.pinch = zoomOptions.wheel || zoomOptions.controls;\n    } else {\n      zoomOptions.pinch = !!zoom['pinch'];\n    }\n    return zoomOptions;\n  }\n\n  /**\n   * Parse the user-specified grid options, using reasonable defaults where\n   * behaviour is unspecified. See grid documentation:\n   *   https://developers.google.com/blockly/guides/configure/web/grid\n   * @param {!Object} options Dictionary of options.\n   * @return {!Options.GridOptions} Normalized grid options.\n   * @private\n   */\n  static parseGridOptions_(options) {\n    const grid = options['grid'] || {};\n    const gridOptions = {};\n    gridOptions.spacing = Number(grid['spacing']) || 0;\n    gridOptions.colour = grid['colour'] || '#888';\n    gridOptions.length =\n        (grid['length'] === undefined) ? 1 : Number(grid['length']);\n    gridOptions.snap = gridOptions.spacing > 0 && !!grid['snap'];\n    return gridOptions;\n  }\n\n  /**\n   * Parse the user-specified theme options, using the classic theme as a\n   * default. https://developers.google.com/blockly/guides/configure/web/themes\n   * @param {!Object} options Dictionary of options.\n   * @return {!Theme} A Blockly Theme.\n   * @private\n   */\n  static parseThemeOptions_(options) {\n    const theme = options['theme'] || Classic;\n    if (typeof theme === 'string') {\n      return /** @type {!Theme} */ (\n          registry.getObject(registry.Type.THEME, theme));\n    } else if (theme instanceof Theme) {\n      return /** @type {!Theme} */ (theme);\n    }\n    return Theme.defineTheme(\n        theme.name || ('builtin' + idGenerator.getNextUniqueId()), theme);\n  }\n}\n\n/**\n * Grid Options.\n * @typedef {{\n *     colour: string,\n *     length: number,\n *     snap: boolean,\n *     spacing: number\n * }}\n */\nOptions.GridOptions;\n\n/**\n * Move Options.\n * @typedef {{\n *     drag: boolean,\n *     scrollbars: (boolean | !Options.ScrollbarOptions),\n *     wheel: boolean\n * }}\n */\nOptions.MoveOptions;\n\n/**\n * Scrollbar Options.\n * @typedef {{\n *     horizontal: boolean,\n *     vertical: boolean\n * }}\n */\nOptions.ScrollbarOptions;\n\n/**\n * Zoom Options.\n * @typedef {{\n *     controls: boolean,\n *     maxScale: number,\n *     minScale: number,\n *     pinch: boolean,\n *     scaleSpeed: number,\n *     startScale: number,\n *     wheel: boolean\n * }}\n */\nOptions.ZoomOptions;\n\nexports.Options = Options;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/options.js?")},
"./core/positionable_helpers.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/toolbox.js\");\n__webpack_require__(\"./core/utils/rect.js\");\n__webpack_require__(\"./core/scrollbar.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility functions for positioning UI elements.\n */\n\n\n/**\n * Utility functions for positioning UI elements.\n * @namespace Blockly.uiPosition\n */\ngoog.module('Blockly.uiPosition');\n\nconst toolbox = goog.require('Blockly.utils.toolbox');\n/* eslint-disable-next-line no-unused-vars */\nconst {MetricsManager} = goog.requireType('Blockly.MetricsManager');\nconst {Rect} = goog.require('Blockly.utils.Rect');\nconst {Scrollbar} = goog.require('Blockly.Scrollbar');\n/* eslint-disable-next-line no-unused-vars */\nconst {Size} = goog.requireType('Blockly.utils.Size');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * Enum for vertical positioning.\n * @enum {number}\n * @alias Blockly.uiPosition.verticalPosition\n * @package\n */\nconst verticalPosition = {\n  TOP: 0,\n  BOTTOM: 1,\n};\nexports.verticalPosition = verticalPosition;\n\n/**\n * Enum for horizontal positioning.\n * @enum {number}\n * @alias Blockly.uiPosition.horizontalPosition\n * @package\n */\nconst horizontalPosition = {\n  LEFT: 0,\n  RIGHT: 1,\n};\nexports.horizontalPosition = horizontalPosition;\n\n/**\n * An object defining a horizontal and vertical positioning.\n * @typedef {{\n *   horizontal: !horizontalPosition,\n *   vertical: !verticalPosition\n * }}\n * @alias Blockly.uiPosition.Position\n * @package\n */\nlet Position;\nexports.Position = Position;\n\n/**\n * Enum for bump rules to use for dealing with collisions.\n * @enum {number}\n * @alias Blockly.uiPosition.bumpDirection\n * @package\n */\nconst bumpDirection = {\n  UP: 0,\n  DOWN: 1,\n};\nexports.bumpDirection = bumpDirection;\n\n/**\n * Returns a rectangle representing reasonable position for where to place a UI\n * element of the specified size given the restraints and locations of the\n * scrollbars. This method does not take into account any already placed UI\n * elements.\n * @param {!Position} position The starting\n *    horizontal and vertical position.\n * @param {!Size} size the size of the UI element to get a start\n *    position for.\n * @param {number} horizontalPadding The horizontal padding to use.\n * @param {number} verticalPadding The vertical padding to use.\n * @param {!MetricsManager.UiMetrics} metrics The workspace UI metrics.\n * @param {!WorkspaceSvg} workspace The workspace.\n * @return {!Rect} The suggested start position.\n * @alias Blockly.uiPosition.getStartPositionRect\n * @package\n */\nconst getStartPositionRect = function(\n    position, size, horizontalPadding, verticalPadding, metrics, workspace) {\n  // Horizontal positioning.\n  let left = 0;\n  const hasVerticalScrollbar =\n      workspace.scrollbar && workspace.scrollbar.canScrollVertically();\n  if (position.horizontal === horizontalPosition.LEFT) {\n    left = metrics.absoluteMetrics.left + horizontalPadding;\n    if (hasVerticalScrollbar && workspace.RTL) {\n      left += Scrollbar.scrollbarThickness;\n    }\n  } else {  // position.horizontal === horizontalPosition.RIGHT\n    left = metrics.absoluteMetrics.left + metrics.viewMetrics.width -\n        size.width - horizontalPadding;\n    if (hasVerticalScrollbar && !workspace.RTL) {\n      left -= Scrollbar.scrollbarThickness;\n    }\n  }\n  // Vertical positioning.\n  let top = 0;\n  if (position.vertical === verticalPosition.TOP) {\n    top = metrics.absoluteMetrics.top + verticalPadding;\n  } else {  // position.vertical === verticalPosition.BOTTOM\n    top = metrics.absoluteMetrics.top + metrics.viewMetrics.height -\n        size.height - verticalPadding;\n    if (workspace.scrollbar && workspace.scrollbar.canScrollHorizontally()) {\n      // The scrollbars are always positioned on the bottom if they exist.\n      top -= Scrollbar.scrollbarThickness;\n    }\n  }\n  return new Rect(top, top + size.height, left, left + size.width);\n};\nexports.getStartPositionRect = getStartPositionRect;\n\n/**\n * Returns a corner position that is on the opposite side of the workspace from\n * the toolbox.\n * If in horizontal orientation, defaults to the bottom corner. If in vertical\n * orientation, defaults to the right corner.\n * @param {!WorkspaceSvg} workspace The workspace.\n * @param {!MetricsManager.UiMetrics} metrics The workspace metrics.\n * @return {!Position} The suggested corner position.\n * @alias Blockly.uiPosition.getCornerOppositeToolbox\n * @package\n */\nconst getCornerOppositeToolbox = function(workspace, metrics) {\n  const leftCorner =\n      metrics.toolboxMetrics.position !== toolbox.Position.LEFT &&\n      (!workspace.horizontalLayout || workspace.RTL);\n  const topCorner = metrics.toolboxMetrics.position === toolbox.Position.BOTTOM;\n  const hPosition =\n      leftCorner ? horizontalPosition.LEFT : horizontalPosition.RIGHT;\n  const vPosition = topCorner ? verticalPosition.TOP : verticalPosition.BOTTOM;\n  return {horizontal: hPosition, vertical: vPosition};\n};\nexports.getCornerOppositeToolbox = getCornerOppositeToolbox;\n\n/**\n * Returns a position Rect based on a starting position that is bumped\n * so that it doesn't intersect with any of the provided savedPositions. This\n * method does not check that the bumped position is still within bounds.\n * @param {!Rect} startRect The starting position to use.\n * @param {number} margin The margin to use between elements when bumping.\n * @param {!bumpDirection} bumpDir The direction to bump if there is a collision\n *    with an existing UI element.\n * @param {!Array<!Rect>} savedPositions List of rectangles that\n *    represent the positions of UI elements already placed.\n * @return {!Rect} The suggested position rectangle.\n * @alias Blockly.uiPosition.bumpPositionRect\n * @package\n */\nconst bumpPositionRect = function(startRect, margin, bumpDir, savedPositions) {\n  let top = startRect.top;\n  const left = startRect.left;\n  const width = startRect.right - startRect.left;\n  const height = startRect.bottom - startRect.top;\n\n  // Check for collision and bump if needed.\n  let boundingRect = startRect;\n  for (let i = 0; i < savedPositions.length; i++) {\n    const otherEl = savedPositions[i];\n    if (boundingRect.intersects(otherEl)) {\n      if (bumpDir === bumpDirection.UP) {\n        top = otherEl.top - height - margin;\n      } else {  // bumpDir === bumpDirection.DOWN\n        top = otherEl.bottom + margin;\n      }\n      // Recheck other savedPositions\n      boundingRect = new Rect(top, top + height, left, left + width);\n      i = -1;\n    }\n  }\n  return boundingRect;\n};\nexports.bumpPositionRect = bumpPositionRect;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/positionable_helpers.js?")},
"./core/procedures.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/variables.js\");\n__webpack_require__(\"./core/xml.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/utils/xml.js\");\n__webpack_require__(\"./core/blocks.js\");\n__webpack_require__(\"./core/msg.js\");\n__webpack_require__(\"./core/names.js\");\n__webpack_require__(\"./core/workspace.js\");\n__webpack_require__(\"./core/events/events_block_change.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility functions for handling procedures.\n */\n\n\n/**\n * Utility functions for handling procedures.\n * @namespace Blockly.Procedures\n */\ngoog.module('Blockly.Procedures');\n\nconst Variables = goog.require('Blockly.Variables');\nconst Xml = goog.require('Blockly.Xml');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst utilsXml = goog.require('Blockly.utils.xml');\n/* eslint-disable-next-line no-unused-vars */\nconst {Abstract} = goog.requireType('Blockly.Events.Abstract');\nconst {Blocks} = goog.require('Blockly.blocks');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\n/* eslint-disable-next-line no-unused-vars */\nconst {BubbleOpen} = goog.requireType('Blockly.Events.BubbleOpen');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Field} = goog.requireType('Blockly.Field');\nconst {Msg} = goog.require('Blockly.Msg');\nconst {Names} = goog.require('Blockly.Names');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\nconst {Workspace} = goog.require('Blockly.Workspace');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockChange');\n\n\n/**\n * String for use in the \"custom\" attribute of a category in toolbox XML.\n * This string indicates that the category should be dynamically populated with\n * procedure blocks.\n * See also Blockly.Variables.CATEGORY_NAME and\n * Blockly.VariablesDynamic.CATEGORY_NAME.\n * @const {string}\n * @alias Blockly.Procedures.CATEGORY_NAME\n */\nconst CATEGORY_NAME = 'PROCEDURE';\nexports.CATEGORY_NAME = CATEGORY_NAME;\n\n/**\n * The default argument for a procedures_mutatorarg block.\n * @type {string}\n * @alias Blockly.Procedures.DEFAULT_ARG\n */\nconst DEFAULT_ARG = 'x';\nexports.DEFAULT_ARG = DEFAULT_ARG;\n\n/**\n * Procedure block type.\n * @typedef {{\n *    getProcedureCall: function():string,\n *    renameProcedure: function(string,string),\n *    getProcedureDef: function():!Array\n * }}\n * @alias Blockly.Procedures.ProcedureBlock\n */\nlet ProcedureBlock;\nexports.ProcedureBlock = ProcedureBlock;\n\n/**\n * Find all user-created procedure definitions in a workspace.\n * @param {!Workspace} root Root workspace.\n * @return {!Array<!Array<!Array>>} Pair of arrays, the\n *     first contains procedures without return variables, the second with.\n *     Each procedure is defined by a three-element list of name, parameter\n *     list, and return value boolean.\n * @alias Blockly.Procedures.allProcedures\n */\nconst allProcedures = function(root) {\n  const proceduresNoReturn =\n      root.getBlocksByType('procedures_defnoreturn', false)\n          .map(function(block) {\n            return /** @type {!ProcedureBlock} */ (block).getProcedureDef();\n          });\n  const proceduresReturn =\n      root.getBlocksByType('procedures_defreturn', false).map(function(block) {\n        return /** @type {!ProcedureBlock} */ (block).getProcedureDef();\n      });\n  proceduresNoReturn.sort(procTupleComparator);\n  proceduresReturn.sort(procTupleComparator);\n  return [proceduresNoReturn, proceduresReturn];\n};\nexports.allProcedures = allProcedures;\n\n/**\n * Comparison function for case-insensitive sorting of the first element of\n * a tuple.\n * @param {!Array} ta First tuple.\n * @param {!Array} tb Second tuple.\n * @return {number} -1, 0, or 1 to signify greater than, equality, or less than.\n */\nconst procTupleComparator = function(ta, tb) {\n  return ta[0].localeCompare(tb[0], undefined, {sensitivity: 'base'});\n};\n\n/**\n * Ensure two identically-named procedures don't exist.\n * Take the proposed procedure name, and return a legal name i.e. one that\n * is not empty and doesn't collide with other procedures.\n * @param {string} name Proposed procedure name.\n * @param {!Block} block Block to disambiguate.\n * @return {string} Non-colliding name.\n * @alias Blockly.Procedures.findLegalName\n */\nconst findLegalName = function(name, block) {\n  if (block.isInFlyout) {\n    // Flyouts can have multiple procedures called 'do something'.\n    return name;\n  }\n  name = name || Msg['UNNAMED_KEY'] || 'unnamed';\n  while (!isLegalName(name, block.workspace, block)) {\n    // Collision with another procedure.\n    const r = name.match(/^(.*?)(\\d+)$/);\n    if (!r) {\n      name += '2';\n    } else {\n      name = r[1] + (parseInt(r[2], 10) + 1);\n    }\n  }\n  return name;\n};\nexports.findLegalName = findLegalName;\n\n/**\n * Does this procedure have a legal name?  Illegal names include names of\n * procedures already defined.\n * @param {string} name The questionable name.\n * @param {!Workspace} workspace The workspace to scan for collisions.\n * @param {Block=} opt_exclude Optional block to exclude from\n *     comparisons (one doesn't want to collide with oneself).\n * @return {boolean} True if the name is legal.\n */\nconst isLegalName = function(name, workspace, opt_exclude) {\n  return !isNameUsed(name, workspace, opt_exclude);\n};\n\n/**\n * Return if the given name is already a procedure name.\n * @param {string} name The questionable name.\n * @param {!Workspace} workspace The workspace to scan for collisions.\n * @param {Block=} opt_exclude Optional block to exclude from\n *     comparisons (one doesn't want to collide with oneself).\n * @return {boolean} True if the name is used, otherwise return false.\n * @alias Blockly.Procedures.isNameUsed\n */\nconst isNameUsed = function(name, workspace, opt_exclude) {\n  const blocks = workspace.getAllBlocks(false);\n  // Iterate through every block and check the name.\n  for (let i = 0; i < blocks.length; i++) {\n    if (blocks[i] === opt_exclude) {\n      continue;\n    }\n    // Assume it is a procedure block so we can check.\n    const procedureBlock = /** @type {!ProcedureBlock} */ (blocks[i]);\n    if (procedureBlock.getProcedureDef) {\n      const procName = procedureBlock.getProcedureDef();\n      if (Names.equals(procName[0], name)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\nexports.isNameUsed = isNameUsed;\n\n/**\n * Rename a procedure.  Called by the editable field.\n * @param {string} name The proposed new name.\n * @return {string} The accepted name.\n * @this {Field}\n * @alias Blockly.Procedures.rename\n */\nconst rename = function(name) {\n  // Strip leading and trailing whitespace.  Beyond this, all names are legal.\n  name = name.trim();\n\n  const legalName = findLegalName(\n      name,\n      /** @type {!Block} */ (this.getSourceBlock()));\n  const oldName = this.getValue();\n  if (oldName !== name && oldName !== legalName) {\n    // Rename any callers.\n    const blocks = this.getSourceBlock().workspace.getAllBlocks(false);\n    for (let i = 0; i < blocks.length; i++) {\n      // Assume it is a procedure so we can check.\n      const procedureBlock = /** @type {!ProcedureBlock} */ (blocks[i]);\n      if (procedureBlock.renameProcedure) {\n        procedureBlock.renameProcedure(\n            /** @type {string} */ (oldName), legalName);\n      }\n    }\n  }\n  return legalName;\n};\nexports.rename = rename;\n\n/**\n * Construct the blocks required by the flyout for the procedure category.\n * @param {!WorkspaceSvg} workspace The workspace containing procedures.\n * @return {!Array<!Element>} Array of XML block elements.\n * @alias Blockly.Procedures.flyoutCategory\n */\nconst flyoutCategory = function(workspace) {\n  const xmlList = [];\n  if (Blocks['procedures_defnoreturn']) {\n    // <block type=\"procedures_defnoreturn\" gap=\"16\">\n    //     <field name=\"NAME\">do something</field>\n    // </block>\n    const block = utilsXml.createElement('block');\n    block.setAttribute('type', 'procedures_defnoreturn');\n    block.setAttribute('gap', 16);\n    const nameField = utilsXml.createElement('field');\n    nameField.setAttribute('name', 'NAME');\n    nameField.appendChild(\n        utilsXml.createTextNode(Msg['PROCEDURES_DEFNORETURN_PROCEDURE']));\n    block.appendChild(nameField);\n    xmlList.push(block);\n  }\n  if (Blocks['procedures_defreturn']) {\n    // <block type=\"procedures_defreturn\" gap=\"16\">\n    //     <field name=\"NAME\">do something</field>\n    // </block>\n    const block = utilsXml.createElement('block');\n    block.setAttribute('type', 'procedures_defreturn');\n    block.setAttribute('gap', 16);\n    const nameField = utilsXml.createElement('field');\n    nameField.setAttribute('name', 'NAME');\n    nameField.appendChild(\n        utilsXml.createTextNode(Msg['PROCEDURES_DEFRETURN_PROCEDURE']));\n    block.appendChild(nameField);\n    xmlList.push(block);\n  }\n  if (Blocks['procedures_ifreturn']) {\n    // <block type=\"procedures_ifreturn\" gap=\"16\"></block>\n    const block = utilsXml.createElement('block');\n    block.setAttribute('type', 'procedures_ifreturn');\n    block.setAttribute('gap', 16);\n    xmlList.push(block);\n  }\n  if (xmlList.length) {\n    // Add slightly larger gap between system blocks and user calls.\n    xmlList[xmlList.length - 1].setAttribute('gap', 24);\n  }\n\n  /**\n   * Add items to xmlList for each listed procedure.\n   * @param {!Array<!Array>} procedureList A list of procedures, each of which\n   *     is defined by a three-element list of name, parameter list, and return\n   *     value boolean.\n   * @param {string} templateName The type of the block to generate.\n   */\n  function populateProcedures(procedureList, templateName) {\n    for (let i = 0; i < procedureList.length; i++) {\n      const name = procedureList[i][0];\n      const args = procedureList[i][1];\n      // <block type=\"procedures_callnoreturn\" gap=\"16\">\n      //   <mutation name=\"do something\">\n      //     <arg name=\"x\"></arg>\n      //   </mutation>\n      // </block>\n      const block = utilsXml.createElement('block');\n      block.setAttribute('type', templateName);\n      block.setAttribute('gap', 16);\n      const mutation = utilsXml.createElement('mutation');\n      mutation.setAttribute('name', name);\n      block.appendChild(mutation);\n      for (let j = 0; j < args.length; j++) {\n        const arg = utilsXml.createElement('arg');\n        arg.setAttribute('name', args[j]);\n        mutation.appendChild(arg);\n      }\n      xmlList.push(block);\n    }\n  }\n\n  const tuple = allProcedures(workspace);\n  populateProcedures(tuple[0], 'procedures_callnoreturn');\n  populateProcedures(tuple[1], 'procedures_callreturn');\n  return xmlList;\n};\nexports.flyoutCategory = flyoutCategory;\n\n/**\n * Updates the procedure mutator's flyout so that the arg block is not a\n * duplicate of another arg.\n * @param {!WorkspaceSvg} workspace The procedure mutator's workspace. This\n *     workspace's flyout is what is being updated.\n */\nconst updateMutatorFlyout = function(workspace) {\n  const usedNames = [];\n  const blocks = workspace.getBlocksByType('procedures_mutatorarg', false);\n  for (let i = 0, block; (block = blocks[i]); i++) {\n    usedNames.push(block.getFieldValue('NAME'));\n  }\n\n  const xmlElement = utilsXml.createElement('xml');\n  const argBlock = utilsXml.createElement('block');\n  argBlock.setAttribute('type', 'procedures_mutatorarg');\n  const nameField = utilsXml.createElement('field');\n  nameField.setAttribute('name', 'NAME');\n  const argValue =\n      Variables.generateUniqueNameFromOptions(DEFAULT_ARG, usedNames);\n  const fieldContent = utilsXml.createTextNode(argValue);\n\n  nameField.appendChild(fieldContent);\n  argBlock.appendChild(nameField);\n  xmlElement.appendChild(argBlock);\n\n  workspace.updateToolbox(xmlElement);\n};\n\n/**\n * Listens for when a procedure mutator is opened. Then it triggers a flyout\n * update and adds a mutator change listener to the mutator workspace.\n * @param {!Abstract} e The event that triggered this listener.\n * @alias Blockly.Procedures.mutatorOpenListener\n * @package\n */\nconst mutatorOpenListener = function(e) {\n  if (e.type !== eventUtils.BUBBLE_OPEN) {\n    return;\n  }\n  const bubbleEvent = /** @type {!BubbleOpen} */ (e);\n  if (!(bubbleEvent.bubbleType === 'mutator' && bubbleEvent.isOpen)) {\n    return;\n  }\n  const workspaceId = /** @type {string} */ (bubbleEvent.workspaceId);\n  const block = /** @type {!BlockSvg} */\n      (Workspace.getById(workspaceId).getBlockById(bubbleEvent.blockId));\n  const type = block.type;\n  if (type !== 'procedures_defnoreturn' && type !== 'procedures_defreturn') {\n    return;\n  }\n  const workspace = /** @type {!WorkspaceSvg} */ (block.mutator.getWorkspace());\n  updateMutatorFlyout(workspace);\n  workspace.addChangeListener(mutatorChangeListener);\n};\nexports.mutatorOpenListener = mutatorOpenListener;\n\n/**\n * Listens for changes in a procedure mutator and triggers flyout updates when\n * necessary.\n * @param {!Abstract} e The event that triggered this listener.\n */\nconst mutatorChangeListener = function(e) {\n  if (e.type !== eventUtils.BLOCK_CREATE &&\n      e.type !== eventUtils.BLOCK_DELETE &&\n      e.type !== eventUtils.BLOCK_CHANGE) {\n    return;\n  }\n  const workspaceId = /** @type {string} */ (e.workspaceId);\n  const workspace = /** @type {!WorkspaceSvg} */\n      (Workspace.getById(workspaceId));\n  updateMutatorFlyout(workspace);\n};\n\n/**\n * Find all the callers of a named procedure.\n * @param {string} name Name of procedure.\n * @param {!Workspace} workspace The workspace to find callers in.\n * @return {!Array<!Block>} Array of caller blocks.\n * @alias Blockly.Procedures.getCallers\n */\nconst getCallers = function(name, workspace) {\n  const callers = [];\n  const blocks = workspace.getAllBlocks(false);\n  // Iterate through every block and check the name.\n  for (let i = 0; i < blocks.length; i++) {\n    // Assume it is a procedure block so we can check.\n    const procedureBlock = /** @type {!ProcedureBlock} */ (blocks[i]);\n    if (procedureBlock.getProcedureCall) {\n      const procName = procedureBlock.getProcedureCall();\n      // Procedure name may be null if the block is only half-built.\n      if (procName && Names.equals(procName, name)) {\n        callers.push(blocks[i]);\n      }\n    }\n  }\n  return callers;\n};\nexports.getCallers = getCallers;\n\n/**\n * When a procedure definition changes its parameters, find and edit all its\n * callers.\n * @param {!Block} defBlock Procedure definition block.\n * @alias Blockly.Procedures.mutateCallers\n */\nconst mutateCallers = function(defBlock) {\n  const oldRecordUndo = eventUtils.getRecordUndo();\n  const procedureBlock = /** @type {!ProcedureBlock} */ (defBlock);\n  const name = procedureBlock.getProcedureDef()[0];\n  const xmlElement = defBlock.mutationToDom(true);\n  const callers = getCallers(name, defBlock.workspace);\n  for (let i = 0, caller; (caller = callers[i]); i++) {\n    const oldMutationDom = caller.mutationToDom();\n    const oldMutation = oldMutationDom && Xml.domToText(oldMutationDom);\n    caller.domToMutation(xmlElement);\n    const newMutationDom = caller.mutationToDom();\n    const newMutation = newMutationDom && Xml.domToText(newMutationDom);\n    if (oldMutation !== newMutation) {\n      // Fire a mutation on every caller block.  But don't record this as an\n      // undo action since it is deterministically tied to the procedure's\n      // definition mutation.\n      eventUtils.setRecordUndo(false);\n      eventUtils.fire(new (eventUtils.get(eventUtils.BLOCK_CHANGE))(\n          caller, 'mutation', null, oldMutation, newMutation));\n      eventUtils.setRecordUndo(oldRecordUndo);\n    }\n  }\n};\nexports.mutateCallers = mutateCallers;\n\n/**\n * Find the definition block for the named procedure.\n * @param {string} name Name of procedure.\n * @param {!Workspace} workspace The workspace to search.\n * @return {?Block} The procedure definition block, or null not found.\n * @alias Blockly.Procedures.getDefinition\n */\nconst getDefinition = function(name, workspace) {\n  // Do not assume procedure is a top block. Some languages allow nested\n  // procedures. Also do not assume it is one of the built-in blocks. Only\n  // rely on getProcedureDef.\n  const blocks = workspace.getAllBlocks(false);\n  for (let i = 0; i < blocks.length; i++) {\n    // Assume it is a procedure block so we can check.\n    const procedureBlock = /** @type {!ProcedureBlock} */ (blocks[i]);\n    if (procedureBlock.getProcedureDef) {\n      const tuple = procedureBlock.getProcedureDef();\n      if (tuple && Names.equals(tuple[0], name)) {\n        return blocks[i];  // Can't use procedureBlock var due to type check.\n      }\n    }\n  }\n  return null;\n};\nexports.getDefinition = getDefinition;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/procedures.js?")},
"./core/registry.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview This file is a universal registry that provides generic methods\n *    for registering and unregistering different types of classes.\n */\n\n\n/**\n * This file is a universal registry that provides generic methods\n *    for registering and unregistering different types of classes.\n * @namespace Blockly.registry\n */\ngoog.module('Blockly.registry');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {Abstract} = goog.requireType('Blockly.Events.Abstract');\n/* eslint-disable-next-line no-unused-vars */\nconst {Cursor} = goog.requireType('Blockly.Cursor');\n/* eslint-disable-next-line no-unused-vars */\nconst {Field} = goog.requireType('Blockly.Field');\n/* eslint-disable-next-line no-unused-vars */\nconst {IBlockDragger} = goog.requireType('Blockly.IBlockDragger');\n/* eslint-disable-next-line no-unused-vars */\nconst {IConnectionChecker} = goog.requireType('Blockly.IConnectionChecker');\n/* eslint-disable-next-line no-unused-vars */\nconst {IFlyout} = goog.requireType('Blockly.IFlyout');\n/* eslint-disable-next-line no-unused-vars */\nconst {IMetricsManager} = goog.requireType('Blockly.IMetricsManager');\n/* eslint-disable-next-line no-unused-vars */\nconst {ISerializer} = goog.requireType('Blockly.serialization.ISerializer');\n/* eslint-disable-next-line no-unused-vars */\nconst {IToolbox} = goog.requireType('Blockly.IToolbox');\n/* eslint-disable-next-line no-unused-vars */\nconst {Options} = goog.requireType('Blockly.Options');\n/* eslint-disable-next-line no-unused-vars */\nconst {Renderer} = goog.requireType('Blockly.blockRendering.Renderer');\n/* eslint-disable-next-line no-unused-vars */\nconst {Theme} = goog.requireType('Blockly.Theme');\n/* eslint-disable-next-line no-unused-vars */\nconst {ToolboxItem} = goog.requireType('Blockly.ToolboxItem');\n\n\n/**\n * A map of maps. With the keys being the type and name of the class we are\n * registering and the value being the constructor function.\n * e.g. {'field': {'field_angle': Blockly.FieldAngle}}\n *\n * @type {!Object<string, !Object<string, (function(new:?)|!Object)>>}\n */\nconst typeMap = Object.create(null);\nexports.TEST_ONLY = {typeMap};\n\n/**\n * A map of maps. With the keys being the type and caseless name of the class we\n * are registring, and the value being the most recent cased name for that\n * registration.\n * @type {!Object<string, !Object<string, string>>}\n */\nconst nameMap = Object.create(null);\n\n/**\n * The string used to register the default class for a type of plugin.\n * @type {string}\n * @alias Blockly.registry.DEFAULT\n */\nconst DEFAULT = 'default';\nexports.DEFAULT = DEFAULT;\n\n/**\n * A name with the type of the element stored in the generic.\n * @template T\n * @alias Blockly.registry.Type\n */\nclass Type {\n  /**\n   * @param {string} name The name of the registry type.\n   */\n  constructor(name) {\n    /**\n     * @type {string}\n     * @private\n     */\n    this.name_ = name;\n  }\n\n  /**\n   * Returns the name of the type.\n   * @return {string} The name.\n   */\n  toString() {\n    return this.name_;\n  }\n}\nexports.Type = Type;\n\n\n/** @type {!Type<IConnectionChecker>} */\nType.CONNECTION_CHECKER = new Type('connectionChecker');\n\n/** @type {!Type<Cursor>} */\nType.CURSOR = new Type('cursor');\n\n/** @type {!Type<Abstract>} */\nType.EVENT = new Type('event');\n\n/** @type {!Type<Field>} */\nType.FIELD = new Type('field');\n\n/** @type {!Type<Renderer>} */\nType.RENDERER = new Type('renderer');\n\n/** @type {!Type<IToolbox>} */\nType.TOOLBOX = new Type('toolbox');\n\n/** @type {!Type<Theme>} */\nType.THEME = new Type('theme');\n\n/** @type {!Type<ToolboxItem>} */\nType.TOOLBOX_ITEM = new Type('toolboxItem');\n\n/** @type {!Type<IFlyout>} */\nType.FLYOUTS_VERTICAL_TOOLBOX = new Type('flyoutsVerticalToolbox');\n\n/** @type {!Type<IFlyout>} */\nType.FLYOUTS_HORIZONTAL_TOOLBOX = new Type('flyoutsHorizontalToolbox');\n\n/** @type {!Type<IMetricsManager>} */\nType.METRICS_MANAGER = new Type('metricsManager');\n\n/** @type {!Type<IBlockDragger>} */\nType.BLOCK_DRAGGER = new Type('blockDragger');\n\n/**\n * @type {!Type<ISerializer>}\n * @package\n */\nType.SERIALIZER = new Type('serializer');\n\n/**\n * Registers a class based on a type and name.\n * @param {string|!Type<T>} type The type of the plugin.\n *     (e.g. Field, Renderer)\n * @param {string} name The plugin's name. (Ex. field_angle, geras)\n * @param {?function(new:T, ...?)|Object} registryItem The class or object to\n *     register.\n * @param {boolean=} opt_allowOverrides True to prevent an error when overriding\n *     an already registered item.\n * @throws {Error} if the type or name is empty, a name with the given type has\n *     already been registered, or if the given class or object is not valid for\n *     its type.\n * @template T\n * @alias Blockly.registry.register\n */\nconst register = function(type, name, registryItem, opt_allowOverrides) {\n  if ((!(type instanceof Type) && typeof type !== 'string') ||\n      String(type).trim() === '') {\n    throw Error(\n        'Invalid type \"' + type + '\". The type must be a' +\n        ' non-empty string or a Blockly.registry.Type.');\n  }\n  type = String(type).toLowerCase();\n\n  if ((typeof name !== 'string') || (name.trim() === '')) {\n    throw Error(\n        'Invalid name \"' + name + '\". The name must be a' +\n        ' non-empty string.');\n  }\n  const caselessName = name.toLowerCase();\n  if (!registryItem) {\n    throw Error('Can not register a null value');\n  }\n  let typeRegistry = typeMap[type];\n  let nameRegistry = nameMap[type];\n  // If the type registry has not been created, create it.\n  if (!typeRegistry) {\n    typeRegistry = typeMap[type] = Object.create(null);\n    nameRegistry = nameMap[type] = Object.create(null);\n  }\n\n  // Validate that the given class has all the required properties.\n  validate(type, registryItem);\n\n  // Don't throw an error if opt_allowOverrides is true.\n  if (!opt_allowOverrides && typeRegistry[caselessName]) {\n    throw Error(\n        'Name \"' + caselessName + '\" with type \"' + type +\n        '\" already registered.');\n  }\n  typeRegistry[caselessName] = registryItem;\n  nameRegistry[caselessName] = name;\n};\nexports.register = register;\n\n/**\n * Checks the given registry item for properties that are required based on the\n * type.\n * @param {string} type The type of the plugin. (e.g. Field, Renderer)\n * @param {Function|Object} registryItem A class or object that we are checking\n *     for the required properties.\n */\nconst validate = function(type, registryItem) {\n  switch (type) {\n    case String(Type.FIELD):\n      if (typeof registryItem.fromJson !== 'function') {\n        throw Error('Type \"' + type + '\" must have a fromJson function');\n      }\n      break;\n  }\n};\n\n/**\n * Unregisters the registry item with the given type and name.\n * @param {string|!Type<T>} type The type of the plugin.\n *     (e.g. Field, Renderer)\n * @param {string} name The plugin's name. (Ex. field_angle, geras)\n * @template T\n * @alias Blockly.registry.unregister\n */\nconst unregister = function(type, name) {\n  type = String(type).toLowerCase();\n  name = name.toLowerCase();\n  const typeRegistry = typeMap[type];\n  if (!typeRegistry || !typeRegistry[name]) {\n    console.warn(\n        'Unable to unregister [' + name + '][' + type + '] from the ' +\n        'registry.');\n    return;\n  }\n  delete typeMap[type][name];\n  delete nameMap[type][name];\n};\nexports.unregister = unregister;\n\n/**\n * Gets the registry item for the given name and type. This can be either a\n * class or an object.\n * @param {string|!Type<T>} type The type of the plugin.\n *     (e.g. Field, Renderer)\n * @param {string} name The plugin's name. (Ex. field_angle, geras)\n * @param {boolean=} opt_throwIfMissing Whether or not to throw an error if we\n *     are unable to find the plugin.\n * @return {?function(new:T, ...?)|Object} The class or object with the given\n *     name and type or null if none exists.\n * @template T\n */\nconst getItem = function(type, name, opt_throwIfMissing) {\n  type = String(type).toLowerCase();\n  name = name.toLowerCase();\n  const typeRegistry = typeMap[type];\n  if (!typeRegistry || !typeRegistry[name]) {\n    const msg = 'Unable to find [' + name + '][' + type + '] in the registry.';\n    if (opt_throwIfMissing) {\n      throw new Error(\n          msg + ' You must require or register a ' + type + ' plugin.');\n    } else {\n      console.warn(msg);\n    }\n    return null;\n  }\n  return typeRegistry[name];\n};\n\n/**\n * Returns whether or not the registry contains an item with the given type and\n * name.\n * @param {string|!Type<T>} type The type of the plugin.\n *     (e.g. Field, Renderer)\n * @param {string} name The plugin's name. (Ex. field_angle, geras)\n * @return {boolean} True if the registry has an item with the given type and\n *     name, false otherwise.\n * @template T\n * @alias Blockly.registry.hasItem\n */\nconst hasItem = function(type, name) {\n  type = String(type).toLowerCase();\n  name = name.toLowerCase();\n  const typeRegistry = typeMap[type];\n  if (!typeRegistry) {\n    return false;\n  }\n  return !!(typeRegistry[name]);\n};\nexports.hasItem = hasItem;\n\n/**\n * Gets the class for the given name and type.\n * @param {string|!Type<T>} type The type of the plugin.\n *     (e.g. Field, Renderer)\n * @param {string} name The plugin's name. (Ex. field_angle, geras)\n * @param {boolean=} opt_throwIfMissing Whether or not to throw an error if we\n *     are unable to find the plugin.\n * @return {?function(new:T, ...?)} The class with the given name and type or\n *     null if none exists.\n * @template T\n * @alias Blockly.registry.getClass\n */\nconst getClass = function(type, name, opt_throwIfMissing) {\n  return /** @type {?function(new:T, ...?)} */ (\n      getItem(type, name, opt_throwIfMissing));\n};\nexports.getClass = getClass;\n\n/**\n * Gets the object for the given name and type.\n * @param {string|!Type<T>} type The type of the plugin.\n *     (e.g. Category)\n * @param {string} name The plugin's name. (Ex. logic_category)\n * @param {boolean=} opt_throwIfMissing Whether or not to throw an error if we\n *     are unable to find the object.\n * @return {?T} The object with the given name and type or null if none exists.\n * @template T\n * @alias Blockly.registry.getObject\n */\nconst getObject = function(type, name, opt_throwIfMissing) {\n  return /** @type {T} */ (getItem(type, name, opt_throwIfMissing));\n};\nexports.getObject = getObject;\n\n/**\n * Returns a map of items registered with the given type.\n * @param {string|!Type<T>} type The type of the plugin. (e.g. Category)\n * @param {boolean} opt_cased Whether or not to return a map with cased keys\n *     (rather than caseless keys). False by default.\n * @param {boolean=} opt_throwIfMissing Whether or not to throw an error if we\n *     are unable to find the object. False by default.\n * @return {?Object<string, ?T|?function(new:T, ...?)>} A map of objects with\n *     the given type, or null if none exists.\n * @template T\n * @alias Blockly.registry.getAllItems\n */\nconst getAllItems = function(type, opt_cased, opt_throwIfMissing) {\n  type = String(type).toLowerCase();\n  const typeRegistry = typeMap[type];\n  if (!typeRegistry) {\n    const msg = `Unable to find [${type}] in the registry.`;\n    if (opt_throwIfMissing) {\n      throw new Error(`${msg} You must require or register a ${type} plugin.`);\n    } else {\n      console.warn(msg);\n    }\n    return null;\n  }\n  if (!opt_cased) {\n    return typeRegistry;\n  }\n  const nameRegistry = nameMap[type];\n  const casedRegistry = Object.create(null);\n  const keys = Object.keys(typeRegistry);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    casedRegistry[nameRegistry[key]] = typeRegistry[key];\n  }\n  return casedRegistry;\n};\nexports.getAllItems = getAllItems;\n\n/**\n * Gets the class from Blockly options for the given type.\n * This is used for plugins that override a built in feature. (e.g. Toolbox)\n * @param {!Type<T>} type The type of the plugin.\n * @param {!Options} options The option object to check for the given\n *     plugin.\n * @param {boolean=} opt_throwIfMissing Whether or not to throw an error if we\n *     are unable to find the plugin.\n * @return {?function(new:T, ...?)} The class for the plugin.\n * @template T\n * @alias Blockly.registry.getClassFromOptions\n */\nconst getClassFromOptions = function(type, options, opt_throwIfMissing) {\n  const typeName = type.toString();\n  const plugin = options.plugins[typeName] || DEFAULT;\n\n  // If the user passed in a plugin class instead of a registered plugin name.\n  if (typeof plugin === 'function') {\n    return plugin;\n  }\n  return getClass(type, plugin, opt_throwIfMissing);\n};\nexports.getClassFromOptions = getClassFromOptions;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/registry.js?")},
"./core/rendered_connection.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/internal_constants.js\");\n__webpack_require__(\"./core/utils/svg_paths.js\");\n__webpack_require__(\"./core/utils/svg_math.js\");\n__webpack_require__(\"./core/config.js\");\n__webpack_require__(\"./core/connection_type.js\");\n__webpack_require__(\"./core/connection.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Components for creating connections between blocks.\n */\n\n\n/**\n * Components for creating connections between blocks.\n * @class\n */\ngoog.module('Blockly.RenderedConnection');\n\nconst common = goog.require('Blockly.common');\nconst dom = goog.require('Blockly.utils.dom');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst internalConstants = goog.require('Blockly.internalConstants');\nconst svgPaths = goog.require('Blockly.utils.svgPaths');\nconst svgMath = goog.require('Blockly.utils.svgMath');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\nconst {config} = goog.require('Blockly.config');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConnectionDB} = goog.requireType('Blockly.ConnectionDB');\nconst {ConnectionType} = goog.require('Blockly.ConnectionType');\nconst {Connection} = goog.require('Blockly.Connection');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n\n\n/**\n * Maximum randomness in workspace units for bumping a block.\n * @const\n */\nconst BUMP_RANDOMNESS = 10;\n\n/**\n * Class for a connection between blocks that may be rendered on screen.\n * @extends {Connection}\n * @alias Blockly.RenderedConnection\n */\nclass RenderedConnection extends Connection {\n  /**\n   * @param {!BlockSvg} source The block establishing this connection.\n   * @param {number} type The type of the connection.\n   */\n  constructor(source, type) {\n    super(source, type);\n\n    /** @type {!BlockSvg} */\n    this.sourceBlock_;\n\n    /**\n     * Connection database for connections of this type on the current\n     * workspace.\n     * @const {!ConnectionDB}\n     * @private\n     */\n    this.db_ = source.workspace.connectionDBList[type];\n\n    /**\n     * Connection database for connections compatible with this type on the\n     * current workspace.\n     * @const {!ConnectionDB}\n     * @private\n     */\n    this.dbOpposite_ =\n        source.workspace\n            .connectionDBList[internalConstants.OPPOSITE_TYPE[type]];\n\n    /**\n     * Workspace units, (0, 0) is top left of block.\n     * @type {!Coordinate}\n     * @private\n     */\n    this.offsetInBlock_ = new Coordinate(0, 0);\n\n    /**\n     * Describes the state of this connection's tracked-ness.\n     * @type {RenderedConnection.TrackedState}\n     * @private\n     */\n    this.trackedState_ = RenderedConnection.TrackedState.WILL_TRACK;\n\n    /**\n     * Connection this connection connects to.  Null if not connected.\n     * @type {RenderedConnection}\n     */\n    this.targetConnection = null;\n  }\n\n  /**\n   * Dispose of this connection. Remove it from the database (if it is\n   * tracked) and call the super-function to deal with connected blocks.\n   * @override\n   * @package\n   */\n  dispose() {\n    super.dispose();\n    if (this.trackedState_ === RenderedConnection.TrackedState.TRACKED) {\n      this.db_.removeConnection(this, this.y);\n    }\n  }\n\n  /**\n   * Get the source block for this connection.\n   * @return {!BlockSvg} The source block.\n   * @override\n   */\n  getSourceBlock() {\n    return /** @type {!BlockSvg} */ (super.getSourceBlock());\n  }\n\n  /**\n   * Returns the block that this connection connects to.\n   * @return {?BlockSvg} The connected block or null if none is connected.\n   * @override\n   */\n  targetBlock() {\n    return /** @type {BlockSvg} */ (super.targetBlock());\n  }\n\n  /**\n   * Returns the distance between this connection and another connection in\n   * workspace units.\n   * @param {!Connection} otherConnection The other connection to measure\n   *     the distance to.\n   * @return {number} The distance between connections, in workspace units.\n   */\n  distanceFrom(otherConnection) {\n    const xDiff = this.x - otherConnection.x;\n    const yDiff = this.y - otherConnection.y;\n    return Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n  }\n\n  /**\n   * Move the block(s) belonging to the connection to a point where they don't\n   * visually interfere with the specified connection.\n   * @param {!RenderedConnection} staticConnection The connection to move away\n   *     from.\n   * @package\n   */\n  bumpAwayFrom(staticConnection) {\n    if (this.sourceBlock_.workspace.isDragging()) {\n      // Don't move blocks around while the user is doing the same.\n      return;\n    }\n    // Move the root block.\n    let rootBlock = this.sourceBlock_.getRootBlock();\n    if (rootBlock.isInFlyout) {\n      // Don't move blocks around in a flyout.\n      return;\n    }\n    let reverse = false;\n    if (!rootBlock.isMovable()) {\n      // Can't bump an uneditable block away.\n      // Check to see if the other block is movable.\n      rootBlock = staticConnection.getSourceBlock().getRootBlock();\n      if (!rootBlock.isMovable()) {\n        return;\n      }\n      // Swap the connections and move the 'static' connection instead.\n      staticConnection = this;\n      reverse = true;\n    }\n    // Raise it to the top for extra visibility.\n    const selected = common.getSelected() == rootBlock;\n    selected || rootBlock.addSelect();\n    let dx = (staticConnection.x + config.snapRadius +\n              Math.floor(Math.random() * BUMP_RANDOMNESS)) -\n        this.x;\n    let dy = (staticConnection.y + config.snapRadius +\n              Math.floor(Math.random() * BUMP_RANDOMNESS)) -\n        this.y;\n    if (reverse) {\n      // When reversing a bump due to an uneditable block, bump up.\n      dy = -dy;\n    }\n    if (rootBlock.RTL) {\n      dx = (staticConnection.x - config.snapRadius -\n            Math.floor(Math.random() * BUMP_RANDOMNESS)) -\n          this.x;\n    }\n    rootBlock.moveBy(dx, dy);\n    selected || rootBlock.removeSelect();\n  }\n\n  /**\n   * Change the connection's coordinates.\n   * @param {number} x New absolute x coordinate, in workspace coordinates.\n   * @param {number} y New absolute y coordinate, in workspace coordinates.\n   */\n  moveTo(x, y) {\n    if (this.trackedState_ === RenderedConnection.TrackedState.WILL_TRACK) {\n      this.db_.addConnection(this, y);\n      this.trackedState_ = RenderedConnection.TrackedState.TRACKED;\n    } else if (this.trackedState_ === RenderedConnection.TrackedState.TRACKED) {\n      this.db_.removeConnection(this, this.y);\n      this.db_.addConnection(this, y);\n    }\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * Change the connection's coordinates.\n   * @param {number} dx Change to x coordinate, in workspace units.\n   * @param {number} dy Change to y coordinate, in workspace units.\n   */\n  moveBy(dx, dy) {\n    this.moveTo(this.x + dx, this.y + dy);\n  }\n\n  /**\n   * Move this connection to the location given by its offset within the block\n   * and the location of the block's top left corner.\n   * @param {!Coordinate} blockTL The location of the top left\n   *     corner of the block, in workspace coordinates.\n   */\n  moveToOffset(blockTL) {\n    this.moveTo(\n        blockTL.x + this.offsetInBlock_.x, blockTL.y + this.offsetInBlock_.y);\n  }\n\n  /**\n   * Set the offset of this connection relative to the top left of its block.\n   * @param {number} x The new relative x, in workspace units.\n   * @param {number} y The new relative y, in workspace units.\n   */\n  setOffsetInBlock(x, y) {\n    this.offsetInBlock_.x = x;\n    this.offsetInBlock_.y = y;\n  }\n\n  /**\n   * Get the offset of this connection relative to the top left of its block.\n   * @return {!Coordinate} The offset of the connection.\n   * @package\n   */\n  getOffsetInBlock() {\n    return this.offsetInBlock_;\n  }\n\n  /**\n   * Move the blocks on either side of this connection right next to each other.\n   * @package\n   */\n  tighten() {\n    const dx = this.targetConnection.x - this.x;\n    const dy = this.targetConnection.y - this.y;\n    if (dx !== 0 || dy !== 0) {\n      const block = this.targetBlock();\n      const svgRoot = block.getSvgRoot();\n      if (!svgRoot) {\n        throw Error('block is not rendered.');\n      }\n      // Workspace coordinates.\n      const xy = svgMath.getRelativeXY(svgRoot);\n      block.getSvgRoot().setAttribute(\n          'transform', 'translate(' + (xy.x - dx) + ',' + (xy.y - dy) + ')');\n      block.moveConnections(-dx, -dy);\n    }\n  }\n\n  /**\n   * Find the closest compatible connection to this connection.\n   * All parameters are in workspace units.\n   * @param {number} maxLimit The maximum radius to another connection.\n   * @param {!Coordinate} dxy Offset between this connection's location\n   *     in the database and the current location (as a result of dragging).\n   * @return {!{connection: ?Connection, radius: number}} Contains two\n   *     properties: 'connection' which is either another connection or null,\n   *     and 'radius' which is the distance.\n   */\n  closest(maxLimit, dxy) {\n    return this.dbOpposite_.searchForClosest(this, maxLimit, dxy);\n  }\n\n  /**\n   * Add highlighting around this connection.\n   */\n  highlight() {\n    let steps;\n    const sourceBlockSvg = /** @type {!BlockSvg} */ (this.sourceBlock_);\n    const renderConstants =\n        sourceBlockSvg.workspace.getRenderer().getConstants();\n    const shape = renderConstants.shapeFor(this);\n    if (this.type === ConnectionType.INPUT_VALUE ||\n        this.type === ConnectionType.OUTPUT_VALUE) {\n      // Vertical line, puzzle tab, vertical line.\n      const yLen = renderConstants.TAB_OFFSET_FROM_TOP;\n      steps = svgPaths.moveBy(0, -yLen) + svgPaths.lineOnAxis('v', yLen) +\n          shape.pathDown + svgPaths.lineOnAxis('v', yLen);\n    } else {\n      const xLen =\n          renderConstants.NOTCH_OFFSET_LEFT - renderConstants.CORNER_RADIUS;\n      // Horizontal line, notch, horizontal line.\n      steps = svgPaths.moveBy(-xLen, 0) + svgPaths.lineOnAxis('h', xLen) +\n          shape.pathLeft + svgPaths.lineOnAxis('h', xLen);\n    }\n    const xy = this.sourceBlock_.getRelativeToSurfaceXY();\n    const x = this.x - xy.x;\n    const y = this.y - xy.y;\n    Connection.highlightedPath_ = dom.createSvgElement(\n        Svg.PATH, {\n          'class': 'blocklyHighlightedConnectionPath',\n          'd': steps,\n          'transform': 'translate(' + x + ',' + y + ')' +\n              (this.sourceBlock_.RTL ? ' scale(-1 1)' : ''),\n        },\n        this.sourceBlock_.getSvgRoot());\n  }\n\n  /**\n   * Remove the highlighting around this connection.\n   */\n  unhighlight() {\n    dom.removeNode(Connection.highlightedPath_);\n    delete Connection.highlightedPath_;\n  }\n\n  /**\n   * Set whether this connections is tracked in the database or not.\n   * @param {boolean} doTracking If true, start tracking. If false, stop\n   *     tracking.\n   * @package\n   */\n  setTracking(doTracking) {\n    if ((doTracking &&\n         this.trackedState_ === RenderedConnection.TrackedState.TRACKED) ||\n        (!doTracking &&\n         this.trackedState_ === RenderedConnection.TrackedState.UNTRACKED)) {\n      return;\n    }\n    if (this.sourceBlock_.isInFlyout) {\n      // Don't bother maintaining a database of connections in a flyout.\n      return;\n    }\n    if (doTracking) {\n      this.db_.addConnection(this, this.y);\n      this.trackedState_ = RenderedConnection.TrackedState.TRACKED;\n      return;\n    }\n    if (this.trackedState_ === RenderedConnection.TrackedState.TRACKED) {\n      this.db_.removeConnection(this, this.y);\n    }\n    this.trackedState_ = RenderedConnection.TrackedState.UNTRACKED;\n  }\n\n  /**\n   * Stop tracking this connection, as well as all down-stream connections on\n   * any block attached to this connection. This happens when a block is\n   * collapsed.\n   *\n   * Also closes down-stream icons/bubbles.\n   * @package\n   */\n  stopTrackingAll() {\n    this.setTracking(false);\n    if (this.targetConnection) {\n      const blocks = this.targetBlock().getDescendants(false);\n      for (let i = 0; i < blocks.length; i++) {\n        const block = blocks[i];\n        // Stop tracking connections of all children.\n        const connections = block.getConnections_(true);\n        for (let j = 0; j < connections.length; j++) {\n          /** @type {!RenderedConnection} */ (connections[j])\n              .setTracking(false);\n        }\n        // Close all bubbles of all children.\n        const icons = block.getIcons();\n        for (let j = 0; j < icons.length; j++) {\n          icons[j].setVisible(false);\n        }\n      }\n    }\n  }\n\n  /**\n   * Start tracking this connection, as well as all down-stream connections on\n   * any block attached to this connection. This happens when a block is\n   * expanded.\n   * @return {!Array<!Block>} List of blocks to render.\n   */\n  startTrackingAll() {\n    this.setTracking(true);\n    // All blocks that are not tracked must start tracking before any\n    // rendering takes place, since rendering requires knowing the dimensions\n    // of lower blocks. Also, since rendering a block renders all its parents,\n    // we only need to render the leaf nodes.\n    let renderList = [];\n    if (this.type !== ConnectionType.INPUT_VALUE &&\n        this.type !== ConnectionType.NEXT_STATEMENT) {\n      // Only spider down.\n      return renderList;\n    }\n    const block = this.targetBlock();\n    if (block) {\n      let connections;\n      if (block.isCollapsed()) {\n        // This block should only be partially revealed since it is collapsed.\n        connections = [];\n        block.outputConnection && connections.push(block.outputConnection);\n        block.nextConnection && connections.push(block.nextConnection);\n        block.previousConnection && connections.push(block.previousConnection);\n      } else {\n        // Show all connections of this block.\n        connections = block.getConnections_(true);\n      }\n      for (let i = 0; i < connections.length; i++) {\n        renderList.push.apply(renderList, connections[i].startTrackingAll());\n      }\n      if (!renderList.length) {\n        // Leaf block.\n        renderList = [block];\n      }\n    }\n    return renderList;\n  }\n\n  /**\n   * Behavior after a connection attempt fails.\n   * Bumps this connection away from the other connection. Called when an\n   * attempted connection fails.\n   * @param {!Connection} otherConnection Connection that this connection\n   *     failed to connect to.\n   * @package\n   */\n  onFailedConnect(otherConnection) {\n    const block = this.getSourceBlock();\n    if (eventUtils.getRecordUndo()) {\n      const group = eventUtils.getGroup();\n      setTimeout(function() {\n        if (!block.isDisposed() && !block.getParent()) {\n          eventUtils.setGroup(group);\n          this.bumpAwayFrom(\n              /** @type {!RenderedConnection} */ (otherConnection));\n          eventUtils.setGroup(false);\n        }\n      }.bind(this), config.bumpDelay);\n    }\n  }\n\n  /**\n   * Disconnect two blocks that are connected by this connection.\n   * @param {!Block} parentBlock The superior block.\n   * @param {!Block} childBlock The inferior block.\n   * @protected\n   * @override\n   */\n  disconnectInternal_(parentBlock, childBlock) {\n    super.disconnectInternal_(parentBlock, childBlock);\n    const renderedParent = /** @type {!BlockSvg} */ (parentBlock);\n    const renderedChild = /** @type {!BlockSvg} */ (childBlock);\n\n    // Rerender the parent so that it may reflow.\n    if (renderedParent.rendered) {\n      renderedParent.render();\n    }\n    if (renderedChild.rendered) {\n      renderedChild.updateDisabled();\n      renderedChild.render();\n      // Reset visibility, since the child is now a top block.\n      renderedChild.getSvgRoot().style.display = 'block';\n    }\n  }\n\n  /**\n   * Respawn the shadow block if there was one connected to the this connection.\n   * Render/rerender blocks as needed.\n   * @protected\n   * @override\n   */\n  respawnShadow_() {\n    super.respawnShadow_();\n    const blockShadow = this.targetBlock();\n    if (!blockShadow) {\n      return;\n    }\n    blockShadow.initSvg();\n    blockShadow.render(false);\n\n    const parentBlock = this.getSourceBlock();\n    if (parentBlock.rendered) {\n      parentBlock.render();\n    }\n  }\n\n  /**\n   * Find all nearby compatible connections to this connection.\n   * Type checking does not apply, since this function is used for bumping.\n   * @param {number} maxLimit The maximum radius to another connection, in\n   *     workspace units.\n   * @return {!Array<!Connection>} List of connections.\n   * @package\n   */\n  neighbours(maxLimit) {\n    return this.dbOpposite_.getNeighbours(this, maxLimit);\n  }\n\n  /**\n   * Connect two connections together.  This is the connection on the superior\n   * block.  Rerender blocks as needed.\n   * @param {!Connection} childConnection Connection on inferior block.\n   * @protected\n   */\n  connect_(childConnection) {\n    super.connect_(childConnection);\n\n    const renderedChildConnection = /** @type {!RenderedConnection} */\n        (childConnection);\n\n    const parentConnection = this;\n    const parentBlock = parentConnection.getSourceBlock();\n    const childBlock = renderedChildConnection.getSourceBlock();\n    const parentRendered = parentBlock.rendered;\n    const childRendered = childBlock.rendered;\n\n    if (parentRendered) {\n      parentBlock.updateDisabled();\n    }\n    if (childRendered) {\n      childBlock.updateDisabled();\n    }\n    if (parentRendered && childRendered) {\n      if (parentConnection.type === ConnectionType.NEXT_STATEMENT ||\n          parentConnection.type === ConnectionType.PREVIOUS_STATEMENT) {\n        // Child block may need to square off its corners if it is in a stack.\n        // Rendering a child will render its parent.\n        childBlock.render();\n      } else {\n        // Child block does not change shape.  Rendering the parent node will\n        // move its connected children into position.\n        parentBlock.render();\n      }\n    }\n\n    // The input the child block is connected to (if any).\n    const parentInput = parentBlock.getInputWithBlock(childBlock);\n    if (parentInput) {\n      const visible = parentInput.isVisible();\n      childBlock.getSvgRoot().style.display = visible ? 'block' : 'none';\n    }\n  }\n\n  /**\n   * Function to be called when this connection's compatible types have changed.\n   * @protected\n   */\n  onCheckChanged_() {\n    // The new value type may not be compatible with the existing connection.\n    if (this.isConnected() &&\n        (!this.targetConnection ||\n         !this.getConnectionChecker().canConnect(\n             this, this.targetConnection, false))) {\n      const child = this.isSuperior() ? this.targetBlock() : this.sourceBlock_;\n      child.unplug();\n      // Bump away.\n      this.sourceBlock_.bumpNeighbours();\n    }\n  }\n}\n\n/**\n * Enum for different kinds of tracked states.\n *\n * WILL_TRACK means that this connection will add itself to\n * the db on the next moveTo call it receives.\n *\n * UNTRACKED means that this connection will not add\n * itself to the database until setTracking(true) is explicitly called.\n *\n * TRACKED means that this connection is currently being tracked.\n * @enum {number}\n */\nRenderedConnection.TrackedState = {\n  WILL_TRACK: -1,\n  UNTRACKED: 0,\n  TRACKED: 1,\n};\n\nexports.RenderedConnection = RenderedConnection;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/rendered_connection.js?")},
"./core/renderers/common/block_rendering.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/common/debug.js\");\n__webpack_require__(\"./core/utils/deprecation.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/renderers/measurables/bottom_row.js\");\n__webpack_require__(\"./core/renderers/measurables/connection.js\");\n__webpack_require__(\"./core/renderers/common/constants.js\");\n__webpack_require__(\"./core/renderers/common/debugger.js\");\n__webpack_require__(\"./core/renderers/common/drawer.js\");\n__webpack_require__(\"./core/renderers/measurables/external_value_input.js\");\n__webpack_require__(\"./core/renderers/measurables/field.js\");\n__webpack_require__(\"./core/renderers/measurables/hat.js\");\n__webpack_require__(\"./core/renderers/common/i_path_object.js\");\n__webpack_require__(\"./core/renderers/measurables/icon.js\");\n__webpack_require__(\"./core/renderers/measurables/in_row_spacer.js\");\n__webpack_require__(\"./core/renderers/measurables/inline_input.js\");\n__webpack_require__(\"./core/renderers/measurables/input_connection.js\");\n__webpack_require__(\"./core/renderers/measurables/input_row.js\");\n__webpack_require__(\"./core/renderers/measurables/jagged_edge.js\");\n__webpack_require__(\"./core/renderers/common/marker_svg.js\");\n__webpack_require__(\"./core/renderers/measurables/base.js\");\n__webpack_require__(\"./core/renderers/measurables/next_connection.js\");\n__webpack_require__(\"./core/renderers/measurables/output_connection.js\");\n__webpack_require__(\"./core/renderers/common/path_object.js\");\n__webpack_require__(\"./core/renderers/measurables/previous_connection.js\");\n__webpack_require__(\"./core/renderers/common/info.js\");\n__webpack_require__(\"./core/renderers/common/renderer.js\");\n__webpack_require__(\"./core/renderers/measurables/round_corner.js\");\n__webpack_require__(\"./core/renderers/measurables/row.js\");\n__webpack_require__(\"./core/renderers/measurables/spacer_row.js\");\n__webpack_require__(\"./core/renderers/measurables/square_corner.js\");\n__webpack_require__(\"./core/renderers/measurables/statement_input.js\");\n__webpack_require__(\"./core/renderers/measurables/top_row.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Namespace for block rendering functionality.\n */\n\n\n/**\n * Namespace for block rendering functionality.\n * @namespace Blockly.blockRendering\n */\ngoog.module('Blockly.blockRendering');\n\nconst debug = goog.require('Blockly.blockRendering.debug');\nconst deprecation = goog.require('Blockly.utils.deprecation');\nconst registry = goog.require('Blockly.registry');\nconst {BottomRow} = goog.require('Blockly.blockRendering.BottomRow');\nconst {Connection} = goog.require('Blockly.blockRendering.Connection');\nconst {ConstantProvider} = goog.require('Blockly.blockRendering.ConstantProvider');\nconst {Debug} = goog.require('Blockly.blockRendering.Debug');\nconst {Drawer} = goog.require('Blockly.blockRendering.Drawer');\nconst {ExternalValueInput} = goog.require('Blockly.blockRendering.ExternalValueInput');\nconst {Field} = goog.require('Blockly.blockRendering.Field');\nconst {Hat} = goog.require('Blockly.blockRendering.Hat');\nconst {IPathObject} = goog.require('Blockly.blockRendering.IPathObject');\nconst {Icon} = goog.require('Blockly.blockRendering.Icon');\nconst {InRowSpacer} = goog.require('Blockly.blockRendering.InRowSpacer');\nconst {InlineInput} = goog.require('Blockly.blockRendering.InlineInput');\nconst {InputConnection} = goog.require('Blockly.blockRendering.InputConnection');\nconst {InputRow} = goog.require('Blockly.blockRendering.InputRow');\nconst {JaggedEdge} = goog.require('Blockly.blockRendering.JaggedEdge');\nconst {MarkerSvg} = goog.require('Blockly.blockRendering.MarkerSvg');\nconst {Measurable} = goog.require('Blockly.blockRendering.Measurable');\nconst {NextConnection} = goog.require('Blockly.blockRendering.NextConnection');\nconst {OutputConnection} = goog.require('Blockly.blockRendering.OutputConnection');\nconst {PathObject} = goog.require('Blockly.blockRendering.PathObject');\nconst {PreviousConnection} = goog.require('Blockly.blockRendering.PreviousConnection');\nconst {RenderInfo} = goog.require('Blockly.blockRendering.RenderInfo');\nconst {Renderer} = goog.require('Blockly.blockRendering.Renderer');\nconst {RoundCorner} = goog.require('Blockly.blockRendering.RoundCorner');\nconst {Row} = goog.require('Blockly.blockRendering.Row');\nconst {SpacerRow} = goog.require('Blockly.blockRendering.SpacerRow');\nconst {SquareCorner} = goog.require('Blockly.blockRendering.SquareCorner');\nconst {StatementInput} = goog.require('Blockly.blockRendering.StatementInput');\n/* eslint-disable-next-line no-unused-vars */\nconst {Theme} = goog.requireType('Blockly.Theme');\nconst {TopRow} = goog.require('Blockly.blockRendering.TopRow');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n/**\n * Returns whether the debugger is turned on.\n * @return {boolean} Whether the debugger is turned on.\n * @alias Blockly.blockRendering.isDebuggerEnabled\n * @package\n * @deprecated\n */\nconst isDebuggerEnabled = function() {\n  deprecation.warn(\n      'Blockly.blockRendering.isDebuggerEnabled()', 'September 2021',\n      'September 2022',\n      'the debug renderer in @blockly/dev-tools (See https://www.npmjs.com/package/@blockly/dev-tools.)');\n  return debug.isDebuggerEnabled();\n};\nexports.isDebuggerEnabled = isDebuggerEnabled;\n\n/**\n * Registers a new renderer.\n * @param {string} name The name of the renderer.\n * @param {!Function} rendererClass The new renderer class\n *     to register.\n * @throws {Error} if a renderer with the same name has already been registered.\n */\nconst register = function(name, rendererClass) {\n  registry.register(registry.Type.RENDERER, name, rendererClass);\n};\nexports.register = register;\n\n/**\n * Unregisters the renderer registered with the given name.\n * @param {string} name The name of the renderer.\n * @alias Blockly.blockRendering.unregister\n */\nconst unregister = function(name) {\n  registry.unregister(registry.Type.RENDERER, name);\n};\nexports.unregister = unregister;\n\n/**\n * Turn on the blocks debugger.\n * @package\n * @alias Blockly.blockRendering.startDebugger\n * @deprecated\n */\nconst startDebugger = function() {\n  deprecation.warn(\n      'Blockly.blockRendering.startDebugger()', 'September 2021',\n      'September 2022',\n      'the debug renderer in @blockly/dev-tools (See https://www.npmjs.com/package/@blockly/dev-tools.)');\n  debug.startDebugger();\n};\nexports.startDebugger = startDebugger;\n\n/**\n * Turn off the blocks debugger.\n * @package\n * @alias Blockly.blockRendering.stopDebugger\n * @deprecated\n */\nconst stopDebugger = function() {\n  deprecation.warn(\n      'Blockly.blockRendering.stopDebugger()', 'September 2021',\n      'September 2022',\n      'the debug renderer in @blockly/dev-tools (See https://www.npmjs.com/package/@blockly/dev-tools.)');\n  debug.stopDebugger();\n};\nexports.stopDebugger = stopDebugger;\n\n/**\n * Initialize anything needed for rendering (constants, etc).\n * @param {!string} name Name of the renderer to initialize.\n * @param {!Theme} theme The workspace theme object.\n * @param {Object=} opt_rendererOverrides Rendering constant overrides.\n * @return {!Renderer} The new instance of a renderer.\n *     Already initialized.\n * @package\n * @alias Blockly.blockRendering.init\n */\nconst init = function(name, theme, opt_rendererOverrides) {\n  const rendererClass = registry.getClass(registry.Type.RENDERER, name);\n  const renderer = new rendererClass(name);\n  renderer.init(theme, opt_rendererOverrides);\n  return renderer;\n};\nexports.init = init;\n\nexports.BottomRow = BottomRow;\nexports.Connection = Connection;\nexports.ConstantProvider = ConstantProvider;\nexports.Debug = Debug;\nexports.Drawer = Drawer;\nexports.ExternalValueInput = ExternalValueInput;\nexports.Field = Field;\nexports.Hat = Hat;\nexports.Icon = Icon;\nexports.InRowSpacer = InRowSpacer;\nexports.InlineInput = InlineInput;\nexports.InputConnection = InputConnection;\nexports.InputRow = InputRow;\nexports.IPathObject = IPathObject;\nexports.JaggedEdge = JaggedEdge;\nexports.MarkerSvg = MarkerSvg;\nexports.Measurable = Measurable;\nexports.NextConnection = NextConnection;\nexports.OutputConnection = OutputConnection;\nexports.PathObject = PathObject;\nexports.PreviousConnection = PreviousConnection;\nexports.Renderer = Renderer;\nexports.RenderInfo = RenderInfo;\nexports.RoundCorner = RoundCorner;\nexports.Row = Row;\nexports.SpacerRow = SpacerRow;\nexports.SquareCorner = SquareCorner;\nexports.StatementInput = StatementInput;\nexports.TopRow = TopRow;\nexports.Types = Types;\nexports.debug = debug;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/common/block_rendering.js?")},
"./core/renderers/common/constants.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/colour.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/utils/object.js\");\n__webpack_require__(\"./core/utils/svg_paths.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\n__webpack_require__(\"./core/utils/parsing.js\");\n__webpack_require__(\"./core/connection_type.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview An object that provides constants for rendering blocks.\n */\n\n\n/**\n * An object that provides constants for rendering blocks.\n * @class\n */\ngoog.module('Blockly.blockRendering.ConstantProvider');\n\nconst colour = goog.require('Blockly.utils.colour');\nconst dom = goog.require('Blockly.utils.dom');\nconst object = goog.require('Blockly.utils.object');\nconst svgPaths = goog.require('Blockly.utils.svgPaths');\nconst userAgent = goog.require('Blockly.utils.userAgent');\nconst parsing = goog.require('Blockly.utils.parsing');\nconst {ConnectionType} = goog.require('Blockly.ConnectionType');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderedConnection} = goog.requireType('Blockly.RenderedConnection');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Theme} = goog.requireType('Blockly.Theme');\n\n\n/**\n * An object that provides constants for rendering blocks.\n * @alias Blockly.blockRendering.ConstantProvider\n */\nclass ConstantProvider {\n  /**\n   * @package\n   */\n  constructor() {\n    /**\n     * The size of an empty spacer.\n     * @type {number}\n     */\n    this.NO_PADDING = 0;\n\n    /**\n     * The size of small padding.\n     * @type {number}\n     */\n    this.SMALL_PADDING = 3;\n\n    /**\n     * The size of medium padding.\n     * @type {number}\n     */\n    this.MEDIUM_PADDING = 5;\n\n    /**\n     * The size of medium-large padding.\n     * @type {number}\n     */\n    this.MEDIUM_LARGE_PADDING = 8;\n\n    /**\n     * The size of large padding.\n     * @type {number}\n     */\n    this.LARGE_PADDING = 10;\n\n    /**\n     * Offset from the top of the row for placing fields on inline input rows\n     * and statement input rows.\n     * Matches existing rendering (in 2019).\n     * @type {number}\n     */\n    this.TALL_INPUT_FIELD_OFFSET_Y = this.MEDIUM_PADDING;\n\n    /**\n     * The height of the puzzle tab used for input and output connections.\n     * @type {number}\n     */\n    this.TAB_HEIGHT = 15;\n\n    /**\n     * The offset from the top of the block at which a puzzle tab is positioned.\n     * @type {number}\n     */\n    this.TAB_OFFSET_FROM_TOP = 5;\n\n    /**\n     * Vertical overlap of the puzzle tab, used to make it look more like a\n     * puzzle piece.\n     * @type {number}\n     */\n    this.TAB_VERTICAL_OVERLAP = 2.5;\n\n    /**\n     * The width of the puzzle tab used for input and output connections.\n     * @type {number}\n     */\n    this.TAB_WIDTH = 8;\n\n    /**\n     * The width of the notch used for previous and next connections.\n     * @type {number}\n     */\n    this.NOTCH_WIDTH = 15;\n\n    /**\n     * The height of the notch used for previous and next connections.\n     * @type {number}\n     */\n    this.NOTCH_HEIGHT = 4;\n\n    /**\n     * The minimum width of the block.\n     * @type {number}\n     */\n    this.MIN_BLOCK_WIDTH = 12;\n\n    this.EMPTY_BLOCK_SPACER_HEIGHT = 16;\n\n    /**\n     * The minimum height of a dummy input row.\n     * @type {number}\n     */\n    this.DUMMY_INPUT_MIN_HEIGHT = this.TAB_HEIGHT;\n\n    /**\n     * The minimum height of a dummy input row in a shadow block.\n     * @type {number}\n     */\n    this.DUMMY_INPUT_SHADOW_MIN_HEIGHT = this.TAB_HEIGHT;\n\n    /**\n     * Rounded corner radius.\n     * @type {number}\n     */\n    this.CORNER_RADIUS = 8;\n\n    /**\n     * Offset from the left side of a block or the inside of a statement input\n     * to the left side of the notch.\n     * @type {number}\n     */\n    this.NOTCH_OFFSET_LEFT = 15;\n\n    /**\n     * Additional offset added to the statement input's width to account for the\n     * notch.\n     * @type {number}\n     */\n    this.STATEMENT_INPUT_NOTCH_OFFSET = this.NOTCH_OFFSET_LEFT;\n\n    this.STATEMENT_BOTTOM_SPACER = 0;\n    this.STATEMENT_INPUT_PADDING_LEFT = 20;\n\n    /**\n     * Vertical padding between consecutive statement inputs.\n     * @type {number}\n     */\n    this.BETWEEN_STATEMENT_PADDING_Y = 4;\n\n    /**\n     * The top row's minimum height.\n     * @type {number}\n     */\n    this.TOP_ROW_MIN_HEIGHT = this.MEDIUM_PADDING;\n\n    /**\n     * The top row's minimum height if it precedes a statement.\n     * @type {number}\n     */\n    this.TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT = this.LARGE_PADDING;\n\n    /**\n     * The bottom row's minimum height.\n     * @type {number}\n     */\n    this.BOTTOM_ROW_MIN_HEIGHT = this.MEDIUM_PADDING;\n\n    /**\n     * The bottom row's minimum height if it follows a statement input.\n     * @type {number}\n     */\n    this.BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT = this.LARGE_PADDING;\n\n    /**\n     * Whether to add a 'hat' on top of all blocks with no previous or output\n     * connections. Can be overridden by 'hat' property on Theme.BlockStyle.\n     * @type {boolean}\n     */\n    this.ADD_START_HATS = false;\n\n    /**\n     * Height of the top hat.\n     * @type {number}\n     */\n    this.START_HAT_HEIGHT = 15;\n\n    /**\n     * Width of the top hat.\n     * @type {number}\n     */\n    this.START_HAT_WIDTH = 100;\n\n    this.SPACER_DEFAULT_HEIGHT = 15;\n\n    this.MIN_BLOCK_HEIGHT = 24;\n\n    this.EMPTY_INLINE_INPUT_PADDING = 14.5;\n\n    /**\n     * The height of an empty inline input.\n     * @type {number}\n     */\n    this.EMPTY_INLINE_INPUT_HEIGHT = this.TAB_HEIGHT + 11;\n\n    this.EXTERNAL_VALUE_INPUT_PADDING = 2;\n\n    /**\n     * The height of an empty statement input.  Note that in the old rendering\n     * this varies slightly depending on whether the block has external or\n     * inline inputs. In the new rendering this is consistent.  It seems\n     * unlikely that the old behaviour was intentional.\n     * @type {number}\n     */\n    this.EMPTY_STATEMENT_INPUT_HEIGHT = this.MIN_BLOCK_HEIGHT;\n\n    this.START_POINT = svgPaths.moveBy(0, 0);\n\n    /**\n     * Height of SVG path for jagged teeth at the end of collapsed blocks.\n     * @type {number}\n     */\n    this.JAGGED_TEETH_HEIGHT = 12;\n\n    /**\n     * Width of SVG path for jagged teeth at the end of collapsed blocks.\n     * @type {number}\n     */\n    this.JAGGED_TEETH_WIDTH = 6;\n\n    /**\n     * Point size of text.\n     * @type {number}\n     */\n    this.FIELD_TEXT_FONTSIZE = 11;\n\n    /**\n     * Text font weight.\n     * @type {string}\n     */\n    this.FIELD_TEXT_FONTWEIGHT = 'normal';\n\n    /**\n     * Text font family.\n     * @type {string}\n     */\n    this.FIELD_TEXT_FONTFAMILY = 'sans-serif';\n\n    /**\n     * Height of text.  This constant is dynamically set in\n     * ``setFontConstants_`` to be the height of the text based on the font\n     * used.\n     * @type {number}\n     */\n    this.FIELD_TEXT_HEIGHT = -1;  // Dynamically set.\n\n    /**\n     * Text baseline.  This constant is dynamically set in ``setFontConstants_``\n     * to be the baseline of the text based on the font used.\n     * @type {number}\n     */\n    this.FIELD_TEXT_BASELINE = -1;  // Dynamically set.\n\n    /**\n     * A field's border rect corner radius.\n     * @type {number}\n     */\n    this.FIELD_BORDER_RECT_RADIUS = 4;\n\n    /**\n     * A field's border rect default height.\n     * @type {number}\n     */\n    this.FIELD_BORDER_RECT_HEIGHT = 16;\n\n    /**\n     * A field's border rect X padding.\n     * @type {number}\n     */\n    this.FIELD_BORDER_RECT_X_PADDING = 5;\n\n    /**\n     * A field's border rect Y padding.\n     * @type {number}\n     */\n    this.FIELD_BORDER_RECT_Y_PADDING = 3;\n\n    /**\n     * The backing colour of a field's border rect.\n     * @type {string}\n     * @package\n     */\n    this.FIELD_BORDER_RECT_COLOUR = '#fff';\n\n    /**\n     * A field's text element's dominant baseline.\n     * @type {boolean}\n     */\n    this.FIELD_TEXT_BASELINE_CENTER = !userAgent.IE && !userAgent.EDGE;\n\n    /**\n     * A dropdown field's border rect height.\n     * @type {number}\n     */\n    this.FIELD_DROPDOWN_BORDER_RECT_HEIGHT = this.FIELD_BORDER_RECT_HEIGHT;\n\n    /**\n     * Whether or not a dropdown field should add a border rect when in a shadow\n     * block.\n     * @type {boolean}\n     */\n    this.FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW = false;\n\n    /**\n     * Whether or not a dropdown field's div should be coloured to match the\n     * block colours.\n     * @type {boolean}\n     */\n    this.FIELD_DROPDOWN_COLOURED_DIV = false;\n\n    /**\n     * Whether or not a dropdown field uses a text or SVG arrow.\n     * @type {boolean}\n     */\n    this.FIELD_DROPDOWN_SVG_ARROW = false;\n\n    /**\n     * A dropdown field's SVG arrow padding.\n     * @type {number}\n     */\n    this.FIELD_DROPDOWN_SVG_ARROW_PADDING = this.FIELD_BORDER_RECT_X_PADDING;\n\n    /**\n     * A dropdown field's SVG arrow size.\n     * @type {number}\n     */\n    this.FIELD_DROPDOWN_SVG_ARROW_SIZE = 12;\n\n    /**\n     * A dropdown field's SVG arrow datauri.\n     * @type {string}\n     */\n    this.FIELD_DROPDOWN_SVG_ARROW_DATAURI =\n        'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllci' +\n        'AxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMi43MSIgaG' +\n        'VpZ2h0PSI4Ljc5IiB2aWV3Qm94PSIwIDAgMTIuNzEgOC43OSI+PHRpdGxlPmRyb3Bkb3duLW' +\n        'Fycm93PC90aXRsZT48ZyBvcGFjaXR5PSIwLjEiPjxwYXRoIGQ9Ik0xMi43MSwyLjQ0QTIuND' +\n        'EsMi40MSwwLDAsMSwxMiw0LjE2TDguMDgsOC4wOGEyLjQ1LDIuNDUsMCwwLDEtMy40NSwwTD' +\n        'AuNzIsNC4xNkEyLjQyLDIuNDIsMCwwLDEsMCwyLjQ0LDIuNDgsMi40OCwwLDAsMSwuNzEuNz' +\n        'FDMSwwLjQ3LDEuNDMsMCw2LjM2LDBTMTEuNzUsMC40NiwxMiwuNzFBMi40NCwyLjQ0LDAsMC' +\n        'wxLDEyLjcxLDIuNDRaIiBmaWxsPSIjMjMxZjIwIi8+PC9nPjxwYXRoIGQ9Ik02LjM2LDcuNz' +\n        'lhMS40MywxLjQzLDAsMCwxLTEtLjQyTDEuNDIsMy40NWExLjQ0LDEuNDQsMCwwLDEsMC0yYz' +\n        'AuNTYtLjU2LDkuMzEtMC41Niw5Ljg3LDBhMS40NCwxLjQ0LDAsMCwxLDAsMkw3LjM3LDcuMz' +\n        'dBMS40MywxLjQzLDAsMCwxLDYuMzYsNy43OVoiIGZpbGw9IiNmZmYiLz48L3N2Zz4=';\n\n    /**\n     * Whether or not to show a box shadow around the widget div. This is only a\n     * feature of full block fields.\n     * @type {boolean}\n     */\n    this.FIELD_TEXTINPUT_BOX_SHADOW = false;\n\n    /**\n     * Whether or not the colour field should display its colour value on the\n     * entire block.\n     * @type {boolean}\n     */\n    this.FIELD_COLOUR_FULL_BLOCK = false;\n\n    /**\n     * A colour field's default width.\n     * @type {number}\n     */\n    this.FIELD_COLOUR_DEFAULT_WIDTH = 26;\n\n    /**\n     * A colour field's default height.\n     * @type {number}\n     */\n    this.FIELD_COLOUR_DEFAULT_HEIGHT = this.FIELD_BORDER_RECT_HEIGHT;\n\n    /**\n     * A checkbox field's X offset.\n     * @type {number}\n     */\n    this.FIELD_CHECKBOX_X_OFFSET = this.FIELD_BORDER_RECT_X_PADDING - 3;\n\n    /**\n     * A random identifier used to ensure a unique ID is used for each\n     * filter/pattern for the case of multiple Blockly instances on a page.\n     * @type {string}\n     * @package\n     */\n    this.randomIdentifier = String(Math.random()).substring(2);\n\n    /**\n     * The defs tag that contains all filters and patterns for this Blockly\n     * instance.\n     * @type {?SVGElement}\n     * @private\n     */\n    this.defs_ = null;\n\n    /**\n     * The ID of the emboss filter, or the empty string if no filter is set.\n     * @type {string}\n     * @package\n     */\n    this.embossFilterId = '';\n\n    /**\n     * The <filter> element to use for highlighting, or null if not set.\n     * @type {SVGElement}\n     * @private\n     */\n    this.embossFilter_ = null;\n\n    /**\n     * The ID of the disabled pattern, or the empty string if no pattern is set.\n     * @type {string}\n     * @package\n     */\n    this.disabledPatternId = '';\n\n    /**\n     * The <pattern> element to use for disabled blocks, or null if not set.\n     * @type {SVGElement}\n     * @private\n     */\n    this.disabledPattern_ = null;\n\n    /**\n     * The ID of the debug filter, or the empty string if no pattern is set.\n     * @type {string}\n     * @package\n     */\n    this.debugFilterId = '';\n\n    /**\n     * The <filter> element to use for a debug highlight, or null if not set.\n     * @type {SVGElement}\n     * @private\n     */\n    this.debugFilter_ = null;\n\n    /**\n     * The <style> element to use for injecting renderer specific CSS.\n     * @type {HTMLStyleElement}\n     * @private\n     */\n    this.cssNode_ = null;\n\n    /**\n     * Cursor colour.\n     * @type {string}\n     * @package\n     */\n    this.CURSOR_COLOUR = '#cc0a0a';\n\n    /**\n     * Immovable marker colour.\n     * @type {string}\n     * @package\n     */\n    this.MARKER_COLOUR = '#4286f4';\n\n    /**\n     * Width of the horizontal cursor.\n     * @type {number}\n     * @package\n     */\n    this.CURSOR_WS_WIDTH = 100;\n\n    /**\n     * Height of the horizontal cursor.\n     * @type {number}\n     * @package\n     */\n    this.WS_CURSOR_HEIGHT = 5;\n\n    /**\n     * Padding around a stack.\n     * @type {number}\n     * @package\n     */\n    this.CURSOR_STACK_PADDING = 10;\n\n    /**\n     * Padding around a block.\n     * @type {number}\n     * @package\n     */\n    this.CURSOR_BLOCK_PADDING = 2;\n\n    /**\n     * Stroke of the cursor.\n     * @type {number}\n     * @package\n     */\n    this.CURSOR_STROKE_WIDTH = 4;\n\n    /**\n     * Whether text input and colour fields fill up the entire source block.\n     * @type {boolean}\n     * @package\n     */\n    this.FULL_BLOCK_FIELDS = false;\n\n    /**\n     * The main colour of insertion markers, in hex.  The block is rendered a\n     * transparent grey by changing the fill opacity in CSS.\n     * @type {string}\n     * @package\n     */\n    this.INSERTION_MARKER_COLOUR = '#000000';\n\n    /**\n     * The insertion marker opacity.\n     * @type {number}\n     * @package\n     */\n    this.INSERTION_MARKER_OPACITY = 0.2;\n\n    /**\n     * Enum for connection shapes.\n     * @enum {number}\n     */\n    this.SHAPES = {PUZZLE: 1, NOTCH: 2};\n  }\n\n  /**\n   * Initialize shape objects based on the constants set in the constructor.\n   * @package\n   */\n  init() {\n    /**\n     * An object containing sizing and path information about collapsed block\n     * indicators.\n     * @type {!Object}\n     */\n    this.JAGGED_TEETH = this.makeJaggedTeeth();\n\n    /**\n     * An object containing sizing and path information about notches.\n     * @type {!Object}\n     */\n    this.NOTCH = this.makeNotch();\n\n    /**\n     * An object containing sizing and path information about start hats\n     * @type {!Object}\n     */\n    this.START_HAT = this.makeStartHat();\n\n    /**\n     * An object containing sizing and path information about puzzle tabs.\n     * @type {!Object}\n     */\n    this.PUZZLE_TAB = this.makePuzzleTab();\n\n    /**\n     * An object containing sizing and path information about inside corners\n     * @type {!Object}\n     */\n    this.INSIDE_CORNERS = this.makeInsideCorners();\n\n    /**\n     * An object containing sizing and path information about outside corners.\n     * @type {!Object}\n     */\n    this.OUTSIDE_CORNERS = this.makeOutsideCorners();\n  }\n\n  /**\n   * Refresh constants properties that depend on the theme.\n   * @param {!Theme} theme The current workspace theme.\n   * @package\n   */\n  setTheme(theme) {\n    /**\n     * The block styles map.\n     * @type {Object<string, !Theme.BlockStyle>}\n     * @package\n     */\n    this.blockStyles = Object.create(null);\n\n    const blockStyles = theme.blockStyles;\n    for (const key in blockStyles) {\n      this.blockStyles[key] = this.validatedBlockStyle_(blockStyles[key]);\n    }\n\n    this.setDynamicProperties_(theme);\n  }\n\n  /**\n   * Sets dynamic properties that depend on other values or theme properties.\n   * @param {!Theme} theme The current workspace theme.\n   * @protected\n   */\n  setDynamicProperties_(theme) {\n    this.setFontConstants_(theme);\n    this.setComponentConstants_(theme);\n\n    this.ADD_START_HATS =\n        theme.startHats !== null ? theme.startHats : this.ADD_START_HATS;\n  }\n\n  /**\n   * Set constants related to fonts.\n   * @param {!Theme} theme The current workspace theme.\n   * @protected\n   */\n  setFontConstants_(theme) {\n    if (theme.fontStyle && theme.fontStyle['family']) {\n      this.FIELD_TEXT_FONTFAMILY = theme.fontStyle['family'];\n    }\n\n    if (theme.fontStyle && theme.fontStyle['weight']) {\n      this.FIELD_TEXT_FONTWEIGHT = theme.fontStyle['weight'];\n    }\n\n    if (theme.fontStyle && theme.fontStyle['size']) {\n      this.FIELD_TEXT_FONTSIZE = theme.fontStyle['size'];\n    }\n\n    const fontMetrics = dom.measureFontMetrics(\n        'Hg', this.FIELD_TEXT_FONTSIZE + 'pt', this.FIELD_TEXT_FONTWEIGHT,\n        this.FIELD_TEXT_FONTFAMILY);\n\n    this.FIELD_TEXT_HEIGHT = fontMetrics.height;\n    this.FIELD_TEXT_BASELINE = fontMetrics.baseline;\n  }\n\n  /**\n   * Set constants from a theme's component styles.\n   * @param {!Theme} theme The current workspace theme.\n   * @protected\n   */\n  setComponentConstants_(theme) {\n    this.CURSOR_COLOUR =\n        theme.getComponentStyle('cursorColour') || this.CURSOR_COLOUR;\n    this.MARKER_COLOUR =\n        theme.getComponentStyle('markerColour') || this.MARKER_COLOUR;\n    this.INSERTION_MARKER_COLOUR =\n        theme.getComponentStyle('insertionMarkerColour') ||\n        this.INSERTION_MARKER_COLOUR;\n    this.INSERTION_MARKER_OPACITY =\n        Number(theme.getComponentStyle('insertionMarkerOpacity')) ||\n        this.INSERTION_MARKER_OPACITY;\n  }\n\n  /**\n   * Get or create a block style based on a single colour value.  Generate a\n   * name for the style based on the colour.\n   * @param {string} colour #RRGGBB colour string.\n   * @return {{style: !Theme.BlockStyle, name: string}} An object\n   *     containing the style and an autogenerated name for that style.\n   * @package\n   */\n  getBlockStyleForColour(colour) {\n    const name = 'auto_' + colour;\n    if (!this.blockStyles[name]) {\n      this.blockStyles[name] = this.createBlockStyle_(colour);\n    }\n    return {style: this.blockStyles[name], name: name};\n  }\n\n  /**\n   * Gets the BlockStyle for the given block style name.\n   * @param {?string} blockStyleName The name of the block style.\n   * @return {!Theme.BlockStyle} The named block style, or a default style\n   *     if no style with the given name was found.\n   */\n  getBlockStyle(blockStyleName) {\n    return this.blockStyles[blockStyleName || ''] ||\n        (blockStyleName && blockStyleName.indexOf('auto_') === 0 ?\n             this.getBlockStyleForColour(blockStyleName.substring(5)).style :\n             this.createBlockStyle_('#000000'));\n  }\n\n  /**\n   * Create a block style object based on the given colour.\n   * @param {string} colour #RRGGBB colour string.\n   * @return {!Theme.BlockStyle} A populated block style based on the\n   *     given colour.\n   * @protected\n   */\n  createBlockStyle_(colour) {\n    return this.validatedBlockStyle_({'colourPrimary': colour});\n  }\n\n  /**\n   * Get a full block style object based on the input style object.  Populate\n   * any missing values.\n   * @param {{\n   *     colourPrimary:string,\n   *     colourSecondary:(string|undefined),\n   *     colourTertiary:(string|undefined),\n   *     hat:(string|undefined)\n   * }} blockStyle A full or partial block style object.\n\n   * @return {!Theme.BlockStyle} A full block style object, with all\n   *     required properties populated.\n   * @protected\n   */\n  validatedBlockStyle_(blockStyle) {\n    // Make a new object with all of the same properties.\n    const valid = /** @type {!Theme.BlockStyle} */ ({});\n    if (blockStyle) {\n      object.mixin(valid, blockStyle);\n    }\n    // Validate required properties.\n    const parsedColour =\n        parsing.parseBlockColour(valid['colourPrimary'] || '#000');\n    valid.colourPrimary = parsedColour.hex;\n    valid.colourSecondary = valid['colourSecondary'] ?\n        parsing.parseBlockColour(valid['colourSecondary']).hex :\n        this.generateSecondaryColour_(valid.colourPrimary);\n    valid.colourTertiary = valid['colourTertiary'] ?\n        parsing.parseBlockColour(valid['colourTertiary']).hex :\n        this.generateTertiaryColour_(valid.colourPrimary);\n\n    valid.hat = valid['hat'] || '';\n    return valid;\n  }\n\n  /**\n   * Generate a secondary colour from the passed in primary colour.\n   * @param {string} inputColour Primary colour.\n   * @return {string} The generated secondary colour.\n   * @protected\n   */\n  generateSecondaryColour_(inputColour) {\n    return colour.blend('#fff', inputColour, 0.6) || inputColour;\n  }\n\n  /**\n   * Generate a tertiary colour from the passed in primary colour.\n   * @param {string} inputColour Primary colour.\n   * @return {string} The generated tertiary colour.\n   * @protected\n   */\n  generateTertiaryColour_(inputColour) {\n    return colour.blend('#fff', inputColour, 0.3) || inputColour;\n  }\n\n  /**\n   * Dispose of this constants provider.\n   * Delete all DOM elements that this provider created.\n   * @package\n   */\n  dispose() {\n    if (this.embossFilter_) {\n      dom.removeNode(this.embossFilter_);\n    }\n    if (this.disabledPattern_) {\n      dom.removeNode(this.disabledPattern_);\n    }\n    if (this.debugFilter_) {\n      dom.removeNode(this.debugFilter_);\n    }\n    this.cssNode_ = null;\n  }\n\n  /**\n   * @return {!Object} An object containing sizing and path information about\n   *     collapsed block indicators.\n   * @package\n   */\n  makeJaggedTeeth() {\n    const height = this.JAGGED_TEETH_HEIGHT;\n    const width = this.JAGGED_TEETH_WIDTH;\n\n    const mainPath = svgPaths.line([\n      svgPaths.point(width, height / 4),\n      svgPaths.point(-width * 2, height / 2),\n      svgPaths.point(width, height / 4),\n    ]);\n    return {height: height, width: width, path: mainPath};\n  }\n\n  /**\n   * @return {!Object} An object containing sizing and path information about\n   *     start hats.\n   * @package\n   */\n  makeStartHat() {\n    const height = this.START_HAT_HEIGHT;\n    const width = this.START_HAT_WIDTH;\n\n    const mainPath = svgPaths.curve('c', [\n      svgPaths.point(30, -height),\n      svgPaths.point(70, -height),\n      svgPaths.point(width, 0),\n    ]);\n    return {height: height, width: width, path: mainPath};\n  }\n\n  /**\n   * @return {!Object} An object containing sizing and path information about\n   *     puzzle tabs.\n   * @package\n   */\n  makePuzzleTab() {\n    const width = this.TAB_WIDTH;\n    const height = this.TAB_HEIGHT;\n\n    /**\n     * Make the main path for the puzzle tab made out of a few curves (c and s).\n     * Those curves are defined with relative positions.  The 'up' and 'down'\n     * versions of the paths are the same, but the Y sign flips.  Forward and\n     * back are the signs to use to move the cursor in the direction that the\n     * path is being drawn.\n     * @param {boolean} up True if the path should be drawn from bottom to top,\n     *     false otherwise.\n     * @return {string} A path fragment describing a puzzle tab.\n     */\n    function makeMainPath(up) {\n      const forward = up ? -1 : 1;\n      const back = -forward;\n\n      const overlap = 2.5;\n      const halfHeight = height / 2;\n      const control1Y = halfHeight + overlap;\n      const control2Y = halfHeight + 0.5;\n      const control3Y = overlap;  // 2.5\n\n      const endPoint1 = svgPaths.point(-width, forward * halfHeight);\n      const endPoint2 = svgPaths.point(width, forward * halfHeight);\n\n      return svgPaths.curve(\n                 'c',\n                 [\n                   svgPaths.point(0, forward * control1Y),\n                   svgPaths.point(-width, back * control2Y),\n                   endPoint1,\n                 ]) +\n          svgPaths.curve(\n              's', [svgPaths.point(width, back * control3Y), endPoint2]);\n    }\n\n    // c 0,-10  -8,8  -8,-7.5  s 8,2.5  8,-7.5\n    const pathUp = makeMainPath(true);\n    // c 0,10  -8,-8  -8,7.5  s 8,-2.5  8,7.5\n    const pathDown = makeMainPath(false);\n\n    return {\n      type: this.SHAPES.PUZZLE,\n      width: width,\n      height: height,\n      pathDown: pathDown,\n      pathUp: pathUp,\n    };\n  }\n\n  /**\n   * @return {!Object} An object containing sizing and path information about\n   *     notches.\n   * @package\n   */\n  makeNotch() {\n    const width = this.NOTCH_WIDTH;\n    const height = this.NOTCH_HEIGHT;\n    const innerWidth = 3;\n    const outerWidth = (width - innerWidth) / 2;\n\n    /**\n     * Make the main path for the notch.\n     * @param {number} dir Direction multiplier to apply to horizontal offsets\n     *     along the path. Either 1 or -1.\n     * @return {string} A path fragment describing a notch.\n     */\n    function makeMainPath(dir) {\n      return svgPaths.line([\n        svgPaths.point(dir * outerWidth, height),\n        svgPaths.point(dir * innerWidth, 0),\n        svgPaths.point(dir * outerWidth, -height),\n      ]);\n    }\n    const pathLeft = makeMainPath(1);\n    const pathRight = makeMainPath(-1);\n\n    return {\n      type: this.SHAPES.NOTCH,\n      width: width,\n      height: height,\n      pathLeft: pathLeft,\n      pathRight: pathRight,\n    };\n  }\n\n  /**\n   * @return {!Object} An object containing sizing and path information about\n   *     inside corners.\n   * @package\n   */\n  makeInsideCorners() {\n    const radius = this.CORNER_RADIUS;\n\n    const innerTopLeftCorner =\n        svgPaths.arc('a', '0 0,0', radius, svgPaths.point(-radius, radius));\n\n    const innerBottomLeftCorner =\n        svgPaths.arc('a', '0 0,0', radius, svgPaths.point(radius, radius));\n\n    return {\n      width: radius,\n      height: radius,\n      pathTop: innerTopLeftCorner,\n      pathBottom: innerBottomLeftCorner,\n    };\n  }\n\n  /**\n   * @return {!Object} An object containing sizing and path information about\n   *     outside corners.\n   * @package\n   */\n  makeOutsideCorners() {\n    const radius = this.CORNER_RADIUS;\n    /**\n     * SVG path for drawing the rounded top-left corner.\n     * @const\n     */\n    const topLeft = svgPaths.moveBy(0, radius) +\n        svgPaths.arc('a', '0 0,1', radius, svgPaths.point(radius, -radius));\n\n    /**\n     * SVG path for drawing the rounded top-right corner.\n     * @const\n     */\n    const topRight =\n        svgPaths.arc('a', '0 0,1', radius, svgPaths.point(radius, radius));\n\n    /**\n     * SVG path for drawing the rounded bottom-left corner.\n     * @const\n     */\n    const bottomLeft =\n        svgPaths.arc('a', '0 0,1', radius, svgPaths.point(-radius, -radius));\n\n    /**\n     * SVG path for drawing the rounded bottom-right corner.\n     * @const\n     */\n    const bottomRight =\n        svgPaths.arc('a', '0 0,1', radius, svgPaths.point(-radius, radius));\n\n    return {\n      topLeft: topLeft,\n      topRight: topRight,\n      bottomRight: bottomRight,\n      bottomLeft: bottomLeft,\n      rightHeight: radius,\n    };\n  }\n\n  /**\n   * Get an object with connection shape and sizing information based on the\n   * type of the connection.\n   * @param {!RenderedConnection} connection The connection to find a\n   *     shape object for\n   * @return {!Object} The shape object for the connection.\n   * @package\n   */\n  shapeFor(connection) {\n    switch (connection.type) {\n      case ConnectionType.INPUT_VALUE:\n      case ConnectionType.OUTPUT_VALUE:\n        return this.PUZZLE_TAB;\n      case ConnectionType.PREVIOUS_STATEMENT:\n      case ConnectionType.NEXT_STATEMENT:\n        return this.NOTCH;\n      default:\n        throw Error('Unknown connection type');\n    }\n  }\n\n  /**\n   * Create any DOM elements that this renderer needs (filters, patterns, etc).\n   * @param {!SVGElement} svg The root of the workspace's SVG.\n   * @param {string} tagName The name to use for the CSS style tag.\n   * @param {string} selector The CSS selector to use.\n   * @suppress {strictModuleDepCheck} Debug renderer only included in\n   * playground.\n   * @package\n   */\n  createDom(svg, tagName, selector) {\n    this.injectCSS_(tagName, selector);\n\n    /*\n    <defs>\n      ... filters go here ...\n    </defs>\n    */\n    this.defs_ = dom.createSvgElement(Svg.DEFS, {}, svg);\n    /*\n      <filter id=\"blocklyEmbossFilter837493\">\n        <feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"1\" result=\"blur\" />\n        <feSpecularLighting in=\"blur\" surfaceScale=\"1\" specularConstant=\"0.5\"\n                            specularExponent=\"10\" lighting-color=\"white\"\n                            result=\"specOut\">\n          <fePointLight x=\"-5000\" y=\"-10000\" z=\"20000\" />\n        </feSpecularLighting>\n        <feComposite in=\"specOut\" in2=\"SourceAlpha\" operator=\"in\"\n                     result=\"specOut\" />\n        <feComposite in=\"SourceGraphic\" in2=\"specOut\" operator=\"arithmetic\"\n                     k1=\"0\" k2=\"1\" k3=\"1\" k4=\"0\" />\n      </filter>\n    */\n    const embossFilter = dom.createSvgElement(\n        Svg.FILTER, {'id': 'blocklyEmbossFilter' + this.randomIdentifier},\n        this.defs_);\n    dom.createSvgElement(\n        Svg.FEGAUSSIANBLUR,\n        {'in': 'SourceAlpha', 'stdDeviation': 1, 'result': 'blur'},\n        embossFilter);\n    const feSpecularLighting = dom.createSvgElement(\n        Svg.FESPECULARLIGHTING, {\n          'in': 'blur',\n          'surfaceScale': 1,\n          'specularConstant': 0.5,\n          'specularExponent': 10,\n          'lighting-color': 'white',\n          'result': 'specOut',\n        },\n        embossFilter);\n    dom.createSvgElement(\n        Svg.FEPOINTLIGHT, {'x': -5000, 'y': -10000, 'z': 20000},\n        feSpecularLighting);\n    dom.createSvgElement(\n        Svg.FECOMPOSITE, {\n          'in': 'specOut',\n          'in2': 'SourceAlpha',\n          'operator': 'in',\n          'result': 'specOut',\n        },\n        embossFilter);\n    dom.createSvgElement(\n        Svg.FECOMPOSITE, {\n          'in': 'SourceGraphic',\n          'in2': 'specOut',\n          'operator': 'arithmetic',\n          'k1': 0,\n          'k2': 1,\n          'k3': 1,\n          'k4': 0,\n        },\n        embossFilter);\n    this.embossFilterId = embossFilter.id;\n    this.embossFilter_ = embossFilter;\n\n    /*\n      <pattern id=\"blocklyDisabledPattern837493\" patternUnits=\"userSpaceOnUse\"\n               width=\"10\" height=\"10\">\n        <rect width=\"10\" height=\"10\" fill=\"#aaa\" />\n        <path d=\"M 0 0 L 10 10 M 10 0 L 0 10\" stroke=\"#cc0\" />\n      </pattern>\n    */\n    const disabledPattern = dom.createSvgElement(\n        Svg.PATTERN, {\n          'id': 'blocklyDisabledPattern' + this.randomIdentifier,\n          'patternUnits': 'userSpaceOnUse',\n          'width': 10,\n          'height': 10,\n        },\n        this.defs_);\n    dom.createSvgElement(\n        Svg.RECT, {'width': 10, 'height': 10, 'fill': '#aaa'}, disabledPattern);\n    dom.createSvgElement(\n        Svg.PATH, {'d': 'M 0 0 L 10 10 M 10 0 L 0 10', 'stroke': '#cc0'},\n        disabledPattern);\n    this.disabledPatternId = disabledPattern.id;\n    this.disabledPattern_ = disabledPattern;\n\n    this.createDebugFilter();\n  }\n\n  /**\n   * Create a filter for highlighting the currently rendering block during\n   * render debugging.\n   * @private\n   */\n  createDebugFilter() {\n    // Only create the debug filter once.\n    if (!this.debugFilter_) {\n      const debugFilter = dom.createSvgElement(\n          Svg.FILTER, {\n            'id': 'blocklyDebugFilter' + this.randomIdentifier,\n            'height': '160%',\n            'width': '180%',\n            'y': '-30%',\n            'x': '-40%',\n          },\n          this.defs_);\n      // Set all gaussian blur pixels to 1 opacity before applying flood\n      const debugComponentTransfer = dom.createSvgElement(\n          Svg.FECOMPONENTTRANSFER, {'result': 'outBlur'}, debugFilter);\n      dom.createSvgElement(\n          Svg.FEFUNCA,\n          {'type': 'table', 'tableValues': '0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1'},\n          debugComponentTransfer);\n      // Color the highlight\n      dom.createSvgElement(\n          Svg.FEFLOOD, {\n            'flood-color': '#ff0000',\n            'flood-opacity': 0.5,\n            'result': 'outColor',\n          },\n          debugFilter);\n      dom.createSvgElement(\n          Svg.FECOMPOSITE, {\n            'in': 'outColor',\n            'in2': 'outBlur',\n            'operator': 'in',\n            'result': 'outGlow',\n          },\n          debugFilter);\n      this.debugFilterId = debugFilter.id;\n      this.debugFilter_ = debugFilter;\n    }\n  }\n\n  /**\n   * Inject renderer specific CSS into the page.\n   * @param {string} tagName The name of the style tag to use.\n   * @param {string} selector The CSS selector to use.\n   * @protected\n   */\n  injectCSS_(tagName, selector) {\n    const cssArray = this.getCSS_(selector);\n    const cssNodeId = 'blockly-renderer-style-' + tagName;\n    this.cssNode_ =\n        /** @type {!HTMLStyleElement} */ (document.getElementById(cssNodeId));\n    const text = cssArray.join('\\n');\n    if (this.cssNode_) {\n      // Already injected, update if the theme changed.\n      this.cssNode_.firstChild.textContent = text;\n      return;\n    }\n    // Inject CSS tag at start of head.\n    const cssNode =\n        /** @type {!HTMLStyleElement} */ (document.createElement('style'));\n    cssNode.id = cssNodeId;\n    const cssTextNode = document.createTextNode(text);\n    cssNode.appendChild(cssTextNode);\n    document.head.insertBefore(cssNode, document.head.firstChild);\n    this.cssNode_ = cssNode;\n  }\n\n  /**\n   * Get any renderer specific CSS to inject when the renderer is initialized.\n   * @param {string} selector CSS selector to use.\n   * @return {!Array<string>} Array of CSS strings.\n   * @protected\n   */\n  getCSS_(selector) {\n    return [\n      /* eslint-disable indent */\n      /* clang-format off */\n      // Text.\n      selector + ' .blocklyText, ',\n      selector + ' .blocklyFlyoutLabelText {',\n        'font: ' + this.FIELD_TEXT_FONTWEIGHT + ' ' +\n            this.FIELD_TEXT_FONTSIZE + 'pt ' + this.FIELD_TEXT_FONTFAMILY + ';',\n      '}',\n\n      // Fields.\n      selector + ' .blocklyText {',\n        'fill: #fff;',\n      '}',\n      selector + ' .blocklyNonEditableText>rect,',\n      selector + ' .blocklyEditableText>rect {',\n        'fill: ' + this.FIELD_BORDER_RECT_COLOUR + ';',\n        'fill-opacity: .6;',\n        'stroke: none;',\n      '}',\n      selector + ' .blocklyNonEditableText>text,',\n      selector + ' .blocklyEditableText>text {',\n        'fill: #000;',\n      '}',\n\n      // Flyout labels.\n      selector + ' .blocklyFlyoutLabelText {',\n        'fill: #000;',\n      '}',\n\n      // Bubbles.\n      selector + ' .blocklyText.blocklyBubbleText {',\n        'fill: #000;',\n      '}',\n\n      // Editable field hover.\n      selector + ' .blocklyEditableText:not(.editing):hover>rect {',\n        'stroke: #fff;',\n        'stroke-width: 2;',\n      '}',\n\n      // Text field input.\n      selector + ' .blocklyHtmlInput {',\n        'font-family: ' + this.FIELD_TEXT_FONTFAMILY + ';',\n        'font-weight: ' + this.FIELD_TEXT_FONTWEIGHT + ';',\n      '}',\n\n      // Selection highlight.\n      selector + ' .blocklySelected>.blocklyPath {',\n        'stroke: #fc3;',\n        'stroke-width: 3px;',\n      '}',\n\n      // Connection highlight.\n      selector + ' .blocklyHighlightedConnectionPath {',\n        'stroke: #fc3;',\n      '}',\n\n      // Replaceable highlight.\n      selector + ' .blocklyReplaceable .blocklyPath {',\n        'fill-opacity: .5;',\n      '}',\n      selector + ' .blocklyReplaceable .blocklyPathLight,',\n      selector + ' .blocklyReplaceable .blocklyPathDark {',\n        'display: none;',\n      '}',\n\n      // Insertion marker.\n      selector + ' .blocklyInsertionMarker>.blocklyPath {',\n        'fill-opacity: ' + this.INSERTION_MARKER_OPACITY + ';',\n        'stroke: none;',\n      '}',\n      /* clang-format on */\n      /* eslint-enable indent */\n    ];\n  }\n}\n\nexports.ConstantProvider = ConstantProvider;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/common/constants.js?")},
"./core/renderers/common/debug.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/deprecation.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Block rendering debugging functionality.\n */\n\n\n/**\n * Block rendering debugging functionality.\n * @namespace Blockly.blockRendering.debug\n */\ngoog.module('Blockly.blockRendering.debug');\n\nconst deprecation = goog.require('Blockly.utils.deprecation');\n\n\n/**\n * Whether or not the debugger is turned on.\n * @type {boolean}\n */\nlet useDebugger = false;\n/**\n * Returns whether the debugger is turned on.\n * @return {boolean} Whether the debugger is turned on.\n * @alias Blockly.blockRendering.debug.isDebuggerEnabled\n * @package\n */\nconst isDebuggerEnabled = function() {\n  return useDebugger;\n};\nexports.isDebuggerEnabled = isDebuggerEnabled;\n\n/**\n * Turn on the blocks debugger.\n * @package\n * @alias Blockly.blockRendering.debug.startDebugger\n * @deprecated March 2022. Use the rendering debugger in @blockly/dev-tools.\n * See https://www.npmjs.com/package/@blockly/dev-tools for more information.\n */\nconst startDebugger = function() {\n  deprecation.warn(\n      'Blockly.blockRendering.debug.startDebugger()', 'February 2022',\n      'September 2022',\n      'the debug renderer in @blockly/dev-tools (See https://www.npmjs.com/package/@blockly/dev-tools.)');\n  useDebugger = true;\n};\nexports.startDebugger = startDebugger;\n\n/**\n * Turn off the blocks debugger.\n * @package\n * @alias Blockly.blockRendering.debug.stopDebugger\n * @deprecated March 2022. Use the rendering debugger in @blockly/dev-tools.\n * See https://www.npmjs.com/package/@blockly/dev-tools for more information.\n */\nconst stopDebugger = function() {\n  deprecation.warn(\n      'Blockly.blockRendering.debug.stopDebugger()', 'February 2022',\n      'September 2022',\n      'the debug renderer in @blockly/dev-tools (See https://www.npmjs.com/package/@blockly/dev-tools.)');\n  useDebugger = false;\n};\nexports.stopDebugger = stopDebugger;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/common/debug.js?")},
"./core/renderers/common/debugger.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/connection_type.js\");\n__webpack_require__(\"./core/renderers/measurables/field.js\");\n__webpack_require__(\"./core/field_label.js\");\n__webpack_require__(\"./core/renderers/measurables/input_connection.js\");\n__webpack_require__(\"./core/utils/svg.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Methods for rendering debug graphics.\n */\n\n\n\n/**\n * Methods for rendering debug graphics.\n * @class\n */\ngoog.module('Blockly.blockRendering.Debug');\n\nconst dom = goog.require('Blockly.utils.dom');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {ConnectionType} = goog.require('Blockly.ConnectionType');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {Field} = goog.require('Blockly.blockRendering.Field');\nconst {FieldLabel} = goog.require('Blockly.FieldLabel');\nconst {InputConnection} = goog.require('Blockly.blockRendering.InputConnection');\n/* eslint-disable-next-line no-unused-vars */\nconst {InRowSpacer} = goog.requireType('Blockly.blockRendering.InRowSpacer');\n/* eslint-disable-next-line no-unused-vars */\nconst {Measurable} = goog.requireType('Blockly.blockRendering.Measurable');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderInfo} = goog.requireType('Blockly.blockRendering.RenderInfo');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderInfo: ZelosInfo} = goog.requireType('Blockly.zelos.RenderInfo');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderedConnection} = goog.requireType('Blockly.RenderedConnection');\n/* eslint-disable-next-line no-unused-vars */\nconst {Row} = goog.requireType('Blockly.blockRendering.Row');\nconst {Svg} = goog.require('Blockly.utils.Svg');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object that renders rectangles and dots for debugging rendering code.\n * @alias Blockly.blockRendering.Debug\n */\nclass Debug {\n  /**\n   * @param {!ConstantProvider} constants The renderer's\n   *     constants.\n   * @package\n   */\n  constructor(constants) {\n    /**\n     * An array of SVG elements that have been created by this object.\n     * @type {Array<!SVGElement>}\n     * @private\n     */\n    this.debugElements_ = [];\n\n    /**\n     * The SVG root of the block that is being rendered.  Debug elements will\n     * be attached to this root.\n     * @type {SVGElement}\n     * @private\n     */\n    this.svgRoot_ = null;\n\n    /**\n     * The renderer's constant provider.\n     * @type {!ConstantProvider}\n     * @private\n     */\n    this.constants_ = constants;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.randomColour_ = '';\n  }\n\n  /**\n   * Remove all elements the this object created on the last pass.\n   * @package\n   */\n  clearElems() {\n    for (let i = 0; i < this.debugElements_.length; i++) {\n      const elem = this.debugElements_[i];\n      dom.removeNode(elem);\n    }\n\n    this.debugElements_ = [];\n  }\n\n  /**\n   * Draw a debug rectangle for a spacer (empty) row.\n   * @param {!Row} row The row to render.\n   * @param {number} cursorY The y position of the top of the row.\n   * @param {boolean} isRtl Whether the block is rendered RTL.\n   * @package\n   */\n  drawSpacerRow(row, cursorY, isRtl) {\n    if (!Debug.config.rowSpacers) {\n      return;\n    }\n\n    const height = Math.abs(row.height);\n    const isNegativeSpacing = row.height < 0;\n    if (isNegativeSpacing) {\n      cursorY -= height;\n    }\n\n    this.debugElements_.push(dom.createSvgElement(\n        Svg.RECT, {\n          'class': 'rowSpacerRect blockRenderDebug',\n          'x': isRtl ? -(row.xPos + row.width) : row.xPos,\n          'y': cursorY,\n          'width': row.width,\n          'height': height,\n          'stroke': isNegativeSpacing ? 'black' : 'blue',\n          'fill': 'blue',\n          'fill-opacity': '0.5',\n          'stroke-width': '1px',\n        },\n        this.svgRoot_));\n  }\n\n  /**\n   * Draw a debug rectangle for a horizontal spacer.\n   * @param {!InRowSpacer} elem The spacer to render.\n   * @param {number} rowHeight The height of the container row.\n   * @param {boolean} isRtl Whether the block is rendered RTL.\n   * @package\n   */\n  drawSpacerElem(elem, rowHeight, isRtl) {\n    if (!Debug.config.elemSpacers) {\n      return;\n    }\n\n    const width = Math.abs(elem.width);\n    const isNegativeSpacing = elem.width < 0;\n    let xPos = isNegativeSpacing ? elem.xPos - width : elem.xPos;\n    if (isRtl) {\n      xPos = -(xPos + width);\n    }\n    const yPos = elem.centerline - elem.height / 2;\n    this.debugElements_.push(dom.createSvgElement(\n        Svg.RECT, {\n          'class': 'elemSpacerRect blockRenderDebug',\n          'x': xPos,\n          'y': yPos,\n          'width': width,\n          'height': elem.height,\n          'stroke': 'pink',\n          'fill': isNegativeSpacing ? 'black' : 'pink',\n          'fill-opacity': '0.5',\n          'stroke-width': '1px',\n        },\n        this.svgRoot_));\n  }\n\n  /**\n   * Draw a debug rectangle for an in-row element.\n   * @param {!Measurable} elem The element to render.\n   * @param {boolean} isRtl Whether the block is rendered RTL.\n   * @package\n   */\n  drawRenderedElem(elem, isRtl) {\n    if (Debug.config.elems) {\n      let xPos = elem.xPos;\n      if (isRtl) {\n        xPos = -(xPos + elem.width);\n      }\n      const yPos = elem.centerline - elem.height / 2;\n      this.debugElements_.push(dom.createSvgElement(\n          Svg.RECT, {\n            'class': 'rowRenderingRect blockRenderDebug',\n            'x': xPos,\n            'y': yPos,\n            'width': elem.width,\n            'height': elem.height,\n            'stroke': 'black',\n            'fill': 'none',\n            'stroke-width': '1px',\n          },\n          this.svgRoot_));\n\n      if (Types.isField(elem) && elem instanceof Field &&\n          elem.field instanceof FieldLabel) {\n        const baseline = this.constants_.FIELD_TEXT_BASELINE;\n        this.debugElements_.push(dom.createSvgElement(\n            Svg.RECT, {\n              'class': 'rowRenderingRect blockRenderDebug',\n              'x': xPos,\n              'y': yPos + baseline,\n              'width': elem.width,\n              'height': '0.1px',\n              'stroke': 'red',\n              'fill': 'none',\n              'stroke-width': '0.5px',\n            },\n            this.svgRoot_));\n      }\n    }\n\n\n    if (Types.isInput(elem) && elem instanceof InputConnection &&\n        Debug.config.connections) {\n      this.drawConnection(elem.connectionModel);\n    }\n  }\n\n  /**\n   * Draw a circle at the location of the given connection.  Inputs and outputs\n   * share the same colours, as do previous and next.  When positioned correctly\n   * a connected pair will look like a bullseye.\n   * @param {RenderedConnection} conn The connection to circle.\n   * @suppress {visibility} Suppress visibility of conn.offsetInBlock_ since\n   * this is a debug module.\n   * @package\n   */\n  drawConnection(conn) {\n    if (!Debug.config.connections) {\n      return;\n    }\n\n    let colour;\n    let size;\n    let fill;\n    if (conn.type === ConnectionType.INPUT_VALUE) {\n      size = 4;\n      colour = 'magenta';\n      fill = 'none';\n    } else if (conn.type === ConnectionType.OUTPUT_VALUE) {\n      size = 2;\n      colour = 'magenta';\n      fill = colour;\n    } else if (conn.type === ConnectionType.NEXT_STATEMENT) {\n      size = 4;\n      colour = 'goldenrod';\n      fill = 'none';\n    } else if (conn.type === ConnectionType.PREVIOUS_STATEMENT) {\n      size = 2;\n      colour = 'goldenrod';\n      fill = colour;\n    }\n    this.debugElements_.push(dom.createSvgElement(\n        Svg.CIRCLE, {\n          'class': 'blockRenderDebug',\n          'cx': conn.offsetInBlock_.x,\n          'cy': conn.offsetInBlock_.y,\n          'r': size,\n          'fill': fill,\n          'stroke': colour,\n        },\n        this.svgRoot_));\n  }\n\n  /**\n   * Draw a debug rectangle for a non-empty row.\n   * @param {!Row} row The non-empty row to render.\n   * @param {number} cursorY The y position of the top of the row.\n   * @param {boolean} isRtl Whether the block is rendered RTL.\n   * @package\n   */\n  drawRenderedRow(row, cursorY, isRtl) {\n    if (!Debug.config.rows) {\n      return;\n    }\n    this.debugElements_.push(dom.createSvgElement(\n        Svg.RECT, {\n          'class': 'elemRenderingRect blockRenderDebug',\n          'x': isRtl ? -(row.xPos + row.width) : row.xPos,\n          'y': row.yPos,\n          'width': row.width,\n          'height': row.height,\n          'stroke': 'red',\n          'fill': 'none',\n          'stroke-width': '1px',\n        },\n        this.svgRoot_));\n\n    if (Types.isTopOrBottomRow(row)) {\n      return;\n    }\n\n    if (Debug.config.connectedBlockBounds) {\n      this.debugElements_.push(dom.createSvgElement(\n          Svg.RECT, {\n            'class': 'connectedBlockWidth blockRenderDebug',\n            'x': isRtl ? -(row.xPos + row.widthWithConnectedBlocks) : row.xPos,\n            'y': row.yPos,\n            'width': row.widthWithConnectedBlocks,\n            'height': row.height,\n            'stroke': this.randomColour_,\n            'fill': 'none',\n            'stroke-width': '1px',\n            'stroke-dasharray': '3,3',\n          },\n          this.svgRoot_));\n    }\n  }\n\n  /**\n   * Draw debug rectangles for a non-empty row and all of its subcomponents.\n   * @param {!Row} row The non-empty row to render.\n   * @param {number} cursorY The y position of the top of the row.\n   * @param {boolean} isRtl Whether the block is rendered RTL.\n   * @package\n   */\n  drawRowWithElements(row, cursorY, isRtl) {\n    for (let i = 0; i < row.elements.length; i++) {\n      const elem = row.elements[i];\n      if (!elem) {\n        console.warn('A row has an undefined or null element.', row, elem);\n        continue;\n      }\n      if (Types.isSpacer(elem)) {\n        this.drawSpacerElem(\n            /** @type {!InRowSpacer} */ (elem), row.height, isRtl);\n      } else {\n        this.drawRenderedElem(elem, isRtl);\n      }\n    }\n    this.drawRenderedRow(row, cursorY, isRtl);\n  }\n\n  /**\n   * Draw a debug rectangle around the entire block.\n   * @param {!RenderInfo} info Rendering information about\n   *     the block to debug.\n   * @package\n   */\n  drawBoundingBox(info) {\n    if (!Debug.config.blockBounds) {\n      return;\n    }\n    // Bounding box without children.\n    let xPos = info.RTL ? -info.width : 0;\n    const yPos = 0;\n    this.debugElements_.push(dom.createSvgElement(\n        Svg.RECT, {\n          'class': 'blockBoundingBox blockRenderDebug',\n          'x': xPos,\n          'y': yPos,\n          'width': info.width,\n          'height': info.height,\n          'stroke': 'black',\n          'fill': 'none',\n          'stroke-width': '1px',\n          'stroke-dasharray': '5,5',\n        },\n        this.svgRoot_));\n\n    if (Debug.config.connectedBlockBounds) {\n      // Bounding box with children.\n      xPos = info.RTL ? -info.widthWithChildren : 0;\n      this.debugElements_.push(dom.createSvgElement(\n          Svg.RECT, {\n            'class': 'blockRenderDebug',\n            'x': xPos,\n            'y': yPos,\n            'width': info.widthWithChildren,\n            'height': info.height,\n            'stroke': '#DF57BC',\n            'fill': 'none',\n            'stroke-width': '1px',\n            'stroke-dasharray': '3,3',\n          },\n          this.svgRoot_));\n    }\n  }\n\n  /**\n   * Do all of the work to draw debug information for the whole block.\n   * @param {!BlockSvg} block The block to draw debug information for.\n   * @param {!RenderInfo} info Rendering information about\n   *     the block to debug.\n   * @package\n   */\n  drawDebug(block, info) {\n    this.clearElems();\n    this.svgRoot_ = block.getSvgRoot();\n\n    this.randomColour_ =\n        '#' + Math.floor(Math.random() * 16777215).toString(16);\n\n    let cursorY = 0;\n    for (let i = 0; i < info.rows.length; i++) {\n      const row = info.rows[i];\n      if (Types.isBetweenRowSpacer(row)) {\n        this.drawSpacerRow(row, cursorY, info.RTL);\n      } else {\n        this.drawRowWithElements(row, cursorY, info.RTL);\n      }\n      cursorY += row.height;\n    }\n\n    if (block.previousConnection) {\n      this.drawConnection(block.previousConnection);\n    }\n    if (block.nextConnection) {\n      this.drawConnection(block.nextConnection);\n    }\n    if (block.outputConnection) {\n      this.drawConnection(block.outputConnection);\n    }\n    /**\n     * TODO: Find a better way to do this check without pulling in all of\n     * zelos, or just delete this line or the whole debug renderer.\n     */\n    const maybeZelosInfo = /** @type {!ZelosInfo} */ (info);\n    if (maybeZelosInfo.rightSide) {\n      this.drawRenderedElem(maybeZelosInfo.rightSide, info.RTL);\n    }\n\n    this.drawBoundingBox(info);\n\n    this.drawRender(block.pathObject.svgPath);\n  }\n\n  /**\n   * Show a debug filter to highlight that a block has been rendered.\n   * @param {!SVGElement} svgPath The block's SVG path.\n   * @package\n   */\n  drawRender(svgPath) {\n    if (!Debug.config.render) {\n      return;\n    }\n    svgPath.setAttribute(\n        'filter', 'url(#' + this.constants_.debugFilterId + ')');\n    setTimeout(function() {\n      svgPath.setAttribute('filter', '');\n    }, 100);\n  }\n}\n\n/**\n * Configuration object containing booleans to enable and disable debug\n * rendering of specific rendering components.\n * @type {!Object<string, boolean>}\n */\nDebug.config = {\n  rowSpacers: true,\n  elemSpacers: true,\n  rows: true,\n  elems: true,\n  connections: true,\n  blockBounds: true,\n  connectedBlockBounds: true,\n  render: true,\n};\n\nexports.Debug = Debug;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/common/debugger.js?")},
"./core/renderers/common/drawer.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/common/debug.js\");\n__webpack_require__(\"./core/utils/svg_paths.js\");\n__webpack_require__(\"./core/renderers/measurables/connection.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Methods for graphically rendering a block as SVG.\n */\n\n\n/**\n * Methods for graphically rendering a block as SVG.\n * @class\n */\ngoog.module('Blockly.blockRendering.Drawer');\n\nconst debug = goog.require('Blockly.blockRendering.debug');\nconst svgPaths = goog.require('Blockly.utils.svgPaths');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {Connection} = goog.require('Blockly.blockRendering.Connection');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {ExternalValueInput} = goog.requireType('Blockly.blockRendering.ExternalValueInput');\n/* eslint-disable-next-line no-unused-vars */\nconst {Field} = goog.requireType('Blockly.blockRendering.Field');\n/* eslint-disable-next-line no-unused-vars */\nconst {Icon} = goog.requireType('Blockly.blockRendering.Icon');\n/* eslint-disable-next-line no-unused-vars */\nconst {InlineInput} = goog.requireType('Blockly.blockRendering.InlineInput');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderInfo} = goog.requireType('Blockly.blockRendering.RenderInfo');\n/* eslint-disable-next-line no-unused-vars */\nconst {Row} = goog.requireType('Blockly.blockRendering.Row');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object that draws a block based on the given rendering information.\n * @alias Blockly.blockRendering.Drawer\n */\nclass Drawer {\n  /**\n   * @param {!BlockSvg} block The block to render.\n   * @param {!RenderInfo} info An object containing all\n   *   information needed to render this block.\n   * @package\n   */\n  constructor(block, info) {\n    this.block_ = block;\n    this.info_ = info;\n    this.topLeft_ = block.getRelativeToSurfaceXY();\n    this.outlinePath_ = '';\n    this.inlinePath_ = '';\n\n    /**\n     * The renderer's constant provider.\n     * @type {!ConstantProvider}\n     * @protected\n     */\n    this.constants_ = info.getRenderer().getConstants();\n  }\n\n  /**\n   * Draw the block to the workspace. Here \"drawing\" means setting SVG path\n   * elements and moving fields, icons, and connections on the screen.\n   *\n   * The pieces of the paths are pushed into arrays of \"steps\", which are then\n   * joined with spaces and set directly on the block.  This guarantees that\n   * the steps are separated by spaces for improved readability, but isn't\n   * required.\n   * @package\n   */\n  draw() {\n    this.hideHiddenIcons_();\n    this.drawOutline_();\n    this.drawInternals_();\n\n    this.block_.pathObject.setPath(this.outlinePath_ + '\\n' + this.inlinePath_);\n    if (this.info_.RTL) {\n      this.block_.pathObject.flipRTL();\n    }\n    if (debug.isDebuggerEnabled()) {\n      this.block_.renderingDebugger.drawDebug(this.block_, this.info_);\n    }\n    this.recordSizeOnBlock_();\n  }\n\n  /**\n   * Save sizing information back to the block\n   * Most of the rendering information can be thrown away at the end of the\n   * render. Anything that needs to be kept around should be set in this\n   * function.\n   * @protected\n   */\n  recordSizeOnBlock_() {\n    // This is used when the block is reporting its size to anyone else.\n    // The dark path adds to the size of the block in both X and Y.\n    this.block_.height = this.info_.height;\n    this.block_.width = this.info_.widthWithChildren;\n  }\n\n  /**\n   * Hide icons that were marked as hidden.\n   * @protected\n   */\n  hideHiddenIcons_() {\n    for (let i = 0, iconInfo; (iconInfo = this.info_.hiddenIcons[i]); i++) {\n      iconInfo.icon.iconGroup_.setAttribute('display', 'none');\n    }\n  }\n\n  /**\n   * Create the outline of the block.  This is a single continuous path.\n   * @protected\n   */\n  drawOutline_() {\n    this.drawTop_();\n    for (let r = 1; r < this.info_.rows.length - 1; r++) {\n      const row = this.info_.rows[r];\n      if (row.hasJaggedEdge) {\n        this.drawJaggedEdge_(row);\n      } else if (row.hasStatement) {\n        this.drawStatementInput_(row);\n      } else if (row.hasExternalInput) {\n        this.drawValueInput_(row);\n      } else {\n        this.drawRightSideRow_(row);\n      }\n    }\n    this.drawBottom_();\n    this.drawLeft_();\n  }\n\n  /**\n   * Add steps for the top corner of the block, taking into account\n   * details such as hats and rounded corners.\n   * @protected\n   */\n  drawTop_() {\n    const topRow = this.info_.topRow;\n    const elements = topRow.elements;\n\n    this.positionPreviousConnection_();\n    this.outlinePath_ += svgPaths.moveBy(topRow.xPos, this.info_.startY);\n    for (let i = 0, elem; (elem = elements[i]); i++) {\n      if (Types.isLeftRoundedCorner(elem)) {\n        this.outlinePath_ += this.constants_.OUTSIDE_CORNERS.topLeft;\n      } else if (Types.isRightRoundedCorner(elem)) {\n        this.outlinePath_ += this.constants_.OUTSIDE_CORNERS.topRight;\n      } else if (\n          Types.isPreviousConnection(elem) && elem instanceof Connection) {\n        this.outlinePath_ += elem.shape.pathLeft;\n      } else if (Types.isHat(elem)) {\n        this.outlinePath_ += this.constants_.START_HAT.path;\n      } else if (Types.isSpacer(elem)) {\n        this.outlinePath_ += svgPaths.lineOnAxis('h', elem.width);\n      }\n      // No branch for a square corner, because it's a no-op.\n    }\n    this.outlinePath_ += svgPaths.lineOnAxis('v', topRow.height);\n  }\n\n  /**\n   * Add steps for the jagged edge of a row on a collapsed block.\n   * @param {!Row} row The row to draw the side of.\n   * @protected\n   */\n  drawJaggedEdge_(row) {\n    const remainder = row.height - this.constants_.JAGGED_TEETH.height;\n    this.outlinePath_ +=\n        this.constants_.JAGGED_TEETH.path + svgPaths.lineOnAxis('v', remainder);\n  }\n\n  /**\n   * Add steps for an external value input, rendered as a notch in the side\n   * of the block.\n   * @param {!Row} row The row that this input belongs to.\n   * @protected\n   */\n  drawValueInput_(row) {\n    const input =\n        /** @type {ExternalValueInput|InlineInput} */ (row.getLastInput());\n    this.positionExternalValueConnection_(row);\n\n    const pathDown = (typeof input.shape.pathDown === 'function') ?\n        input.shape.pathDown(input.height) :\n        input.shape.pathDown;\n\n    this.outlinePath_ += svgPaths.lineOnAxis('H', input.xPos + input.width) +\n        pathDown +\n        svgPaths.lineOnAxis('v', row.height - input.connectionHeight);\n  }\n\n  /**\n   * Add steps for a statement input.\n   * @param {!Row} row The row that this input belongs to.\n   * @protected\n   */\n  drawStatementInput_(row) {\n    const input = row.getLastInput();\n    // Where to start drawing the notch, which is on the right side in LTR.\n    const x = input.xPos + input.notchOffset + input.shape.width;\n\n    const innerTopLeftCorner = input.shape.pathRight +\n        svgPaths.lineOnAxis(\n            'h', -(input.notchOffset - this.constants_.INSIDE_CORNERS.width)) +\n        this.constants_.INSIDE_CORNERS.pathTop;\n\n    const innerHeight =\n        row.height - (2 * this.constants_.INSIDE_CORNERS.height);\n\n    this.outlinePath_ += svgPaths.lineOnAxis('H', x) + innerTopLeftCorner +\n        svgPaths.lineOnAxis('v', innerHeight) +\n        this.constants_.INSIDE_CORNERS.pathBottom +\n        svgPaths.lineOnAxis('H', row.xPos + row.width);\n\n    this.positionStatementInputConnection_(row);\n  }\n\n  /**\n   * Add steps for the right side of a row that does not have value or\n   * statement input connections.\n   * @param {!Row} row The row to draw the side of.\n   * @protected\n   */\n  drawRightSideRow_(row) {\n    this.outlinePath_ += svgPaths.lineOnAxis('V', row.yPos + row.height);\n  }\n\n  /**\n   * Add steps for the bottom edge of a block, possibly including a notch\n   * for the next connection.\n   * @protected\n   */\n  drawBottom_() {\n    const bottomRow = this.info_.bottomRow;\n    const elems = bottomRow.elements;\n    this.positionNextConnection_();\n\n    let rightCornerYOffset = 0;\n    let outlinePath = '';\n    for (let i = elems.length - 1, elem; (elem = elems[i]); i--) {\n      if (Types.isNextConnection(elem) && elem instanceof Connection) {\n        outlinePath += elem.shape.pathRight;\n      } else if (Types.isLeftSquareCorner(elem)) {\n        outlinePath += svgPaths.lineOnAxis('H', bottomRow.xPos);\n      } else if (Types.isLeftRoundedCorner(elem)) {\n        outlinePath += this.constants_.OUTSIDE_CORNERS.bottomLeft;\n      } else if (Types.isRightRoundedCorner(elem)) {\n        outlinePath += this.constants_.OUTSIDE_CORNERS.bottomRight;\n        rightCornerYOffset = this.constants_.OUTSIDE_CORNERS.rightHeight;\n      } else if (Types.isSpacer(elem)) {\n        outlinePath += svgPaths.lineOnAxis('h', elem.width * -1);\n      }\n    }\n\n    this.outlinePath_ +=\n        svgPaths.lineOnAxis('V', bottomRow.baseline - rightCornerYOffset);\n    this.outlinePath_ += outlinePath;\n  }\n\n  /**\n   * Add steps for the left side of the block, which may include an output\n   * connection\n   * @protected\n   */\n  drawLeft_() {\n    const outputConnection = this.info_.outputConnection;\n    this.positionOutputConnection_();\n\n    if (outputConnection) {\n      const tabBottom =\n          outputConnection.connectionOffsetY + outputConnection.height;\n      const pathUp = (typeof outputConnection.shape.pathUp === 'function') ?\n          outputConnection.shape.pathUp(outputConnection.height) :\n          outputConnection.shape.pathUp;\n\n      // Draw a line up to the bottom of the tab.\n      this.outlinePath_ += svgPaths.lineOnAxis('V', tabBottom) + pathUp;\n    }\n    // Close off the path.  This draws a vertical line up to the start of the\n    // block's path, which may be either a rounded or a sharp corner.\n    this.outlinePath_ += 'z';\n  }\n\n  /**\n   * Draw the internals of the block: inline inputs, fields, and icons.  These\n   * do not depend on the outer path for placement.\n   * @protected\n   */\n  drawInternals_() {\n    for (let i = 0, row; (row = this.info_.rows[i]); i++) {\n      for (let j = 0, elem; (elem = row.elements[j]); j++) {\n        if (Types.isInlineInput(elem)) {\n          this.drawInlineInput_(\n              /** @type {!InlineInput} */ (elem));\n        } else if (Types.isIcon(elem) || Types.isField(elem)) {\n          this.layoutField_(\n              /** @type {!Field|!Icon} */\n              (elem));\n        }\n      }\n    }\n  }\n\n  /**\n   * Push a field or icon's new position to its SVG root.\n   * @param {!Icon|!Field} fieldInfo\n   *     The rendering information for the field or icon.\n   * @protected\n   */\n  layoutField_(fieldInfo) {\n    let svgGroup;\n    if (Types.isField(fieldInfo)) {\n      svgGroup = fieldInfo.field.getSvgRoot();\n    } else if (Types.isIcon(fieldInfo)) {\n      svgGroup = fieldInfo.icon.iconGroup_;\n    }\n\n    const yPos = fieldInfo.centerline - fieldInfo.height / 2;\n    let xPos = fieldInfo.xPos;\n    let scale = '';\n    if (this.info_.RTL) {\n      xPos = -(xPos + fieldInfo.width);\n      if (fieldInfo.flipRtl) {\n        xPos += fieldInfo.width;\n        scale = 'scale(-1 1)';\n      }\n    }\n    if (Types.isIcon(fieldInfo)) {\n      svgGroup.setAttribute('display', 'block');\n      svgGroup.setAttribute(\n          'transform', 'translate(' + xPos + ',' + yPos + ')');\n      fieldInfo.icon.computeIconLocation();\n    } else {\n      svgGroup.setAttribute(\n          'transform', 'translate(' + xPos + ',' + yPos + ')' + scale);\n    }\n\n    if (this.info_.isInsertionMarker) {\n      // Fields and icons are invisible on insertion marker.  They still have to\n      // be rendered so that the block can be sized correctly.\n      svgGroup.setAttribute('display', 'none');\n    }\n  }\n\n  /**\n   * Add steps for an inline input.\n   * @param {!InlineInput} input The information about the\n   * input to render.\n   * @protected\n   */\n  drawInlineInput_(input) {\n    const width = input.width;\n    const height = input.height;\n    const yPos = input.centerline - height / 2;\n\n    const connectionTop = input.connectionOffsetY;\n    const connectionBottom = input.connectionHeight + connectionTop;\n    const connectionRight = input.xPos + input.connectionWidth;\n\n    this.inlinePath_ += svgPaths.moveTo(connectionRight, yPos) +\n        svgPaths.lineOnAxis('v', connectionTop) + input.shape.pathDown +\n        svgPaths.lineOnAxis('v', height - connectionBottom) +\n        svgPaths.lineOnAxis('h', width - input.connectionWidth) +\n        svgPaths.lineOnAxis('v', -height) + 'z';\n\n    this.positionInlineInputConnection_(input);\n  }\n\n  /**\n   * Position the connection on an inline value input, taking into account\n   * RTL and the small gap between the parent block and child block which lets\n   * the parent block's dark path show through.\n   * @param {InlineInput} input The information about\n   * the input that the connection is on.\n   * @protected\n   */\n  positionInlineInputConnection_(input) {\n    const yPos = input.centerline - input.height / 2;\n    // Move the connection.\n    if (input.connectionModel) {\n      // xPos already contains info about startX\n      let connX = input.xPos + input.connectionWidth + input.connectionOffsetX;\n      if (this.info_.RTL) {\n        connX *= -1;\n      }\n      input.connectionModel.setOffsetInBlock(\n          connX, yPos + input.connectionOffsetY);\n    }\n  }\n\n  /**\n   * Position the connection on a statement input, taking into account\n   * RTL and the small gap between the parent block and child block which lets\n   * the parent block's dark path show through.\n   * @param {!Row} row The row that the connection is on.\n   * @protected\n   */\n  positionStatementInputConnection_(row) {\n    const input = row.getLastInput();\n    if (input.connectionModel) {\n      let connX = row.xPos + row.statementEdge + input.notchOffset;\n      if (this.info_.RTL) {\n        connX *= -1;\n      }\n      input.connectionModel.setOffsetInBlock(connX, row.yPos);\n    }\n  }\n\n  /**\n   * Position the connection on an external value input, taking into account\n   * RTL and the small gap between the parent block and child block which lets\n   * the parent block's dark path show through.\n   * @param {!Row} row The row that the connection is on.\n   * @protected\n   */\n  positionExternalValueConnection_(row) {\n    const input = row.getLastInput();\n    if (input.connectionModel) {\n      let connX = row.xPos + row.width;\n      if (this.info_.RTL) {\n        connX *= -1;\n      }\n      input.connectionModel.setOffsetInBlock(connX, row.yPos);\n    }\n  }\n\n  /**\n   * Position the previous connection on a block.\n   * @protected\n   */\n  positionPreviousConnection_() {\n    const topRow = this.info_.topRow;\n    if (topRow.connection) {\n      const x = topRow.xPos + topRow.notchOffset;\n      const connX = (this.info_.RTL ? -x : x);\n      topRow.connection.connectionModel.setOffsetInBlock(connX, 0);\n    }\n  }\n\n  /**\n   * Position the next connection on a block.\n   * @protected\n   */\n  positionNextConnection_() {\n    const bottomRow = this.info_.bottomRow;\n\n    if (bottomRow.connection) {\n      const connInfo = bottomRow.connection;\n      const x = connInfo.xPos;  // Already contains info about startX.\n      const connX = (this.info_.RTL ? -x : x);\n      connInfo.connectionModel.setOffsetInBlock(connX, bottomRow.baseline);\n    }\n  }\n\n  /**\n   * Position the output connection on a block.\n   * @protected\n   */\n  positionOutputConnection_() {\n    if (this.info_.outputConnection) {\n      const x =\n          this.info_.startX + this.info_.outputConnection.connectionOffsetX;\n      const connX = this.info_.RTL ? -x : x;\n      this.block_.outputConnection.setOffsetInBlock(\n          connX, this.info_.outputConnection.connectionOffsetY);\n    }\n  }\n}\n\nexports.Drawer = Drawer;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/common/drawer.js?")},
"./core/renderers/common/i_path_object.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for an object that owns a block's rendering SVG\n * elements.\n */\n\n\n\n/**\n * The interface for an object that owns a block's rendering SVG\n * elements.\n * @namespace Blockly.blockRendering.IPathObject\n */\ngoog.module('Blockly.blockRendering.IPathObject');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {Theme} = goog.requireType('Blockly.Theme');\n\n\n/**\n * An interface for a block's path object.\n * @param {!SVGElement} _root The root SVG element.\n * @param {!ConstantProvider} _constants The renderer's\n *     constants.\n * @interface\n * @alias Blockly.blockRendering.IPathObject\n */\nconst IPathObject = function(_root, _constants) {};\n\n/**\n * The primary path of the block.\n * @type {!SVGElement}\n */\nIPathObject.prototype.svgPath;\n\n/**\n * The renderer's constant provider.\n * @type {!ConstantProvider}\n */\nIPathObject.prototype.constants;\n\n/**\n * The primary path of the block.\n * @type {!Theme.BlockStyle}\n */\nIPathObject.prototype.style;\n\n/**\n * Holds the cursors SVG element when the cursor is attached to the block.\n * This is null if there is no cursor on the block.\n * @type {SVGElement}\n */\nIPathObject.prototype.cursorSvg;\n\n/**\n * Holds the markers SVG element when the marker is attached to the block.\n * This is null if there is no marker on the block.\n * @type {SVGElement}\n */\nIPathObject.prototype.markerSvg;\n\n/**\n * Set the path generated by the renderer onto the respective SVG element.\n * @param {string} pathString The path.\n * @package\n */\nIPathObject.prototype.setPath;\n\n/**\n * Apply the stored colours to the block's path, taking into account whether\n * the paths belong to a shadow block.\n * @param {!BlockSvg} block The source block.\n * @package\n */\nIPathObject.prototype.applyColour;\n\n/**\n * Update the style.\n * @param {!Theme.BlockStyle} blockStyle The block style to use.\n * @package\n */\nIPathObject.prototype.setStyle;\n\n/**\n * Flip the SVG paths in RTL.\n * @package\n */\nIPathObject.prototype.flipRTL;\n\n/**\n * Add the cursor SVG to this block's SVG group.\n * @param {SVGElement} cursorSvg The SVG root of the cursor to be added to the\n *     block SVG group.\n * @package\n */\nIPathObject.prototype.setCursorSvg;\n\n/**\n * Add the marker SVG to this block's SVG group.\n * @param {SVGElement} markerSvg The SVG root of the marker to be added to the\n *     block SVG group.\n * @package\n */\nIPathObject.prototype.setMarkerSvg;\n\n/**\n * Set whether the block shows a highlight or not.  Block highlighting is\n * often used to visually mark blocks currently being executed.\n * @param {boolean} highlighted True if highlighted.\n * @package\n */\nIPathObject.prototype.updateHighlighted;\n\n/**\n * Add or remove styling showing that a block is selected.\n * @param {boolean} enable True if selection is enabled, false otherwise.\n * @package\n */\nIPathObject.prototype.updateSelected;\n\n/**\n * Add or remove styling showing that a block is dragged over a delete area.\n * @param {boolean} enable True if the block is being dragged over a delete\n *     area, false otherwise.\n * @package\n */\nIPathObject.prototype.updateDraggingDelete;\n\n/**\n * Add or remove styling showing that a block is an insertion marker.\n * @param {boolean} enable True if the block is an insertion marker, false\n *     otherwise.\n * @package\n */\nIPathObject.prototype.updateInsertionMarker;\n\n/**\n * Add or remove styling showing that a block is movable.\n * @param {boolean} enable True if the block is movable, false otherwise.\n * @package\n */\nIPathObject.prototype.updateMovable;\n\n/**\n * Add or remove styling that shows that if the dragging block is dropped, this\n * block will be replaced.  If a shadow block, it will disappear.  Otherwise it\n * will bump.\n * @param {boolean} enable True if styling should be added.\n * @package\n */\nIPathObject.prototype.updateReplacementFade;\n\nexports.IPathObject = IPathObject;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/common/i_path_object.js?")},
"./core/renderers/common/info.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/input.js\");\n__webpack_require__(\"./core/renderers/measurables/bottom_row.js\");\n__webpack_require__(\"./core/renderers/measurables/external_value_input.js\");\n__webpack_require__(\"./core/renderers/measurables/field.js\");\n__webpack_require__(\"./core/renderers/measurables/hat.js\");\n__webpack_require__(\"./core/renderers/measurables/icon.js\");\n__webpack_require__(\"./core/renderers/measurables/in_row_spacer.js\");\n__webpack_require__(\"./core/renderers/measurables/inline_input.js\");\n__webpack_require__(\"./core/renderers/measurables/input_row.js\");\n__webpack_require__(\"./core/renderers/measurables/jagged_edge.js\");\n__webpack_require__(\"./core/renderers/measurables/next_connection.js\");\n__webpack_require__(\"./core/renderers/measurables/output_connection.js\");\n__webpack_require__(\"./core/renderers/measurables/previous_connection.js\");\n__webpack_require__(\"./core/renderers/measurables/round_corner.js\");\n__webpack_require__(\"./core/renderers/measurables/spacer_row.js\");\n__webpack_require__(\"./core/renderers/measurables/square_corner.js\");\n__webpack_require__(\"./core/renderers/measurables/statement_input.js\");\n__webpack_require__(\"./core/renderers/measurables/top_row.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\n__webpack_require__(\"./core/input_types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Methods for graphically rendering a block as SVG.\n */\n\n\n/**\n * Methods for graphically rendering a block as SVG.\n * @class\n */\ngoog.module('Blockly.blockRendering.RenderInfo');\n\nconst {Align} = goog.require('Blockly.Input');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {BottomRow} = goog.require('Blockly.blockRendering.BottomRow');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {ExternalValueInput} = goog.require('Blockly.blockRendering.ExternalValueInput');\nconst {Field} = goog.require('Blockly.blockRendering.Field');\nconst {Hat} = goog.require('Blockly.blockRendering.Hat');\nconst {Icon} = goog.require('Blockly.blockRendering.Icon');\nconst {InRowSpacer} = goog.require('Blockly.blockRendering.InRowSpacer');\nconst {InlineInput} = goog.require('Blockly.blockRendering.InlineInput');\nconst {InputRow} = goog.require('Blockly.blockRendering.InputRow');\n/* eslint-disable-next-line no-unused-vars */\nconst {Input} = goog.requireType('Blockly.Input');\nconst {JaggedEdge} = goog.require('Blockly.blockRendering.JaggedEdge');\n/* eslint-disable-next-line no-unused-vars */\nconst {Measurable} = goog.requireType('Blockly.blockRendering.Measurable');\nconst {NextConnection} = goog.require('Blockly.blockRendering.NextConnection');\nconst {OutputConnection} = goog.require('Blockly.blockRendering.OutputConnection');\nconst {PreviousConnection} = goog.require('Blockly.blockRendering.PreviousConnection');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderedConnection} = goog.requireType('Blockly.RenderedConnection');\n/* eslint-disable-next-line no-unused-vars */\nconst {Renderer} = goog.requireType('Blockly.blockRendering.Renderer');\nconst {RoundCorner} = goog.require('Blockly.blockRendering.RoundCorner');\n/* eslint-disable-next-line no-unused-vars */\nconst {Row} = goog.requireType('Blockly.blockRendering.Row');\nconst {SpacerRow} = goog.require('Blockly.blockRendering.SpacerRow');\nconst {SquareCorner} = goog.require('Blockly.blockRendering.SquareCorner');\nconst {StatementInput} = goog.require('Blockly.blockRendering.StatementInput');\nconst {TopRow} = goog.require('Blockly.blockRendering.TopRow');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\nconst {inputTypes} = goog.require('Blockly.inputTypes');\n\n\n/**\n * An object containing all sizing information needed to draw this block.\n *\n * This measure pass does not propagate changes to the block (although fields\n * may choose to rerender when getSize() is called).  However, calling it\n * repeatedly may be expensive.\n * @alias Blockly.blockRendering.RenderInfo\n */\nclass RenderInfo {\n  /**\n   * @param {!Renderer} renderer The renderer in use.\n   * @param {!BlockSvg} block The block to measure.\n   * @package\n   */\n  constructor(renderer, block) {\n    this.block_ = block;\n\n    /**\n     * The block renderer in use.\n     * @type {!Renderer}\n     * @protected\n     */\n    this.renderer_ = renderer;\n\n    /**\n     * The renderer's constant provider.\n     * @type {!ConstantProvider}\n     * @protected\n     */\n    this.constants_ = this.renderer_.getConstants();\n\n    /**\n     * A measurable representing the output connection if the block has one.\n     * Otherwise null.\n     * @type {OutputConnection}\n     */\n    this.outputConnection = !block.outputConnection ?\n        null :\n        new OutputConnection(\n            this.constants_,\n            /** @type {!RenderedConnection} */ (block.outputConnection));\n\n    /**\n     * Whether the block should be rendered as a single line, either because\n     * it's inline or because it has been collapsed.\n     * @type {boolean}\n     */\n    this.isInline = block.getInputsInline() && !block.isCollapsed();\n\n    /**\n     * Whether the block is collapsed.\n     * @type {boolean}\n     */\n    this.isCollapsed = block.isCollapsed();\n\n    /**\n     * Whether the block is an insertion marker.  Insertion markers are the same\n     * shape as normal blocks, but don't show fields.\n     * @type {boolean}\n     */\n    this.isInsertionMarker = block.isInsertionMarker();\n\n    /**\n     * True if the block should be rendered right-to-left.\n     * @type {boolean}\n     */\n    this.RTL = block.RTL;\n\n    /**\n     * The height of the rendered block, including child blocks.\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * The width of the rendered block, including child blocks.\n     * @type {number}\n     */\n    this.widthWithChildren = 0;\n\n    /**\n     * The width of the rendered block, excluding child blocks.  This is the\n     * right edge of the block when rendered LTR.\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     *\n     * @type {number}\n     */\n    this.statementEdge = 0;\n\n    /**\n     * An array of Row objects containing sizing information.\n     * @type {!Array<!Row>}\n     */\n    this.rows = [];\n\n    /**\n     * An array of input rows on the block.\n     * @type {!Array<!InputRow>}\n     */\n    this.inputRows = [];\n\n    /**\n     * An array of measurable objects containing hidden icons.\n     * @type {!Array<!Icon>}\n     */\n    this.hiddenIcons = [];\n\n    /**\n     * An object with rendering information about the top row of the block.\n     * @type {!TopRow}\n     */\n    this.topRow = new TopRow(this.constants_);\n\n    /**\n     * An object with rendering information about the bottom row of the block.\n     * @type {!BottomRow}\n     */\n    this.bottomRow = new BottomRow(this.constants_);\n\n    // The position of the start point for drawing, relative to the block's\n    // location.\n    this.startX = 0;\n    this.startY = 0;\n  }\n\n  /**\n   * Get the block renderer in use.\n   * @return {!Renderer} The block renderer in use.\n   * @package\n   */\n  getRenderer() {\n    return this.renderer_;\n  }\n\n  /**\n   * Populate and return an object containing all sizing information needed to\n   * draw this block.\n   *\n   * This measure pass does not propagate changes to the block (although fields\n   * may choose to rerender when getSize() is called).  However, calling it\n   * repeatedly may be expensive.\n   *\n   * @package\n   */\n  measure() {\n    this.createRows_();\n    this.addElemSpacing_();\n    this.addRowSpacing_();\n    this.computeBounds_();\n    this.alignRowElements_();\n    this.finalize_();\n  }\n\n  /**\n   * Create rows of Measurable objects representing all renderable parts of the\n   * block.\n   * @protected\n   */\n  createRows_() {\n    this.populateTopRow_();\n    this.rows.push(this.topRow);\n    let activeRow = new InputRow(this.constants_);\n    this.inputRows.push(activeRow);\n\n    // Icons always go on the first row, before anything else.\n    const icons = this.block_.getIcons();\n    for (let i = 0, icon; (icon = icons[i]); i++) {\n      const iconInfo = new Icon(this.constants_, icon);\n      if (this.isCollapsed && icon.collapseHidden) {\n        this.hiddenIcons.push(iconInfo);\n      } else {\n        activeRow.elements.push(iconInfo);\n      }\n    }\n\n    let lastInput = null;\n    // Loop across all of the inputs on the block, creating objects for anything\n    // that needs to be rendered and breaking the block up into visual rows.\n    for (let i = 0, input; (input = this.block_.inputList[i]); i++) {\n      if (!input.isVisible()) {\n        continue;\n      }\n      if (this.shouldStartNewRow_(input, lastInput)) {\n        // Finish this row and create a new one.\n        this.rows.push(activeRow);\n        activeRow = new InputRow(this.constants_);\n        this.inputRows.push(activeRow);\n      }\n\n      // All of the fields in an input go on the same row.\n      for (let j = 0, field; (field = input.fieldRow[j]); j++) {\n        activeRow.elements.push(new Field(this.constants_, field, input));\n      }\n      this.addInput_(input, activeRow);\n      lastInput = input;\n    }\n\n    if (this.isCollapsed) {\n      activeRow.hasJaggedEdge = true;\n      activeRow.elements.push(new JaggedEdge(this.constants_));\n    }\n\n    if (activeRow.elements.length || activeRow.hasDummyInput) {\n      this.rows.push(activeRow);\n    }\n    this.populateBottomRow_();\n    this.rows.push(this.bottomRow);\n  }\n\n  /**\n   * Create all non-spacer elements that belong on the top row.\n   * @package\n   */\n  populateTopRow_() {\n    const hasPrevious = !!this.block_.previousConnection;\n    const hasHat = (this.block_.hat ? this.block_.hat === 'cap' :\n                                      this.constants_.ADD_START_HATS) &&\n        !this.outputConnection && !hasPrevious;\n\n    let cornerClass = this.topRow.hasLeftSquareCorner(this.block_) ?\n        SquareCorner :\n        RoundCorner;\n    this.topRow.elements.push(new cornerClass(this.constants_));\n\n    if (hasHat) {\n      const hat = new Hat(this.constants_);\n      this.topRow.elements.push(hat);\n      this.topRow.capline = hat.ascenderHeight;\n    } else if (hasPrevious) {\n      this.topRow.hasPreviousConnection = true;\n      this.topRow.connection = new PreviousConnection(\n          this.constants_,\n          /** @type {!RenderedConnection} */\n          (this.block_.previousConnection));\n      this.topRow.elements.push(this.topRow.connection);\n    }\n\n    const precedesStatement = this.block_.inputList.length &&\n        this.block_.inputList[0].type === inputTypes.STATEMENT;\n\n    // This is the minimum height for the row. If one of its elements has a\n    // greater height it will be overwritten in the compute pass.\n    if (precedesStatement && !this.block_.isCollapsed()) {\n      this.topRow.minHeight =\n          this.constants_.TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT;\n    } else {\n      this.topRow.minHeight = this.constants_.TOP_ROW_MIN_HEIGHT;\n    }\n\n    cornerClass = this.topRow.hasRightSquareCorner(this.block_) ? SquareCorner :\n                                                                  RoundCorner;\n    this.topRow.elements.push(new cornerClass(this.constants_, 'right'));\n  }\n\n  /**\n   * Create all non-spacer elements that belong on the bottom row.\n   * @package\n   */\n  populateBottomRow_() {\n    this.bottomRow.hasNextConnection = !!this.block_.nextConnection;\n\n    const followsStatement = this.block_.inputList.length &&\n        this.block_.inputList[this.block_.inputList.length - 1].type ===\n            inputTypes.STATEMENT;\n\n    // This is the minimum height for the row. If one of its elements has a\n    // greater height it will be overwritten in the compute pass.\n    if (followsStatement) {\n      this.bottomRow.minHeight =\n          this.constants_.BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT;\n    } else {\n      this.bottomRow.minHeight = this.constants_.BOTTOM_ROW_MIN_HEIGHT;\n    }\n\n    const leftSquareCorner = this.bottomRow.hasLeftSquareCorner(this.block_);\n\n    if (leftSquareCorner) {\n      this.bottomRow.elements.push(new SquareCorner(this.constants_));\n    } else {\n      this.bottomRow.elements.push(new RoundCorner(this.constants_));\n    }\n\n    if (this.bottomRow.hasNextConnection) {\n      this.bottomRow.connection = new NextConnection(\n          this.constants_,\n          /** @type {!RenderedConnection} */ (this.block_.nextConnection));\n      this.bottomRow.elements.push(this.bottomRow.connection);\n    }\n\n    const rightSquareCorner = this.bottomRow.hasRightSquareCorner(this.block_);\n\n    if (rightSquareCorner) {\n      this.bottomRow.elements.push(new SquareCorner(this.constants_, 'right'));\n    } else {\n      this.bottomRow.elements.push(new RoundCorner(this.constants_, 'right'));\n    }\n  }\n\n  /**\n   * Add an input element to the active row, if needed, and record the type of\n   * the input on the row.\n   * @param {!Input} input The input to record information about.\n   * @param {!Row} activeRow The row that is currently being\n   *     populated.\n   * @protected\n   */\n  addInput_(input, activeRow) {\n    // Non-dummy inputs have visual representations onscreen.\n    if (this.isInline && input.type === inputTypes.VALUE) {\n      activeRow.elements.push(new InlineInput(this.constants_, input));\n      activeRow.hasInlineInput = true;\n    } else if (input.type === inputTypes.STATEMENT) {\n      activeRow.elements.push(new StatementInput(this.constants_, input));\n      activeRow.hasStatement = true;\n    } else if (input.type === inputTypes.VALUE) {\n      activeRow.elements.push(new ExternalValueInput(this.constants_, input));\n      activeRow.hasExternalInput = true;\n    } else if (input.type === inputTypes.DUMMY) {\n      // Dummy inputs have no visual representation, but the information is\n      // still important.\n      activeRow.minHeight = Math.max(\n          activeRow.minHeight,\n          input.getSourceBlock() && input.getSourceBlock().isShadow() ?\n              this.constants_.DUMMY_INPUT_SHADOW_MIN_HEIGHT :\n              this.constants_.DUMMY_INPUT_MIN_HEIGHT);\n      activeRow.hasDummyInput = true;\n    }\n    if (activeRow.align === null) {\n      activeRow.align = input.align;\n    }\n  }\n\n  /**\n   * Decide whether to start a new row between the two Blockly.Inputs.\n   * @param {!Input} input The first input to consider\n   * @param {Input} lastInput The input that follows.\n   * @return {boolean} True if the next input should be rendered on a new row.\n   * @protected\n   */\n  shouldStartNewRow_(input, lastInput) {\n    // If this is the first input, just add to the existing row.\n    // That row is either empty or has some icons in it.\n    if (!lastInput) {\n      return false;\n    }\n    // A statement input or an input following one always gets a new row.\n    if (input.type === inputTypes.STATEMENT ||\n        lastInput.type === inputTypes.STATEMENT) {\n      return true;\n    }\n    // Value and dummy inputs get new row if inputs are not inlined.\n    if (input.type === inputTypes.VALUE || input.type === inputTypes.DUMMY) {\n      return !this.isInline;\n    }\n    return false;\n  }\n\n  /**\n   * Add horizontal spacing between and around elements within each row.\n   * @protected\n   */\n  addElemSpacing_() {\n    for (let i = 0, row; (row = this.rows[i]); i++) {\n      const oldElems = row.elements;\n      row.elements = [];\n      // No spacing needed before the corner on the top row or the bottom row.\n      if (row.startsWithElemSpacer()) {\n        // There's a spacer before the first element in the row.\n        row.elements.push(new InRowSpacer(\n            this.constants_, this.getInRowSpacing_(null, oldElems[0])));\n      }\n      if (!oldElems.length) {\n        continue;\n      }\n      for (let e = 0; e < oldElems.length - 1; e++) {\n        row.elements.push(oldElems[e]);\n        const spacing = this.getInRowSpacing_(oldElems[e], oldElems[e + 1]);\n        row.elements.push(new InRowSpacer(this.constants_, spacing));\n      }\n      row.elements.push(oldElems[oldElems.length - 1]);\n      if (row.endsWithElemSpacer()) {\n        // There's a spacer after the last element in the row.\n        row.elements.push(new InRowSpacer(\n            this.constants_,\n            this.getInRowSpacing_(oldElems[oldElems.length - 1], null)));\n      }\n    }\n  }\n\n  /**\n   * Calculate the width of a spacer element in a row based on the previous and\n   * next elements in that row.  For instance, extra padding is added between\n   * two editable fields.\n   * @param {Measurable} prev The element before the\n   *     spacer.\n   * @param {Measurable} next The element after the spacer.\n   * @return {number} The size of the spacing between the two elements.\n   * @protected\n   */\n  getInRowSpacing_(prev, next) {\n    if (!prev) {\n      // Statement input padding.\n      if (next && Types.isStatementInput(next)) {\n        return this.constants_.STATEMENT_INPUT_PADDING_LEFT;\n      }\n    }\n    // Between inputs and the end of the row.\n    if (prev && Types.isInput(prev) && !next) {\n      if (Types.isExternalInput(prev)) {\n        return this.constants_.NO_PADDING;\n      } else if (Types.isInlineInput(prev)) {\n        return this.constants_.LARGE_PADDING;\n      } else if (Types.isStatementInput(prev)) {\n        return this.constants_.NO_PADDING;\n      }\n    }\n\n    // Spacing between a square corner and a previous or next connection\n    if (prev && Types.isLeftSquareCorner(prev) && next) {\n      if (Types.isPreviousConnection(next) || Types.isNextConnection(next)) {\n        return next.notchOffset;\n      }\n    }\n\n    // Spacing between a rounded corner and a previous or next connection.\n    if (prev && Types.isLeftRoundedCorner(prev) && next) {\n      if (Types.isPreviousConnection(next) || Types.isNextConnection(next)) {\n        return next.notchOffset - this.constants_.CORNER_RADIUS;\n      }\n    }\n\n    return this.constants_.MEDIUM_PADDING;\n  }\n\n  /**\n   * Figure out where the right edge of the block and right edge of statement\n   * inputs should be placed.\n   * @protected\n   */\n  computeBounds_() {\n    let widestStatementRowFields = 0;\n    let blockWidth = 0;\n    let widestRowWithConnectedBlocks = 0;\n    for (let i = 0, row; (row = this.rows[i]); i++) {\n      row.measure();\n      blockWidth = Math.max(blockWidth, row.width);\n      if (row.hasStatement) {\n        const statementInput = row.getLastInput();\n        const innerWidth = row.width - statementInput.width;\n        widestStatementRowFields =\n            Math.max(widestStatementRowFields, innerWidth);\n      }\n      widestRowWithConnectedBlocks =\n          Math.max(widestRowWithConnectedBlocks, row.widthWithConnectedBlocks);\n    }\n\n    this.statementEdge = widestStatementRowFields;\n    this.width = blockWidth;\n\n    for (let i = 0, row; (row = this.rows[i]); i++) {\n      if (row.hasStatement) {\n        row.statementEdge = this.statementEdge;\n      }\n    }\n\n    this.widthWithChildren = Math.max(blockWidth, widestRowWithConnectedBlocks);\n\n    if (this.outputConnection) {\n      this.startX = this.outputConnection.width;\n      this.width += this.outputConnection.width;\n      this.widthWithChildren += this.outputConnection.width;\n    }\n  }\n\n  /**\n   * Extra spacing may be necessary to make sure that the right sides of all\n   * rows line up.  This can only be calculated after a first pass to calculate\n   * the sizes of all rows.\n   * @protected\n   */\n  alignRowElements_() {\n    for (let i = 0, row; (row = this.rows[i]); i++) {\n      if (row.hasStatement) {\n        this.alignStatementRow_(\n            /** @type {!InputRow} */ (row));\n      } else {\n        const currentWidth = row.width;\n        const desiredWidth = this.getDesiredRowWidth_(row);\n        const missingSpace = desiredWidth - currentWidth;\n        if (missingSpace > 0) {\n          this.addAlignmentPadding_(row, missingSpace);\n        }\n        if (Types.isTopOrBottomRow(row)) {\n          row.widthWithConnectedBlocks = row.width;\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate the desired width of an input row.\n   * @param {!Row} _row The input row.\n   * @return {number} The desired width of the input row.\n   * @protected\n   */\n  getDesiredRowWidth_(_row) {\n    return this.width - this.startX;\n  }\n\n  /**\n   * Modify the given row to add the given amount of padding around its fields.\n   * The exact location of the padding is based on the alignment property of the\n   * last input in the field.\n   * @param {!Row} row The row to add padding to.\n   * @param {number} missingSpace How much padding to add.\n   * @protected\n   */\n  addAlignmentPadding_(row, missingSpace) {\n    const firstSpacer = row.getFirstSpacer();\n    const lastSpacer = row.getLastSpacer();\n    if (row.hasExternalInput || row.hasStatement) {\n      row.widthWithConnectedBlocks += missingSpace;\n    }\n\n    // Decide where the extra padding goes.\n    if (row.align === Align.LEFT) {\n      // Add padding to the end of the row.\n      lastSpacer.width += missingSpace;\n    } else if (row.align === Align.CENTRE) {\n      // Split the padding between the beginning and end of the row.\n      firstSpacer.width += missingSpace / 2;\n      lastSpacer.width += missingSpace / 2;\n    } else if (row.align === Align.RIGHT) {\n      // Add padding at the beginning of the row.\n      firstSpacer.width += missingSpace;\n    } else {\n      // Default to left-aligning.\n      lastSpacer.width += missingSpace;\n    }\n    row.width += missingSpace;\n  }\n\n  /**\n   * Align the elements of a statement row based on computed bounds.\n   * Unlike other types of rows, statement rows add space in multiple places.\n   * @param {!InputRow} row The statement row to resize.\n   * @protected\n   */\n  alignStatementRow_(row) {\n    const statementInput = row.getLastInput();\n    let currentWidth = row.width - statementInput.width;\n    let desiredWidth = this.statementEdge;\n    // Add padding before the statement input.\n    const missingSpace = desiredWidth - currentWidth;\n    if (missingSpace > 0) {\n      this.addAlignmentPadding_(row, missingSpace);\n    }\n    // Also widen the statement input to reach to the right side of the\n    // block. Note that this does not add padding.\n    currentWidth = row.width;\n    desiredWidth = this.getDesiredRowWidth_(row);\n    statementInput.width += (desiredWidth - currentWidth);\n    statementInput.height = Math.max(statementInput.height, row.height);\n    row.width += (desiredWidth - currentWidth);\n    row.widthWithConnectedBlocks =\n        Math.max(row.width, this.statementEdge + row.connectedBlockWidths);\n  }\n\n  /**\n   * Add spacers between rows and set their sizes.\n   * @protected\n   */\n  addRowSpacing_() {\n    const oldRows = this.rows;\n    this.rows = [];\n\n    for (let r = 0; r < oldRows.length; r++) {\n      this.rows.push(oldRows[r]);\n      if (r !== oldRows.length - 1) {\n        this.rows.push(this.makeSpacerRow_(oldRows[r], oldRows[r + 1]));\n      }\n    }\n  }\n\n  /**\n   * Create a spacer row to go between prev and next, and set its size.\n   * @param {!Row} prev The previous row.\n   * @param {!Row} next The next row.\n   * @return {!SpacerRow} The newly created spacer row.\n   * @protected\n   */\n  makeSpacerRow_(prev, next) {\n    const height = this.getSpacerRowHeight_(prev, next);\n    const width = this.getSpacerRowWidth_(prev, next);\n    const spacer = new SpacerRow(this.constants_, height, width);\n    if (prev.hasStatement) {\n      spacer.followsStatement = true;\n    }\n    if (next.hasStatement) {\n      spacer.precedesStatement = true;\n    }\n    return spacer;\n  }\n\n  /**\n   * Calculate the width of a spacer row.\n   * @param {!Row} _prev The row before the spacer.\n   * @param {!Row} _next The row after the spacer.\n   * @return {number} The desired width of the spacer row between these two\n   *     rows.\n   * @protected\n   */\n  getSpacerRowWidth_(_prev, _next) {\n    return this.width - this.startX;\n  }\n\n  /**\n   * Calculate the height of a spacer row.\n   * @param {!Row} _prev The row before the spacer.\n   * @param {!Row} _next The row after the spacer.\n   * @return {number} The desired height of the spacer row between these two\n   *     rows.\n   * @protected\n   */\n  getSpacerRowHeight_(_prev, _next) {\n    return this.constants_.MEDIUM_PADDING;\n  }\n\n  /**\n   * Calculate the centerline of an element in a rendered row.\n   * This base implementation puts the centerline at the middle of the row\n   * vertically, with no special cases.  You will likely need extra logic to\n   * handle (at minimum) top and bottom rows.\n   * @param {!Row} row The row containing the element.\n   * @param {!Measurable} elem The element to place.\n   * @return {number} The desired centerline of the given element, as an offset\n   *     from the top left of the block.\n   * @protected\n   */\n  getElemCenterline_(row, elem) {\n    if (Types.isSpacer(elem)) {\n      return row.yPos + elem.height / 2;\n    }\n    if (Types.isBottomRow(row)) {\n      const bottomRow = /** @type {!BottomRow} */ (row);\n      const baseline =\n          bottomRow.yPos + bottomRow.height - bottomRow.descenderHeight;\n      if (Types.isNextConnection(elem)) {\n        return baseline + elem.height / 2;\n      }\n      return baseline - elem.height / 2;\n    }\n    if (Types.isTopRow(row)) {\n      const topRow = /** @type {!TopRow} */ (row);\n      if (Types.isHat(elem)) {\n        return topRow.capline - elem.height / 2;\n      }\n      return topRow.capline + elem.height / 2;\n    }\n    return row.yPos + row.height / 2;\n  }\n\n  /**\n   * Record final position information on elements on the given row, for use in\n   * drawing.  At minimum this records xPos and centerline on each element.\n   * @param {!Row} row The row containing the elements.\n   * @protected\n   */\n  recordElemPositions_(row) {\n    let xCursor = row.xPos;\n    for (let j = 0, elem; (elem = row.elements[j]); j++) {\n      // Now that row heights are finalized, make spacers use the row height.\n      if (Types.isSpacer(elem)) {\n        elem.height = row.height;\n      }\n      elem.xPos = xCursor;\n      elem.centerline = this.getElemCenterline_(row, elem);\n      xCursor += elem.width;\n    }\n  }\n\n  /**\n   * Make any final changes to the rendering information object.  In particular,\n   * store the y position of each row, and record the height of the full block.\n   * @protected\n   */\n  finalize_() {\n    // Performance note: this could be combined with the draw pass, if the time\n    // that this takes is excessive.  But it shouldn't be, because it only\n    // accesses and sets properties that already exist on the objects.\n    let widestRowWithConnectedBlocks = 0;\n    let yCursor = 0;\n    for (let i = 0, row; (row = this.rows[i]); i++) {\n      row.yPos = yCursor;\n      row.xPos = this.startX;\n      yCursor += row.height;\n\n      widestRowWithConnectedBlocks =\n          Math.max(widestRowWithConnectedBlocks, row.widthWithConnectedBlocks);\n      this.recordElemPositions_(row);\n    }\n    if (this.outputConnection && this.block_.nextConnection &&\n        this.block_.nextConnection.isConnected()) {\n      // Include width of connected block in value to stack width measurement.\n      widestRowWithConnectedBlocks = Math.max(\n          widestRowWithConnectedBlocks,\n          this.block_.nextConnection.targetBlock().getHeightWidth().width);\n    }\n\n    this.widthWithChildren = widestRowWithConnectedBlocks + this.startX;\n\n    this.height = yCursor;\n    this.startY = this.topRow.capline;\n    this.bottomRow.baseline = yCursor - this.bottomRow.descenderHeight;\n  }\n}\n\nexports.RenderInfo = RenderInfo;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/common/info.js?")},
"./core/renderers/common/marker_svg.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/utils/svg_paths.js\");\n__webpack_require__(\"./core/keyboard_nav/ast_node.js\");\n__webpack_require__(\"./core/connection_type.js\");\n__webpack_require__(\"./core/utils/svg.js\");\n__webpack_require__(\"./core/events/events_marker_move.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Methods for graphically rendering a marker as SVG.\n */\n\n\n\n/**\n * Methods for graphically rendering a marker as SVG.\n * @class\n */\ngoog.module('Blockly.blockRendering.MarkerSvg');\n\nconst dom = goog.require('Blockly.utils.dom');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst svgPaths = goog.require('Blockly.utils.svgPaths');\nconst {ASTNode} = goog.require('Blockly.ASTNode');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {ConnectionType} = goog.require('Blockly.ConnectionType');\n/* eslint-disable-next-line no-unused-vars */\nconst {Connection} = goog.requireType('Blockly.Connection');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {Field} = goog.requireType('Blockly.Field');\n/* eslint-disable-next-line no-unused-vars */\nconst {IASTNodeLocationSvg} = goog.requireType('Blockly.IASTNodeLocationSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Marker} = goog.requireType('Blockly.Marker');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderedConnection} = goog.requireType('Blockly.RenderedConnection');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.MarkerMove');\n\n\n/**\n * The name of the CSS class for a cursor.\n * @const {string}\n */\nconst CURSOR_CLASS = 'blocklyCursor';\n\n/**\n * The name of the CSS class for a marker.\n * @const {string}\n */\nconst MARKER_CLASS = 'blocklyMarker';\n\n/**\n * What we multiply the height by to get the height of the marker.\n * Only used for the block and block connections.\n * @const {number}\n */\nconst HEIGHT_MULTIPLIER = 3 / 4;\n\n/**\n * Class for a marker.\n * @alias Blockly.blockRendering.MarkerSvg\n */\nclass MarkerSvg {\n  /**\n   * @param {!WorkspaceSvg} workspace The workspace the marker belongs to.\n   * @param {!ConstantProvider} constants The constants for\n   *     the renderer.\n   * @param {!Marker} marker The marker to draw.\n   */\n  constructor(workspace, constants, marker) {\n    /**\n     * The workspace the marker belongs to.\n     * @type {!WorkspaceSvg}\n     * @private\n     */\n    this.workspace_ = workspace;\n\n    /**\n     * The marker to draw.\n     * @type {!Marker}\n     * @private\n     */\n    this.marker_ = marker;\n\n    /**\n     * The workspace, field, or block that the marker SVG element should be\n     * attached to.\n     * @type {IASTNodeLocationSvg}\n     * @private\n     */\n    this.parent_ = null;\n\n    /**\n     * The constants necessary to draw the marker.\n     * @type {ConstantProvider}\n     * @protected\n     */\n    this.constants_ = constants;\n\n    /**\n     * The current SVG element for the marker.\n     * @type {Element}\n     */\n    this.currentMarkerSvg = null;\n\n    const defaultColour = this.isCursor() ? this.constants_.CURSOR_COLOUR :\n                                            this.constants_.MARKER_COLOUR;\n\n    /**\n     * The colour of the marker.\n     * @type {string}\n     */\n    this.colour_ = marker.colour || defaultColour;\n\n    /**\n     * The root SVG group containing the marker.\n     * @type {SVGGElement}\n     * @protected\n     */\n    this.markerSvg_ = null;\n\n    /**\n     * @type {?SVGGElement}\n     * @protected\n     */\n    this.svgGroup_ = null;\n\n    /**\n     * @type {?SVGPathElement}\n     * @protected\n     */\n    this.markerBlock_ = null;\n\n    /**\n     * @type {?SVGPathElement}\n     * @protected\n     */\n    this.markerInput_ = null;\n\n    /**\n     * @type {?SVGRectElement}\n     * @protected\n     */\n    this.markerSvgLine_ = null;\n\n    /**\n     * @type {?SVGRectElement}\n     * @protected\n     */\n    this.markerSvgRect_ = null;\n  }\n\n  /**\n   * Return the root node of the SVG or null if none exists.\n   * @return {SVGElement} The root SVG node.\n   */\n  getSvgRoot() {\n    return this.svgGroup_;\n  }\n\n  /**\n   * Get the marker.\n   * @return {!Marker} The marker to draw for.\n   */\n  getMarker() {\n    return this.marker_;\n  }\n\n  /**\n   * True if the marker should be drawn as a cursor, false otherwise.\n   * A cursor is drawn as a flashing line. A marker is drawn as a solid line.\n   * @return {boolean} True if the marker is a cursor, false otherwise.\n   */\n  isCursor() {\n    return this.marker_.type === 'cursor';\n  }\n\n  /**\n   * Create the DOM element for the marker.\n   * @return {!SVGElement} The marker controls SVG group.\n   * @package\n   */\n  createDom() {\n    const className = this.isCursor() ? CURSOR_CLASS : MARKER_CLASS;\n\n    this.svgGroup_ = dom.createSvgElement(Svg.G, {'class': className}, null);\n\n    this.createDomInternal_();\n    return this.svgGroup_;\n  }\n\n  /**\n   * Attaches the SVG root of the marker to the SVG group of the parent.\n   * @param {!IASTNodeLocationSvg} newParent The workspace, field, or\n   *     block that the marker SVG element should be attached to.\n   * @protected\n   */\n  setParent_(newParent) {\n    if (!this.isCursor()) {\n      if (this.parent_) {\n        this.parent_.setMarkerSvg(null);\n      }\n      newParent.setMarkerSvg(this.getSvgRoot());\n    } else {\n      if (this.parent_) {\n        this.parent_.setCursorSvg(null);\n      }\n      newParent.setCursorSvg(this.getSvgRoot());\n    }\n    this.parent_ = newParent;\n  }\n\n  /**\n   * Update the marker.\n   * @param {ASTNode} oldNode The previous node the marker was on or null.\n   * @param {ASTNode} curNode The node that we want to draw the marker for.\n   */\n  draw(oldNode, curNode) {\n    if (!curNode) {\n      this.hide();\n      return;\n    }\n\n    this.constants_ = this.workspace_.getRenderer().getConstants();\n\n    const defaultColour = this.isCursor() ? this.constants_.CURSOR_COLOUR :\n                                            this.constants_.MARKER_COLOUR;\n    this.colour_ = this.marker_.colour || defaultColour;\n    this.applyColour_(curNode);\n\n    this.showAtLocation_(curNode);\n\n    this.fireMarkerEvent_(oldNode, curNode);\n\n    // Ensures the marker will be visible immediately after the move.\n    const animate = this.currentMarkerSvg.childNodes[0];\n    if (animate !== undefined) {\n      animate.beginElement && animate.beginElement();\n    }\n  }\n\n  /**\n   * Update the marker's visible state based on the type of curNode..\n   * @param {!ASTNode} curNode The node that we want to draw the marker for.\n   * @protected\n   */\n  showAtLocation_(curNode) {\n    const curNodeAsConnection =\n        /** @type {!Connection} */ (curNode.getLocation());\n    const connectionType = curNodeAsConnection.type;\n    if (curNode.getType() === ASTNode.types.BLOCK) {\n      this.showWithBlock_(curNode);\n    } else if (curNode.getType() === ASTNode.types.OUTPUT) {\n      this.showWithOutput_(curNode);\n    } else if (connectionType === ConnectionType.INPUT_VALUE) {\n      this.showWithInput_(curNode);\n    } else if (connectionType === ConnectionType.NEXT_STATEMENT) {\n      this.showWithNext_(curNode);\n    } else if (curNode.getType() === ASTNode.types.PREVIOUS) {\n      this.showWithPrevious_(curNode);\n    } else if (curNode.getType() === ASTNode.types.FIELD) {\n      this.showWithField_(curNode);\n    } else if (curNode.getType() === ASTNode.types.WORKSPACE) {\n      this.showWithCoordinates_(curNode);\n    } else if (curNode.getType() === ASTNode.types.STACK) {\n      this.showWithStack_(curNode);\n    }\n  }\n\n  /**************************\n   * Display\n   **************************/\n\n  /**\n   * Show the marker as a combination of the previous connection and block,\n   * the output connection and block, or just the block.\n   * @param {!ASTNode} curNode The node to draw the marker for.\n   * @private\n   */\n  showWithBlockPrevOutput_(curNode) {\n    const block = /** @type {!BlockSvg} */ (curNode.getSourceBlock());\n    const width = block.width;\n    const height = block.height;\n    const markerHeight = height * HEIGHT_MULTIPLIER;\n    const markerOffset = this.constants_.CURSOR_BLOCK_PADDING;\n\n    if (block.previousConnection) {\n      const connectionShape =\n          this.constants_.shapeFor(block.previousConnection);\n      this.positionPrevious_(\n          width, markerOffset, markerHeight, connectionShape);\n    } else if (block.outputConnection) {\n      const connectionShape = this.constants_.shapeFor(block.outputConnection);\n      this.positionOutput_(width, height, connectionShape);\n    } else {\n      this.positionBlock_(width, markerOffset, markerHeight);\n    }\n    this.setParent_(block);\n    this.showCurrent_();\n  }\n\n  /**\n   * Position and display the marker for a block.\n   * @param {!ASTNode} curNode The node to draw the marker for.\n   * @protected\n   */\n  showWithBlock_(curNode) {\n    this.showWithBlockPrevOutput_(curNode);\n  }\n\n  /**\n   * Position and display the marker for a previous connection.\n   * @param {!ASTNode} curNode The node to draw the marker for.\n   * @protected\n   */\n  showWithPrevious_(curNode) {\n    this.showWithBlockPrevOutput_(curNode);\n  }\n\n  /**\n   * Position and display the marker for an output connection.\n   * @param {!ASTNode} curNode The node to draw the marker for.\n   * @protected\n   */\n  showWithOutput_(curNode) {\n    this.showWithBlockPrevOutput_(curNode);\n  }\n\n  /**\n   * Position and display the marker for a workspace coordinate.\n   * This is a horizontal line.\n   * @param {!ASTNode} curNode The node to draw the marker for.\n   * @protected\n   */\n  showWithCoordinates_(curNode) {\n    const wsCoordinate = curNode.getWsCoordinate();\n    let x = wsCoordinate.x;\n    const y = wsCoordinate.y;\n\n    if (this.workspace_.RTL) {\n      x -= this.constants_.CURSOR_WS_WIDTH;\n    }\n\n    this.positionLine_(x, y, this.constants_.CURSOR_WS_WIDTH);\n    this.setParent_(this.workspace_);\n    this.showCurrent_();\n  }\n\n  /**\n   * Position and display the marker for a field.\n   * This is a box around the field.\n   * @param {!ASTNode} curNode The node to draw the marker for.\n   * @protected\n   */\n  showWithField_(curNode) {\n    const field = /** @type {Field} */ (curNode.getLocation());\n    const width = field.getSize().width;\n    const height = field.getSize().height;\n\n    this.positionRect_(0, 0, width, height);\n    this.setParent_(field);\n    this.showCurrent_();\n  }\n\n  /**\n   * Position and display the marker for an input.\n   * This is a puzzle piece.\n   * @param {!ASTNode} curNode The node to draw the marker for.\n   * @protected\n   */\n  showWithInput_(curNode) {\n    const connection = /** @type {RenderedConnection} */\n        (curNode.getLocation());\n    const sourceBlock = /** @type {!BlockSvg} */ (connection.getSourceBlock());\n\n    this.positionInput_(connection);\n    this.setParent_(sourceBlock);\n    this.showCurrent_();\n  }\n\n  /**\n   * Position and display the marker for a next connection.\n   * This is a horizontal line.\n   * @param {!ASTNode} curNode The node to draw the marker for.\n   * @protected\n   */\n  showWithNext_(curNode) {\n    const connection =\n        /** @type {!RenderedConnection} */ (curNode.getLocation());\n    const targetBlock =\n        /** @type {BlockSvg} */ (connection.getSourceBlock());\n    let x = 0;\n    const y = connection.getOffsetInBlock().y;\n    const width = targetBlock.getHeightWidth().width;\n    if (this.workspace_.RTL) {\n      x = -width;\n    }\n    this.positionLine_(x, y, width);\n    this.setParent_(targetBlock);\n    this.showCurrent_();\n  }\n\n  /**\n   * Position and display the marker for a stack.\n   * This is a box with extra padding around the entire stack of blocks.\n   * @param {!ASTNode} curNode The node to draw the marker for.\n   * @protected\n   */\n  showWithStack_(curNode) {\n    const block = /** @type {BlockSvg} */ (curNode.getLocation());\n\n    // Gets the height and width of entire stack.\n    const heightWidth = block.getHeightWidth();\n\n    // Add padding so that being on a stack looks different than being on a\n    // block.\n    const width = heightWidth.width + this.constants_.CURSOR_STACK_PADDING;\n    const height = heightWidth.height + this.constants_.CURSOR_STACK_PADDING;\n\n    // Shift the rectangle slightly to upper left so padding is equal on all\n    // sides.\n    const xPadding = -this.constants_.CURSOR_STACK_PADDING / 2;\n    const yPadding = -this.constants_.CURSOR_STACK_PADDING / 2;\n\n    let x = xPadding;\n    const y = yPadding;\n\n    if (this.workspace_.RTL) {\n      x = -(width + xPadding);\n    }\n    this.positionRect_(x, y, width, height);\n    this.setParent_(block);\n    this.showCurrent_();\n  }\n\n  /**\n   * Show the current marker.\n   * @protected\n   */\n  showCurrent_() {\n    this.hide();\n    this.currentMarkerSvg.style.display = '';\n  }\n\n  /**************************\n   * Position\n   **************************/\n\n  /**\n   * Position the marker for a block.\n   * Displays an outline of the top half of a rectangle around a block.\n   * @param {number} width The width of the block.\n   * @param {number} markerOffset The extra padding for around the block.\n   * @param {number} markerHeight The height of the marker.\n   * @protected\n   */\n  positionBlock_(width, markerOffset, markerHeight) {\n    const markerPath = svgPaths.moveBy(-markerOffset, markerHeight) +\n        svgPaths.lineOnAxis('V', -markerOffset) +\n        svgPaths.lineOnAxis('H', width + markerOffset * 2) +\n        svgPaths.lineOnAxis('V', markerHeight);\n    this.markerBlock_.setAttribute('d', markerPath);\n    if (this.workspace_.RTL) {\n      this.flipRtl_(this.markerBlock_);\n    }\n    this.currentMarkerSvg = this.markerBlock_;\n  }\n\n  /**\n   * Position the marker for an input connection.\n   * Displays a filled in puzzle piece.\n   * @param {!RenderedConnection} connection The connection to position\n   *     marker around.\n   * @protected\n   */\n  positionInput_(connection) {\n    const x = connection.getOffsetInBlock().x;\n    const y = connection.getOffsetInBlock().y;\n\n    const path =\n        svgPaths.moveTo(0, 0) + this.constants_.shapeFor(connection).pathDown;\n\n    this.markerInput_.setAttribute('d', path);\n    this.markerInput_.setAttribute(\n        'transform',\n        'translate(' + x + ',' + y + ')' +\n            (this.workspace_.RTL ? ' scale(-1 1)' : ''));\n    this.currentMarkerSvg = this.markerInput_;\n  }\n\n  /**\n   * Move and show the marker at the specified coordinate in workspace units.\n   * Displays a horizontal line.\n   * @param {number} x The new x, in workspace units.\n   * @param {number} y The new y, in workspace units.\n   * @param {number} width The new width, in workspace units.\n   * @protected\n   */\n  positionLine_(x, y, width) {\n    this.markerSvgLine_.setAttribute('x', x);\n    this.markerSvgLine_.setAttribute('y', y);\n    this.markerSvgLine_.setAttribute('width', width);\n    this.currentMarkerSvg = this.markerSvgLine_;\n  }\n\n  /**\n   * Position the marker for an output connection.\n   * Displays a puzzle outline and the top and bottom path.\n   * @param {number} width The width of the block.\n   * @param {number} height The height of the block.\n   * @param {!Object} connectionShape The shape object for the connection.\n   * @protected\n   */\n  positionOutput_(width, height, connectionShape) {\n    const markerPath = svgPaths.moveBy(width, 0) +\n        svgPaths.lineOnAxis('h', -(width - connectionShape.width)) +\n        svgPaths.lineOnAxis('v', this.constants_.TAB_OFFSET_FROM_TOP) +\n        connectionShape.pathDown + svgPaths.lineOnAxis('V', height) +\n        svgPaths.lineOnAxis('H', width);\n    this.markerBlock_.setAttribute('d', markerPath);\n    if (this.workspace_.RTL) {\n      this.flipRtl_(this.markerBlock_);\n    }\n    this.currentMarkerSvg = this.markerBlock_;\n  }\n\n  /**\n   * Position the marker for a previous connection.\n   * Displays a half rectangle with a notch in the top to represent the previous\n   * connection.\n   * @param {number} width The width of the block.\n   * @param {number} markerOffset The offset of the marker from around the\n   *     block.\n   * @param {number} markerHeight The height of the marker.\n   * @param {!Object} connectionShape The shape object for the connection.\n   * @protected\n   */\n  positionPrevious_(width, markerOffset, markerHeight, connectionShape) {\n    const markerPath = svgPaths.moveBy(-markerOffset, markerHeight) +\n        svgPaths.lineOnAxis('V', -markerOffset) +\n        svgPaths.lineOnAxis('H', this.constants_.NOTCH_OFFSET_LEFT) +\n        connectionShape.pathLeft +\n        svgPaths.lineOnAxis('H', width + markerOffset * 2) +\n        svgPaths.lineOnAxis('V', markerHeight);\n    this.markerBlock_.setAttribute('d', markerPath);\n    if (this.workspace_.RTL) {\n      this.flipRtl_(this.markerBlock_);\n    }\n    this.currentMarkerSvg = this.markerBlock_;\n  }\n\n  /**\n   * Move and show the marker at the specified coordinate in workspace units.\n   * Displays a filled in rectangle.\n   * @param {number} x The new x, in workspace units.\n   * @param {number} y The new y, in workspace units.\n   * @param {number} width The new width, in workspace units.\n   * @param {number} height The new height, in workspace units.\n   * @protected\n   */\n  positionRect_(x, y, width, height) {\n    this.markerSvgRect_.setAttribute('x', x);\n    this.markerSvgRect_.setAttribute('y', y);\n    this.markerSvgRect_.setAttribute('width', width);\n    this.markerSvgRect_.setAttribute('height', height);\n    this.currentMarkerSvg = this.markerSvgRect_;\n  }\n\n  /**\n   * Flip the SVG paths in RTL.\n   * @param {!SVGElement} markerSvg The marker that we want to flip.\n   * @private\n   */\n  flipRtl_(markerSvg) {\n    markerSvg.setAttribute('transform', 'scale(-1 1)');\n  }\n\n  /**\n   * Hide the marker.\n   */\n  hide() {\n    this.markerSvgLine_.style.display = 'none';\n    this.markerSvgRect_.style.display = 'none';\n    this.markerInput_.style.display = 'none';\n    this.markerBlock_.style.display = 'none';\n  }\n\n  /**\n   * Fire event for the marker or marker.\n   * @param {ASTNode} oldNode The old node the marker used to be on.\n   * @param {!ASTNode} curNode The new node the marker is currently on.\n   * @private\n   */\n  fireMarkerEvent_(oldNode, curNode) {\n    const curBlock = curNode.getSourceBlock();\n    const event = new (eventUtils.get(eventUtils.MARKER_MOVE))(\n        curBlock, this.isCursor(), oldNode, curNode);\n    eventUtils.fire(event);\n  }\n\n  /**\n   * Get the properties to make a marker blink.\n   * @return {!Object} The object holding attributes to make the marker blink.\n   * @protected\n   */\n  getBlinkProperties_() {\n    return {\n      'attributeType': 'XML',\n      'attributeName': 'fill',\n      'dur': '1s',\n      'values': this.colour_ + ';transparent;transparent;',\n      'repeatCount': 'indefinite',\n    };\n  }\n\n  /**\n   * Create the marker SVG.\n   * @return {Element} The SVG node created.\n   * @protected\n   */\n  createDomInternal_() {\n    /* This markup will be generated and added to the .svgGroup_:\n    <g>\n      <rect width=\"100\" height=\"5\">\n        <animate attributeType=\"XML\" attributeName=\"fill\" dur=\"1s\"\n          values=\"transparent;transparent;#fff;transparent\"\n    repeatCount=\"indefinite\" />\n      </rect>\n    </g>\n    */\n\n    this.markerSvg_ = dom.createSvgElement(\n        Svg.G, {\n          'width': this.constants_.CURSOR_WS_WIDTH,\n          'height': this.constants_.WS_CURSOR_HEIGHT,\n        },\n        this.svgGroup_);\n\n    // A horizontal line used to represent a workspace coordinate or next\n    // connection.\n    this.markerSvgLine_ = dom.createSvgElement(\n        Svg.RECT, {\n          'width': this.constants_.CURSOR_WS_WIDTH,\n          'height': this.constants_.WS_CURSOR_HEIGHT,\n          'style': 'display: none',\n        },\n        this.markerSvg_);\n\n    // A filled in rectangle used to represent a stack.\n    this.markerSvgRect_ = dom.createSvgElement(\n        Svg.RECT, {\n          'class': 'blocklyVerticalMarker',\n          'rx': 10,\n          'ry': 10,\n          'style': 'display: none',\n        },\n        this.markerSvg_);\n\n    // A filled in puzzle piece used to represent an input value.\n    this.markerInput_ = dom.createSvgElement(\n        Svg.PATH, {'transform': '', 'style': 'display: none'}, this.markerSvg_);\n\n    // A path used to represent a previous connection and a block, an output\n    // connection and a block, or a block.\n    this.markerBlock_ = dom.createSvgElement(\n        Svg.PATH, {\n          'transform': '',\n          'style': 'display: none',\n          'fill': 'none',\n          'stroke-width': this.constants_.CURSOR_STROKE_WIDTH,\n        },\n        this.markerSvg_);\n\n    // Markers and stack markers don't blink.\n    if (this.isCursor()) {\n      const blinkProperties = this.getBlinkProperties_();\n      dom.createSvgElement(Svg.ANIMATE, blinkProperties, this.markerSvgLine_);\n      dom.createSvgElement(Svg.ANIMATE, blinkProperties, this.markerInput_);\n      blinkProperties['attributeName'] = 'stroke';\n      dom.createSvgElement(Svg.ANIMATE, blinkProperties, this.markerBlock_);\n    }\n\n    return this.markerSvg_;\n  }\n\n  /**\n   * Apply the marker's colour.\n   * @param {!ASTNode} _curNode The node that we want to draw the marker\n   *    for.\n   * @protected\n   */\n  applyColour_(_curNode) {\n    this.markerSvgLine_.setAttribute('fill', this.colour_);\n    this.markerSvgRect_.setAttribute('stroke', this.colour_);\n    this.markerInput_.setAttribute('fill', this.colour_);\n    this.markerBlock_.setAttribute('stroke', this.colour_);\n\n    if (this.isCursor()) {\n      const values = this.colour_ + ';transparent;transparent;';\n      this.markerSvgLine_.firstChild.setAttribute('values', values);\n      this.markerInput_.firstChild.setAttribute('values', values);\n      this.markerBlock_.firstChild.setAttribute('values', values);\n    }\n  }\n\n  /**\n   * Dispose of this marker.\n   */\n  dispose() {\n    if (this.svgGroup_) {\n      dom.removeNode(this.svgGroup_);\n    }\n  }\n}\n\nexports.MarkerSvg = MarkerSvg;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/common/marker_svg.js?")},
"./core/renderers/common/path_object.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/renderers/common/i_path_object.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview An object that owns a block's rendering SVG elements.\n */\n\n\n\n/**\n * An object that owns a block's rendering SVG elements.\n * @class\n */\ngoog.module('Blockly.blockRendering.PathObject');\n\nconst dom = goog.require('Blockly.utils.dom');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Connection} = goog.requireType('Blockly.Connection');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {IPathObject} = goog.require('Blockly.blockRendering.IPathObject');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Theme} = goog.requireType('Blockly.Theme');\n\n\n/**\n * An object that handles creating and setting each of the SVG elements\n * used by the renderer.\n * @implements {IPathObject}\n * @alias Blockly.blockRendering.PathObject\n */\nclass PathObject {\n  /**\n   * @param {!SVGElement} root The root SVG element.\n   * @param {!Theme.BlockStyle} style The style object to use for\n   *     colouring.\n   * @param {!ConstantProvider} constants The renderer's\n   *     constants.\n   * @package\n   */\n  constructor(root, style, constants) {\n    /**\n     * The renderer's constant provider.\n     * @type {!ConstantProvider}\n     * @package\n     */\n    this.constants = constants;\n\n    this.svgRoot = root;\n\n    /**\n     * The primary path of the block.\n     * @type {!SVGElement}\n     * @package\n     */\n    this.svgPath =\n        dom.createSvgElement(Svg.PATH, {'class': 'blocklyPath'}, this.svgRoot);\n\n    /**\n     * The style object to use when colouring block paths.\n     * @type {!Theme.BlockStyle}\n     * @package\n     */\n    this.style = style;\n\n    /**\n     * Holds the cursors svg element when the cursor is attached to the block.\n     * This is null if there is no cursor on the block.\n     * @type {SVGElement}\n     * @package\n     */\n    this.cursorSvg = null;\n\n    /**\n     * Holds the markers svg element when the marker is attached to the block.\n     * This is null if there is no marker on the block.\n     * @type {SVGElement}\n     * @package\n     */\n    this.markerSvg = null;\n  }\n\n  /**\n   * Set the path generated by the renderer onto the respective SVG element.\n   * @param {string} pathString The path.\n   * @package\n   */\n  setPath(pathString) {\n    this.svgPath.setAttribute('d', pathString);\n  }\n\n  /**\n   * Flip the SVG paths in RTL.\n   * @package\n   */\n  flipRTL() {\n    // Mirror the block's path.\n    this.svgPath.setAttribute('transform', 'scale(-1 1)');\n  }\n\n  /**\n   * Add the cursor SVG to this block's SVG group.\n   * @param {SVGElement} cursorSvg The SVG root of the cursor to be added to the\n   *     block SVG group.\n   * @package\n   */\n  setCursorSvg(cursorSvg) {\n    if (!cursorSvg) {\n      this.cursorSvg = null;\n      return;\n    }\n\n    this.svgRoot.appendChild(cursorSvg);\n    this.cursorSvg = cursorSvg;\n  }\n\n  /**\n   * Add the marker SVG to this block's SVG group.\n   * @param {SVGElement} markerSvg The SVG root of the marker to be added to the\n   *     block SVG group.\n   * @package\n   */\n  setMarkerSvg(markerSvg) {\n    if (!markerSvg) {\n      this.markerSvg = null;\n      return;\n    }\n\n    if (this.cursorSvg) {\n      this.svgRoot.insertBefore(markerSvg, this.cursorSvg);\n    } else {\n      this.svgRoot.appendChild(markerSvg);\n    }\n    this.markerSvg = markerSvg;\n  }\n\n  /**\n   * Apply the stored colours to the block's path, taking into account whether\n   * the paths belong to a shadow block.\n   * @param {!BlockSvg} block The source block.\n   * @package\n   */\n  applyColour(block) {\n    this.svgPath.setAttribute('stroke', this.style.colourTertiary);\n    this.svgPath.setAttribute('fill', this.style.colourPrimary);\n\n    this.updateShadow_(block.isShadow());\n    this.updateDisabled_(!block.isEnabled() || block.getInheritedDisabled());\n  }\n\n  /**\n   * Set the style.\n   * @param {!Theme.BlockStyle} blockStyle The block style to use.\n   * @package\n   */\n  setStyle(blockStyle) {\n    this.style = blockStyle;\n  }\n\n  /**\n   * Add or remove the given CSS class on the path object's root SVG element.\n   * @param {string} className The name of the class to add or remove\n   * @param {boolean} add True if the class should be added.  False if it should\n   *     be removed.\n   * @protected\n   */\n  setClass_(className, add) {\n    if (add) {\n      dom.addClass(/** @type {!Element} */ (this.svgRoot), className);\n    } else {\n      dom.removeClass(/** @type {!Element} */ (this.svgRoot), className);\n    }\n  }\n\n  /**\n   * Set whether the block shows a highlight or not.  Block highlighting is\n   * often used to visually mark blocks currently being executed.\n   * @param {boolean} enable True if highlighted.\n   * @package\n   */\n  updateHighlighted(enable) {\n    if (enable) {\n      this.svgPath.setAttribute(\n          'filter', 'url(#' + this.constants.embossFilterId + ')');\n    } else {\n      this.svgPath.setAttribute('filter', 'none');\n    }\n  }\n\n  /**\n   * Updates the look of the block to reflect a shadow state.\n   * @param {boolean} shadow True if the block is a shadow block.\n   * @protected\n   */\n  updateShadow_(shadow) {\n    if (shadow) {\n      this.svgPath.setAttribute('stroke', 'none');\n      this.svgPath.setAttribute('fill', this.style.colourSecondary);\n    }\n  }\n\n  /**\n   * Updates the look of the block to reflect a disabled state.\n   * @param {boolean} disabled True if disabled.\n   * @protected\n   */\n  updateDisabled_(disabled) {\n    this.setClass_('blocklyDisabled', disabled);\n    if (disabled) {\n      this.svgPath.setAttribute(\n          'fill', 'url(#' + this.constants.disabledPatternId + ')');\n    }\n  }\n\n  /**\n   * Add or remove styling showing that a block is selected.\n   * @param {boolean} enable True if selection is enabled, false otherwise.\n   * @package\n   */\n  updateSelected(enable) {\n    this.setClass_('blocklySelected', enable);\n  }\n\n  /**\n   * Add or remove styling showing that a block is dragged over a delete area.\n   * @param {boolean} enable True if the block is being dragged over a delete\n   *     area, false otherwise.\n   * @package\n   */\n  updateDraggingDelete(enable) {\n    this.setClass_('blocklyDraggingDelete', enable);\n  }\n\n  /**\n   * Add or remove styling showing that a block is an insertion marker.\n   * @param {boolean} enable True if the block is an insertion marker, false\n   *     otherwise.\n   * @package\n   */\n  updateInsertionMarker(enable) {\n    this.setClass_('blocklyInsertionMarker', enable);\n  }\n\n  /**\n   * Add or remove styling showing that a block is movable.\n   * @param {boolean} enable True if the block is movable, false otherwise.\n   * @package\n   */\n  updateMovable(enable) {\n    this.setClass_('blocklyDraggable', enable);\n  }\n\n  /**\n   * Add or remove styling that shows that if the dragging block is dropped,\n   * this block will be replaced.  If a shadow block, it will disappear.\n   * Otherwise it will bump.\n   * @param {boolean} enable True if styling should be added.\n   * @package\n   */\n  updateReplacementFade(enable) {\n    this.setClass_('blocklyReplaceable', enable);\n  }\n\n  /**\n   * Add or remove styling that shows that if the dragging block is dropped,\n   * this block will be connected to the input.\n   * @param {Connection} _conn The connection on the input to highlight.\n   * @param {boolean} _enable True if styling should be added.\n   * @package\n   */\n  updateShapeForInputHighlight(_conn, _enable) {\n    // NOP\n  }\n}\n\nexports.PathObject = PathObject;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/common/path_object.js?")},
"./core/renderers/common/renderer.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/common/debug.js\");\n__webpack_require__(\"./core/utils/object.js\");\n__webpack_require__(\"./core/connection_type.js\");\n__webpack_require__(\"./core/connection.js\");\n__webpack_require__(\"./core/renderers/common/constants.js\");\n__webpack_require__(\"./core/renderers/common/drawer.js\");\n__webpack_require__(\"./core/interfaces/i_registrable.js\");\n__webpack_require__(\"./core/insertion_marker_manager.js\");\n__webpack_require__(\"./core/renderers/common/marker_svg.js\");\n__webpack_require__(\"./core/renderers/common/path_object.js\");\n__webpack_require__(\"./core/renderers/common/info.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Base renderer.\n */\n\n\n/**\n * Base renderer.\n * @class\n */\ngoog.module('Blockly.blockRendering.Renderer');\n\nconst debug = goog.require('Blockly.blockRendering.debug');\nconst object = goog.require('Blockly.utils.object');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\nconst {ConnectionType} = goog.require('Blockly.ConnectionType');\nconst {Connection} = goog.require('Blockly.Connection');\nconst {ConstantProvider} = goog.require('Blockly.blockRendering.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {Debug} = goog.requireType('Blockly.blockRendering.Debug');\nconst {Drawer} = goog.require('Blockly.blockRendering.Drawer');\n/* eslint-disable-next-line no-unused-vars */\nconst {IPathObject} = goog.requireType('Blockly.blockRendering.IPathObject');\n/* eslint-disable-next-line no-unused-vars */\nconst {IRegistrable} = goog.require('Blockly.IRegistrable');\nconst {InsertionMarkerManager} = goog.require('Blockly.InsertionMarkerManager');\nconst {MarkerSvg} = goog.require('Blockly.blockRendering.MarkerSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Marker} = goog.requireType('Blockly.Marker');\nconst {PathObject} = goog.require('Blockly.blockRendering.PathObject');\nconst {RenderInfo} = goog.require('Blockly.blockRendering.RenderInfo');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderedConnection} = goog.requireType('Blockly.RenderedConnection');\n/* eslint-disable-next-line no-unused-vars */\nconst {Theme} = goog.requireType('Blockly.Theme');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * The base class for a block renderer.\n * @implements {IRegistrable}\n * @alias Blockly.blockRendering.Renderer\n */\nclass Renderer {\n  /**\n   * @param {string} name The renderer name.\n   * @package\n   */\n  constructor(name) {\n    /**\n     * The renderer name.\n     * @type {string}\n     * @package\n     */\n    this.name = name;\n\n    /**\n     * The renderer's constant provider.\n     * @type {ConstantProvider}\n     * @private\n     */\n    this.constants_ = null;\n\n    /**\n     * Rendering constant overrides, passed in through options.\n     * @type {?Object}\n     * @package\n     */\n    this.overrides = null;\n  }\n\n  /**\n   * Gets the class name that identifies this renderer.\n   * @return {string} The CSS class name.\n   * @package\n   */\n  getClassName() {\n    return this.name + '-renderer';\n  }\n\n  /**\n   * Initialize the renderer.\n   * @param {!Theme} theme The workspace theme object.\n   * @param {Object=} opt_rendererOverrides Rendering constant overrides.\n   * @package\n   */\n  init(theme, opt_rendererOverrides) {\n    this.constants_ = this.makeConstants_();\n    if (opt_rendererOverrides) {\n      this.overrides = opt_rendererOverrides;\n      object.mixin(this.constants_, opt_rendererOverrides);\n    }\n    this.constants_.setTheme(theme);\n    this.constants_.init();\n  }\n\n  /**\n   * Create any DOM elements that this renderer needs.\n   * @param {!SVGElement} svg The root of the workspace's SVG.\n   * @param {!Theme} theme The workspace theme object.\n   * @package\n   */\n  createDom(svg, theme) {\n    this.constants_.createDom(\n        svg, this.name + '-' + theme.name,\n        '.' + this.getClassName() + '.' + theme.getClassName());\n  }\n\n  /**\n   * Refresh the renderer after a theme change.\n   * @param {!SVGElement} svg The root of the workspace's SVG.\n   * @param {!Theme} theme The workspace theme object.\n   * @package\n   */\n  refreshDom(svg, theme) {\n    const previousConstants = this.getConstants();\n    previousConstants.dispose();\n    this.constants_ = this.makeConstants_();\n    if (this.overrides) {\n      object.mixin(this.constants_, this.overrides);\n    }\n    // Ensure the constant provider's random identifier does not change.\n    this.constants_.randomIdentifier = previousConstants.randomIdentifier;\n    this.constants_.setTheme(theme);\n    this.constants_.init();\n    this.createDom(svg, theme);\n  }\n\n  /**\n   * Dispose of this renderer.\n   * Delete all DOM elements that this renderer and its constants created.\n   * @package\n   */\n  dispose() {\n    if (this.constants_) {\n      this.constants_.dispose();\n    }\n  }\n\n  /**\n   * Create a new instance of the renderer's constant provider.\n   * @return {!ConstantProvider} The constant provider.\n   * @protected\n   */\n  makeConstants_() {\n    return new ConstantProvider();\n  }\n\n  /**\n   * Create a new instance of the renderer's render info object.\n   * @param {!BlockSvg} block The block to measure.\n   * @return {!RenderInfo} The render info object.\n   * @protected\n   */\n  makeRenderInfo_(block) {\n    return new RenderInfo(this, block);\n  }\n\n  /**\n   * Create a new instance of the renderer's drawer.\n   * @param {!BlockSvg} block The block to render.\n   * @param {!RenderInfo} info An object containing all\n   *   information needed to render this block.\n   * @return {!Drawer} The drawer.\n   * @protected\n   */\n  makeDrawer_(block, info) {\n    return new Drawer(block, info);\n  }\n\n  /**\n   * Create a new instance of the renderer's debugger.\n   * @return {!Debug} The renderer debugger.\n   * @suppress {strictModuleDepCheck} Debug renderer only included in\n   * playground.\n   * @protected\n   */\n  makeDebugger_() {\n    const {Debug} = goog.module.get('Blockly.blockRendering.Debug');\n    if (!Debug) {\n      throw Error('Missing require for Blockly.blockRendering.Debug');\n    }\n    return new Debug(this.getConstants());\n  }\n\n  /**\n   * Create a new instance of the renderer's marker drawer.\n   * @param {!WorkspaceSvg} workspace The workspace the marker belongs to.\n   * @param {!Marker} marker The marker.\n   * @return {!MarkerSvg} The object in charge of drawing\n   *     the marker.\n   * @package\n   */\n  makeMarkerDrawer(workspace, marker) {\n    return new MarkerSvg(workspace, this.getConstants(), marker);\n  }\n\n  /**\n   * Create a new instance of a renderer path object.\n   * @param {!SVGElement} root The root SVG element.\n   * @param {!Theme.BlockStyle} style The style object to use for\n   *     colouring.\n   * @return {!IPathObject} The renderer path object.\n   * @package\n   */\n  makePathObject(root, style) {\n    return new PathObject(\n        root, style, /** @type {!ConstantProvider} */ (this.constants_));\n  }\n\n  /**\n   * Get the current renderer's constant provider.  We assume that when this is\n   * called, the renderer has already been initialized.\n   * @return {!ConstantProvider} The constant provider.\n   * @package\n   */\n  getConstants() {\n    return /** @type {!ConstantProvider} */ (this.constants_);\n  }\n\n  /**\n   * Determine whether or not to highlight a connection.\n   * @param {Connection} _conn The connection to determine whether or not\n   *     to highlight.\n   * @return {boolean} True if we should highlight the connection.\n   * @package\n   */\n  shouldHighlightConnection(_conn) {\n    return true;\n  }\n\n  /**\n   * Checks if an orphaned block can connect to the \"end\" of the topBlock's\n   * block-clump. If the clump is a row the end is the last input. If the clump\n   * is a stack, the end is the last next connection. If the clump is neither,\n   * then this returns false.\n   * @param {!BlockSvg} topBlock The top block of the block clump we want to try\n   *     and connect to.\n   * @param {!BlockSvg} orphanBlock The orphan block that wants to find\n   *     a home.\n   * @param {number} localType The type of the connection being dragged.\n   * @return {boolean} Whether there is a home for the orphan or not.\n   * @package\n   */\n  orphanCanConnectAtEnd(topBlock, orphanBlock, localType) {\n    const orphanConnection =\n        (localType === ConnectionType.OUTPUT_VALUE ?\n             orphanBlock.outputConnection :\n             orphanBlock.previousConnection);\n    return !!Connection.getConnectionForOrphanedConnection(\n        /** @type {!Block} **/ (topBlock),\n        /** @type {!Connection} **/ (orphanConnection));\n  }\n\n  /**\n   * Chooses a connection preview method based on the available connection, the\n   * current dragged connection, and the block being dragged.\n   * @param {!RenderedConnection} closest The available connection.\n   * @param {!RenderedConnection} local The connection currently being\n   *     dragged.\n   * @param {!BlockSvg} topBlock The block currently being dragged.\n   * @return {!InsertionMarkerManager.PREVIEW_TYPE} The preview type\n   *     to display.\n   * @package\n   */\n  getConnectionPreviewMethod(closest, local, topBlock) {\n    if (local.type === ConnectionType.OUTPUT_VALUE ||\n        local.type === ConnectionType.PREVIOUS_STATEMENT) {\n      if (!closest.isConnected() ||\n          this.orphanCanConnectAtEnd(\n              topBlock,\n              /** @type {!BlockSvg} */ (closest.targetBlock()), local.type)) {\n        return InsertionMarkerManager.PREVIEW_TYPE.INSERTION_MARKER;\n      }\n      return InsertionMarkerManager.PREVIEW_TYPE.REPLACEMENT_FADE;\n    }\n\n    return InsertionMarkerManager.PREVIEW_TYPE.INSERTION_MARKER;\n  }\n\n  /**\n   * Render the block.\n   * @param {!BlockSvg} block The block to render.\n   * @package\n   */\n  render(block) {\n    if (debug.isDebuggerEnabled() && !block.renderingDebugger) {\n      block.renderingDebugger = this.makeDebugger_();\n    }\n    const info = this.makeRenderInfo_(block);\n    info.measure();\n    this.makeDrawer_(block, info).draw();\n  }\n}\n\nexports.Renderer = Renderer;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/common/renderer.js?")},
"./core/renderers/geras/constants.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/common/constants.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview An object that provides constants for rendering blocks in Geras\n * mode.\n */\n\n\n/**\n * An object that provides constants for rendering blocks in Geras\n * mode.\n * @class\n */\ngoog.module('Blockly.geras.ConstantProvider');\n\nconst {ConstantProvider: BaseConstantProvider} = goog.require('Blockly.blockRendering.ConstantProvider');\n\n\n/**\n * An object that provides constants for rendering blocks in Geras mode.\n * @extends {BaseConstantProvider}\n * @alias Blockly.geras.ConstantProvider\n */\nclass ConstantProvider extends BaseConstantProvider {\n  /**\n   * @package\n   */\n  constructor() {\n    super();\n\n    /**\n     * @override\n     */\n    this.FIELD_TEXT_BASELINE_CENTER = false;\n\n    // The dark/shadow path in classic rendering is the same as the normal block\n    // path, but translated down one and right one.\n    this.DARK_PATH_OFFSET = 1;\n\n    /**\n     * The maximum width of a bottom row that follows a statement input and has\n     * inputs inline.\n     * @type {number}\n     */\n    this.MAX_BOTTOM_WIDTH = 30;\n\n    /**\n     * @override\n     */\n    this.STATEMENT_BOTTOM_SPACER = -this.NOTCH_HEIGHT / 2;\n  }\n\n  /**\n   * @override\n   */\n  getCSS_(selector) {\n    return super.getCSS_(selector).concat([\n      /* eslint-disable indent */\n      // Insertion marker.\n      selector + ' .blocklyInsertionMarker>.blocklyPathLight,',\n      selector + ' .blocklyInsertionMarker>.blocklyPathDark {',\n      'fill-opacity: ' + this.INSERTION_MARKER_OPACITY + ';', 'stroke: none;',\n      '}',\n      /* eslint-enable indent */\n    ]);\n  }\n}\n\nexports.ConstantProvider = ConstantProvider;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/geras/constants.js?")},
"./core/renderers/geras/drawer.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/common/debug.js\");\n__webpack_require__(\"./core/utils/svg_paths.js\");\n__webpack_require__(\"./core/renderers/common/drawer.js\");\n__webpack_require__(\"./core/renderers/geras/highlighter.js\");\n__webpack_require__(\"./core/renderers/geras/measurables/inline_input.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Renderer that preserves the look and feel of Blockly pre-2019.\n */\n\n\n/**\n * Renderer that preserves the look and feel of Blockly pre-2019.\n * @class\n */\ngoog.module('Blockly.geras.Drawer');\n\nconst debug = goog.require('Blockly.blockRendering.debug');\nconst svgPaths = goog.require('Blockly.utils.svgPaths');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.geras.ConstantProvider');\nconst {Drawer: BaseDrawer} = goog.require('Blockly.blockRendering.Drawer');\nconst {Highlighter} = goog.require('Blockly.geras.Highlighter');\n/* eslint-disable-next-line no-unused-vars */\nconst {InlineInput} = goog.require('Blockly.geras.InlineInput');\n/* eslint-disable-next-line no-unused-vars */\nconst {PathObject} = goog.requireType('Blockly.geras.PathObject');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderInfo} = goog.requireType('Blockly.geras.RenderInfo');\n\n\n/**\n * An object that draws a block based on the given rendering information.\n * @extends {BaseDrawer}\n * @alias Blockly.geras.Drawer\n */\nclass Drawer extends BaseDrawer {\n  /**\n   * @param {!BlockSvg} block The block to render.\n   * @param {!RenderInfo} info An object containing all\n   *   information needed to render this block.\n   * @package\n   */\n  constructor(block, info) {\n    super(block, info);\n    // Unlike Thrasos, Geras has highlights and drop shadows.\n    this.highlighter_ = new Highlighter(info);\n\n    /** @type {!ConstantProvider} */\n    this.constants_;\n  }\n\n  /**\n   * @override\n   */\n  draw() {\n    this.hideHiddenIcons_();\n    this.drawOutline_();\n    this.drawInternals_();\n\n    const pathObject =\n        /** @type {!PathObject} */ (this.block_.pathObject);\n    pathObject.setPath(this.outlinePath_ + '\\n' + this.inlinePath_);\n    pathObject.setHighlightPath(this.highlighter_.getPath());\n    if (this.info_.RTL) {\n      pathObject.flipRTL();\n    }\n    if (debug.isDebuggerEnabled()) {\n      this.block_.renderingDebugger.drawDebug(this.block_, this.info_);\n    }\n    this.recordSizeOnBlock_();\n  }\n\n  /**\n   * @override\n   */\n  drawTop_() {\n    this.highlighter_.drawTopCorner(this.info_.topRow);\n    this.highlighter_.drawRightSideRow(this.info_.topRow);\n\n    super.drawTop_();\n  }\n\n  /**\n   * @override\n   */\n  drawJaggedEdge_(row) {\n    this.highlighter_.drawJaggedEdge_(row);\n\n    super.drawJaggedEdge_(row);\n  }\n\n  /**\n   * @override\n   */\n  drawValueInput_(row) {\n    this.highlighter_.drawValueInput(row);\n\n    super.drawValueInput_(row);\n  }\n\n  /**\n   * @override\n   */\n  drawStatementInput_(row) {\n    this.highlighter_.drawStatementInput(row);\n\n    super.drawStatementInput_(row);\n  }\n\n  /**\n   * @override\n   */\n  drawRightSideRow_(row) {\n    this.highlighter_.drawRightSideRow(row);\n\n    this.outlinePath_ += svgPaths.lineOnAxis('H', row.xPos + row.width) +\n        svgPaths.lineOnAxis('V', row.yPos + row.height);\n  }\n\n  /**\n   * @override\n   */\n  drawBottom_() {\n    this.highlighter_.drawBottomRow(this.info_.bottomRow);\n\n    super.drawBottom_();\n  }\n\n  /**\n   * Add steps for the left side of the block, which may include an output\n   * connection\n   * @protected\n   * @override\n   */\n  drawLeft_() {\n    this.highlighter_.drawLeft();\n\n    super.drawLeft_();\n  }\n\n  /**\n   * @override\n   */\n  drawInlineInput_(input) {\n    this.highlighter_.drawInlineInput(/** @type {!InlineInput} */ (input));\n\n    super.drawInlineInput_(input);\n  }\n\n  /**\n   * @override\n   */\n  positionInlineInputConnection_(input) {\n    const yPos = input.centerline - input.height / 2;\n    // Move the connection.\n    if (input.connectionModel) {\n      // xPos already contains info about startX\n      let connX =\n          input.xPos + input.connectionWidth + this.constants_.DARK_PATH_OFFSET;\n      if (this.info_.RTL) {\n        connX *= -1;\n      }\n      input.connectionModel.setOffsetInBlock(\n          connX,\n          yPos + input.connectionOffsetY + this.constants_.DARK_PATH_OFFSET);\n    }\n  }\n\n  /**\n   * @override\n   */\n  positionStatementInputConnection_(row) {\n    const input = row.getLastInput();\n    if (input.connectionModel) {\n      let connX = row.xPos + row.statementEdge + input.notchOffset;\n      if (this.info_.RTL) {\n        connX *= -1;\n      } else {\n        connX += this.constants_.DARK_PATH_OFFSET;\n      }\n      input.connectionModel.setOffsetInBlock(\n          connX, row.yPos + this.constants_.DARK_PATH_OFFSET);\n    }\n  }\n\n  /**\n   * @override\n   */\n  positionExternalValueConnection_(row) {\n    const input = row.getLastInput();\n    if (input.connectionModel) {\n      let connX = row.xPos + row.width + this.constants_.DARK_PATH_OFFSET;\n      if (this.info_.RTL) {\n        connX *= -1;\n      }\n      input.connectionModel.setOffsetInBlock(connX, row.yPos);\n    }\n  }\n\n  /**\n   * @override\n   */\n  positionNextConnection_() {\n    const bottomRow = this.info_.bottomRow;\n\n    if (bottomRow.connection) {\n      const connInfo = bottomRow.connection;\n      const x = connInfo.xPos;  // Already contains info about startX.\n      const connX =\n          (this.info_.RTL ? -x : x) + (this.constants_.DARK_PATH_OFFSET / 2);\n      connInfo.connectionModel.setOffsetInBlock(\n          connX, bottomRow.baseline + this.constants_.DARK_PATH_OFFSET);\n    }\n  }\n}\n\nexports.Drawer = Drawer;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/geras/drawer.js?")},
"./core/renderers/geras/geras.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/geras/constants.js\");\n__webpack_require__(\"./core/renderers/geras/drawer.js\");\n__webpack_require__(\"./core/renderers/geras/highlight_constants.js\");\n__webpack_require__(\"./core/renderers/geras/highlighter.js\");\n__webpack_require__(\"./core/renderers/geras/measurables/inline_input.js\");\n__webpack_require__(\"./core/renderers/geras/path_object.js\");\n__webpack_require__(\"./core/renderers/geras/info.js\");\n__webpack_require__(\"./core/renderers/geras/renderer.js\");\n__webpack_require__(\"./core/renderers/geras/measurables/statement_input.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Re-exports of Blockly.geras.* modules.\n */\n\n\n/**\n * Re-exports of Blockly.geras.* modules.\n * @namespace Blockly.geras\n */\ngoog.module('Blockly.geras');\n\nconst {ConstantProvider} = goog.require('Blockly.geras.ConstantProvider');\nconst {Drawer} = goog.require('Blockly.geras.Drawer');\nconst {HighlightConstantProvider} = goog.require('Blockly.geras.HighlightConstantProvider');\nconst {Highlighter} = goog.require('Blockly.geras.Highlighter');\nconst {InlineInput} = goog.require('Blockly.geras.InlineInput');\nconst {PathObject} = goog.require('Blockly.geras.PathObject');\nconst {RenderInfo} = goog.require('Blockly.geras.RenderInfo');\nconst {Renderer} = goog.require('Blockly.geras.Renderer');\nconst {StatementInput} = goog.require('Blockly.geras.StatementInput');\n\nexports.ConstantProvider = ConstantProvider;\nexports.Drawer = Drawer;\nexports.HighlightConstantProvider = HighlightConstantProvider;\nexports.Highlighter = Highlighter;\nexports.InlineInput = InlineInput;\nexports.PathObject = PathObject;\nexports.RenderInfo = RenderInfo;\nexports.Renderer = Renderer;\nexports.StatementInput = StatementInput;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/geras/geras.js?")},
"./core/renderers/geras/highlight_constants.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/svg_paths.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Objects for rendering highlights on blocks.\n */\n\n\n/**\n * Objects for rendering highlights on blocks.\n * @class\n */\ngoog.module('Blockly.geras.HighlightConstantProvider');\n\nconst svgPaths = goog.require('Blockly.utils.svgPaths');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n\n\n/**\n * An object that provides constants for rendering highlights on blocks.\n * Some highlights are simple offsets of the parent paths and can be generated\n * programmatically.  Others, especially on curves, are just made out of piles\n * of constants and are hard to tweak.\n * @alias Blockly.geras.HighlightConstantProvider\n */\nclass HighlightConstantProvider {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @package\n   */\n  constructor(constants) {\n    /**\n     * The renderer's constant provider.\n     * @type {!ConstantProvider}\n     */\n    this.constantProvider = constants;\n\n    /**\n     * The offset between the block's main path and highlight path.\n     * @type {number}\n     * @package\n     */\n    this.OFFSET = 0.5;\n\n    /**\n     * The start point, which is offset in both X and Y, as an SVG path chunk.\n     * @type {string}\n     */\n    this.START_POINT = svgPaths.moveBy(this.OFFSET, this.OFFSET);\n  }\n\n  /**\n   * Initialize shape objects based on the constants set in the constructor.\n   * @package\n   */\n  init() {\n    /**\n     * An object containing sizing and path information about inside corner\n     * highlights.\n     * @type {!Object}\n     */\n    this.INSIDE_CORNER = this.makeInsideCorner();\n\n    /**\n     * An object containing sizing and path information about outside corner\n     * highlights.\n     * @type {!Object}\n     */\n    this.OUTSIDE_CORNER = this.makeOutsideCorner();\n\n    /**\n     * An object containing sizing and path information about puzzle tab\n     * highlights.\n     * @type {!Object}\n     */\n    this.PUZZLE_TAB = this.makePuzzleTab();\n\n    /**\n     * An object containing sizing and path information about notch highlights.\n     * @type {!Object}\n     */\n    this.NOTCH = this.makeNotch();\n\n    /**\n     * An object containing sizing and path information about highlights for\n     * collapsed block indicators.\n     * @type {!Object}\n     */\n    this.JAGGED_TEETH = this.makeJaggedTeeth();\n\n    /**\n     * An object containing sizing and path information about start hat\n     * highlights.\n     * @type {!Object}\n     */\n    this.START_HAT = this.makeStartHat();\n  }\n\n  /**\n   * @return {!Object} An object containing sizing and path information about\n   *     inside corner highlights.\n   * @package\n   */\n  makeInsideCorner() {\n    const radius = this.constantProvider.CORNER_RADIUS;\n    const offset = this.OFFSET;\n\n    /**\n     * Distance from shape edge to intersect with a curved corner at 45 degrees.\n     * Applies to highlighting on around the outside of a curve.\n     * @const\n     */\n    const distance45outside = (1 - Math.SQRT1_2) * (radius + offset) - offset;\n\n    const pathTopRtl = svgPaths.moveBy(distance45outside, distance45outside) +\n        svgPaths.arc(\n            'a', '0 0,0', radius,\n            svgPaths.point(\n                -distance45outside - offset, radius - distance45outside));\n\n    const pathBottomRtl = svgPaths.arc(\n        'a', '0 0,0', radius + offset,\n        svgPaths.point(radius + offset, radius + offset));\n\n    const pathBottomLtr =\n        svgPaths.moveBy(distance45outside, -distance45outside) +\n        svgPaths.arc(\n            'a', '0 0,0', radius + offset,\n            svgPaths.point(\n                radius - distance45outside, distance45outside + offset));\n\n    return {\n      width: radius + offset,\n      height: radius,\n      pathTop: function(rtl) {\n        return rtl ? pathTopRtl : '';\n      },\n      pathBottom: function(rtl) {\n        return rtl ? pathBottomRtl : pathBottomLtr;\n      },\n    };\n  }\n\n  /**\n   * @return {!Object} An object containing sizing and path information about\n   *     outside corner highlights.\n   * @package\n   */\n  makeOutsideCorner() {\n    const radius = this.constantProvider.CORNER_RADIUS;\n    const offset = this.OFFSET;\n\n    /**\n     * Distance from shape edge to intersect with a curved corner at 45 degrees.\n     * Applies to highlighting on around the inside of a curve.\n     * @const\n     */\n    const distance45inside = (1 - Math.SQRT1_2) * (radius - offset) + offset;\n\n    const topLeftStartX = distance45inside;\n    const topLeftStartY = distance45inside;\n    const topLeftCornerHighlightRtl =\n        svgPaths.moveBy(topLeftStartX, topLeftStartY) +\n        svgPaths.arc(\n            'a', '0 0,1', radius - offset,\n            svgPaths.point(radius - topLeftStartX, -topLeftStartY + offset));\n    /**\n     * SVG path for drawing the highlight on the rounded top-left corner.\n     * @const\n     */\n    const topLeftCornerHighlightLtr = svgPaths.moveBy(offset, radius) +\n        svgPaths.arc(\n            'a', '0 0,1', radius - offset,\n            svgPaths.point(radius, -radius + offset));\n\n    const bottomLeftStartX = distance45inside;\n    const bottomLeftStartY = -distance45inside;\n    const bottomLeftPath = svgPaths.moveBy(bottomLeftStartX, bottomLeftStartY) +\n        svgPaths.arc(\n            'a', '0 0,1', radius - offset,\n            svgPaths.point(\n                -bottomLeftStartX + offset, -bottomLeftStartY - radius));\n\n    return {\n      height: radius,\n      topLeft: function(rtl) {\n        return rtl ? topLeftCornerHighlightRtl : topLeftCornerHighlightLtr;\n      },\n      bottomLeft: function() {\n        return bottomLeftPath;\n      },\n    };\n  }\n\n  /**\n   * @return {!Object} An object containing sizing and path information about\n   *     puzzle tab highlights.\n   * @package\n   */\n  makePuzzleTab() {\n    const width = this.constantProvider.TAB_WIDTH;\n    const height = this.constantProvider.TAB_HEIGHT;\n\n    // This is how much of the vertical block edge is actually drawn by the\n    // puzzle tab.\n    const verticalOverlap = 2.5;\n\n    const highlightRtlUp =\n        svgPaths.moveBy(-2, -height + verticalOverlap + 0.9) +\n        svgPaths.lineTo(width * -0.45, -2.1);\n\n    const highlightRtlDown = svgPaths.lineOnAxis('v', verticalOverlap) +\n        svgPaths.moveBy(-width * 0.97, 2.5) +\n        svgPaths.curve(\n            'q',\n            [\n              svgPaths.point(-width * 0.05, 10),\n              svgPaths.point(width * 0.3, 9.5),\n            ]) +\n        svgPaths.moveBy(width * 0.67, -1.9) +\n        svgPaths.lineOnAxis('v', verticalOverlap);\n\n    const highlightLtrUp = svgPaths.lineOnAxis('v', -1.5) +\n        svgPaths.moveBy(width * -0.92, -0.5) +\n        svgPaths.curve(\n            'q',\n            [svgPaths.point(width * -0.19, -5.5), svgPaths.point(0, -11)]) +\n        svgPaths.moveBy(width * 0.92, 1);\n\n    const highlightLtrDown =\n        svgPaths.moveBy(-5, height - 0.7) + svgPaths.lineTo(width * 0.46, -2.1);\n\n    return {\n      width: width,\n      height: height,\n      pathUp: function(rtl) {\n        return rtl ? highlightRtlUp : highlightLtrUp;\n      },\n      pathDown: function(rtl) {\n        return rtl ? highlightRtlDown : highlightLtrDown;\n      },\n    };\n  }\n\n  /**\n   * @return {!Object} An object containing sizing and path information about\n   *     notch highlights.\n   * @package\n   */\n  makeNotch() {\n    // This is only for the previous connection.\n    const pathLeft = svgPaths.lineOnAxis('h', this.OFFSET) +\n        this.constantProvider.NOTCH.pathLeft;\n    return {pathLeft: pathLeft};\n  }\n\n  /**\n   * @return {!Object} An object containing sizing and path information about\n   *     collapsed block edge highlights.\n   * @package\n   */\n  makeJaggedTeeth() {\n    const pathLeft = svgPaths.lineTo(5.1, 2.6) + svgPaths.moveBy(-10.2, 6.8) +\n        svgPaths.lineTo(5.1, 2.6);\n    return {pathLeft: pathLeft, height: 12, width: 10.2};\n  }\n\n  /**\n   * @return {!Object} An object containing sizing and path information about\n   *     start highlights.\n   * @package\n   */\n  makeStartHat() {\n    const hatHeight = this.constantProvider.START_HAT.height;\n    const pathRtl = svgPaths.moveBy(25, -8.7) + svgPaths.curve('c', [\n      svgPaths.point(29.7, -6.2),\n      svgPaths.point(57.2, -0.5),\n      svgPaths.point(75, 8.7),\n    ]);\n\n    const pathLtr = svgPaths.curve('c', [\n      svgPaths.point(17.8, -9.2),\n      svgPaths.point(45.3, -14.9),\n      svgPaths.point(75, -8.7),\n    ]) + svgPaths.moveTo(100.5, hatHeight + 0.5);\n    return {\n      path: function(rtl) {\n        return rtl ? pathRtl : pathLtr;\n      },\n    };\n  }\n}\n\nexports.HighlightConstantProvider = HighlightConstantProvider;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/geras/highlight_constants.js?")},
"./core/renderers/geras/highlighter.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/svg_paths.js\");\n__webpack_require__(\"./core/renderers/measurables/bottom_row.js\");\n__webpack_require__(\"./core/renderers/geras/measurables/inline_input.js\");\n__webpack_require__(\"./core/renderers/measurables/spacer_row.js\");\n__webpack_require__(\"./core/renderers/measurables/top_row.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Methods for adding highlights on block, for rendering in\n * compatibility mode.\n */\n\n\n/**\n * Methods for adding highlights on block, for rendering in\n * compatibility mode.\n * @class\n */\ngoog.module('Blockly.geras.Highlighter');\n\nconst svgPaths = goog.require('Blockly.utils.svgPaths');\n/* eslint-disable-next-line no-unused-vars */\nconst {BottomRow} = goog.require('Blockly.blockRendering.BottomRow');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {HighlightConstantProvider} = goog.requireType('Blockly.geras.HighlightConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {InlineInput} = goog.require('Blockly.geras.InlineInput');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderInfo} = goog.requireType('Blockly.geras.RenderInfo');\n/* eslint-disable-next-line no-unused-vars */\nconst {Renderer} = goog.requireType('Blockly.geras.Renderer');\n/* eslint-disable-next-line no-unused-vars */\nconst {Row} = goog.requireType('Blockly.blockRendering.Row');\nconst {SpacerRow} = goog.require('Blockly.blockRendering.SpacerRow');\n/* eslint-disable-next-line no-unused-vars */\nconst {TopRow} = goog.require('Blockly.blockRendering.TopRow');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object that adds highlights to a block based on the given rendering\n * information.\n *\n * Highlighting is interesting because the highlights do not fully enclose the\n * block.  Instead, they are positioned based on a light source in the top left.\n * This means that rendering highlights requires exact information about the\n * position of each part of the block.  The resulting paths are not continuous\n * or closed paths.  The highlights for tabs and notches are loosely based on\n * tab and notch shapes, but are not exactly the same.\n * @alias Blockly.geras.Highlighter\n */\nclass Highlighter {\n  /**\n   * @param {!RenderInfo} info An object containing all\n   *     information needed to render this block.\n   * @package\n   */\n  constructor(info) {\n    this.info_ = info;\n    this.steps_ = '';\n    this.inlineSteps_ = '';\n\n    this.RTL_ = this.info_.RTL;\n\n    const renderer = /** @type {!Renderer} */ (info.getRenderer());\n\n    /**\n     * The renderer's constant provider.\n     * @type {!ConstantProvider}\n     */\n    this.constants_ = renderer.getConstants();\n\n    /**\n     * @type {!HighlightConstantProvider}\n     */\n    this.highlightConstants_ = renderer.getHighlightConstants();\n    /**\n     * The offset between the block's main path and highlight path.\n     * @type {number}\n     * @private\n     */\n    this.highlightOffset_ = this.highlightConstants_.OFFSET;\n\n    this.outsideCornerPaths_ = this.highlightConstants_.OUTSIDE_CORNER;\n    this.insideCornerPaths_ = this.highlightConstants_.INSIDE_CORNER;\n    this.puzzleTabPaths_ = this.highlightConstants_.PUZZLE_TAB;\n    this.notchPaths_ = this.highlightConstants_.NOTCH;\n    this.startPaths_ = this.highlightConstants_.START_HAT;\n    this.jaggedTeethPaths_ = this.highlightConstants_.JAGGED_TEETH;\n  }\n\n  /**\n   * Get the steps for the highlight path.\n   * @return {string} The steps for the highlight path.\n   * @package\n   */\n  getPath() {\n    return this.steps_ + '\\n' + this.inlineSteps_;\n  }\n\n  /**\n   * Add a highlight to the top corner of a block.\n   * @param {!TopRow} row The top row of the block.\n   * @package\n   */\n  drawTopCorner(row) {\n    this.steps_ += svgPaths.moveBy(row.xPos, this.info_.startY);\n    for (let i = 0, elem; (elem = row.elements[i]); i++) {\n      if (Types.isLeftSquareCorner(elem)) {\n        this.steps_ += this.highlightConstants_.START_POINT;\n      } else if (Types.isLeftRoundedCorner(elem)) {\n        this.steps_ += this.outsideCornerPaths_.topLeft(this.RTL_);\n      } else if (Types.isPreviousConnection(elem)) {\n        this.steps_ += this.notchPaths_.pathLeft;\n      } else if (Types.isHat(elem)) {\n        this.steps_ += this.startPaths_.path(this.RTL_);\n      } else if (Types.isSpacer(elem) && elem.width !== 0) {\n        // The end point of the spacer needs to be offset by the highlight\n        // amount. So instead of using the spacer's width for a relative\n        // horizontal, use its width and position for an absolute horizontal\n        // move.\n        this.steps_ += svgPaths.lineOnAxis(\n            'H', elem.xPos + elem.width - this.highlightOffset_);\n      }\n    }\n\n    const right = row.xPos + row.width - this.highlightOffset_;\n    this.steps_ += svgPaths.lineOnAxis('H', right);\n  }\n\n  /**\n   * Add a highlight on a jagged edge for a collapsed block.\n   * @param {!Row} row  The row to highlight.\n   * @package\n   */\n  drawJaggedEdge_(row) {\n    if (this.info_.RTL) {\n      const remainder =\n          row.height - this.jaggedTeethPaths_.height - this.highlightOffset_;\n      this.steps_ +=\n          this.jaggedTeethPaths_.pathLeft + svgPaths.lineOnAxis('v', remainder);\n    }\n  }\n\n  /**\n   * Add a highlight on a value input.\n   * @param {!Row} row The row the input belongs to.\n   * @package\n   */\n  drawValueInput(row) {\n    const input = /** @type {!InlineInput}} */ (row.getLastInput());\n    if (this.RTL_) {\n      const belowTabHeight = row.height - input.connectionHeight;\n\n      this.steps_ +=\n          svgPaths.moveTo(\n              input.xPos + input.width - this.highlightOffset_, row.yPos) +\n          this.puzzleTabPaths_.pathDown(this.RTL_) +\n          svgPaths.lineOnAxis('v', belowTabHeight);\n    } else {\n      this.steps_ += svgPaths.moveTo(input.xPos + input.width, row.yPos) +\n          this.puzzleTabPaths_.pathDown(this.RTL_);\n    }\n  }\n\n  /**\n   * Add a highlight on a statement input.\n   * @param {!Row} row The row to highlight.\n   * @package\n   */\n  drawStatementInput(row) {\n    const input = row.getLastInput();\n    if (this.RTL_) {\n      const innerHeight = row.height - (2 * this.insideCornerPaths_.height);\n      this.steps_ += svgPaths.moveTo(input.xPos, row.yPos) +\n          this.insideCornerPaths_.pathTop(this.RTL_) +\n          svgPaths.lineOnAxis('v', innerHeight) +\n          this.insideCornerPaths_.pathBottom(this.RTL_) +\n          svgPaths.lineTo(\n              row.width - input.xPos - this.insideCornerPaths_.width, 0);\n    } else {\n      this.steps_ += svgPaths.moveTo(input.xPos, row.yPos + row.height) +\n          this.insideCornerPaths_.pathBottom(this.RTL_) +\n          svgPaths.lineTo(\n              row.width - input.xPos - this.insideCornerPaths_.width, 0);\n    }\n  }\n\n  /**\n   * Add a highlight on the right side of a row.\n   * @param {!Row} row The row to highlight.\n   * @package\n   */\n  drawRightSideRow(row) {\n    const rightEdge = row.xPos + row.width - this.highlightOffset_;\n    if (row instanceof SpacerRow && row.followsStatement) {\n      this.steps_ += svgPaths.lineOnAxis('H', rightEdge);\n    }\n    if (this.RTL_) {\n      this.steps_ += svgPaths.lineOnAxis('H', rightEdge);\n      if (row.height > this.highlightOffset_) {\n        this.steps_ += svgPaths.lineOnAxis(\n            'V', row.yPos + row.height - this.highlightOffset_);\n      }\n    }\n  }\n\n  /**\n   * Add a highlight to the bottom row.\n   * @param {!BottomRow} row The row to highlight.\n   * @package\n   */\n  drawBottomRow(row) {\n    // Highlight the vertical edge of the bottom row on the input side.\n    // Highlighting is always from the top left, both in LTR and RTL.\n    if (this.RTL_) {\n      this.steps_ +=\n          svgPaths.lineOnAxis('V', row.baseline - this.highlightOffset_);\n    } else {\n      const cornerElem = this.info_.bottomRow.elements[0];\n      if (Types.isLeftSquareCorner(cornerElem)) {\n        this.steps_ += svgPaths.moveTo(\n            row.xPos + this.highlightOffset_,\n            row.baseline - this.highlightOffset_);\n      } else if (Types.isLeftRoundedCorner(cornerElem)) {\n        this.steps_ += svgPaths.moveTo(row.xPos, row.baseline);\n        this.steps_ += this.outsideCornerPaths_.bottomLeft();\n      }\n    }\n  }\n\n  /**\n   * Draw the highlight on the left side of the block.\n   * @package\n   */\n  drawLeft() {\n    const outputConnection = this.info_.outputConnection;\n    if (outputConnection) {\n      const tabBottom =\n          outputConnection.connectionOffsetY + outputConnection.height;\n      // Draw a line up to the bottom of the tab.\n      if (this.RTL_) {\n        this.steps_ += svgPaths.moveTo(this.info_.startX, tabBottom);\n      } else {\n        const left = this.info_.startX + this.highlightOffset_;\n        const bottom = this.info_.bottomRow.baseline - this.highlightOffset_;\n        this.steps_ += svgPaths.moveTo(left, bottom);\n        this.steps_ += svgPaths.lineOnAxis('V', tabBottom);\n      }\n      this.steps_ += this.puzzleTabPaths_.pathUp(this.RTL_);\n    }\n\n    if (!this.RTL_) {\n      const topRow = this.info_.topRow;\n      if (Types.isLeftRoundedCorner(topRow.elements[0])) {\n        this.steps_ +=\n            svgPaths.lineOnAxis('V', this.outsideCornerPaths_.height);\n      } else {\n        this.steps_ +=\n            svgPaths.lineOnAxis('V', topRow.capline + this.highlightOffset_);\n      }\n    }\n  }\n\n  /**\n   * Add a highlight to an inline input.\n   * @param {!InlineInput} input The input to highlight.\n   * @package\n   */\n  drawInlineInput(input) {\n    const offset = this.highlightOffset_;\n\n    // Relative to the block's left.\n    const connectionRight = input.xPos + input.connectionWidth;\n    const yPos = input.centerline - input.height / 2;\n    const bottomHighlightWidth = input.width - input.connectionWidth;\n    const startY = yPos + offset;\n\n    if (this.RTL_) {\n      const aboveTabHeight = input.connectionOffsetY - offset;\n      const belowTabHeight = input.height -\n          (input.connectionOffsetY + input.connectionHeight) + offset;\n\n      const startX = connectionRight - offset;\n\n      this.inlineSteps_ += svgPaths.moveTo(startX, startY) +\n          // Right edge above tab.\n          svgPaths.lineOnAxis('v', aboveTabHeight) +\n          // Back of tab.\n          this.puzzleTabPaths_.pathDown(this.RTL_) +\n          // Right edge below tab.\n          svgPaths.lineOnAxis('v', belowTabHeight) +\n          // Bottom.\n          svgPaths.lineOnAxis('h', bottomHighlightWidth);\n    } else {\n      this.inlineSteps_ +=\n          // Go to top right corner.\n          svgPaths.moveTo(input.xPos + input.width + offset, startY) +\n          // Highlight right edge, bottom.\n          svgPaths.lineOnAxis('v', input.height) +\n          svgPaths.lineOnAxis('h', -bottomHighlightWidth) +\n          // Go to top of tab.\n          svgPaths.moveTo(connectionRight, yPos + input.connectionOffsetY) +\n          // Short highlight glint at bottom of tab.\n          this.puzzleTabPaths_.pathDown(this.RTL_);\n    }\n  }\n}\n\nexports.Highlighter = Highlighter;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/geras/highlighter.js?")},
"./core/renderers/geras/info.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/external_value_input.js\");\n__webpack_require__(\"./core/renderers/measurables/in_row_spacer.js\");\n__webpack_require__(\"./core/renderers/geras/measurables/inline_input.js\");\n__webpack_require__(\"./core/renderers/common/info.js\");\n__webpack_require__(\"./core/renderers/geras/measurables/statement_input.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\n__webpack_require__(\"./core/input_types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Old (compatibility) renderer.\n * Geras: spirit of old age.\n */\n\n\n/**\n * Old (compatibility) renderer.\n * Geras: spirit of old age.\n * @class\n */\ngoog.module('Blockly.geras.RenderInfo');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {BottomRow} = goog.requireType('Blockly.blockRendering.BottomRow');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.geras.ConstantProvider');\nconst {ExternalValueInput} = goog.require('Blockly.blockRendering.ExternalValueInput');\n/* eslint-disable-next-line no-unused-vars */\nconst {Field} = goog.requireType('Blockly.blockRendering.Field');\nconst {InRowSpacer} = goog.require('Blockly.blockRendering.InRowSpacer');\nconst {InlineInput} = goog.require('Blockly.geras.InlineInput');\n/* eslint-disable-next-line no-unused-vars */\nconst {InputRow} = goog.requireType('Blockly.blockRendering.InputRow');\nconst {RenderInfo: BaseRenderInfo} = goog.require('Blockly.blockRendering.RenderInfo');\n/* eslint-disable-next-line no-unused-vars */\nconst {Renderer} = goog.requireType('Blockly.geras.Renderer');\nconst {StatementInput} = goog.require('Blockly.geras.StatementInput');\n/* eslint-disable-next-line no-unused-vars */\nconst {TopRow} = goog.requireType('Blockly.blockRendering.TopRow');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\nconst {inputTypes} = goog.require('Blockly.inputTypes');\n\n\n/**\n * An object containing all sizing information needed to draw this block.\n *\n * This measure pass does not propagate changes to the block (although fields\n * may choose to rerender when getSize() is called).  However, calling it\n * repeatedly may be expensive.\n * @extends {BaseRenderInfo}\n * @alias Blockly.geras.RenderInfo\n */\nclass RenderInfo extends BaseRenderInfo {\n  /**\n   * @param {!Renderer} renderer The renderer in use.\n   * @param {!BlockSvg} block The block to measure.\n   * @package\n   */\n  constructor(renderer, block) {\n    super(renderer, block);\n\n    /** @type {!ConstantProvider} */\n    this.constants_;\n  }\n\n  /**\n   * Get the block renderer in use.\n   * @return {!Renderer} The block renderer in use.\n   * @package\n   */\n  getRenderer() {\n    return /** @type {!Renderer} */ (this.renderer_);\n  }\n\n  /**\n   * @override\n   */\n  populateBottomRow_() {\n    super.populateBottomRow_();\n\n    const followsStatement = this.block_.inputList.length &&\n        this.block_.inputList[this.block_.inputList.length - 1].type ===\n            inputTypes.STATEMENT;\n\n    // The minimum height of the bottom row is smaller in Geras than in other\n    // renderers, because the dark path adds a pixel.\n    // If one of the row's elements has a greater height this will be\n    // overwritten in the compute pass.\n    if (!followsStatement) {\n      this.bottomRow.minHeight =\n          this.constants_.MEDIUM_PADDING - this.constants_.DARK_PATH_OFFSET;\n    }\n  }\n\n  /**\n   * @override\n   */\n  addInput_(input, activeRow) {\n    // Non-dummy inputs have visual representations onscreen.\n    if (this.isInline && input.type === inputTypes.VALUE) {\n      activeRow.elements.push(new InlineInput(this.constants_, input));\n      activeRow.hasInlineInput = true;\n    } else if (input.type === inputTypes.STATEMENT) {\n      activeRow.elements.push(new StatementInput(this.constants_, input));\n      activeRow.hasStatement = true;\n    } else if (input.type === inputTypes.VALUE) {\n      activeRow.elements.push(new ExternalValueInput(this.constants_, input));\n      activeRow.hasExternalInput = true;\n    } else if (input.type === inputTypes.DUMMY) {\n      // Dummy inputs have no visual representation, but the information is\n      // still important.\n      activeRow.minHeight =\n          Math.max(activeRow.minHeight, this.constants_.DUMMY_INPUT_MIN_HEIGHT);\n      activeRow.hasDummyInput = true;\n    }\n    // Ignore row alignment if inline.\n    if (!this.isInline && activeRow.align === null) {\n      activeRow.align = input.align;\n    }\n  }\n\n  /**\n   * @override\n   */\n  addElemSpacing_() {\n    let hasExternalInputs = false;\n    for (let i = 0, row; (row = this.rows[i]); i++) {\n      if (row.hasExternalInput) {\n        hasExternalInputs = true;\n      }\n    }\n    for (let i = 0, row; (row = this.rows[i]); i++) {\n      const oldElems = row.elements;\n      row.elements = [];\n      // No spacing needed before the corner on the top row or the bottom row.\n      if (row.startsWithElemSpacer()) {\n        // There's a spacer before the first element in the row.\n        row.elements.push(new InRowSpacer(\n            this.constants_, this.getInRowSpacing_(null, oldElems[0])));\n      }\n      if (!oldElems.length) {\n        continue;\n      }\n      for (let e = 0; e < oldElems.length - 1; e++) {\n        row.elements.push(oldElems[e]);\n        const spacing = this.getInRowSpacing_(oldElems[e], oldElems[e + 1]);\n        row.elements.push(new InRowSpacer(this.constants_, spacing));\n      }\n      row.elements.push(oldElems[oldElems.length - 1]);\n      if (row.endsWithElemSpacer()) {\n        let spacing =\n            this.getInRowSpacing_(oldElems[oldElems.length - 1], null);\n        if (hasExternalInputs && row.hasDummyInput) {\n          spacing += this.constants_.TAB_WIDTH;\n        }\n        // There's a spacer after the last element in the row.\n        row.elements.push(new InRowSpacer(this.constants_, spacing));\n      }\n    }\n  }\n\n  /**\n   * @override\n   */\n  getInRowSpacing_(prev, next) {\n    if (!prev) {\n      // Between an editable field and the beginning of the row.\n      if (next && Types.isField(next) &&\n          (/** @type {Field} */ (next)).isEditable) {\n        return this.constants_.MEDIUM_PADDING;\n      }\n      // Inline input at the beginning of the row.\n      if (next && Types.isInlineInput(next)) {\n        return this.constants_.MEDIUM_LARGE_PADDING;\n      }\n      if (next && Types.isStatementInput(next)) {\n        return this.constants_.STATEMENT_INPUT_PADDING_LEFT;\n      }\n      // Anything else at the beginning of the row.\n      return this.constants_.LARGE_PADDING;\n    }\n\n    // Spacing between a non-input and the end of the row or a statement input.\n    if (!Types.isInput(prev) && (!next || Types.isStatementInput(next))) {\n      // Between an editable field and the end of the row.\n      if (Types.isField(prev) && (/** @type {Field} */ (prev)).isEditable) {\n        return this.constants_.MEDIUM_PADDING;\n      }\n      // Padding at the end of an icon-only row to make the block shape clearer.\n      if (Types.isIcon(prev)) {\n        return (this.constants_.LARGE_PADDING * 2) + 1;\n      }\n      if (Types.isHat(prev)) {\n        return this.constants_.NO_PADDING;\n      }\n      // Establish a minimum width for a block with a previous or next\n      // connection.\n      if (Types.isPreviousOrNextConnection(prev)) {\n        return this.constants_.LARGE_PADDING;\n      }\n      // Between rounded corner and the end of the row.\n      if (Types.isLeftRoundedCorner(prev)) {\n        return this.constants_.MIN_BLOCK_WIDTH;\n      }\n      // Between a jagged edge and the end of the row.\n      if (Types.isJaggedEdge(prev)) {\n        return this.constants_.NO_PADDING;\n      }\n      // Between noneditable fields and icons and the end of the row.\n      return this.constants_.LARGE_PADDING;\n    }\n\n    // Between inputs and the end of the row.\n    if (Types.isInput(prev) && !next) {\n      if (Types.isExternalInput(prev)) {\n        return this.constants_.NO_PADDING;\n      } else if (Types.isInlineInput(prev)) {\n        return this.constants_.LARGE_PADDING;\n      } else if (Types.isStatementInput(prev)) {\n        return this.constants_.NO_PADDING;\n      }\n    }\n\n    // Spacing between a non-input and an input.\n    if (!Types.isInput(prev) && next && Types.isInput(next)) {\n      // Between an editable field and an input.\n      if (Types.isField(prev) && (/** @type {Field} */ (prev)).isEditable) {\n        if (Types.isInlineInput(next)) {\n          return this.constants_.SMALL_PADDING;\n        } else if (Types.isExternalInput(next)) {\n          return this.constants_.SMALL_PADDING;\n        }\n      } else {\n        if (Types.isInlineInput(next)) {\n          return this.constants_.MEDIUM_LARGE_PADDING;\n        } else if (Types.isExternalInput(next)) {\n          return this.constants_.MEDIUM_LARGE_PADDING;\n        } else if (Types.isStatementInput(next)) {\n          return this.constants_.LARGE_PADDING;\n        }\n      }\n      return this.constants_.LARGE_PADDING - 1;\n    }\n\n    // Spacing between an icon and an icon or field.\n    if (Types.isIcon(prev) && next && !Types.isInput(next)) {\n      return this.constants_.LARGE_PADDING;\n    }\n\n    // Spacing between an inline input and a field.\n    if (Types.isInlineInput(prev) && next && Types.isField(next)) {\n      // Editable field after inline input.\n      if ((/** @type {Field} */ (next)).isEditable) {\n        return this.constants_.MEDIUM_PADDING;\n      } else {\n        // Noneditable field after inline input.\n        return this.constants_.LARGE_PADDING;\n      }\n    }\n\n    if (Types.isLeftSquareCorner(prev) && next) {\n      // Spacing between a hat and a corner\n      if (Types.isHat(next)) {\n        return this.constants_.NO_PADDING;\n      }\n      // Spacing between a square corner and a previous or next connection\n      if (Types.isPreviousConnection(next)) {\n        return next.notchOffset;\n      } else if (Types.isNextConnection(next)) {\n        // Next connections are shifted slightly to the left (in both LTR and\n        // RTL) to make the dark path under the previous connection show\n        // through.\n        const offset =\n            (this.RTL ? 1 : -1) * this.constants_.DARK_PATH_OFFSET / 2;\n        return next.notchOffset + offset;\n      }\n    }\n\n    // Spacing between a rounded corner and a previous or next connection.\n    if (Types.isLeftRoundedCorner(prev) && next) {\n      if (Types.isPreviousConnection(next)) {\n        return next.notchOffset - this.constants_.CORNER_RADIUS;\n      } else if (Types.isNextConnection(next)) {\n        // Next connections are shifted slightly to the left (in both LTR and\n        // RTL) to make the dark path under the previous connection show\n        // through.\n        const offset =\n            (this.RTL ? 1 : -1) * this.constants_.DARK_PATH_OFFSET / 2;\n        return next.notchOffset - this.constants_.CORNER_RADIUS + offset;\n      }\n    }\n\n    // Spacing between two fields of the same editability.\n    if (Types.isField(prev) && next && Types.isField(next) &&\n        ((/** @type {Field} */ (prev)).isEditable ===\n         (/** @type {Field} */ (next)).isEditable)) {\n      return this.constants_.LARGE_PADDING;\n    }\n\n    // Spacing between anything and a jagged edge.\n    if (next && Types.isJaggedEdge(next)) {\n      return this.constants_.LARGE_PADDING;\n    }\n\n    return this.constants_.MEDIUM_PADDING;\n  }\n\n  /**\n   * @override\n   */\n  getSpacerRowHeight_(prev, next) {\n    // If we have an empty block add a spacer to increase the height.\n    if (Types.isTopRow(prev) && Types.isBottomRow(next)) {\n      return this.constants_.EMPTY_BLOCK_SPACER_HEIGHT;\n    }\n    // Top and bottom rows act as a spacer so we don't need any extra padding.\n    if (Types.isTopRow(prev) || Types.isBottomRow(next)) {\n      return this.constants_.NO_PADDING;\n    }\n    if (prev.hasExternalInput && next.hasExternalInput) {\n      return this.constants_.LARGE_PADDING;\n    }\n    if (!prev.hasStatement && next.hasStatement) {\n      return this.constants_.BETWEEN_STATEMENT_PADDING_Y;\n    }\n    if (prev.hasStatement && next.hasStatement) {\n      return this.constants_.LARGE_PADDING;\n    }\n    if (!prev.hasStatement && next.hasDummyInput) {\n      return this.constants_.LARGE_PADDING;\n    }\n    if (prev.hasDummyInput) {\n      return this.constants_.LARGE_PADDING;\n    }\n    return this.constants_.MEDIUM_PADDING;\n  }\n\n  /**\n   * @override\n   */\n  getElemCenterline_(row, elem) {\n    if (Types.isSpacer(elem)) {\n      return row.yPos + elem.height / 2;\n    }\n    if (Types.isBottomRow(row)) {\n      const bottomRow = /** @type {!BottomRow} */ (row);\n      const baseline =\n          bottomRow.yPos + bottomRow.height - bottomRow.descenderHeight;\n      if (Types.isNextConnection(elem)) {\n        return baseline + elem.height / 2;\n      }\n      return baseline - elem.height / 2;\n    }\n    if (Types.isTopRow(row)) {\n      const topRow = /** @type {!TopRow} */ (row);\n      if (Types.isHat(elem)) {\n        return topRow.capline - elem.height / 2;\n      }\n      return topRow.capline + elem.height / 2;\n    }\n\n    let result = row.yPos;\n    if (Types.isField(elem) || Types.isIcon(elem)) {\n      result += (elem.height / 2);\n      if ((row.hasInlineInput || row.hasStatement) &&\n          elem.height + this.constants_.TALL_INPUT_FIELD_OFFSET_Y <=\n              row.height) {\n        result += this.constants_.TALL_INPUT_FIELD_OFFSET_Y;\n      }\n    } else if (Types.isInlineInput(elem)) {\n      result += elem.height / 2;\n    } else {\n      result += (row.height / 2);\n    }\n    return result;\n  }\n\n  /**\n   * @override\n   */\n  alignRowElements_() {\n    if (!this.isInline) {\n      super.alignRowElements_();\n      return;\n    }\n\n    // Walk backgrounds through rows on the block, keeping track of the right\n    // input edge.\n    let nextRightEdge = 0;\n    const rowNextRightEdges = new WeakMap();\n    let prevInput = null;\n    for (let i = this.rows.length - 1, row; (row = this.rows[i]); i--) {\n      rowNextRightEdges.set(row, nextRightEdge);\n      if (Types.isInputRow(row)) {\n        if (row.hasStatement) {\n          this.alignStatementRow_(\n              /** @type {!InputRow} */ (row));\n        }\n        if (prevInput && prevInput.hasStatement &&\n            row.width < prevInput.width) {\n          rowNextRightEdges.set(row, prevInput.width);\n        } else {\n          nextRightEdge = row.width;\n        }\n        prevInput = row;\n      }\n    }\n    // Walk down each row from the top, comparing the prev and next right input\n    // edges and setting the desired width to the max of the two.\n    let prevRightEdge = 0;\n    for (let i = 0, row; (row = this.rows[i]); i++) {\n      if (row.hasStatement) {\n        prevRightEdge = this.getDesiredRowWidth_(row);\n      } else if (Types.isSpacer(row)) {\n        // Set the spacer row to the max of the prev or next input width.\n        row.width = Math.max(prevRightEdge, rowNextRightEdges.get(row));\n      } else {\n        const currentWidth = row.width;\n        const desiredWidth =\n            Math.max(prevRightEdge, rowNextRightEdges.get(row));\n        const missingSpace = desiredWidth - currentWidth;\n        if (missingSpace > 0) {\n          this.addAlignmentPadding_(row, missingSpace);\n        }\n        prevRightEdge = row.width;\n      }\n    }\n  }\n\n  /**\n   * @override\n   */\n  getDesiredRowWidth_(row) {\n    // Limit the width of a statement row when a block is inline.\n    if (this.isInline && row.hasStatement) {\n      return this.statementEdge + this.constants_.MAX_BOTTOM_WIDTH +\n          this.startX;\n    }\n    return super.getDesiredRowWidth_(row);\n  }\n\n  /**\n   * @override\n   */\n  finalize_() {\n    // Performance note: this could be combined with the draw pass, if the time\n    // that this takes is excessive.  But it shouldn't be, because it only\n    // accesses and sets properties that already exist on the objects.\n    let widestRowWithConnectedBlocks = 0;\n    let yCursor = 0;\n    for (let i = 0, row; (row = this.rows[i]); i++) {\n      row.yPos = yCursor;\n      row.xPos = this.startX;\n      yCursor += row.height;\n\n      widestRowWithConnectedBlocks =\n          Math.max(widestRowWithConnectedBlocks, row.widthWithConnectedBlocks);\n      // Add padding to the bottom row if block height is less than minimum\n      const heightWithoutHat = yCursor - this.topRow.ascenderHeight;\n      if (row === this.bottomRow &&\n          heightWithoutHat < this.constants_.MIN_BLOCK_HEIGHT) {\n        // But the hat height shouldn't be part of this.\n        const diff = this.constants_.MIN_BLOCK_HEIGHT - heightWithoutHat;\n        this.bottomRow.height += diff;\n        yCursor += diff;\n      }\n      this.recordElemPositions_(row);\n    }\n    if (this.outputConnection && this.block_.nextConnection &&\n        this.block_.nextConnection.isConnected()) {\n      // Include width of connected block in value to stack width measurement.\n      widestRowWithConnectedBlocks = Math.max(\n          widestRowWithConnectedBlocks,\n          this.block_.nextConnection.targetBlock().getHeightWidth().width -\n              this.constants_.DARK_PATH_OFFSET);\n    }\n\n    this.bottomRow.baseline = yCursor - this.bottomRow.descenderHeight;\n\n    // The dark (lowlight) adds to the size of the block in both x and y.\n    this.widthWithChildren = widestRowWithConnectedBlocks + this.startX +\n        this.constants_.DARK_PATH_OFFSET;\n    this.width += this.constants_.DARK_PATH_OFFSET;\n    this.height = yCursor + this.constants_.DARK_PATH_OFFSET;\n    this.startY = this.topRow.capline;\n  }\n}\n\nexports.RenderInfo = RenderInfo;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/geras/info.js?")},
"./core/renderers/geras/measurables/inline_input.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/inline_input.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Objects representing inline inputs with connections on a\n * rendered block.\n */\n\n\n/**\n * Objects representing inline inputs with connections on a\n * rendered block.\n * @class\n */\ngoog.module('Blockly.geras.InlineInput');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider: BaseConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider: GerasConstantProvider} = goog.requireType('Blockly.geras.ConstantProvider');\nconst {InlineInput: BaseInlineInput} = goog.require('Blockly.blockRendering.InlineInput');\n/* eslint-disable-next-line no-unused-vars */\nconst {Input} = goog.requireType('Blockly.Input');\n\n\n/**\n * An object containing information about the space an inline input takes up\n * during rendering.\n * @extends {BaseInlineInput}\n * @alias Blockly.geras.InlineInput\n */\nclass InlineInput extends BaseInlineInput {\n  /**\n   * @param {!BaseConstantProvider} constants The rendering\n   *   constants provider.\n   * @param {!Input} input The inline input to measure and store\n   *     information for.\n   * @package\n   */\n  constructor(constants, input) {\n    super(constants, input);\n\n    /** @type {!GerasConstantProvider} */\n    this.constants_;\n\n    if (this.connectedBlock) {\n      // We allow the dark path to show on the parent block so that the child\n      // block looks embossed.  This takes up an extra pixel in both x and y.\n      this.width += this.constants_.DARK_PATH_OFFSET;\n      this.height += this.constants_.DARK_PATH_OFFSET;\n    }\n  }\n}\n\nexports.InlineInput = InlineInput;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/geras/measurables/inline_input.js?")},
"./core/renderers/geras/measurables/statement_input.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/statement_input.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Objects representing statement inputs with connections on a\n * rendered block.\n */\n\n\n/**\n * Objects representing statement inputs with connections on a\n * rendered block.\n * @class\n */\ngoog.module('Blockly.geras.StatementInput');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider: BaseConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider: GerasConstantProvider} = goog.requireType('Blockly.geras.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {Input} = goog.requireType('Blockly.Input');\nconst {StatementInput: BaseStatementInput} = goog.require('Blockly.blockRendering.StatementInput');\n\n\n/**\n * An object containing information about the space a statement input takes up\n * during rendering.\n * @extends {BaseStatementInput}\n * @alias Blockly.geras.StatementInput\n */\nclass StatementInput extends BaseStatementInput {\n  /**\n   * @param {!BaseConstantProvider} constants The rendering\n   *   constants provider.\n   * @param {!Input} input The statement input to measure and store\n   *     information for.\n   * @package\n   */\n  constructor(constants, input) {\n    super(constants, input);\n\n    /** @type {!GerasConstantProvider} */\n    this.constants_;\n\n    if (this.connectedBlock) {\n      // We allow the dark path to show on the parent block so that the child\n      // block looks embossed.  This takes up an extra pixel in both x and y.\n      this.height += this.constants_.DARK_PATH_OFFSET;\n    }\n  }\n}\n\nexports.StatementInput = StatementInput;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/geras/measurables/statement_input.js?")},
"./core/renderers/geras/path_object.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/colour.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/renderers/common/path_object.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview An object that owns a block's rendering SVG elements.\n */\n\n\n\n/**\n * An object that owns a block's rendering SVG elements.\n * @class\n */\ngoog.module('Blockly.geras.PathObject');\n\nconst colour = goog.require('Blockly.utils.colour');\nconst dom = goog.require('Blockly.utils.dom');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.geras.ConstantProvider');\nconst {PathObject: BasePathObject} = goog.require('Blockly.blockRendering.PathObject');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Theme} = goog.requireType('Blockly.Theme');\n\n\n/**\n * An object that handles creating and setting each of the SVG elements\n * used by the renderer.\n * @alias Blockly.geras.PathObject\n */\nclass PathObject extends BasePathObject {\n  /**\n   * @param {!SVGElement} root The root SVG element.\n   * @param {!Theme.BlockStyle} style The style object to use for\n   *     colouring.\n   * @param {!ConstantProvider} constants The renderer's constants.\n   * @package\n   */\n  constructor(root, style, constants) {\n    super(root, style, constants);\n    /**\n     * The renderer's constant provider.\n     * @type {!ConstantProvider}\n     */\n    this.constants = constants;\n\n    /**\n     * The dark path of the block.\n     * @type {SVGElement}\n     * @package\n     */\n    this.svgPathDark = dom.createSvgElement(\n        Svg.PATH, {'class': 'blocklyPathDark', 'transform': 'translate(1,1)'});\n\n    // SVG draw order is based on the order of elements (top most = back most)\n    // So we need to insert the dark path before the base path to make sure it\n    // gets drawn first.\n    this.svgRoot.insertBefore(this.svgPathDark, this.svgPath);\n\n    /**\n     * The light path of the block.\n     * @type {SVGElement}\n     * @package\n     */\n    this.svgPathLight = dom.createSvgElement(\n        Svg.PATH, {'class': 'blocklyPathLight'}, this.svgRoot);\n\n    /**\n     * The colour of the dark path on the block in '#RRGGBB' format.\n     * @type {string}\n     * @package\n     */\n    this.colourDark = '#000000';\n  }\n\n  /**\n   * @override\n   */\n  setPath(mainPath) {\n    this.svgPath.setAttribute('d', mainPath);\n    this.svgPathDark.setAttribute('d', mainPath);\n  }\n\n  /**\n   * Set the highlight path generated by the renderer onto the SVG element.\n   * @param {string} highlightPath The highlight path.\n   * @package\n   */\n  setHighlightPath(highlightPath) {\n    this.svgPathLight.setAttribute('d', highlightPath);\n  }\n\n  /**\n   * @override\n   */\n  flipRTL() {\n    // Mirror the block's path.\n    this.svgPath.setAttribute('transform', 'scale(-1 1)');\n    this.svgPathLight.setAttribute('transform', 'scale(-1 1)');\n    this.svgPathDark.setAttribute('transform', 'translate(1,1) scale(-1 1)');\n  }\n\n  /**\n   * @override\n   */\n  applyColour(block) {\n    this.svgPathLight.style.display = '';\n    this.svgPathDark.style.display = '';\n    this.svgPathLight.setAttribute('stroke', this.style.colourTertiary);\n    this.svgPathDark.setAttribute('fill', this.colourDark);\n\n    super.applyColour(block);\n\n    this.svgPath.setAttribute('stroke', 'none');\n  }\n\n  /**\n   * @override\n   */\n  setStyle(blockStyle) {\n    this.style = blockStyle;\n    this.colourDark =\n        colour.blend('#000', this.style.colourPrimary, 0.2) || this.colourDark;\n  }\n\n  /**\n   * @override\n   */\n  updateHighlighted(highlighted) {\n    if (highlighted) {\n      this.svgPath.setAttribute(\n          'filter', 'url(#' + this.constants.embossFilterId + ')');\n      this.svgPathLight.style.display = 'none';\n    } else {\n      this.svgPath.setAttribute('filter', 'none');\n      this.svgPathLight.style.display = 'inline';\n    }\n  }\n\n  /**\n   * @override\n   */\n  updateShadow_(shadow) {\n    if (shadow) {\n      this.svgPathLight.style.display = 'none';\n      this.svgPathDark.setAttribute('fill', this.style.colourSecondary);\n      this.svgPath.setAttribute('stroke', 'none');\n      this.svgPath.setAttribute('fill', this.style.colourSecondary);\n    }\n  }\n\n  /**\n   * @override\n   */\n  updateDisabled_(disabled) {\n    super.updateDisabled_(disabled);\n    if (disabled) {\n      this.svgPath.setAttribute('stroke', 'none');\n    }\n  }\n}\n\nexports.PathObject = PathObject;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/geras/path_object.js?")},
"./core/renderers/geras/renderer.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/common/block_rendering.js\");\n__webpack_require__(\"./core/renderers/geras/constants.js\");\n__webpack_require__(\"./core/renderers/geras/drawer.js\");\n__webpack_require__(\"./core/renderers/geras/highlight_constants.js\");\n__webpack_require__(\"./core/renderers/geras/path_object.js\");\n__webpack_require__(\"./core/renderers/geras/info.js\");\n__webpack_require__(\"./core/renderers/common/renderer.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Geras renderer.\n */\n\n\n/**\n * Geras renderer.\n * @class\n */\ngoog.module('Blockly.geras.Renderer');\n\nconst blockRendering = goog.require('Blockly.blockRendering');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider: BaseConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {ConstantProvider} = goog.require('Blockly.geras.ConstantProvider');\nconst {Drawer} = goog.require('Blockly.geras.Drawer');\nconst {HighlightConstantProvider} = goog.require('Blockly.geras.HighlightConstantProvider');\nconst {PathObject} = goog.require('Blockly.geras.PathObject');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderInfo: BaseRenderInfo} = goog.requireType('Blockly.blockRendering.RenderInfo');\nconst {RenderInfo} = goog.require('Blockly.geras.RenderInfo');\nconst {Renderer: BaseRenderer} = goog.require('Blockly.blockRendering.Renderer');\n/* eslint-disable-next-line no-unused-vars */\nconst {Theme} = goog.requireType('Blockly.Theme');\n\n\n/**\n * The geras renderer.\n * @extends {BaseRenderer}\n * @alias Blockly.geras.Renderer\n */\nclass Renderer extends BaseRenderer {\n  /**\n   * @param {string} name The renderer name.\n   * @package\n   */\n  constructor(name) {\n    super(name);\n\n    /**\n     * The renderer's highlight constant provider.\n     * @type {HighlightConstantProvider}\n     * @private\n     */\n    this.highlightConstants_ = null;\n  }\n\n  /**\n   * Initialize the renderer.  Geras has a highlight provider in addition to\n   * the normal constant provider.\n   * @package\n   * @override\n   */\n  init(theme, opt_rendererOverrides) {\n    super.init(theme, opt_rendererOverrides);\n    this.highlightConstants_ = this.makeHighlightConstants_();\n    this.highlightConstants_.init();\n  }\n\n  /**\n   * @override\n   */\n  refreshDom(svg, theme) {\n    super.refreshDom(svg, theme);\n    this.getHighlightConstants().init();\n  }\n\n  /**\n   * @override\n   */\n  makeConstants_() {\n    return new ConstantProvider();\n  }\n\n  /**\n   * Create a new instance of the renderer's render info object.\n   * @param {!BlockSvg} block The block to measure.\n   * @return {!RenderInfo} The render info object.\n   * @protected\n   * @override\n   */\n  makeRenderInfo_(block) {\n    return new RenderInfo(this, block);\n  }\n\n  /**\n   * Create a new instance of the renderer's drawer.\n   * @param {!BlockSvg} block The block to render.\n   * @param {!BaseRenderInfo} info An object containing all information needed\n   *     to render this block.\n   * @return {!Drawer} The drawer.\n   * @protected\n   * @override\n   */\n  makeDrawer_(block, info) {\n    return new Drawer(\n        block,\n        /** @type {!RenderInfo} */ (info));\n  }\n\n  /**\n   * Create a new instance of a renderer path object.\n   * @param {!SVGElement} root The root SVG element.\n   * @param {!Theme.BlockStyle} style The style object to use for colouring.\n   * @return {!PathObject} The renderer path object.\n   * @package\n   * @override\n   */\n  makePathObject(root, style) {\n    return new PathObject(\n        root, style,\n        /** @type {!ConstantProvider} */ (this.getConstants()));\n  }\n\n  /**\n   * Create a new instance of the renderer's highlight constant provider.\n   * @return {!HighlightConstantProvider} The highlight constant provider.\n   * @protected\n   */\n  makeHighlightConstants_() {\n    return new HighlightConstantProvider(\n        /** @type {!BaseConstantProvider} */\n        (this.getConstants()));\n  }\n\n  /**\n   * Get the renderer's highlight constant provider.  We assume that when this\n   * is called, the renderer has already been initialized.\n   * @return {!HighlightConstantProvider} The highlight constant provider.\n   * @package\n   */\n  getHighlightConstants() {\n    return (\n        /** @type {!HighlightConstantProvider} */\n        (this.highlightConstants_));\n  }\n}\n\nblockRendering.register('geras', Renderer);\n\nexports.Renderer = Renderer;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/geras/renderer.js?")},
"./core/renderers/measurables/base.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Methods for graphically rendering a block as SVG.\n */\n\n\n\n/**\n * Methods for graphically rendering a block as SVG.\n * @class\n */\ngoog.module('Blockly.blockRendering.Measurable');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * The base class to represent a part of a block that takes up space during\n * rendering.  The constructor for each non-spacer Measurable records the size\n * of the block element (e.g. field, statement input).\n * @alias Blockly.blockRendering.Measurable\n */\nclass Measurable {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @package\n   */\n  constructor(constants) {\n    /** @type {number} */\n    this.width = 0;\n\n    /** @type {number} */\n    this.height = 0;\n\n    /** @type {number} */\n    this.type = Types.NONE;\n\n    /** @type {number} */\n    this.xPos = 0;\n\n    /** @type {number} */\n    this.centerline = 0;\n\n    /**\n     * The renderer's constant provider.\n     * @type {!ConstantProvider}\n     * @protected\n     */\n    this.constants_ = constants;\n\n    /** @type {number} */\n    this.notchOffset = this.constants_.NOTCH_OFFSET_LEFT;\n  }\n}\n\nexports.Measurable = Measurable;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/base.js?")},
"./core/renderers/measurables/bottom_row.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/row.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing a bottom row on a rendered block.\n * of its subcomponents.\n */\n\n/**\n * Object representing a bottom row on a rendered block.\n * of its subcomponents.\n * @class\n */\ngoog.module('Blockly.blockRendering.BottomRow');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {NextConnection} = goog.requireType('Blockly.blockRendering.NextConnection');\nconst {Row} = goog.require('Blockly.blockRendering.Row');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing information about what elements are in the bottom row of\n * a block as well as spacing information for the bottom row.\n * Elements in a bottom row can consist of corners, spacers and next\n * connections.\n * @extends {Row}\n * @struct\n * @alias Blockly.blockRendering.BottomRow\n */\nclass BottomRow extends Row {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @package\n   */\n  constructor(constants) {\n    super(constants);\n    this.type |= Types.BOTTOM_ROW;\n\n    /**\n     * Whether this row has a next connection.\n     * @package\n     * @type {boolean}\n     */\n    this.hasNextConnection = false;\n\n    /**\n     * The next connection on the row, if any.\n     * @package\n     * @type {NextConnection}\n     */\n    this.connection = null;\n\n    /**\n     * The amount that the bottom of the block extends below the horizontal\n     * edge, e.g. because of a next connection.  Must be non-negative (see\n     * #2820).\n     * @package\n     * @type {number}\n     */\n    this.descenderHeight = 0;\n\n    /**\n     * The Y position of the bottom edge of the block, relative to the origin\n     * of the block rendering.\n     * @type {number}\n     */\n    this.baseline = 0;\n  }\n\n  /**\n   * Returns whether or not the bottom row has a left square corner.\n   * @param {!BlockSvg} block The block whose bottom row this represents.\n   * @return {boolean} Whether or not the bottom row has a left square corner.\n   */\n  hasLeftSquareCorner(block) {\n    return !!block.outputConnection || !!block.getNextBlock();\n  }\n\n  /**\n   * Returns whether or not the bottom row has a right square corner.\n   * @param {!BlockSvg} _block The block whose bottom row this represents.\n   * @return {boolean} Whether or not the bottom row has a right square corner.\n   */\n  hasRightSquareCorner(_block) {\n    return true;\n  }\n\n  /**\n   * @override\n   */\n  measure() {\n    let height = 0;\n    let width = 0;\n    let descenderHeight = 0;\n    for (let i = 0; i < this.elements.length; i++) {\n      const elem = this.elements[i];\n      width += elem.width;\n      if (!(Types.isSpacer(elem))) {\n        // Note: this assumes that next connections have *only* descenderHeight,\n        // with no height above the baseline.\n        if (Types.isNextConnection(elem)) {\n          descenderHeight = Math.max(descenderHeight, elem.height);\n        } else {\n          height = Math.max(height, elem.height);\n        }\n      }\n    }\n    this.width = Math.max(this.minWidth, width);\n    this.height = Math.max(this.minHeight, height) + descenderHeight;\n    this.descenderHeight = descenderHeight;\n    this.widthWithConnectedBlocks = this.width;\n  }\n\n  /**\n   * @override\n   */\n  startsWithElemSpacer() {\n    return false;\n  }\n\n  /**\n   * @override\n   */\n  endsWithElemSpacer() {\n    return false;\n  }\n}\n\nexports.BottomRow = BottomRow;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/bottom_row.js?")},
"./core/renderers/measurables/connection.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/base.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Base class representing the space a connection takes up during\n * rendering.\n */\n\n/**\n * Base class representing the space a connection takes up during\n * rendering.\n * @class\n */\ngoog.module('Blockly.blockRendering.Connection');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {Measurable} = goog.require('Blockly.blockRendering.Measurable');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderedConnection} = goog.requireType('Blockly.RenderedConnection');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * The base class to represent a connection and the space that it takes up on\n * the block.\n * @extends {Measurable}\n * @alias Blockly.blockRendering.Connection\n */\nclass Connection extends Measurable {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @param {!RenderedConnection} connectionModel The connection object on\n   *     the block that this represents.\n   * @package\n   */\n  constructor(constants, connectionModel) {\n    super(constants);\n\n    /** @type {!RenderedConnection} */\n    this.connectionModel = connectionModel;\n\n    /** @type {!Object} */\n    this.shape = this.constants_.shapeFor(connectionModel);\n\n    /** @type {boolean} */\n    this.isDynamicShape = !!this.shape['isDynamic'];\n    this.type |= Types.CONNECTION;\n  }\n}\n\nexports.Connection = Connection;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/connection.js?")},
"./core/renderers/measurables/external_value_input.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/input_connection.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class representing external value inputs with connections on a\n * rendered block.\n */\n\n/**\n * Class representing external value inputs with connections on a\n * rendered block.\n * @class\n */\ngoog.module('Blockly.blockRendering.ExternalValueInput');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {InputConnection} = goog.require('Blockly.blockRendering.InputConnection');\n/* eslint-disable-next-line no-unused-vars */\nconst {Input} = goog.requireType('Blockly.Input');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing information about the space an external value input\n * takes up during rendering\n * @struct\n * @extends {InputConnection}\n * @alias Blockly.blockRendering.ExternalValueInput\n */\nclass ExternalValueInput extends InputConnection {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @param {!Input} input The external value input to measure and store\n   *     information for.\n   * @package\n   */\n  constructor(constants, input) {\n    super(constants, input);\n    this.type |= Types.EXTERNAL_VALUE_INPUT;\n\n    /** @type {number} */\n    this.height = 0;\n    if (!this.connectedBlock) {\n      this.height = this.shape.height;\n    } else {\n      this.height = this.connectedBlockHeight -\n          this.constants_.TAB_OFFSET_FROM_TOP - this.constants_.MEDIUM_PADDING;\n    }\n\n    /** @type {number} */\n    this.width =\n        this.shape.width + this.constants_.EXTERNAL_VALUE_INPUT_PADDING;\n\n    /** @type {number} */\n    this.connectionOffsetY = this.constants_.TAB_OFFSET_FROM_TOP;\n\n    /** @type {number} */\n    this.connectionHeight = this.shape.height;\n\n    /** @type {number} */\n    this.connectionWidth = this.shape.width;\n  }\n}\n\nexports.ExternalValueInput = ExternalValueInput;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/external_value_input.js?")},
"./core/renderers/measurables/field.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/base.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Objects representing a field in a row of a rendered\n * block.\n */\n\n/**\n * Objects representing a field in a row of a rendered\n * block.\n * @class\n */\ngoog.module('Blockly.blockRendering.Field');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {Field: BlocklyField} = goog.requireType('Blockly.Field');\n/* eslint-disable-next-line no-unused-vars */\nconst {Input} = goog.requireType('Blockly.Input');\nconst {Measurable} = goog.require('Blockly.blockRendering.Measurable');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing information about the space a field takes up during\n * rendering\n * @struct\n * @extends {Measurable}\n * @alias Blockly.blockRendering.Field\n */\nclass Field extends Measurable {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @param {!BlocklyField} field The field to measure and store information\n   *     for.\n   * @param {!Input} parentInput The parent input for the field.\n   * @package\n   */\n  constructor(constants, field, parentInput) {\n    super(constants);\n\n    /** @type {!BlocklyField} */\n    this.field = field;\n\n    /** @type {boolean} */\n    this.isEditable = field.EDITABLE;\n\n    /** @type {boolean} */\n    this.flipRtl = field.getFlipRtl();\n    this.type |= Types.FIELD;\n\n    const size = this.field.getSize();\n\n    /** @type {number} */\n    this.height = size.height;\n\n    /** @type {number} */\n    this.width = size.width;\n\n    /** @type {!Input} */\n    this.parentInput = parentInput;\n  }\n}\n\nexports.Field = Field;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/field.js?")},
"./core/renderers/measurables/hat.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/base.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Objects representing a hat in a row of a rendered\n * block.\n */\n\n/**\n * Objects representing a hat in a row of a rendered\n * block.\n * @class\n */\ngoog.module('Blockly.blockRendering.Hat');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {Measurable} = goog.require('Blockly.blockRendering.Measurable');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing information about the space a hat takes up during\n * rendering.\n * @struct\n * @extends {Measurable}\n * @alias Blockly.blockRendering.Hat\n */\nclass Hat extends Measurable {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @package\n   */\n  constructor(constants) {\n    super(constants);\n    this.type |= Types.HAT;\n\n    this.height = this.constants_.START_HAT.height;\n    this.width = this.constants_.START_HAT.width;\n\n    /** @type {number} */\n    this.ascenderHeight = this.height;\n  }\n}\n\nexports.Hat = Hat;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/hat.js?")},
"./core/renderers/measurables/icon.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/base.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Objects representing an icon in a row of a rendered\n * block.\n */\n\n/**\n * Objects representing an icon in a row of a rendered\n * block.\n * @class\n */\ngoog.module('Blockly.blockRendering.Icon');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {Icon: BlocklyIcon} = goog.requireType('Blockly.Icon');\nconst {Measurable} = goog.require('Blockly.blockRendering.Measurable');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing information about the space an icon takes up during\n * rendering\n * @extends {Measurable}\n * @struct\n * @alias Blockly.blockRendering.Icon\n */\nclass Icon extends Measurable {\n  /**\n   * An object containing information about the space an icon takes up during\n   * rendering\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @param {!BlocklyIcon} icon The icon to measure and store information for.\n   * @package\n   */\n  constructor(constants, icon) {\n    super(constants);\n\n    /** @type {!BlocklyIcon} */\n    this.icon = icon;\n\n    /** @type {boolean} */\n    this.isVisible = icon.isVisible();\n    this.type |= Types.ICON;\n\n    const size = icon.getCorrectedSize();\n    this.height = size.height;\n    this.width = size.width;\n  }\n}\nexports.Icon = Icon;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/icon.js?")},
"./core/renderers/measurables/in_row_spacer.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/base.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Objects representing a spacer in a row of a rendered\n * block.\n */\n\n/**\n * Objects representing a spacer in a row of a rendered\n * block.\n * @class\n */\ngoog.module('Blockly.blockRendering.InRowSpacer');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {Measurable} = goog.require('Blockly.blockRendering.Measurable');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing information about a spacer between two elements on a\n * row.\n * @extends {Measurable}\n * @struct\n * @alias Blockly.blockRendering.InRowSpacer\n */\nclass InRowSpacer extends Measurable {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @param {number} width The width of the spacer.\n   * @package\n   */\n  constructor(constants, width) {\n    super(constants);\n    this.type |= Types.SPACER | Types.IN_ROW_SPACER;\n    this.width = width;\n    this.height = this.constants_.SPACER_DEFAULT_HEIGHT;\n  }\n}\n\nexports.InRowSpacer = InRowSpacer;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/in_row_spacer.js?")},
"./core/renderers/measurables/inline_input.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/input_connection.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class representing inline inputs with connections on a rendered\n * block.\n */\n\n/**\n * Class representing inline inputs with connections on a rendered\n * block.\n * @class\n */\ngoog.module('Blockly.blockRendering.InlineInput');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {InputConnection} = goog.require('Blockly.blockRendering.InputConnection');\n/* eslint-disable-next-line no-unused-vars */\nconst {Input} = goog.requireType('Blockly.Input');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing information about the space an inline input takes up\n * during rendering\n * @extends {InputConnection}\n * @struct\n * @alias Blockly.blockRendering.InlineInput\n */\nclass InlineInput extends InputConnection {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @param {!Input} input The inline input to measure and store\n   *     information for.\n   * @package\n   */\n  constructor(constants, input) {\n    super(constants, input);\n    this.type |= Types.INLINE_INPUT;\n\n    if (!this.connectedBlock) {\n      this.height = this.constants_.EMPTY_INLINE_INPUT_HEIGHT;\n      this.width = this.constants_.EMPTY_INLINE_INPUT_PADDING;\n    } else {\n      // We allow the dark path to show on the parent block so that the child\n      // block looks embossed.  This takes up an extra pixel in both x and y.\n      this.width = this.connectedBlockWidth;\n      this.height = this.connectedBlockHeight;\n    }\n\n    /** @type {number} */\n    this.connectionHeight = !this.isDynamicShape ?\n        this.shape.height :\n        this.shape.height(this.height);\n\n    /** @type {number} */\n    this.connectionWidth =\n        !this.isDynamicShape ? this.shape.width : this.shape.width(this.height);\n    if (!this.connectedBlock) {\n      this.width += this.connectionWidth * (this.isDynamicShape ? 2 : 1);\n    }\n\n    /** @type {number} */\n    this.connectionOffsetY = this.isDynamicShape ?\n        this.shape.connectionOffsetY(this.connectionHeight) :\n        this.constants_.TAB_OFFSET_FROM_TOP;\n\n    /** @type {number} */\n    this.connectionOffsetX = this.isDynamicShape ?\n        this.shape.connectionOffsetX(this.connectionWidth) :\n        0;\n  }\n}\n\nexports.InlineInput = InlineInput;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/inline_input.js?")},
"./core/renderers/measurables/input_connection.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/connection.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class representing inputs with connections on a rendered block.\n */\n\n/**\n * Class representing inputs with connections on a rendered block.\n * @class\n */\ngoog.module('Blockly.blockRendering.InputConnection');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {Connection} = goog.require('Blockly.blockRendering.Connection');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {Input} = goog.requireType('Blockly.Input');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderedConnection} = goog.requireType('Blockly.RenderedConnection');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * The base class to represent an input that takes up space on a block\n * during rendering\n * @package\n * @extends {Connection}\n * @alias Blockly.blockRendering.InputConnection\n */\nclass InputConnection extends Connection {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @param {!Input} input The input to measure and store information for.\n   */\n  constructor(constants, input) {\n    super(constants, /** @type {!RenderedConnection} */ (input.connection));\n\n    this.type |= Types.INPUT;\n\n    /** @type {!Input} */\n    this.input = input;\n\n    /** @type {number} */\n    this.align = input.align;\n\n    /** @type {BlockSvg} */\n    this.connectedBlock = input.connection && input.connection.targetBlock() ?\n        /** @type {BlockSvg} */ (input.connection.targetBlock()) :\n        null;\n\n    if (this.connectedBlock) {\n      const bBox = this.connectedBlock.getHeightWidth();\n      this.connectedBlockWidth = bBox.width;\n      this.connectedBlockHeight = bBox.height;\n    } else {\n      this.connectedBlockWidth = 0;\n      this.connectedBlockHeight = 0;\n    }\n\n    /** @type {number} */\n    this.connectionOffsetX = 0;\n\n    /** @type {number} */\n    this.connectionOffsetY = 0;\n  }\n}\n\nexports.InputConnection = InputConnection;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/input_connection.js?")},
"./core/renderers/measurables/input_row.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/input_connection.js\");\n__webpack_require__(\"./core/renderers/measurables/external_value_input.js\");\n__webpack_require__(\"./core/renderers/measurables/row.js\");\n__webpack_require__(\"./core/renderers/measurables/statement_input.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing a row that holds one or more inputs on a\n * rendered block.\n */\n\n/**\n * Object representing a row that holds one or more inputs on a\n * rendered block.\n * @class\n */\ngoog.module('Blockly.blockRendering.InputRow');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {InputConnection} = goog.require('Blockly.blockRendering.InputConnection');\nconst {ExternalValueInput} = goog.require('Blockly.blockRendering.ExternalValueInput');\nconst {Row} = goog.require('Blockly.blockRendering.Row');\nconst {StatementInput} = goog.require('Blockly.blockRendering.StatementInput');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing information about a row that holds one or more inputs.\n * @extends {Row}\n * @struct\n * @alias Blockly.blockRendering.InputRow\n */\nclass InputRow extends Row {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @package\n   */\n  constructor(constants) {\n    super(constants);\n    this.type |= Types.INPUT_ROW;\n\n    /**\n     * The total width of all blocks connected to this row.\n     * @type {number}\n     * @package\n     */\n    this.connectedBlockWidths = 0;\n  }\n\n  /**\n   * Inspect all subcomponents and populate all size properties on the row.\n   * @package\n   */\n  measure() {\n    this.width = this.minWidth;\n    this.height = this.minHeight;\n    let connectedBlockWidths = 0;\n    for (let i = 0; i < this.elements.length; i++) {\n      const elem = this.elements[i];\n      this.width += elem.width;\n      if (Types.isInput(elem) && elem instanceof InputConnection) {\n        if (Types.isStatementInput(elem) && elem instanceof StatementInput) {\n          connectedBlockWidths += elem.connectedBlockWidth;\n        } else if (\n            Types.isExternalInput(elem) && elem instanceof ExternalValueInput &&\n            elem.connectedBlockWidth !== 0) {\n          connectedBlockWidths +=\n              (elem.connectedBlockWidth - elem.connectionWidth);\n        }\n      }\n      if (!(Types.isSpacer(elem))) {\n        this.height = Math.max(this.height, elem.height);\n      }\n    }\n    this.connectedBlockWidths = connectedBlockWidths;\n    this.widthWithConnectedBlocks = this.width + connectedBlockWidths;\n  }\n\n  /**\n   * @override\n   */\n  endsWithElemSpacer() {\n    return !this.hasExternalInput && !this.hasStatement;\n  }\n}\n\nexports.InputRow = InputRow;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/input_row.js?")},
"./core/renderers/measurables/jagged_edge.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/base.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Objects representing a jagged edge in a row of a rendered\n * block.\n */\n\n/**\n * Objects representing a jagged edge in a row of a rendered\n * block.\n * @class\n */\ngoog.module('Blockly.blockRendering.JaggedEdge');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {Measurable} = goog.require('Blockly.blockRendering.Measurable');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing information about the jagged edge of a collapsed block\n * takes up during rendering\n * @extends {Measurable}\n * @struct\n * @alias Blockly.blockRendering.JaggedEdge\n */\nclass JaggedEdge extends Measurable {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @package\n   */\n  constructor(constants) {\n    super(constants);\n    this.type |= Types.JAGGED_EDGE;\n    this.height = this.constants_.JAGGED_TEETH.height;\n    this.width = this.constants_.JAGGED_TEETH.width;\n  }\n}\n\nexports.JaggedEdge = JaggedEdge;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/jagged_edge.js?")},
"./core/renderers/measurables/next_connection.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/connection.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class representing the space a next connection takes up during\n * rendering.\n */\n\n/**\n * Class representing the space a next connection takes up during\n * rendering.\n * @class\n */\ngoog.module('Blockly.blockRendering.NextConnection');\n\nconst {Connection} = goog.require('Blockly.blockRendering.Connection');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderedConnection} = goog.requireType('Blockly.RenderedConnection');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing information about the space a next connection takes\n * up during rendering.\n * @extends {Connection}\n * @struct\n * @alias Blockly.blockRendering.NextConnection\n */\nclass NextConnection extends Connection {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @param {!RenderedConnection} connectionModel The connection object on\n   *     the block that this represents.\n   * @package\n   */\n  constructor(constants, connectionModel) {\n    super(constants, connectionModel);\n    this.type |= Types.NEXT_CONNECTION;\n    this.height = this.shape.height;\n    this.width = this.shape.width;\n  }\n}\n\nexports.NextConnection = NextConnection;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/next_connection.js?")},
"./core/renderers/measurables/output_connection.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/connection.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class representing the space a output connection takes up\n * during rendering.\n */\n\n/**\n * Class representing the space a output connection takes up\n * during rendering.\n * @class\n */\ngoog.module('Blockly.blockRendering.OutputConnection');\n\nconst {Connection} = goog.require('Blockly.blockRendering.Connection');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderedConnection} = goog.requireType('Blockly.RenderedConnection');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing information about the space an output connection takes\n * up during rendering.\n * @extends {Connection}\n * @struct\n * @alias Blockly.blockRendering.OutputConnection\n */\nclass OutputConnection extends Connection {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @param {!RenderedConnection} connectionModel The connection object on\n   *     the block that this represents.\n   * @package\n   */\n  constructor(constants, connectionModel) {\n    super(constants, connectionModel);\n    this.type |= Types.OUTPUT_CONNECTION;\n\n    this.height = !this.isDynamicShape ? this.shape.height : 0;\n    this.width = !this.isDynamicShape ? this.shape.width : 0;\n\n    /** @type {number} */\n    this.startX = this.width;\n\n    /** @type {number} */\n    this.connectionOffsetY = this.constants_.TAB_OFFSET_FROM_TOP;\n\n    /** @type {number} */\n    this.connectionOffsetX = 0;\n  }\n}\n\nexports.OutputConnection = OutputConnection;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/output_connection.js?")},
"./core/renderers/measurables/previous_connection.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/connection.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class representing the space a previous connection takes up\n * during rendering.\n */\n\n/**\n * Class representing the space a previous connection takes up\n * during rendering.\n * @class\n */\ngoog.module('Blockly.blockRendering.PreviousConnection');\n\nconst {Connection} = goog.require('Blockly.blockRendering.Connection');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderedConnection} = goog.requireType('Blockly.RenderedConnection');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing information about the space a previous connection takes\n * up during rendering.\n * @extends {Connection}\n * @struct\n * @alias Blockly.blockRendering.PreviousConnection\n */\nclass PreviousConnection extends Connection {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @param {!RenderedConnection} connectionModel The connection object on\n   *     the block that this represents.\n   * @package\n   */\n  constructor(constants, connectionModel) {\n    super(constants, connectionModel);\n    this.type |= Types.PREVIOUS_CONNECTION;\n    this.height = this.shape.height;\n    this.width = this.shape.width;\n  }\n}\n\nexports.PreviousConnection = PreviousConnection;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/previous_connection.js?")},
"./core/renderers/measurables/round_corner.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/base.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Objects representing a round corner in a row of a rendered\n * block.\n */\n\n/**\n * Objects representing a round corner in a row of a rendered\n * block.\n * @class\n */\ngoog.module('Blockly.blockRendering.RoundCorner');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {Measurable} = goog.require('Blockly.blockRendering.Measurable');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing information about the space a rounded corner takes up\n * during rendering.\n * @extends {Measurable}\n * @struct\n * @alias Blockly.blockRendering.RoundCorner\n */\nclass RoundCorner extends Measurable {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @param {string=} opt_position The position of this corner.\n   * @package\n   */\n  constructor(constants, opt_position) {\n    super(constants);\n    this.type = ((!opt_position || opt_position === 'left') ?\n                     Types.LEFT_ROUND_CORNER :\n                     Types.RIGHT_ROUND_CORNER) |\n        Types.CORNER;\n    this.width = this.constants_.CORNER_RADIUS;\n    // The rounded corner extends into the next row by 4 so we only take the\n    // height that is aligned with this row.\n    this.height = this.constants_.CORNER_RADIUS / 2;\n  }\n}\n\nexports.RoundCorner = RoundCorner;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/round_corner.js?")},
"./core/renderers/measurables/row.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing a single row on a rendered block.\n */\n\n/**\n * Object representing a single row on a rendered block.\n * @class\n */\ngoog.module('Blockly.blockRendering.Row');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {InRowSpacer} = goog.requireType('Blockly.blockRendering.InRowSpacer');\n/* eslint-disable-next-line no-unused-vars */\nconst {InputConnection} = goog.requireType('Blockly.blockRendering.InputConnection');\n/* eslint-disable-next-line no-unused-vars */\nconst {Measurable} = goog.requireType('Blockly.blockRendering.Measurable');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object representing a single row on a rendered block and all of its\n * subcomponents.\n * @alias Blockly.blockRendering.Row\n */\nclass Row {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @package\n   */\n  constructor(constants) {\n    /**\n     * The type of this rendering object.\n     * @package\n     * @type {number}\n     */\n    this.type = Types.ROW;\n\n    /**\n     * An array of elements contained in this row.\n     * @package\n     * @type {!Array<!Measurable>}\n     */\n    this.elements = [];\n\n    /**\n     * The height of the row.\n     * @package\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * The width of the row, from the left edge of the block to the right.\n     * Does not include child blocks unless they are inline.\n     * @package\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     * The minimum height of the row.\n     * @package\n     * @type {number}\n     */\n    this.minHeight = 0;\n\n    /**\n     * The minimum width of the row, from the left edge of the block to the\n     * right. Does not include child blocks unless they are inline.\n     * @package\n     * @type {number}\n     */\n    this.minWidth = 0;\n\n    /**\n     * The width of the row, from the left edge of the block to the edge of the\n     * block or any connected child blocks.\n     * @package\n     * @type {number}\n     */\n    this.widthWithConnectedBlocks = 0;\n\n    /**\n     * The Y position of the row relative to the origin of the block's svg\n     * group.\n     * @package\n     * @type {number}\n     */\n    this.yPos = 0;\n\n    /**\n     * The X position of the row relative to the origin of the block's svg\n     * group.\n     * @package\n     * @type {number}\n     */\n    this.xPos = 0;\n\n    /**\n     * Whether the row has any external inputs.\n     * @package\n     * @type {boolean}\n     */\n    this.hasExternalInput = false;\n\n    /**\n     * Whether the row has any statement inputs.\n     * @package\n     * @type {boolean}\n     */\n    this.hasStatement = false;\n\n    /**\n     * Where the left edge of all of the statement inputs on the block should\n     * be. This makes sure that statement inputs which are proceded by fields\n     * of varius widths are all aligned.\n     * @type {number}\n     */\n    this.statementEdge = 0;\n\n    /**\n     * Whether the row has any inline inputs.\n     * @package\n     * @type {boolean}\n     */\n    this.hasInlineInput = false;\n\n    /**\n     * Whether the row has any dummy inputs.\n     * @package\n     * @type {boolean}\n     */\n    this.hasDummyInput = false;\n\n    /**\n     * Whether the row has a jagged edge.\n     * @package\n     * @type {boolean}\n     */\n    this.hasJaggedEdge = false;\n\n    /**\n     * The renderer's constant provider.\n     * @type {!ConstantProvider}\n     * @protected\n     */\n    this.constants_ = constants;\n\n    /**\n     * @type {number}\n     */\n    this.notchOffset = this.constants_.NOTCH_OFFSET_LEFT;\n\n    /**\n     * Alignment of the row.\n     * @package\n     * @type {?number}\n     */\n    this.align = null;\n  }\n\n  /**\n   * Get the last input on this row, if it has one.\n   * @return {InputConnection} The last input on the row,\n   *     or null.\n   * @package\n   */\n  getLastInput() {\n    // TODO: Consider moving this to InputRow, if possible.\n    for (let i = this.elements.length - 1; i >= 0; i--) {\n      const elem = this.elements[i];\n      if (Types.isInput(elem)) {\n        return /** @type {InputConnection} */ (elem);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Inspect all subcomponents and populate all size properties on the row.\n   * @package\n   */\n  measure() {\n    throw Error('Unexpected attempt to measure a base Row.');\n  }\n\n  /**\n   * Determines whether this row should start with an element spacer.\n   * @return {boolean} Whether the row should start with a spacer.\n   * @package\n   */\n  startsWithElemSpacer() {\n    return true;\n  }\n\n  /**\n   * Determines whether this row should end with an element spacer.\n   * @return {boolean} Whether the row should end with a spacer.\n   * @package\n   */\n  endsWithElemSpacer() {\n    return true;\n  }\n\n  /**\n   * Convenience method to get the first spacer element on this row.\n   * @return {InRowSpacer} The first spacer element on\n   *   this row.\n   * @package\n   */\n  getFirstSpacer() {\n    for (let i = 0; i < this.elements.length; i++) {\n      const elem = this.elements[i];\n      if (Types.isSpacer(elem)) {\n        return /** @type {InRowSpacer} */ (elem);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Convenience method to get the last spacer element on this row.\n   * @return {InRowSpacer} The last spacer element on\n   *   this row.\n   * @package\n   */\n  getLastSpacer() {\n    for (let i = this.elements.length - 1; i >= 0; i--) {\n      const elem = this.elements[i];\n      if (Types.isSpacer(elem)) {\n        return /** @type {InRowSpacer} */ (elem);\n      }\n    }\n    return null;\n  }\n}\n\nexports.Row = Row;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/row.js?")},
"./core/renderers/measurables/spacer_row.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/in_row_spacer.js\");\n__webpack_require__(\"./core/renderers/measurables/row.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing a spacer between two rows.\n */\n\n/**\n * Object representing a spacer between two rows.\n * @class\n */\ngoog.module('Blockly.blockRendering.SpacerRow');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {InRowSpacer} = goog.require('Blockly.blockRendering.InRowSpacer');\nconst {Row} = goog.require('Blockly.blockRendering.Row');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing information about a spacer between two rows.\n * @extends {Row}\n * @struct\n * @alias Blockly.blockRendering.SpacerRow\n */\nclass SpacerRow extends Row {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @param {number} height The height of the spacer.\n   * @param {number} width The width of the spacer.\n   * @package\n   */\n  constructor(constants, height, width) {\n    super(constants);\n    this.type |= Types.SPACER | Types.BETWEEN_ROW_SPACER;\n\n    /** @type {number} */\n    this.width = width;\n\n    /** @type {number} */\n    this.height = height;\n\n    /** @type {boolean} */\n    this.followsStatement = false;\n\n    /** @type {boolean} */\n    this.precedesStatement = false;\n\n    /** @type {number} */\n    this.widthWithConnectedBlocks = 0;\n\n    /** @type {!Array.<!InRowSpacer>} */\n    this.elements = [new InRowSpacer(this.constants_, width)];\n  }\n\n  /**\n   * @override\n   */\n  measure() {\n    // NOP.  Width and height were set at creation.\n  }\n}\n\nexports.SpacerRow = SpacerRow;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/spacer_row.js?")},
"./core/renderers/measurables/square_corner.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/base.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Objects representing a square corner in a row of a rendered\n * block.\n */\n\n/**\n * Objects representing a square corner in a row of a rendered\n * block.\n * @class\n */\ngoog.module('Blockly.blockRendering.SquareCorner');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {Measurable} = goog.require('Blockly.blockRendering.Measurable');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing information about the space a square corner takes up\n * during rendering.\n * @extends {Measurable}\n * @struct\n * @alias Blockly.blockRendering.SquareCorner\n */\nclass SquareCorner extends Measurable {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @param {string=} opt_position The position of this corner.\n   * @package\n   */\n  constructor(constants, opt_position) {\n    super(constants);\n    this.type = ((!opt_position || opt_position === 'left') ?\n                     Types.LEFT_SQUARE_CORNER :\n                     Types.RIGHT_SQUARE_CORNER) |\n        Types.CORNER;\n    this.height = this.constants_.NO_PADDING;\n    this.width = this.constants_.NO_PADDING;\n  }\n}\n\nexports.SquareCorner = SquareCorner;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/square_corner.js?")},
"./core/renderers/measurables/statement_input.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/input_connection.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class representing statement inputs with connections on a\n * rendered block.\n */\n\n/**\n * Class representing statement inputs with connections on a\n * rendered block.\n * @class\n */\ngoog.module('Blockly.blockRendering.StatementInput');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {InputConnection} = goog.require('Blockly.blockRendering.InputConnection');\n/* eslint-disable-next-line no-unused-vars */\nconst {Input} = goog.requireType('Blockly.Input');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing information about the space a statement input takes up\n * during rendering\n * @struct\n * @extends {InputConnection}\n * @alias Blockly.blockRendering.StatementInput\n */\nclass StatementInput extends InputConnection {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @param {!Input} input The statement input to measure and store\n   *     information for.\n   * @package\n   */\n  constructor(constants, input) {\n    super(constants, input);\n    this.type |= Types.STATEMENT_INPUT;\n\n    if (!this.connectedBlock) {\n      this.height = this.constants_.EMPTY_STATEMENT_INPUT_HEIGHT;\n    } else {\n      // We allow the dark path to show on the parent block so that the child\n      // block looks embossed.  This takes up an extra pixel in both x and y.\n      this.height =\n          this.connectedBlockHeight + this.constants_.STATEMENT_BOTTOM_SPACER;\n    }\n    this.width =\n        this.constants_.STATEMENT_INPUT_NOTCH_OFFSET + this.shape.width;\n  }\n}\n\nexports.StatementInput = StatementInput;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/statement_input.js?")},
"./core/renderers/measurables/top_row.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/hat.js\");\n__webpack_require__(\"./core/renderers/measurables/row.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing a top row on a rendered block.\n */\n\n/**\n * Object representing a top row on a rendered block.\n * @class\n */\ngoog.module('Blockly.blockRendering.TopRow');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {Hat} = goog.require('Blockly.blockRendering.Hat');\n/* eslint-disable-next-line no-unused-vars */\nconst {PreviousConnection} = goog.requireType('Blockly.blockRendering.PreviousConnection');\nconst {Row} = goog.require('Blockly.blockRendering.Row');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing information about what elements are in the top row of a\n * block as well as sizing information for the top row.\n * Elements in a top row can consist of corners, hats, spacers, and previous\n * connections.\n * After this constructor is called, the row will contain all non-spacer\n * elements it needs.\n * @extends {Row}\n * @struct\n * @alias Blockly.blockRendering.TopRow\n */\nclass TopRow extends Row {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @package\n   */\n  constructor(constants) {\n    super(constants);\n\n    this.type |= Types.TOP_ROW;\n\n    /**\n     * The starting point for drawing the row, in the y direction.\n     * This allows us to draw hats and similar shapes that don't start at the\n     * origin. Must be non-negative (see #2820).\n     * @package\n     * @type {number}\n     */\n    this.capline = 0;\n\n    /**\n     * How much the row extends up above its capline.\n     * @type {number}\n     */\n    this.ascenderHeight = 0;\n\n    /**\n     * Whether the block has a previous connection.\n     * @package\n     * @type {boolean}\n     */\n    this.hasPreviousConnection = false;\n\n    /**\n     * The previous connection on the block, if any.\n     * @type {PreviousConnection}\n     */\n    this.connection = null;\n  }\n\n  /**\n   * Returns whether or not the top row has a left square corner.\n   * @param {!BlockSvg} block The block whose top row this represents.\n   * @return {boolean} Whether or not the top row has a left square corner.\n   */\n  hasLeftSquareCorner(block) {\n    const hasHat =\n        (block.hat ? block.hat === 'cap' : this.constants_.ADD_START_HATS) &&\n        !block.outputConnection && !block.previousConnection;\n    const prevBlock = block.getPreviousBlock();\n\n    return !!block.outputConnection || hasHat ||\n        (prevBlock ? prevBlock.getNextBlock() === block : false);\n  }\n\n  /**\n   * Returns whether or not the top row has a right square corner.\n   * @param {!BlockSvg} _block The block whose top row this represents.\n   * @return {boolean} Whether or not the top row has a right square corner.\n   */\n  hasRightSquareCorner(_block) {\n    return true;\n  }\n\n  /**\n   * @override\n   */\n  measure() {\n    let height = 0;\n    let width = 0;\n    let ascenderHeight = 0;\n    for (let i = 0; i < this.elements.length; i++) {\n      const elem = this.elements[i];\n      width += elem.width;\n      if (!(Types.isSpacer(elem))) {\n        if (Types.isHat(elem) && elem instanceof Hat) {\n          ascenderHeight = Math.max(ascenderHeight, elem.ascenderHeight);\n        } else {\n          height = Math.max(height, elem.height);\n        }\n      }\n    }\n    this.width = Math.max(this.minWidth, width);\n    this.height = Math.max(this.minHeight, height) + ascenderHeight;\n    this.ascenderHeight = ascenderHeight;\n    this.capline = this.ascenderHeight;\n    this.widthWithConnectedBlocks = this.width;\n  }\n\n  /**\n   * @override\n   */\n  startsWithElemSpacer() {\n    return false;\n  }\n\n  /**\n   * @override\n   */\n  endsWithElemSpacer() {\n    return false;\n  }\n}\n\nexports.TopRow = TopRow;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/top_row.js?")},
"./core/renderers/measurables/types.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Measurable types.\n */\n\n\n\n/**\n * Measurable types.\n * @namespace Blockly.blockRendering.Types\n */\ngoog.module('Blockly.blockRendering.Types');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {Measurable} = goog.requireType('Blockly.blockRendering.Measurable');\n/* eslint-disable-next-line no-unused-vars */\nconst {Row} = goog.requireType('Blockly.blockRendering.Row');\n\n\n/**\n * Types of rendering elements.\n * @enum {number}\n * @alias Blockly.blockRendering.Types\n */\nconst Types = {\n  NONE: 0,                       // None\n  FIELD: 1 << 0,                 // Field.\n  HAT: 1 << 1,                   // Hat.\n  ICON: 1 << 2,                  // Icon.\n  SPACER: 1 << 3,                // Spacer.\n  BETWEEN_ROW_SPACER: 1 << 4,    // Between Row Spacer.\n  IN_ROW_SPACER: 1 << 5,         // In Row Spacer.\n  EXTERNAL_VALUE_INPUT: 1 << 6,  // External Value Input.\n  INPUT: 1 << 7,                 // Input.\n  INLINE_INPUT: 1 << 8,          // Inline Input.\n  STATEMENT_INPUT: 1 << 9,       // Statement Input.\n  CONNECTION: 1 << 10,           // Connection.\n  PREVIOUS_CONNECTION: 1 << 11,  // Previous Connection.\n  NEXT_CONNECTION: 1 << 12,      // Next Connection.\n  OUTPUT_CONNECTION: 1 << 13,    // Output Connection.\n  CORNER: 1 << 14,               // Corner.\n  LEFT_SQUARE_CORNER: 1 << 15,   // Square Corner.\n  LEFT_ROUND_CORNER: 1 << 16,    // Round Corner.\n  RIGHT_SQUARE_CORNER: 1 << 17,  // Right Square Corner.\n  RIGHT_ROUND_CORNER: 1 << 18,   // Right Round Corner.\n  JAGGED_EDGE: 1 << 19,          // Jagged Edge.\n  ROW: 1 << 20,                  // Row.\n  TOP_ROW: 1 << 21,              // Top Row.\n  BOTTOM_ROW: 1 << 22,           // Bottom Row.\n  INPUT_ROW: 1 << 23,            // Input Row.\n};\n\n/**\n * A Left Corner Union Type.\n * @type {number}\n * @const\n * @package\n */\nTypes.LEFT_CORNER = Types.LEFT_SQUARE_CORNER | Types.LEFT_ROUND_CORNER;\n\n/**\n * A Right Corner Union Type.\n * @type {number}\n * @const\n * @package\n */\nTypes.RIGHT_CORNER = Types.RIGHT_SQUARE_CORNER | Types.RIGHT_ROUND_CORNER;\n\n/**\n * Next flag value to use for custom rendering element types.\n * This must be updated to reflect the next enum flag value\n * to use if additional elements are added to\n * `Types`.\n * @type {number}\n * @private\n */\nTypes.nextTypeValue_ = 1 << 24;\n\n/**\n * Get the enum flag value of an existing type or register a new type.\n * @param {!string} type The name of the type.\n * @return {!number} The enum flag value associated with that type.\n * @package\n */\nTypes.getType = function(type) {\n  if (!Object.prototype.hasOwnProperty.call(Types, type)) {\n    Types[type] = Types.nextTypeValue_;\n    Types.nextTypeValue_ <<= 1;\n  }\n  return Types[type];\n};\n\n/**\n * Whether a measurable stores information about a field.\n * @param {!Measurable} elem The element to check.\n * @return {number} 1 if the object stores information about a field.\n * @package\n */\nTypes.isField = function(elem) {\n  return elem.type & Types.FIELD;\n};\n\n/**\n * Whether a measurable stores information about a hat.\n * @param {!Measurable} elem The element to check.\n * @return {number} 1 if the object stores information about a hat.\n * @package\n */\nTypes.isHat = function(elem) {\n  return elem.type & Types.HAT;\n};\n\n/**\n * Whether a measurable stores information about an icon.\n * @param {!Measurable} elem The element to check.\n * @return {number} 1 if the object stores information about an icon.\n * @package\n */\nTypes.isIcon = function(elem) {\n  return elem.type & Types.ICON;\n};\n\n/**\n * Whether a measurable stores information about a spacer.\n * @param {!Measurable|!Row} elem\n *     The element to check.\n * @return {number} 1 if the object stores information about a spacer.\n * @package\n */\nTypes.isSpacer = function(elem) {\n  return elem.type & Types.SPACER;\n};\n\n/**\n * Whether a measurable stores information about an in-row spacer.\n * @param {!Measurable} elem The element to check.\n * @return {number} 1 if the object stores information about an\n *   in-row spacer.\n * @package\n */\nTypes.isInRowSpacer = function(elem) {\n  return elem.type & Types.IN_ROW_SPACER;\n};\n\n/**\n * Whether a measurable stores information about an input.\n * @param {!Measurable} elem The element to check.\n * @return {number} 1 if the object stores information about an input.\n * @package\n */\nTypes.isInput = function(elem) {\n  return elem.type & Types.INPUT;\n};\n\n/**\n * Whether a measurable stores information about an external input.\n * @param {!Measurable} elem The element to check.\n * @return {number} 1 if the object stores information about an\n *   external input.\n * @package\n */\nTypes.isExternalInput = function(elem) {\n  return elem.type & Types.EXTERNAL_VALUE_INPUT;\n};\n\n/**\n * Whether a measurable stores information about an inline input.\n * @param {!Measurable} elem The element to check.\n * @return {number} 1 if the object stores information about an\n *   inline input.\n * @package\n */\nTypes.isInlineInput = function(elem) {\n  return elem.type & Types.INLINE_INPUT;\n};\n\n/**\n * Whether a measurable stores information about a statement input.\n * @param {!Measurable} elem The element to check.\n * @return {number} 1 if the object stores information about a\n *   statement input.\n * @package\n */\nTypes.isStatementInput = function(elem) {\n  return elem.type & Types.STATEMENT_INPUT;\n};\n\n/**\n * Whether a measurable stores information about a previous connection.\n * @param {!Measurable} elem The element to check.\n * @return {number} 1 if the object stores information about a\n *   previous connection.\n * @package\n */\nTypes.isPreviousConnection = function(elem) {\n  return elem.type & Types.PREVIOUS_CONNECTION;\n};\n\n/**\n * Whether a measurable stores information about a next connection.\n * @param {!Measurable} elem The element to check.\n * @return {number} 1 if the object stores information about a\n *   next connection.\n * @package\n */\nTypes.isNextConnection = function(elem) {\n  return elem.type & Types.NEXT_CONNECTION;\n};\n\n/**\n * Whether a measurable stores information about a previous or next connection.\n * @param {!Measurable} elem The element to check.\n * @return {number} 1 if the object stores information about a previous or\n *   next connection.\n * @package\n */\nTypes.isPreviousOrNextConnection = function(elem) {\n  return elem.type & (Types.PREVIOUS_CONNECTION | Types.NEXT_CONNECTION);\n};\n\n/**\n * Whether a measurable stores information about a left round corner.\n * @param {!Measurable} elem The element to check.\n * @return {number} 1 if the object stores information about a\n *   left round corner.\n * @package\n */\nTypes.isLeftRoundedCorner = function(elem) {\n  return elem.type & Types.LEFT_ROUND_CORNER;\n};\n\n/**\n * Whether a measurable stores information about a right round corner.\n * @param {!Measurable} elem The element to check.\n * @return {number} 1 if the object stores information about a\n *   right round corner.\n * @package\n */\nTypes.isRightRoundedCorner = function(elem) {\n  return elem.type & Types.RIGHT_ROUND_CORNER;\n};\n\n/**\n * Whether a measurable stores information about a left square corner.\n * @param {!Measurable} elem The element to check.\n * @return {number} 1 if the object stores information about a\n *   left square corner.\n * @package\n */\nTypes.isLeftSquareCorner = function(elem) {\n  return elem.type & Types.LEFT_SQUARE_CORNER;\n};\n\n/**\n * Whether a measurable stores information about a right square corner.\n * @param {!Measurable} elem The element to check.\n * @return {number} 1 if the object stores information about a\n *   right square corner.\n * @package\n */\nTypes.isRightSquareCorner = function(elem) {\n  return elem.type & Types.RIGHT_SQUARE_CORNER;\n};\n\n/**\n * Whether a measurable stores information about a corner.\n * @param {!Measurable} elem The element to check.\n * @return {number} 1 if the object stores information about a\n *   corner.\n * @package\n */\nTypes.isCorner = function(elem) {\n  return elem.type & Types.CORNER;\n};\n\n/**\n * Whether a measurable stores information about a jagged edge.\n * @param {!Measurable} elem The element to check.\n * @return {number} 1 if the object stores information about a jagged edge.\n * @package\n */\nTypes.isJaggedEdge = function(elem) {\n  return elem.type & Types.JAGGED_EDGE;\n};\n\n/**\n * Whether a measurable stores information about a row.\n * @param {!Row} row The row to check.\n * @return {number} 1 if the object stores information about a row.\n * @package\n */\nTypes.isRow = function(row) {\n  return row.type & Types.ROW;\n};\n\n/**\n * Whether a measurable stores information about a between-row spacer.\n * @param {!Row} row The row to check.\n * @return {number} 1 if the object stores information about a\n *   between-row spacer.\n * @package\n */\nTypes.isBetweenRowSpacer = function(row) {\n  return row.type & Types.BETWEEN_ROW_SPACER;\n};\n\n/**\n * Whether a measurable stores information about a top row.\n * @param {!Row} row The row to check.\n * @return {number} 1 if the object stores information about a top row.\n * @package\n */\nTypes.isTopRow = function(row) {\n  return row.type & Types.TOP_ROW;\n};\n\n/**\n * Whether a measurable stores information about a bottom row.\n * @param {!Row} row The row to check.\n * @return {number} 1 if the object stores information about a bottom row.\n * @package\n */\nTypes.isBottomRow = function(row) {\n  return row.type & Types.BOTTOM_ROW;\n};\n\n/**\n * Whether a measurable stores information about a top or bottom row.\n * @param {!Row} row The row to check.\n * @return {number} 1 if the object stores information about a top or\n *   bottom row.\n * @package\n */\nTypes.isTopOrBottomRow = function(row) {\n  return row.type & (Types.TOP_ROW | Types.BOTTOM_ROW);\n};\n\n/**\n * Whether a measurable stores information about an input row.\n * @param {!Row} row The row to check.\n * @return {number} 1 if the object stores information about an input row.\n * @package\n */\nTypes.isInputRow = function(row) {\n  return row.type & Types.INPUT_ROW;\n};\n\nexports.Types = Types;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/measurables/types.js?")},
"./core/renderers/minimalist/constants.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/common/constants.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview An object that provides constants for rendering blocks in the\n * minimalist renderer.\n */\n\n\n/**\n * An object that provides constants for rendering blocks in the\n * minimalist renderer.\n * @class\n */\ngoog.module('Blockly.minimalist.ConstantProvider');\n\nconst {ConstantProvider: BaseConstantProvider} = goog.require('Blockly.blockRendering.ConstantProvider');\n\n\n/**\n * An object that provides constants for rendering blocks in the sample.\n * @extends {BaseConstantProvider}\n * @alias Blockly.minimalist.ConstantProvider\n */\nclass ConstantProvider extends BaseConstantProvider {\n  /**\n   * @package\n   */\n  constructor() {\n    super();\n  }\n}\n\nexports.ConstantProvider = ConstantProvider;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/minimalist/constants.js?")},
"./core/renderers/minimalist/drawer.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/common/drawer.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Minimalist rendering drawer.\n */\n\n\n/**\n * Minimalist rendering drawer.\n * @class\n */\ngoog.module('Blockly.minimalist.Drawer');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {Drawer: BaseDrawer} = goog.require('Blockly.blockRendering.Drawer');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderInfo} = goog.requireType('Blockly.minimalist.RenderInfo');\n\n\n/**\n * An object that draws a block based on the given rendering information.\n * @extends {BaseDrawer}\n * @alias Blockly.minimalist.Drawer\n */\nclass Drawer extends BaseDrawer {\n  /**\n   * @param {!BlockSvg} block The block to render.\n   * @param {!RenderInfo} info An object containing all\n   *   information needed to render this block.\n   * @package\n   */\n  constructor(block, info) {\n    super(block, info);\n  }\n}\n\nexports.Drawer = Drawer;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/minimalist/drawer.js?")},
"./core/renderers/minimalist/info.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/common/info.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Minimalist render info object.\n */\n\n\n/**\n * Minimalist render info object.\n * @class\n */\ngoog.module('Blockly.minimalist.RenderInfo');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {RenderInfo: BaseRenderInfo} = goog.require('Blockly.blockRendering.RenderInfo');\n/* eslint-disable-next-line no-unused-vars */\nconst {Renderer} = goog.requireType('Blockly.minimalist.Renderer');\n\n\n/**\n * An object containing all sizing information needed to draw this block.\n *\n * This measure pass does not propagate changes to the block (although fields\n * may choose to rerender when getSize() is called).  However, calling it\n * repeatedly may be expensive.\n * @extends {BaseRenderInfo}\n * @alias Blockly.minimalist.RenderInfo\n */\nclass RenderInfo extends BaseRenderInfo {\n  /**\n   * @param {!Renderer} renderer The renderer in use.\n   * @param {!BlockSvg} block The block to measure.\n   * @package\n   */\n  constructor(renderer, block) {\n    super(renderer, block);\n  }\n\n  /**\n   * Get the block renderer in use.\n   * @return {!Renderer} The block renderer in use.\n   * @package\n   */\n  getRenderer() {\n    return /** @type {!Renderer} */ (this.renderer_);\n  }\n}\n\nexports.RenderInfo = RenderInfo;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/minimalist/info.js?")},
"./core/renderers/minimalist/minimalist.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/minimalist/constants.js\");\n__webpack_require__(\"./core/renderers/minimalist/drawer.js\");\n__webpack_require__(\"./core/renderers/minimalist/info.js\");\n__webpack_require__(\"./core/renderers/minimalist/renderer.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Re-exports of Blockly.minimalist.* modules.\n */\n\n\n/**\n * Re-exports of Blockly.minimalist.* modules.\n * @namespace Blockly.minimalist\n */\ngoog.module('Blockly.minimalist');\n\nconst {ConstantProvider} = goog.require('Blockly.minimalist.ConstantProvider');\nconst {Drawer} = goog.require('Blockly.minimalist.Drawer');\nconst {RenderInfo} = goog.require('Blockly.minimalist.RenderInfo');\nconst {Renderer} = goog.require('Blockly.minimalist.Renderer');\n\nexports.ConstantProvider = ConstantProvider;\nexports.Drawer = Drawer;\nexports.RenderInfo = RenderInfo;\nexports.Renderer = Renderer;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/minimalist/minimalist.js?")},
"./core/renderers/minimalist/renderer.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/common/block_rendering.js\");\n__webpack_require__(\"./core/renderers/minimalist/constants.js\");\n__webpack_require__(\"./core/renderers/minimalist/drawer.js\");\n__webpack_require__(\"./core/renderers/minimalist/info.js\");\n__webpack_require__(\"./core/renderers/common/renderer.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Minimalist renderer.\n */\n\n\n/**\n * Minimalist renderer.\n * @class\n */\ngoog.module('Blockly.minimalist.Renderer');\n\nconst blockRendering = goog.require('Blockly.blockRendering');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {ConstantProvider} = goog.require('Blockly.minimalist.ConstantProvider');\nconst {Drawer} = goog.require('Blockly.minimalist.Drawer');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderInfo: BaseRenderInfo} = goog.requireType('Blockly.blockRendering.RenderInfo');\nconst {RenderInfo} = goog.require('Blockly.minimalist.RenderInfo');\nconst {Renderer: BaseRenderer} = goog.require('Blockly.blockRendering.Renderer');\n\n\n/**\n * The minimalist renderer.\n * @extends {BaseRenderer}\n * @alias Blockly.minimalist.Renderer\n */\nclass Renderer extends BaseRenderer {\n  /**\n   * @param {string} name The renderer name.\n   * @package\n   */\n  constructor(name) {\n    super(name);\n  }\n\n  /**\n   * Create a new instance of the renderer's constant provider.\n   * @return {!ConstantProvider} The constant provider.\n   * @protected\n   * @override\n   */\n  makeConstants_() {\n    return new ConstantProvider();\n  }\n\n  /**\n   * Create a new instance of the renderer's render info object.\n   * @param {!BlockSvg} block The block to measure.\n   * @return {!RenderInfo} The render info object.\n   * @protected\n   * @override\n   */\n  makeRenderInfo_(block) {\n    return new RenderInfo(this, block);\n  }\n\n  /**\n   * Create a new instance of the renderer's drawer.\n   * @param {!BlockSvg} block The block to render.\n   * @param {!BaseRenderInfo} info An object containing all\n   *   information needed to render this block.\n   * @return {!Drawer} The drawer.\n   * @protected\n   * @override\n   */\n  makeDrawer_(block, info) {\n    return new Drawer(block, /** @type {!RenderInfo} */ (info));\n  }\n}\n\nblockRendering.register('minimalist', Renderer);\n\nexports.Renderer = Renderer;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/minimalist/renderer.js?")},
"./core/renderers/thrasos/info.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/in_row_spacer.js\");\n__webpack_require__(\"./core/renderers/common/info.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview New (evolving) renderer.\n * Thrasos: spirit of boldness.\n */\n\n\n/**\n * New (evolving) renderer.\n * Thrasos: spirit of boldness.\n * @class\n */\ngoog.module('Blockly.thrasos.RenderInfo');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {BottomRow} = goog.requireType('Blockly.blockRendering.BottomRow');\n/* eslint-disable-next-line no-unused-vars */\nconst {Field} = goog.requireType('Blockly.blockRendering.Field');\nconst {InRowSpacer} = goog.require('Blockly.blockRendering.InRowSpacer');\nconst {RenderInfo: BaseRenderInfo} = goog.require('Blockly.blockRendering.RenderInfo');\n/* eslint-disable-next-line no-unused-vars */\nconst {Renderer} = goog.requireType('Blockly.thrasos.Renderer');\n/* eslint-disable-next-line no-unused-vars */\nconst {TopRow} = goog.requireType('Blockly.blockRendering.TopRow');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing all sizing information needed to draw this block.\n *\n * This measure pass does not propagate changes to the block (although fields\n * may choose to rerender when getSize() is called).  However, calling it\n * repeatedly may be expensive.\n * @extends {BaseRenderInfo}\n * @alias Blockly.thrasos.RenderInfo\n */\nclass RenderInfo extends BaseRenderInfo {\n  /**\n   * @param {!Renderer} renderer The renderer in use.\n   * @param {!BlockSvg} block The block to measure.\n   * @package\n   */\n  constructor(renderer, block) {\n    super(renderer, block);\n  }\n\n  /**\n   * Get the block renderer in use.\n   * @return {!Renderer} The block renderer in use.\n   * @package\n   */\n  getRenderer() {\n    return /** @type {!Renderer} */ (this.renderer_);\n  }\n\n  /**\n   * @override\n   */\n  addElemSpacing_() {\n    let hasExternalInputs = false;\n    for (let i = 0; i < this.rows.length; i++) {\n      const row = this.rows[i];\n      if (row.hasExternalInput) {\n        hasExternalInputs = true;\n        break;\n      }\n    }\n    for (let i = 0; i < this.rows.length; i++) {\n      const row = this.rows[i];\n      const oldElems = row.elements;\n      row.elements = [];\n      // No spacing needed before the corner on the top row or the bottom row.\n      if (row.startsWithElemSpacer()) {\n        // There's a spacer before the first element in the row.\n        row.elements.push(new InRowSpacer(\n            this.constants_, this.getInRowSpacing_(null, oldElems[0])));\n      }\n      for (let e = 0; e < oldElems.length - 1; e++) {\n        row.elements.push(oldElems[e]);\n        const spacing = this.getInRowSpacing_(oldElems[e], oldElems[e + 1]);\n        row.elements.push(new InRowSpacer(this.constants_, spacing));\n      }\n      row.elements.push(oldElems[oldElems.length - 1]);\n      if (row.endsWithElemSpacer()) {\n        let spacing =\n            this.getInRowSpacing_(oldElems[oldElems.length - 1], null);\n        if (hasExternalInputs && row.hasDummyInput) {\n          spacing += this.constants_.TAB_WIDTH;\n        }\n        // There's a spacer after the last element in the row.\n        row.elements.push(new InRowSpacer(this.constants_, spacing));\n      }\n    }\n  }\n\n  /**\n   * @override\n   */\n  getInRowSpacing_(prev, next) {\n    if (!prev) {\n      // Between an editable field and the beginning of the row.\n      if (next && Types.isField(next) &&\n          (/** @type {Field} */ (next)).isEditable) {\n        return this.constants_.MEDIUM_PADDING;\n      }\n      // Inline input at the beginning of the row.\n      if (next && Types.isInlineInput(next)) {\n        return this.constants_.MEDIUM_LARGE_PADDING;\n      }\n      if (next && Types.isStatementInput(next)) {\n        return this.constants_.STATEMENT_INPUT_PADDING_LEFT;\n      }\n      // Anything else at the beginning of the row.\n      return this.constants_.LARGE_PADDING;\n    }\n\n    // Spacing between a non-input and the end of the row.\n    if (!Types.isInput(prev) && !next) {\n      // Between an editable field and the end of the row.\n      if (Types.isField(prev) && (/** @type {Field} */ (prev)).isEditable) {\n        return this.constants_.MEDIUM_PADDING;\n      }\n      // Padding at the end of an icon-only row to make the block shape clearer.\n      if (Types.isIcon(prev)) {\n        return (this.constants_.LARGE_PADDING * 2) + 1;\n      }\n      if (Types.isHat(prev)) {\n        return this.constants_.NO_PADDING;\n      }\n      // Establish a minimum width for a block with a previous or next\n      // connection.\n      if (Types.isPreviousOrNextConnection(prev)) {\n        return this.constants_.LARGE_PADDING;\n      }\n      // Between rounded corner and the end of the row.\n      if (Types.isLeftRoundedCorner(prev)) {\n        return this.constants_.MIN_BLOCK_WIDTH;\n      }\n      // Between a jagged edge and the end of the row.\n      if (Types.isJaggedEdge(prev)) {\n        return this.constants_.NO_PADDING;\n      }\n      // Between noneditable fields and icons and the end of the row.\n      return this.constants_.LARGE_PADDING;\n    }\n\n    // Between inputs and the end of the row.\n    if (Types.isInput(prev) && !next) {\n      if (Types.isExternalInput(prev)) {\n        return this.constants_.NO_PADDING;\n      } else if (Types.isInlineInput(prev)) {\n        return this.constants_.LARGE_PADDING;\n      } else if (Types.isStatementInput(prev)) {\n        return this.constants_.NO_PADDING;\n      }\n    }\n\n    // Spacing between a non-input and an input.\n    if (!Types.isInput(prev) && next && Types.isInput(next)) {\n      // Between an editable field and an input.\n      if (Types.isField(prev) && (/** @type {Field} */ (prev)).isEditable) {\n        if (Types.isInlineInput(next)) {\n          return this.constants_.SMALL_PADDING;\n        } else if (Types.isExternalInput(next)) {\n          return this.constants_.SMALL_PADDING;\n        }\n      } else {\n        if (Types.isInlineInput(next)) {\n          return this.constants_.MEDIUM_LARGE_PADDING;\n        } else if (Types.isExternalInput(next)) {\n          return this.constants_.MEDIUM_LARGE_PADDING;\n        } else if (Types.isStatementInput(next)) {\n          return this.constants_.LARGE_PADDING;\n        }\n      }\n      return this.constants_.LARGE_PADDING - 1;\n    }\n\n    // Spacing between an icon and an icon or field.\n    if (Types.isIcon(prev) && next && !Types.isInput(next)) {\n      return this.constants_.LARGE_PADDING;\n    }\n\n    // Spacing between an inline input and a field.\n    if (Types.isInlineInput(prev) && next && Types.isField(next)) {\n      // Editable field after inline input.\n      if ((/** @type {Field} */ (next)).isEditable) {\n        return this.constants_.MEDIUM_PADDING;\n      } else {\n        // Noneditable field after inline input.\n        return this.constants_.LARGE_PADDING;\n      }\n    }\n\n    if (Types.isLeftSquareCorner(prev) && next) {\n      // Spacing between a hat and a corner\n      if (Types.isHat(next)) {\n        return this.constants_.NO_PADDING;\n      }\n      // Spacing between a square corner and a previous or next connection\n      if (Types.isPreviousConnection(next) || Types.isNextConnection(next)) {\n        return next.notchOffset;\n      }\n    }\n\n    // Spacing between a rounded corner and a previous or next connection.\n    if (Types.isLeftRoundedCorner(prev) && next) {\n      return next.notchOffset - this.constants_.CORNER_RADIUS;\n    }\n\n    // Spacing between two fields of the same editability.\n    if (Types.isField(prev) && next && Types.isField(next) &&\n        ((/** @type {Field} */ (prev)).isEditable ===\n         (/** @type {Field} */ (next)).isEditable)) {\n      return this.constants_.LARGE_PADDING;\n    }\n\n    // Spacing between anything and a jagged edge.\n    if (next && Types.isJaggedEdge(next)) {\n      return this.constants_.LARGE_PADDING;\n    }\n\n    return this.constants_.MEDIUM_PADDING;\n  }\n\n  /**\n   * @override\n   */\n  getSpacerRowHeight_(prev, next) {\n    // If we have an empty block add a spacer to increase the height.\n    if (Types.isTopRow(prev) && Types.isBottomRow(next)) {\n      return this.constants_.EMPTY_BLOCK_SPACER_HEIGHT;\n    }\n    // Top and bottom rows act as a spacer so we don't need any extra padding.\n    if (Types.isTopRow(prev) || Types.isBottomRow(next)) {\n      return this.constants_.NO_PADDING;\n    }\n    if (prev.hasExternalInput && next.hasExternalInput) {\n      return this.constants_.LARGE_PADDING;\n    }\n    if (!prev.hasStatement && next.hasStatement) {\n      return this.constants_.BETWEEN_STATEMENT_PADDING_Y;\n    }\n    if (prev.hasStatement && next.hasStatement) {\n      return this.constants_.LARGE_PADDING;\n    }\n    if (prev.hasDummyInput || next.hasDummyInput) {\n      return this.constants_.LARGE_PADDING;\n    }\n    return this.constants_.MEDIUM_PADDING;\n  }\n\n  /**\n   * @override\n   */\n  getElemCenterline_(row, elem) {\n    if (Types.isSpacer(elem)) {\n      return row.yPos + elem.height / 2;\n    }\n    if (Types.isBottomRow(row)) {\n      const bottomRow = /** @type {!BottomRow} */ (row);\n      const baseline =\n          bottomRow.yPos + bottomRow.height - bottomRow.descenderHeight;\n      if (Types.isNextConnection(elem)) {\n        return baseline + elem.height / 2;\n      }\n      return baseline - elem.height / 2;\n    }\n    if (Types.isTopRow(row)) {\n      const topRow = /** @type {!TopRow} */ (row);\n      if (Types.isHat(elem)) {\n        return topRow.capline - elem.height / 2;\n      }\n      return topRow.capline + elem.height / 2;\n    }\n\n    let result = row.yPos;\n    if (Types.isField(elem) && row.hasStatement) {\n      const offset =\n          this.constants_.TALL_INPUT_FIELD_OFFSET_Y + elem.height / 2;\n      result += offset;\n    } else {\n      result += (row.height / 2);\n    }\n    return result;\n  }\n\n  /**\n   * @override\n   */\n  finalize_() {\n    // Performance note: this could be combined with the draw pass, if the time\n    // that this takes is excessive.  But it shouldn't be, because it only\n    // accesses and sets properties that already exist on the objects.\n    let widestRowWithConnectedBlocks = 0;\n    let yCursor = 0;\n    for (let i = 0; i < this.rows.length; i++) {\n      const row = this.rows[i];\n      row.yPos = yCursor;\n      row.xPos = this.startX;\n      yCursor += row.height;\n\n      widestRowWithConnectedBlocks =\n          Math.max(widestRowWithConnectedBlocks, row.widthWithConnectedBlocks);\n      // Add padding to the bottom row if block height is less than minimum\n      const heightWithoutHat = yCursor - this.topRow.ascenderHeight;\n      if (row === this.bottomRow &&\n          heightWithoutHat < this.constants_.MIN_BLOCK_HEIGHT) {\n        // But the hat height shouldn't be part of this.\n        const diff = this.constants_.MIN_BLOCK_HEIGHT - heightWithoutHat;\n        this.bottomRow.height += diff;\n        yCursor += diff;\n      }\n      this.recordElemPositions_(row);\n    }\n    if (this.outputConnection && this.block_.nextConnection &&\n        this.block_.nextConnection.isConnected()) {\n      // Include width of connected block in value to stack width measurement.\n      widestRowWithConnectedBlocks = Math.max(\n          widestRowWithConnectedBlocks,\n          this.block_.nextConnection.targetBlock().getHeightWidth().width);\n    }\n\n    this.bottomRow.baseline = yCursor - this.bottomRow.descenderHeight;\n    this.widthWithChildren = widestRowWithConnectedBlocks + this.startX;\n\n    this.height = yCursor;\n    this.startY = this.topRow.capline;\n  }\n}\n\nexports.RenderInfo = RenderInfo;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/thrasos/info.js?")},
"./core/renderers/thrasos/renderer.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/common/block_rendering.js\");\n__webpack_require__(\"./core/renderers/thrasos/info.js\");\n__webpack_require__(\"./core/renderers/common/renderer.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Thrasos renderer.\n */\n\n\n/**\n * Thrasos renderer.\n * @class\n */\ngoog.module('Blockly.thrasos.Renderer');\n\nconst blockRendering = goog.require('Blockly.blockRendering');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {RenderInfo} = goog.require('Blockly.thrasos.RenderInfo');\nconst {Renderer: BaseRenderer} = goog.require('Blockly.blockRendering.Renderer');\n\n\n/**\n * The thrasos renderer.\n * @extends {BaseRenderer}\n * @alias Blockly.thrasos.Renderer\n */\nclass Renderer extends BaseRenderer {\n  /**\n   * @param {string} name The renderer name.\n   * @package\n   */\n  constructor(name) {\n    super(name);\n  }\n\n  /**\n   * Create a new instance of the renderer's render info object.\n   * @param {!BlockSvg} block The block to measure.\n   * @return {!RenderInfo} The render info object.\n   * @protected\n   * @override\n   */\n  makeRenderInfo_(block) {\n    return new RenderInfo(this, block);\n  }\n}\n\nblockRendering.register('thrasos', Renderer);\n\nexports.Renderer = Renderer;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/thrasos/renderer.js?")},
"./core/renderers/thrasos/thrasos.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/thrasos/info.js\");\n__webpack_require__(\"./core/renderers/thrasos/renderer.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Re-exports of Blockly.thrasos.* modules.\n */\n\n\n/**\n * Re-exports of Blockly.thrasos.* modules.\n * @namespace Blockly.thrasos\n */\ngoog.module('Blockly.thrasos');\n\nconst {RenderInfo} = goog.require('Blockly.thrasos.RenderInfo');\nconst {Renderer} = goog.require('Blockly.thrasos.Renderer');\n\nexports.RenderInfo = RenderInfo;\nexports.Renderer = Renderer;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/thrasos/thrasos.js?")},
"./core/renderers/zelos/constants.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/utils/svg_paths.js\");\n__webpack_require__(\"./core/utils/colour.js\");\n__webpack_require__(\"./core/connection_type.js\");\n__webpack_require__(\"./core/renderers/common/constants.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview An object that provides constants for rendering blocks in Zelos\n * mode.\n */\n\n\n/**\n * An object that provides constants for rendering blocks in Zelos\n * mode.\n * @class\n */\ngoog.module('Blockly.zelos.ConstantProvider');\n\nconst dom = goog.require('Blockly.utils.dom');\nconst svgPaths = goog.require('Blockly.utils.svgPaths');\nconst utilsColour = goog.require('Blockly.utils.colour');\nconst {ConnectionType} = goog.require('Blockly.ConnectionType');\nconst {ConstantProvider: BaseConstantProvider} = goog.require('Blockly.blockRendering.ConstantProvider');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n\n\n/**\n * An object that provides constants for rendering blocks in Zelos mode.\n * @extends {BaseConstantProvider}\n * @alias Blockly.zelos.ConstantProvider\n */\nclass ConstantProvider extends BaseConstantProvider {\n  /**\n   * @package\n   */\n  constructor() {\n    super();\n\n    this.GRID_UNIT = 4;\n\n    /**\n     * @override\n     */\n    this.SMALL_PADDING = this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.MEDIUM_PADDING = 2 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.MEDIUM_LARGE_PADDING = 3 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.LARGE_PADDING = 4 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.CORNER_RADIUS = 1 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.NOTCH_WIDTH = 9 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.NOTCH_HEIGHT = 2 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.NOTCH_OFFSET_LEFT = 3 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.STATEMENT_INPUT_NOTCH_OFFSET = this.NOTCH_OFFSET_LEFT;\n\n    /**\n     * @override\n     */\n    this.MIN_BLOCK_WIDTH = 2 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.MIN_BLOCK_HEIGHT = 12 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.EMPTY_STATEMENT_INPUT_HEIGHT = 6 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.TAB_OFFSET_FROM_TOP = 0;\n\n    /**\n     * @override\n     */\n    this.TOP_ROW_MIN_HEIGHT = this.CORNER_RADIUS;\n\n    /**\n     * @override\n     */\n    this.TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT = this.LARGE_PADDING;\n\n    /**\n     * @override\n     */\n    this.BOTTOM_ROW_MIN_HEIGHT = this.CORNER_RADIUS;\n\n    /**\n     * @override\n     */\n    this.BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT = 6 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.STATEMENT_BOTTOM_SPACER = -this.NOTCH_HEIGHT;\n\n    /**\n     * Minimum statement input spacer width.\n     * @type {number}\n     */\n    this.STATEMENT_INPUT_SPACER_MIN_WIDTH = 40 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.STATEMENT_INPUT_PADDING_LEFT = 4 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.EMPTY_INLINE_INPUT_PADDING = 4 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.EMPTY_INLINE_INPUT_HEIGHT = 8 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.DUMMY_INPUT_MIN_HEIGHT = 8 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.DUMMY_INPUT_SHADOW_MIN_HEIGHT = 6 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.CURSOR_WS_WIDTH = 20 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.CURSOR_COLOUR = '#ffa200';\n\n    /**\n     * Radius of the cursor for input and output connections.\n     * @type {number}\n     * @package\n     */\n    this.CURSOR_RADIUS = 5;\n\n    /**\n     * @override\n     */\n    this.JAGGED_TEETH_HEIGHT = 0;\n\n    /**\n     * @override\n     */\n    this.JAGGED_TEETH_WIDTH = 0;\n\n    /**\n     * @override\n     */\n    this.START_HAT_HEIGHT = 22;\n\n    /**\n     * @override\n     */\n    this.START_HAT_WIDTH = 96;\n\n    /**\n     * @enum {number}\n     * @override\n     */\n    this.SHAPES = {HEXAGONAL: 1, ROUND: 2, SQUARE: 3, PUZZLE: 4, NOTCH: 5};\n\n    /**\n     * Map of output/input shapes and the amount they should cause a block to be\n     * padded. Outer key is the outer shape, inner key is the inner shape.\n     * When a block with the outer shape contains an input block with the inner\n     * shape on its left or right edge, the block elements are aligned such that\n     * the padding specified is reached.\n     * @package\n     */\n    this.SHAPE_IN_SHAPE_PADDING = {\n      1: {\n        // Outer shape: hexagon.\n        0: 5 * this.GRID_UNIT,  // Field in hexagon.\n        1: 2 * this.GRID_UNIT,  // Hexagon in hexagon.\n        2: 5 * this.GRID_UNIT,  // Round in hexagon.\n        3: 5 * this.GRID_UNIT,  // Square in hexagon.\n      },\n      2: {\n        // Outer shape: round.\n        0: 3 * this.GRID_UNIT,  // Field in round.\n        1: 3 * this.GRID_UNIT,  // Hexagon in round.\n        2: 1 * this.GRID_UNIT,  // Round in round.\n        3: 2 * this.GRID_UNIT,  // Square in round.\n      },\n      3: {\n        // Outer shape: square.\n        0: 2 * this.GRID_UNIT,  // Field in square.\n        1: 2 * this.GRID_UNIT,  // Hexagon in square.\n        2: 2 * this.GRID_UNIT,  // Round in square.\n        3: 2 * this.GRID_UNIT,  // Square in square.\n      },\n    };\n\n    /**\n     * @override\n     */\n    this.FULL_BLOCK_FIELDS = true;\n\n    /**\n     * @override\n     */\n    this.FIELD_TEXT_FONTSIZE = 3 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.FIELD_TEXT_FONTWEIGHT = 'bold';\n\n    /**\n     * @override\n     */\n    this.FIELD_TEXT_FONTFAMILY =\n        '\"Helvetica Neue\", \"Segoe UI\", Helvetica, sans-serif';\n\n    /**\n     * @override\n     */\n    this.FIELD_BORDER_RECT_RADIUS = this.CORNER_RADIUS;\n\n    /**\n     * @override\n     */\n    this.FIELD_BORDER_RECT_X_PADDING = 2 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.FIELD_BORDER_RECT_Y_PADDING = 1.625 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.FIELD_BORDER_RECT_HEIGHT = 8 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.FIELD_DROPDOWN_BORDER_RECT_HEIGHT = 8 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW = true;\n\n    /**\n     * @override\n     */\n    this.FIELD_DROPDOWN_COLOURED_DIV = true;\n\n    /**\n     * @override\n     */\n    this.FIELD_DROPDOWN_SVG_ARROW = true;\n\n    /**\n     * @override\n     */\n    this.FIELD_DROPDOWN_SVG_ARROW_PADDING = this.FIELD_BORDER_RECT_X_PADDING;\n\n    /**\n     * @override\n     */\n    this.FIELD_TEXTINPUT_BOX_SHADOW = true;\n\n    /**\n     * @override\n     */\n    this.FIELD_COLOUR_FULL_BLOCK = true;\n\n    /**\n     * @override\n     */\n    this.FIELD_COLOUR_DEFAULT_WIDTH = 2 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.FIELD_COLOUR_DEFAULT_HEIGHT = 4 * this.GRID_UNIT;\n\n    /**\n     * @override\n     */\n    this.FIELD_CHECKBOX_X_OFFSET = 1 * this.GRID_UNIT;\n\n    /**\n     * The maximum width of a dynamic connection shape.\n     * @type {number}\n     */\n    this.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH = 12 * this.GRID_UNIT;\n\n    /**\n     * The selected glow colour.\n     * @type {string}\n     */\n    this.SELECTED_GLOW_COLOUR = '#fff200';\n\n    /**\n     * The size of the selected glow.\n     * @type {number}\n     */\n    this.SELECTED_GLOW_SIZE = 0.5;\n\n    /**\n     * The replacement glow colour.\n     * @type {string}\n     */\n    this.REPLACEMENT_GLOW_COLOUR = '#fff200';\n\n    /**\n     * The size of the selected glow.\n     * @type {number}\n     */\n    this.REPLACEMENT_GLOW_SIZE = 2;\n\n    /**\n     * The ID of the selected glow filter, or the empty string if no filter is\n     * set.\n     * @type {string}\n     * @package\n     */\n    this.selectedGlowFilterId = '';\n\n    /**\n     * The <filter> element to use for a selected glow, or null if not set.\n     * @type {SVGElement}\n     * @private\n     */\n    this.selectedGlowFilter_ = null;\n\n    /**\n     * The ID of the replacement glow filter, or the empty string if no filter\n     * is set.\n     * @type {string}\n     * @package\n     */\n    this.replacementGlowFilterId = '';\n\n    /**\n     * The <filter> element to use for a replacement glow, or null if not set.\n     * @type {SVGElement}\n     * @private\n     */\n    this.replacementGlowFilter_ = null;\n\n    /**\n     * The object containing information about the hexagon used for a boolean\n     * reporter block. Null before init is called.\n     * @type {Object}\n     */\n    this.HEXAGONAL = null;\n\n    /**\n     * The object containing information about the hexagon used for a number or\n     * string reporter block. Null before init is called.\n     * @type {Object}\n     */\n    this.ROUNDED = null;\n\n    /**\n     * The object containing information about the hexagon used for a\n     * rectangular reporter block. Null before init is called.\n     * @type {Object}\n     */\n    this.SQUARED = null;\n  }\n\n  /**\n   * @override\n   */\n  setFontConstants_(theme) {\n    super.setFontConstants_(theme);\n\n    this.FIELD_BORDER_RECT_HEIGHT =\n        this.FIELD_TEXT_HEIGHT + this.FIELD_BORDER_RECT_Y_PADDING * 2;\n    this.FIELD_DROPDOWN_BORDER_RECT_HEIGHT = this.FIELD_BORDER_RECT_HEIGHT;\n  }\n\n  /**\n   * @override\n   */\n  init() {\n    super.init();\n    this.HEXAGONAL = this.makeHexagonal();\n    this.ROUNDED = this.makeRounded();\n    this.SQUARED = this.makeSquared();\n\n    this.STATEMENT_INPUT_NOTCH_OFFSET =\n        this.NOTCH_OFFSET_LEFT + this.INSIDE_CORNERS.rightWidth;\n  }\n\n  /**\n   * @override\n   */\n  setDynamicProperties_(theme) {\n    super.setDynamicProperties_(theme);\n\n    this.SELECTED_GLOW_COLOUR = theme.getComponentStyle('selectedGlowColour') ||\n        this.SELECTED_GLOW_COLOUR;\n    const selectedGlowSize =\n        Number(theme.getComponentStyle('selectedGlowSize'));\n    this.SELECTED_GLOW_SIZE = selectedGlowSize && !isNaN(selectedGlowSize) ?\n        selectedGlowSize :\n        this.SELECTED_GLOW_SIZE;\n    this.REPLACEMENT_GLOW_COLOUR =\n        theme.getComponentStyle('replacementGlowColour') ||\n        this.REPLACEMENT_GLOW_COLOUR;\n    const replacementGlowSize =\n        Number(theme.getComponentStyle('replacementGlowSize'));\n    this.REPLACEMENT_GLOW_SIZE =\n        replacementGlowSize && !isNaN(replacementGlowSize) ?\n        replacementGlowSize :\n        this.REPLACEMENT_GLOW_SIZE;\n  }\n\n  /**\n   * @override\n   */\n  dispose() {\n    super.dispose();\n    if (this.selectedGlowFilter_) {\n      dom.removeNode(this.selectedGlowFilter_);\n    }\n    if (this.replacementGlowFilter_) {\n      dom.removeNode(this.replacementGlowFilter_);\n    }\n  }\n\n  /**\n   * @override\n   */\n  makeStartHat() {\n    const height = this.START_HAT_HEIGHT;\n    const width = this.START_HAT_WIDTH;\n\n    const mainPath = svgPaths.curve('c', [\n      svgPaths.point(25, -height),\n      svgPaths.point(71, -height),\n      svgPaths.point(width, 0),\n    ]);\n    return {height: height, width: width, path: mainPath};\n  }\n\n  /**\n   * Create sizing and path information about a hexagonal shape.\n   * @return {!Object} An object containing sizing and path information about\n   *     a hexagonal shape for connections.\n   * @package\n   */\n  makeHexagonal() {\n    const maxWidth = this.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH;\n\n    /**\n     * Make the main path for the hexagonal connection shape out of two lines.\n     * The lines are defined with relative positions and require the block\n     * height. The 'up' and 'down' versions of the paths are the same, but the Y\n     * sign flips.  The 'left' and 'right' versions of the path are also the\n     * same, but the X sign flips.\n     * @param {number} height The height of the block the connection is on.\n     * @param {boolean} up True if the path should be drawn from bottom to top,\n     *     false otherwise.\n     * @param {boolean} right True if the path is for the right side of the\n     *     block.\n     * @return {string} A path fragment describing a rounded connection.\n     */\n    function makeMainPath(height, up, right) {\n      const halfHeight = height / 2;\n      const width = halfHeight > maxWidth ? maxWidth : halfHeight;\n      const forward = up ? -1 : 1;\n      const direction = right ? -1 : 1;\n      const dy = forward * height / 2;\n      return svgPaths.lineTo(-direction * width, dy) +\n          svgPaths.lineTo(direction * width, dy);\n    }\n\n    return {\n      type: this.SHAPES.HEXAGONAL,\n      isDynamic: true,\n      width: function(height) {\n        const halfHeight = height / 2;\n        return halfHeight > maxWidth ? maxWidth : halfHeight;\n      },\n      height: function(height) {\n        return height;\n      },\n      connectionOffsetY: function(connectionHeight) {\n        return connectionHeight / 2;\n      },\n      connectionOffsetX: function(connectionWidth) {\n        return -connectionWidth;\n      },\n      pathDown: function(height) {\n        return makeMainPath(height, false, false);\n      },\n      pathUp: function(height) {\n        return makeMainPath(height, true, false);\n      },\n      pathRightDown: function(height) {\n        return makeMainPath(height, false, true);\n      },\n      pathRightUp: function(height) {\n        return makeMainPath(height, false, true);\n      },\n    };\n  }\n\n  /**\n   * Create sizing and path information about a rounded shape.\n   * @return {!Object} An object containing sizing and path information about\n   *     a rounded shape for connections.\n   * @package\n   */\n  makeRounded() {\n    const maxWidth = this.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH;\n    const maxHeight = maxWidth * 2;\n\n    /**\n     * Make the main path for the rounded connection shape out of two arcs and\n     * a line that joins them.  The arcs are defined with relative positions.\n     * Usually, the height of the block is split between the two arcs. In the\n     * case where the height of the block exceeds the maximum height, a line is\n     * drawn in between the two arcs. The 'up' and 'down' versions of the paths\n     * are the same, but the Y sign flips.  The 'up' and 'right' versions of the\n     * path flip the sweep-flag which moves the arc at negative angles.\n     * @param {number} blockHeight The height of the block the connection is on.\n     * @param {boolean} up True if the path should be drawn from bottom to top,\n     *     false otherwise.\n     * @param {boolean} right True if the path is for the right side of the\n     *     block.\n     * @return {string} A path fragment describing a rounded connection.\n     */\n    function makeMainPath(blockHeight, up, right) {\n      const remainingHeight =\n          blockHeight > maxHeight ? blockHeight - maxHeight : 0;\n      const height = blockHeight > maxHeight ? maxHeight : blockHeight;\n      const radius = height / 2;\n      return svgPaths.arc(\n                 'a', '0 0,1', radius,\n                 svgPaths.point(\n                     (up ? -1 : 1) * radius, (up ? -1 : 1) * radius)) +\n          svgPaths.lineOnAxis('v', (right ? 1 : -1) * remainingHeight) +\n          svgPaths.arc(\n              'a', '0 0,1', radius,\n              svgPaths.point((up ? 1 : -1) * radius, (up ? -1 : 1) * radius));\n    }\n\n    return {\n      type: this.SHAPES.ROUND,\n      isDynamic: true,\n      width: function(height) {\n        const halfHeight = height / 2;\n        return halfHeight > maxWidth ? maxWidth : halfHeight;\n      },\n      height: function(height) {\n        return height;\n      },\n      connectionOffsetY: function(connectionHeight) {\n        return connectionHeight / 2;\n      },\n      connectionOffsetX: function(connectionWidth) {\n        return -connectionWidth;\n      },\n      pathDown: function(height) {\n        return makeMainPath(height, false, false);\n      },\n      pathUp: function(height) {\n        return makeMainPath(height, true, false);\n      },\n      pathRightDown: function(height) {\n        return makeMainPath(height, false, true);\n      },\n      pathRightUp: function(height) {\n        return makeMainPath(height, false, true);\n      },\n    };\n  }\n\n  /**\n   * Create sizing and path information about a squared shape.\n   * @return {!Object} An object containing sizing and path information about\n   *     a squared shape for connections.\n   * @package\n   */\n  makeSquared() {\n    const radius = this.CORNER_RADIUS;\n\n    /**\n     * Make the main path for the squared connection shape out of two corners\n     * and a single line in-between (a and v). These are defined in relative\n     * positions and require the height of the block.\n     * The 'left' and 'right' versions of the paths are the same, but the Y sign\n     * flips.  The 'up' and 'down' versions of the path determine where the\n     * corner point is placed and in turn the direction of the corners.\n     * @param {number} height The height of the block the connection is on.\n     * @param {boolean} up True if the path should be drawn from bottom to top,\n     *     false otherwise.\n     * @param {boolean} right True if the path is for the right side of the\n     *     block.\n     * @return {string} A path fragment describing a squared connection.\n     */\n    function makeMainPath(height, up, right) {\n      const innerHeight = height - radius * 2;\n      return svgPaths.arc(\n                 'a', '0 0,1', radius,\n                 svgPaths.point(\n                     (up ? -1 : 1) * radius, (up ? -1 : 1) * radius)) +\n          svgPaths.lineOnAxis('v', (right ? 1 : -1) * innerHeight) +\n          svgPaths.arc(\n              'a', '0 0,1', radius,\n              svgPaths.point((up ? 1 : -1) * radius, (up ? -1 : 1) * radius));\n    }\n\n    return {\n      type: this.SHAPES.SQUARE,\n      isDynamic: true,\n      width: function(_height) {\n        return radius;\n      },\n      height: function(height) {\n        return height;\n      },\n      connectionOffsetY: function(connectionHeight) {\n        return connectionHeight / 2;\n      },\n      connectionOffsetX: function(connectionWidth) {\n        return -connectionWidth;\n      },\n      pathDown: function(height) {\n        return makeMainPath(height, false, false);\n      },\n      pathUp: function(height) {\n        return makeMainPath(height, true, false);\n      },\n      pathRightDown: function(height) {\n        return makeMainPath(height, false, true);\n      },\n      pathRightUp: function(height) {\n        return makeMainPath(height, false, true);\n      },\n    };\n  }\n\n  /**\n   * @override\n   */\n  shapeFor(connection) {\n    let checks = connection.getCheck();\n    if (!checks && connection.targetConnection) {\n      checks = connection.targetConnection.getCheck();\n    }\n    let outputShape;\n    switch (connection.type) {\n      case ConnectionType.INPUT_VALUE:\n      case ConnectionType.OUTPUT_VALUE:\n        outputShape = connection.getSourceBlock().getOutputShape();\n        // If the block has an output shape set, use that instead.\n        if (outputShape !== null) {\n          switch (outputShape) {\n            case this.SHAPES.HEXAGONAL:\n              return /** @type {!Object} */ (this.HEXAGONAL);\n            case this.SHAPES.ROUND:\n              return /** @type {!Object} */ (this.ROUNDED);\n            case this.SHAPES.SQUARE:\n              return /** @type {!Object} */ (this.SQUARED);\n          }\n        }\n        // Includes doesn't work in IE.\n        if (checks && checks.indexOf('Boolean') !== -1) {\n          return /** @type {!Object} */ (this.HEXAGONAL);\n        }\n        if (checks && checks.indexOf('Number') !== -1) {\n          return /** @type {!Object} */ (this.ROUNDED);\n        }\n        if (checks && checks.indexOf('String') !== -1) {\n          return /** @type {!Object} */ (this.ROUNDED);\n        }\n        return /** @type {!Object} */ (this.ROUNDED);\n      case ConnectionType.PREVIOUS_STATEMENT:\n      case ConnectionType.NEXT_STATEMENT:\n        return this.NOTCH;\n      default:\n        throw Error('Unknown type');\n    }\n  }\n\n  /**\n   * @override\n   */\n  makeNotch() {\n    const width = this.NOTCH_WIDTH;\n    const height = this.NOTCH_HEIGHT;\n\n    const innerWidth = width / 3;\n    const curveWidth = innerWidth / 3;\n\n    const halfHeight = height / 2;\n    const quarterHeight = halfHeight / 2;\n\n    /**\n     * Make the main path for the notch.\n     * @param {number} dir Direction multiplier to apply to horizontal offsets\n     *     along the path. Either 1 or -1.\n     * @return {string} A path fragment describing a notch.\n     */\n    function makeMainPath(dir) {\n      return (\n          svgPaths.curve(\n              'c',\n              [\n                svgPaths.point(dir * curveWidth / 2, 0),\n                svgPaths.point(dir * curveWidth * 3 / 4, quarterHeight / 2),\n                svgPaths.point(dir * curveWidth, quarterHeight),\n              ]) +\n          svgPaths.line([svgPaths.point(dir * curveWidth, halfHeight)]) +\n          svgPaths.curve(\n              'c',\n              [\n                svgPaths.point(dir * curveWidth / 4, quarterHeight / 2),\n                svgPaths.point(dir * curveWidth / 2, quarterHeight),\n                svgPaths.point(dir * curveWidth, quarterHeight),\n              ]) +\n          svgPaths.lineOnAxis('h', dir * innerWidth) +\n          svgPaths.curve(\n              'c',\n              [\n                svgPaths.point(dir * curveWidth / 2, 0),\n                svgPaths.point(dir * curveWidth * 3 / 4, -(quarterHeight / 2)),\n                svgPaths.point(dir * curveWidth, -quarterHeight),\n              ]) +\n          svgPaths.line([svgPaths.point(dir * curveWidth, -halfHeight)]) +\n          svgPaths.curve('c', [\n            svgPaths.point(dir * curveWidth / 4, -(quarterHeight / 2)),\n            svgPaths.point(dir * curveWidth / 2, -quarterHeight),\n            svgPaths.point(dir * curveWidth, -quarterHeight),\n          ]));\n    }\n\n    const pathLeft = makeMainPath(1);\n    const pathRight = makeMainPath(-1);\n\n    return {\n      type: this.SHAPES.NOTCH,\n      width: width,\n      height: height,\n      pathLeft: pathLeft,\n      pathRight: pathRight,\n    };\n  }\n\n  /**\n   * @override\n   */\n  makeInsideCorners() {\n    const radius = this.CORNER_RADIUS;\n\n    const innerTopLeftCorner =\n        svgPaths.arc('a', '0 0,0', radius, svgPaths.point(-radius, radius));\n\n    const innerTopRightCorner =\n        svgPaths.arc('a', '0 0,1', radius, svgPaths.point(-radius, radius));\n\n    const innerBottomLeftCorner =\n        svgPaths.arc('a', '0 0,0', radius, svgPaths.point(radius, radius));\n\n    const innerBottomRightCorner =\n        svgPaths.arc('a', '0 0,1', radius, svgPaths.point(radius, radius));\n\n    return {\n      width: radius,\n      height: radius,\n      pathTop: innerTopLeftCorner,\n      pathBottom: innerBottomLeftCorner,\n      rightWidth: radius,\n      rightHeight: radius,\n      pathTopRight: innerTopRightCorner,\n      pathBottomRight: innerBottomRightCorner,\n    };\n  }\n\n  /**\n   * @override\n   */\n  generateSecondaryColour_(colour) {\n    return utilsColour.blend('#000', colour, 0.15) || colour;\n  }\n\n  /**\n   * @override\n   */\n  generateTertiaryColour_(colour) {\n    return utilsColour.blend('#000', colour, 0.25) || colour;\n  }\n\n  /**\n   * @override\n   */\n  createDom(svg, tagName, selector) {\n    super.createDom(svg, tagName, selector);\n    /*\n    <defs>\n      ... filters go here ...\n    </defs>\n    */\n    const defs = dom.createSvgElement(Svg.DEFS, {}, svg);\n    // Using a dilate distorts the block shape.\n    // Instead use a gaussian blur, and then set all alpha to 1 with a transfer.\n    const selectedGlowFilter = dom.createSvgElement(\n        Svg.FILTER, {\n          'id': 'blocklySelectedGlowFilter' + this.randomIdentifier,\n          'height': '160%',\n          'width': '180%',\n          'y': '-30%',\n          'x': '-40%',\n        },\n        defs);\n    dom.createSvgElement(\n        Svg.FEGAUSSIANBLUR,\n        {'in': 'SourceGraphic', 'stdDeviation': this.SELECTED_GLOW_SIZE},\n        selectedGlowFilter);\n    // Set all gaussian blur pixels to 1 opacity before applying flood\n    const selectedComponentTransfer = dom.createSvgElement(\n        Svg.FECOMPONENTTRANSFER, {'result': 'outBlur'}, selectedGlowFilter);\n    dom.createSvgElement(\n        Svg.FEFUNCA,\n        {'type': 'table', 'tableValues': '0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1'},\n        selectedComponentTransfer);\n    // Color the highlight\n    dom.createSvgElement(\n        Svg.FEFLOOD, {\n          'flood-color': this.SELECTED_GLOW_COLOUR,\n          'flood-opacity': 1,\n          'result': 'outColor',\n        },\n        selectedGlowFilter);\n    dom.createSvgElement(\n        Svg.FECOMPOSITE, {\n          'in': 'outColor',\n          'in2': 'outBlur',\n          'operator': 'in',\n          'result': 'outGlow',\n        },\n        selectedGlowFilter);\n    this.selectedGlowFilterId = selectedGlowFilter.id;\n    this.selectedGlowFilter_ = selectedGlowFilter;\n\n    // Using a dilate distorts the block shape.\n    // Instead use a gaussian blur, and then set all alpha to 1 with a transfer.\n    const replacementGlowFilter = dom.createSvgElement(\n        Svg.FILTER, {\n          'id': 'blocklyReplacementGlowFilter' + this.randomIdentifier,\n          'height': '160%',\n          'width': '180%',\n          'y': '-30%',\n          'x': '-40%',\n        },\n        defs);\n    dom.createSvgElement(\n        Svg.FEGAUSSIANBLUR,\n        {'in': 'SourceGraphic', 'stdDeviation': this.REPLACEMENT_GLOW_SIZE},\n        replacementGlowFilter);\n    // Set all gaussian blur pixels to 1 opacity before applying flood\n    const replacementComponentTransfer = dom.createSvgElement(\n        Svg.FECOMPONENTTRANSFER, {'result': 'outBlur'}, replacementGlowFilter);\n    dom.createSvgElement(\n        Svg.FEFUNCA,\n        {'type': 'table', 'tableValues': '0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1'},\n        replacementComponentTransfer);\n    // Color the highlight\n    dom.createSvgElement(\n        Svg.FEFLOOD, {\n          'flood-color': this.REPLACEMENT_GLOW_COLOUR,\n          'flood-opacity': 1,\n          'result': 'outColor',\n        },\n        replacementGlowFilter);\n    dom.createSvgElement(\n        Svg.FECOMPOSITE, {\n          'in': 'outColor',\n          'in2': 'outBlur',\n          'operator': 'in',\n          'result': 'outGlow',\n        },\n        replacementGlowFilter);\n    dom.createSvgElement(\n        Svg.FECOMPOSITE, {\n          'in': 'SourceGraphic',\n          'in2': 'outGlow',\n          'operator': 'over',\n        },\n        replacementGlowFilter);\n    this.replacementGlowFilterId = replacementGlowFilter.id;\n    this.replacementGlowFilter_ = replacementGlowFilter;\n  }\n\n  /**\n   * @override\n   */\n  getCSS_(selector) {\n    return [\n      /* eslint-disable indent */\n      // Text.\n      selector + ' .blocklyText,', selector + ' .blocklyFlyoutLabelText {',\n      'font: ' + this.FIELD_TEXT_FONTWEIGHT + ' ' + this.FIELD_TEXT_FONTSIZE +\n          'pt ' + this.FIELD_TEXT_FONTFAMILY + ';',\n      '}',\n\n      // Fields.\n      selector + ' .blocklyText {', 'fill: #fff;', '}',\n      selector + ' .blocklyNonEditableText>rect:not(.blocklyDropdownRect),',\n      selector + ' .blocklyEditableText>rect:not(.blocklyDropdownRect) {',\n      'fill: ' + this.FIELD_BORDER_RECT_COLOUR + ';', '}',\n      selector + ' .blocklyNonEditableText>text,',\n      selector + ' .blocklyEditableText>text,',\n      selector + ' .blocklyNonEditableText>g>text,',\n      selector + ' .blocklyEditableText>g>text {', 'fill: #575E75;', '}',\n\n      // Flyout labels.\n      selector + ' .blocklyFlyoutLabelText {', 'fill: #575E75;', '}',\n\n      // Bubbles.\n      selector + ' .blocklyText.blocklyBubbleText {', 'fill: #575E75;', '}',\n\n      // Editable field hover.\n      selector + ' .blocklyDraggable:not(.blocklyDisabled)',\n      ' .blocklyEditableText:not(.editing):hover>rect,',\n      selector + ' .blocklyDraggable:not(.blocklyDisabled)',\n      ' .blocklyEditableText:not(.editing):hover>.blocklyPath {',\n      'stroke: #fff;', 'stroke-width: 2;', '}',\n\n      // Text field input.\n      selector + ' .blocklyHtmlInput {',\n      'font-family: ' + this.FIELD_TEXT_FONTFAMILY + ';',\n      'font-weight: ' + this.FIELD_TEXT_FONTWEIGHT + ';', 'color: #575E75;',\n      '}',\n\n      // Dropdown field.\n      selector + ' .blocklyDropdownText {', 'fill: #fff !important;', '}',\n      // Widget and Dropdown Div\n      selector + '.blocklyWidgetDiv .goog-menuitem,',\n      selector + '.blocklyDropDownDiv .goog-menuitem {',\n      'font-family: ' + this.FIELD_TEXT_FONTFAMILY + ';', '}',\n      selector + '.blocklyDropDownDiv .goog-menuitem-content {', 'color: #fff;',\n      '}',\n\n      // Connection highlight.\n      selector + ' .blocklyHighlightedConnectionPath {',\n      'stroke: ' + this.SELECTED_GLOW_COLOUR + ';', '}',\n\n      // Disabled outline paths.\n      selector + ' .blocklyDisabled > .blocklyOutlinePath {',\n      'fill: url(#blocklyDisabledPattern' + this.randomIdentifier + ')', '}',\n\n      // Insertion marker.\n      selector + ' .blocklyInsertionMarker>.blocklyPath {',\n      'fill-opacity: ' + this.INSERTION_MARKER_OPACITY + ';', 'stroke: none;',\n      '}',\n      /* eslint-enable indent */\n    ];\n  }\n}\n\nexports.ConstantProvider = ConstantProvider;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/zelos/constants.js?")},
"./core/renderers/zelos/drawer.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/common/debug.js\");\n__webpack_require__(\"./core/utils/svg_paths.js\");\n__webpack_require__(\"./core/renderers/common/drawer.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Zelos renderer.\n */\n\n\n/**\n * Zelos renderer.\n * @class\n */\ngoog.module('Blockly.zelos.Drawer');\n\nconst debug = goog.require('Blockly.blockRendering.debug');\nconst svgPaths = goog.require('Blockly.utils.svgPaths');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {Drawer: BaseDrawer} = goog.require('Blockly.blockRendering.Drawer');\n/* eslint-disable-next-line no-unused-vars */\nconst {PathObject} = goog.requireType('Blockly.zelos.PathObject');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderInfo} = goog.requireType('Blockly.zelos.RenderInfo');\n/* eslint-disable-next-line no-unused-vars */\nconst {Row} = goog.requireType('Blockly.blockRendering.Row');\n/* eslint-disable-next-line no-unused-vars */\nconst {SpacerRow} = goog.requireType('Blockly.blockRendering.SpacerRow');\n/* eslint-disable-next-line no-unused-vars */\nconst {StatementInput} = goog.requireType('Blockly.zelos.StatementInput');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object that draws a block based on the given rendering information.\n * @extends {BaseDrawer}\n * @alias Blockly.zelos.Drawer\n */\nclass Drawer extends BaseDrawer {\n  /**\n   * @param {!BlockSvg} block The block to render.\n   * @param {!RenderInfo} info An object containing all\n   *   information needed to render this block.\n   * @package\n   */\n  constructor(block, info) {\n    super(block, info);\n\n    /**\n     * @type {!RenderInfo}\n     */\n    this.info_;\n  }\n\n  /**\n   * @override\n   */\n  draw() {\n    const pathObject =\n        /** @type {!PathObject} */ (this.block_.pathObject);\n    pathObject.beginDrawing();\n    this.hideHiddenIcons_();\n    this.drawOutline_();\n    this.drawInternals_();\n\n    pathObject.setPath(this.outlinePath_ + '\\n' + this.inlinePath_);\n    if (this.info_.RTL) {\n      pathObject.flipRTL();\n    }\n    if (debug.isDebuggerEnabled()) {\n      this.block_.renderingDebugger.drawDebug(this.block_, this.info_);\n    }\n    this.recordSizeOnBlock_();\n    if (this.info_.outputConnection) {\n      // Store the output connection shape type for parent blocks to use during\n      // rendering.\n      pathObject.outputShapeType = this.info_.outputConnection.shape.type;\n    }\n    pathObject.endDrawing();\n  }\n\n  /**\n   * @override\n   */\n  drawOutline_() {\n    if (this.info_.outputConnection &&\n        this.info_.outputConnection.isDynamicShape &&\n        !this.info_.hasStatementInput &&\n        !this.info_.bottomRow.hasNextConnection) {\n      this.drawFlatTop_();\n      this.drawRightDynamicConnection_();\n      this.drawFlatBottom_();\n      this.drawLeftDynamicConnection_();\n    } else {\n      super.drawOutline_();\n    }\n  }\n\n  /**\n   * @override\n   */\n  drawLeft_() {\n    if (this.info_.outputConnection &&\n        this.info_.outputConnection.isDynamicShape) {\n      this.drawLeftDynamicConnection_();\n    } else {\n      super.drawLeft_();\n    }\n  }\n\n  /**\n   * Add steps for the right side of a row that does not have value or\n   * statement input connections.\n   * @param {!Row} row The row to draw the\n   *     side of.\n   * @protected\n   */\n  drawRightSideRow_(row) {\n    if (row.height <= 0) {\n      return;\n    }\n    if (Types.isSpacer(row)) {\n      const spacerRow = /** @type {!SpacerRow} */ (row);\n      if (spacerRow.precedesStatement || spacerRow.followsStatement) {\n        const cornerHeight = this.constants_.INSIDE_CORNERS.rightHeight;\n        const remainingHeight =\n            spacerRow.height - (spacerRow.precedesStatement ? cornerHeight : 0);\n        this.outlinePath_ +=\n            (spacerRow.followsStatement ?\n                 this.constants_.INSIDE_CORNERS.pathBottomRight :\n                 '') +\n            (remainingHeight > 0 ?\n                 svgPaths.lineOnAxis('V', spacerRow.yPos + remainingHeight) :\n                 '') +\n            (spacerRow.precedesStatement ?\n                 this.constants_.INSIDE_CORNERS.pathTopRight :\n                 '');\n        return;\n      }\n    }\n    this.outlinePath_ += svgPaths.lineOnAxis('V', row.yPos + row.height);\n  }\n\n  /**\n   * Add steps to draw the right side of an output with a dynamic connection.\n   * @protected\n   */\n  drawRightDynamicConnection_() {\n    this.outlinePath_ += this.info_.outputConnection.shape.pathRightDown(\n        this.info_.outputConnection.height);\n  }\n\n  /**\n   * Add steps to draw the left side of an output with a dynamic connection.\n   * @protected\n   */\n  drawLeftDynamicConnection_() {\n    this.positionOutputConnection_();\n\n    this.outlinePath_ += this.info_.outputConnection.shape.pathUp(\n        this.info_.outputConnection.height);\n\n    // Close off the path.  This draws a vertical line up to the start of the\n    // block's path, which may be either a rounded or a sharp corner.\n    this.outlinePath_ += 'z';\n  }\n\n  /**\n   * Add steps to draw a flat top row.\n   * @protected\n   */\n  drawFlatTop_() {\n    const topRow = this.info_.topRow;\n    this.positionPreviousConnection_();\n\n    this.outlinePath_ += svgPaths.moveBy(topRow.xPos, this.info_.startY);\n\n    this.outlinePath_ += svgPaths.lineOnAxis('h', topRow.width);\n  }\n\n  /**\n   * Add steps to draw a flat bottom row.\n   * @protected\n   */\n  drawFlatBottom_() {\n    const bottomRow = this.info_.bottomRow;\n    this.positionNextConnection_();\n\n    this.outlinePath_ += svgPaths.lineOnAxis('V', bottomRow.baseline);\n\n    this.outlinePath_ += svgPaths.lineOnAxis('h', -bottomRow.width);\n  }\n\n  /**\n   * @override\n   */\n  drawInlineInput_(input) {\n    this.positionInlineInputConnection_(input);\n\n    const inputName = input.input.name;\n    if (input.connectedBlock || this.info_.isInsertionMarker) {\n      return;\n    }\n\n    const width = input.width - (input.connectionWidth * 2);\n    const height = input.height;\n    const yPos = input.centerline - height / 2;\n\n    const connectionRight = input.xPos + input.connectionWidth;\n\n    const outlinePath = svgPaths.moveTo(connectionRight, yPos) +\n        svgPaths.lineOnAxis('h', width) +\n        input.shape.pathRightDown(input.height) +\n        svgPaths.lineOnAxis('h', -width) + input.shape.pathUp(input.height) +\n        'z';\n    this.block_.pathObject.setOutlinePath(inputName, outlinePath);\n  }\n\n  /**\n   * @override\n   */\n  drawStatementInput_(row) {\n    const input = /** @type {!StatementInput} */ (row.getLastInput());\n    // Where to start drawing the notch, which is on the right side in LTR.\n    const x = input.xPos + input.notchOffset + input.shape.width;\n\n    const innerTopLeftCorner = input.shape.pathRight +\n        svgPaths.lineOnAxis(\n            'h', -(input.notchOffset - this.constants_.INSIDE_CORNERS.width)) +\n        this.constants_.INSIDE_CORNERS.pathTop;\n\n    const innerHeight =\n        row.height - (2 * this.constants_.INSIDE_CORNERS.height);\n\n    const innerBottomLeftCorner = this.constants_.INSIDE_CORNERS.pathBottom +\n        svgPaths.lineOnAxis(\n            'h', (input.notchOffset - this.constants_.INSIDE_CORNERS.width)) +\n        (input.connectedBottomNextConnection ? '' : input.shape.pathLeft);\n\n    this.outlinePath_ += svgPaths.lineOnAxis('H', x) + innerTopLeftCorner +\n        svgPaths.lineOnAxis('v', innerHeight) + innerBottomLeftCorner +\n        svgPaths.lineOnAxis('H', row.xPos + row.width);\n\n    this.positionStatementInputConnection_(row);\n  }\n}\n\nexports.Drawer = Drawer;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/zelos/drawer.js?")},
"./core/renderers/zelos/info.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/input.js\");\n__webpack_require__(\"./core/renderers/zelos/measurables/bottom_row.js\");\n__webpack_require__(\"./core/renderers/measurables/field.js\");\n__webpack_require__(\"./core/field_image.js\");\n__webpack_require__(\"./core/field_label.js\");\n__webpack_require__(\"./core/field_textinput.js\");\n__webpack_require__(\"./core/renderers/measurables/input_connection.js\");\n__webpack_require__(\"./core/renderers/measurables/in_row_spacer.js\");\n__webpack_require__(\"./core/renderers/common/info.js\");\n__webpack_require__(\"./core/renderers/zelos/measurables/row_elements.js\");\n__webpack_require__(\"./core/renderers/measurables/row.js\");\n__webpack_require__(\"./core/renderers/zelos/measurables/inputs.js\");\n__webpack_require__(\"./core/renderers/zelos/measurables/top_row.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\n__webpack_require__(\"./core/input_types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Makecode/scratch-style renderer.\n * Zelos: spirit of eager rivalry, emulation, envy, jealousy, and zeal.\n */\n\n\n/**\n * Makecode/scratch-style renderer.\n * @class\n */\ngoog.module('Blockly.zelos.RenderInfo');\n\nconst {Align} = goog.require('Blockly.Input');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {BottomRow} = goog.require('Blockly.zelos.BottomRow');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.zelos.ConstantProvider');\nconst {Field} = goog.require('Blockly.blockRendering.Field');\nconst {FieldImage} = goog.require('Blockly.FieldImage');\nconst {FieldLabel} = goog.require('Blockly.FieldLabel');\nconst {FieldTextInput} = goog.require('Blockly.FieldTextInput');\n/* eslint-disable-next-line no-unused-vars */\nconst {Input} = goog.requireType('Blockly.Input');\nconst {InputConnection} = goog.require('Blockly.blockRendering.InputConnection');\nconst {InRowSpacer} = goog.require('Blockly.blockRendering.InRowSpacer');\n/* eslint-disable-next-line no-unused-vars */\nconst {Measurable} = goog.requireType('Blockly.blockRendering.Measurable');\nconst {RenderInfo: BaseRenderInfo} = goog.require('Blockly.blockRendering.RenderInfo');\n/* eslint-disable-next-line no-unused-vars */\nconst {Renderer} = goog.requireType('Blockly.zelos.Renderer');\nconst {RightConnectionShape} = goog.require('Blockly.zelos.RightConnectionShape');\n/* eslint-disable-next-line no-unused-vars */\nconst {Row} = goog.require('Blockly.blockRendering.Row');\n/* eslint-disable-next-line no-unused-vars */\nconst {SpacerRow} = goog.requireType('Blockly.blockRendering.SpacerRow');\nconst {StatementInput} = goog.require('Blockly.zelos.StatementInput');\nconst {TopRow} = goog.require('Blockly.zelos.TopRow');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\nconst {inputTypes} = goog.require('Blockly.inputTypes');\n\n\n/**\n * An object containing all sizing information needed to draw this block.\n *\n * This measure pass does not propagate changes to the block (although fields\n * may choose to rerender when getSize() is called).  However, calling it\n * repeatedly may be expensive.\n * @extends {BaseRenderInfo}\n * @alias Blockly.zelos.RenderInfo\n */\nclass RenderInfo extends BaseRenderInfo {\n  /**\n   * @param {!Renderer} renderer The renderer in use.\n   * @param {!BlockSvg} block The block to measure.\n   * @package\n   */\n  constructor(renderer, block) {\n    super(renderer, block);\n\n    /** @type {!ConstantProvider} */\n    this.constants_;\n\n    /**\n     * An object with rendering information about the top row of the block.\n     * @type {!TopRow}\n     * @override\n     */\n    this.topRow = new TopRow(this.constants_);\n\n    /**\n     * An object with rendering information about the bottom row of the block.\n     * @type {!BottomRow}\n     * @override\n     */\n    this.bottomRow = new BottomRow(this.constants_);\n\n    /**\n     * @override\n     */\n    this.isInline = true;\n\n    /**\n     * Whether the block should be rendered as a multi-line block, either\n     * because it's not inline or because it has been collapsed.\n     * @type {boolean}\n     */\n    this.isMultiRow = !block.getInputsInline() || block.isCollapsed();\n\n    /**\n     * Whether or not the block has a statement input in one of its rows.\n     * @type {boolean}\n     */\n    this.hasStatementInput = block.statementInputCount > 0;\n\n    /**\n     * An object with rendering information about the right connection shape.\n     * @type {RightConnectionShape}\n     */\n    this.rightSide = this.outputConnection ?\n        new RightConnectionShape(this.constants_) :\n        null;\n\n    /**\n     * A map of rows to right aligned dummy inputs within those rows. Used to\n     * add padding between left and right aligned inputs.\n     * @type {!WeakMap<!Row, !Input>}\n     * @private\n     */\n    this.rightAlignedDummyInputs_ = new WeakMap();\n  }\n\n  /**\n   * Get the block renderer in use.\n   * @return {!Renderer} The block renderer in use.\n   * @package\n   */\n  getRenderer() {\n    return /** @type {!Renderer} */ (this.renderer_);\n  }\n\n  /**\n   * @override\n   */\n  measure() {\n    // Modifying parent measure method to add `adjustXPosition_`.\n    this.createRows_();\n    this.addElemSpacing_();\n    this.addRowSpacing_();\n    this.adjustXPosition_();\n    this.computeBounds_();\n    this.alignRowElements_();\n    this.finalize_();\n  }\n\n  /**\n   * @override\n   */\n  shouldStartNewRow_(input, lastInput) {\n    // If this is the first input, just add to the existing row.\n    // That row is either empty or has some icons in it.\n    if (!lastInput) {\n      return false;\n    }\n    // A statement input or an input following one always gets a new row.\n    if (input.type === inputTypes.STATEMENT ||\n        lastInput.type === inputTypes.STATEMENT) {\n      return true;\n    }\n    // Value and dummy inputs get new row if inputs are not inlined.\n    if (input.type === inputTypes.VALUE || input.type === inputTypes.DUMMY) {\n      return !this.isInline || this.isMultiRow;\n    }\n    return false;\n  }\n\n  /**\n   * @override\n   */\n  getDesiredRowWidth_(row) {\n    if (row.hasStatement) {\n      const rightCornerWidth = this.constants_.INSIDE_CORNERS.rightWidth || 0;\n      return this.width - this.startX - rightCornerWidth;\n    }\n    return super.getDesiredRowWidth_(row);\n  }\n\n  /**\n   * @override\n   */\n  getInRowSpacing_(prev, next) {\n    if (!prev || !next) {\n      // No need for padding at the beginning or end of the row if the\n      // output shape is dynamic.\n      if (this.outputConnection && this.outputConnection.isDynamicShape &&\n          !this.hasStatementInput && !this.bottomRow.hasNextConnection) {\n        return this.constants_.NO_PADDING;\n      }\n    }\n    if (!prev) {\n      // Statement input padding.\n      if (next && Types.isStatementInput(next)) {\n        return this.constants_.STATEMENT_INPUT_PADDING_LEFT;\n      }\n    }\n    // Spacing between a rounded corner and a previous or next connection.\n    if (prev && Types.isLeftRoundedCorner(prev) && next) {\n      if (Types.isPreviousConnection(next) || Types.isNextConnection(next)) {\n        return next.notchOffset - this.constants_.CORNER_RADIUS;\n      }\n    }\n    // Spacing between a square corner and a hat.\n    if (prev && Types.isLeftSquareCorner(prev) && next && Types.isHat(next)) {\n      return this.constants_.NO_PADDING;\n    }\n    return this.constants_.MEDIUM_PADDING;\n  }\n\n  /**\n   * @override\n   */\n  getSpacerRowHeight_(prev, next) {\n    // If we have an empty block add a spacer to increase the height.\n    if (Types.isTopRow(prev) && Types.isBottomRow(next)) {\n      return this.constants_.EMPTY_BLOCK_SPACER_HEIGHT;\n    }\n    const followsStatement = Types.isInputRow(prev) && prev.hasStatement;\n    const precedesStatement = Types.isInputRow(next) && next.hasStatement;\n    if (precedesStatement || followsStatement) {\n      const cornerHeight = this.constants_.INSIDE_CORNERS.rightHeight || 0;\n      const height = Math.max(this.constants_.NOTCH_HEIGHT, cornerHeight);\n      return precedesStatement && followsStatement ?\n          Math.max(height, this.constants_.DUMMY_INPUT_MIN_HEIGHT) :\n          height;\n    }\n    // Top and bottom rows act as a spacer so we don't need any extra padding.\n    if (Types.isTopRow(prev)) {\n      const topRow = /** @type {!TopRow} */ (prev);\n      if (!topRow.hasPreviousConnection &&\n          (!this.outputConnection || this.hasStatementInput)) {\n        return Math.abs(\n            this.constants_.NOTCH_HEIGHT - this.constants_.CORNER_RADIUS);\n      }\n      return this.constants_.NO_PADDING;\n    }\n    if (Types.isBottomRow(next)) {\n      const bottomRow = /** @type {!BottomRow} */ (next);\n      if (!this.outputConnection) {\n        const topHeight = Math.max(\n                              this.topRow.minHeight,\n                              Math.max(\n                                  this.constants_.NOTCH_HEIGHT,\n                                  this.constants_.CORNER_RADIUS)) -\n            this.constants_.CORNER_RADIUS;\n        return topHeight;\n      } else if (!bottomRow.hasNextConnection && this.hasStatementInput) {\n        return Math.abs(\n            this.constants_.NOTCH_HEIGHT - this.constants_.CORNER_RADIUS);\n      }\n      return this.constants_.NO_PADDING;\n    }\n    return this.constants_.MEDIUM_PADDING;\n  }\n\n  /**\n   * @override\n   */\n  getSpacerRowWidth_(prev, next) {\n    const width = this.width - this.startX;\n    if ((Types.isInputRow(prev) && prev.hasStatement) ||\n        (Types.isInputRow(next) && next.hasStatement)) {\n      return Math.max(width, this.constants_.STATEMENT_INPUT_SPACER_MIN_WIDTH);\n    }\n    return width;\n  }\n\n  /**\n   * @override\n   */\n  getElemCenterline_(row, elem) {\n    if (row.hasStatement && !Types.isSpacer(elem) &&\n        !Types.isStatementInput(elem)) {\n      return row.yPos + this.constants_.EMPTY_STATEMENT_INPUT_HEIGHT / 2;\n    }\n    if (Types.isInlineInput(elem) && elem instanceof InputConnection) {\n      const connectedBlock = elem.connectedBlock;\n      if (connectedBlock && connectedBlock.outputConnection &&\n          connectedBlock.nextConnection) {\n        return row.yPos + connectedBlock.height / 2;\n      }\n    }\n    return super.getElemCenterline_(row, elem);\n  }\n\n  /**\n   * @override\n   */\n  addInput_(input, activeRow) {\n    // If we have two dummy inputs on the same row, one aligned left and the\n    // other right, keep track of the right aligned dummy input so we can add\n    // padding later.\n    if (input.type === inputTypes.DUMMY && activeRow.hasDummyInput &&\n        activeRow.align === Align.LEFT && input.align === Align.RIGHT) {\n      this.rightAlignedDummyInputs_.set(activeRow, input);\n    } else if (input.type === inputTypes.STATEMENT) {\n      // Handle statements without next connections correctly.\n      activeRow.elements.push(new StatementInput(this.constants_, input));\n      activeRow.hasStatement = true;\n\n      if (activeRow.align === null) {\n        activeRow.align = input.align;\n      }\n      return;\n    }\n    super.addInput_(input, activeRow);\n  }\n\n  /**\n   * @override\n   */\n  addAlignmentPadding_(row, missingSpace) {\n    if (this.rightAlignedDummyInputs_.get(row)) {\n      let alignmentDivider;\n      for (let i = 0; i < row.elements.length; i++) {\n        const elem = row.elements[i];\n        if (Types.isSpacer(elem)) {\n          alignmentDivider = elem;\n        }\n        if (Types.isField(elem) && elem instanceof Field &&\n            elem.parentInput === this.rightAlignedDummyInputs_.get(row)) {\n          break;\n        }\n      }\n      if (alignmentDivider) {\n        alignmentDivider.width += missingSpace;\n        row.width += missingSpace;\n        return;\n      }\n    }\n    super.addAlignmentPadding_(row, missingSpace);\n  }\n\n  /**\n   * Adjust the x position of fields to bump all non-label fields in the first\n   * row past the notch position.  This must be called before ``computeBounds``\n   * is called.\n   * @protected\n   */\n  adjustXPosition_() {\n    const notchTotalWidth =\n        this.constants_.NOTCH_OFFSET_LEFT + this.constants_.NOTCH_WIDTH;\n    let minXPos = notchTotalWidth;\n    // Run through every input row on the block and only apply bump logic to the\n    // first input row (if the block has prev connection) and every input row\n    // that has a prev and next notch.\n    for (let i = 2; i < this.rows.length - 1; i += 2) {\n      const prevSpacer = /** @type {!SpacerRow} */ (this.rows[i - 1]);\n      const row = this.rows[i];\n      const nextSpacer = /** @type {!SpacerRow} */ (this.rows[i + 1]);\n\n      const hasPrevNotch = i === 2 ? !!this.topRow.hasPreviousConnection :\n                                     !!prevSpacer.followsStatement;\n      const hasNextNotch = i + 2 >= this.rows.length - 1 ?\n          !!this.bottomRow.hasNextConnection :\n          !!nextSpacer.precedesStatement;\n\n      if (Types.isInputRow(row) && row.hasStatement) {\n        row.measure();\n        minXPos = row.width - row.getLastInput().width + notchTotalWidth;\n      } else if (\n          hasPrevNotch && (i === 2 || hasNextNotch) && Types.isInputRow(row) &&\n          !row.hasStatement) {\n        let xCursor = row.xPos;\n        let prevInRowSpacer = null;\n        for (let j = 0; j < row.elements.length; j++) {\n          const elem = row.elements[j];\n          if (Types.isSpacer(elem)) {\n            prevInRowSpacer = elem;\n          }\n          if (prevInRowSpacer && (Types.isField(elem) || Types.isInput(elem))) {\n            if (xCursor < minXPos &&\n                !(Types.isField(elem) && elem instanceof Field &&\n                  (elem.field instanceof FieldLabel ||\n                   elem.field instanceof FieldImage))) {\n              const difference = minXPos - xCursor;\n              prevInRowSpacer.width += difference;\n            }\n          }\n          xCursor += elem.width;\n        }\n      }\n    }\n  }\n\n  /**\n   * Finalize the output connection info.  In particular, set the height of the\n   * output connection to match that of the block.  For the right side, add a\n   * right connection shape element and have it match the dimensions of the\n   * output connection.\n   * @protected\n   */\n  finalizeOutputConnection_() {\n    // Dynamic output connections depend on the height of the block.\n    if (!this.outputConnection || !this.outputConnection.isDynamicShape) {\n      return;\n    }\n    let yCursor = 0;\n    // Determine the block height.\n    for (let i = 0; i < this.rows.length; i++) {\n      const row = this.rows[i];\n      row.yPos = yCursor;\n      yCursor += row.height;\n    }\n    this.height = yCursor;\n\n    // Adjust the height of the output connection.\n    const blockHeight = this.bottomRow.hasNextConnection ?\n        this.height - this.bottomRow.descenderHeight :\n        this.height;\n    const connectionHeight = this.outputConnection.shape.height(blockHeight);\n    const connectionWidth = this.outputConnection.shape.width(blockHeight);\n\n    this.outputConnection.height = connectionHeight;\n    this.outputConnection.width = connectionWidth;\n    this.outputConnection.startX = connectionWidth;\n    this.outputConnection.connectionOffsetY =\n        this.outputConnection.shape.connectionOffsetY(connectionHeight);\n    this.outputConnection.connectionOffsetX =\n        this.outputConnection.shape.connectionOffsetX(connectionWidth);\n\n    // Add the right connection measurable.\n    // Don't add it if we have a value-to-statement or a value-to-stack block.\n    let rightConnectionWidth = 0;\n    if (!this.hasStatementInput && !this.bottomRow.hasNextConnection) {\n      rightConnectionWidth = connectionWidth;\n      this.rightSide.height = connectionHeight;\n      this.rightSide.width = rightConnectionWidth;\n      this.rightSide.centerline = connectionHeight / 2;\n      this.rightSide.xPos = this.width + rightConnectionWidth;\n    }\n    this.startX = connectionWidth;\n    this.width += connectionWidth + rightConnectionWidth;\n    this.widthWithChildren += connectionWidth + rightConnectionWidth;\n  }\n\n  /**\n   * Finalize horizontal alignment of elements on the block.  In particular,\n   * reduce the implicit spacing created by the left and right output connection\n   * shapes by adding setting negative spacing onto the leftmost and rightmost\n   * spacers.\n   * @protected\n   */\n  finalizeHorizontalAlignment_() {\n    if (!this.outputConnection || this.hasStatementInput ||\n        this.bottomRow.hasNextConnection) {\n      return;\n    }\n    let totalNegativeSpacing = 0;\n    for (let i = 0; i < this.rows.length; i++) {\n      const row = this.rows[i];\n      if (!Types.isInputRow(row)) {\n        continue;\n      }\n      const firstElem = row.elements[1];\n      const lastElem = row.elements[row.elements.length - 2];\n      let leftNegPadding = this.getNegativeSpacing_(firstElem);\n      let rightNegPadding = this.getNegativeSpacing_(lastElem);\n      totalNegativeSpacing = leftNegPadding + rightNegPadding;\n      const minBlockWidth =\n          this.constants_.MIN_BLOCK_WIDTH + this.outputConnection.width * 2;\n      if (this.width - totalNegativeSpacing < minBlockWidth) {\n        // Maintain a minimum block width, split negative spacing between left\n        // and right edge.\n        totalNegativeSpacing = this.width - minBlockWidth;\n        leftNegPadding = totalNegativeSpacing / 2;\n        rightNegPadding = totalNegativeSpacing / 2;\n      }\n      // Add a negative spacer on the start and end of the block.\n      row.elements.unshift(new InRowSpacer(this.constants_, -leftNegPadding));\n      row.elements.push(new InRowSpacer(this.constants_, -rightNegPadding));\n    }\n    if (totalNegativeSpacing) {\n      this.width -= totalNegativeSpacing;\n      this.widthWithChildren -= totalNegativeSpacing;\n      this.rightSide.xPos -= totalNegativeSpacing;\n      for (let i = 0; i < this.rows.length; i++) {\n        const row = this.rows[i];\n        if (Types.isTopOrBottomRow(row)) {\n          row.elements[1].width -= totalNegativeSpacing;\n        }\n        row.width -= totalNegativeSpacing;\n        row.widthWithConnectedBlocks -= totalNegativeSpacing;\n      }\n    }\n  }\n\n  /**\n   * Calculate the spacing to reduce the left and right edges by based on the\n   * outer and inner connection shape.\n   * @param {Measurable} elem The first or last element on\n   *     a block.\n   * @return {number} The amount of spacing to reduce the first or last spacer.\n   * @protected\n   */\n  getNegativeSpacing_(elem) {\n    if (!elem) {\n      return 0;\n    }\n    const connectionWidth = this.outputConnection.width;\n    const outerShape = this.outputConnection.shape.type;\n    const constants =\n        /** @type {!ConstantProvider} */ (this.constants_);\n    if (this.isMultiRow && this.inputRows.length > 1) {\n      switch (outerShape) {\n        case constants.SHAPES.ROUND: {\n          // Special case for multi-row round reporter blocks.\n          const maxWidth = this.constants_.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH;\n          const width = this.height / 2 > maxWidth ? maxWidth : this.height / 2;\n          const topPadding = this.constants_.SMALL_PADDING;\n          const roundPadding =\n              width * (1 - Math.sin(Math.acos((width - topPadding) / width)));\n          return connectionWidth - roundPadding;\n        }\n        default:\n          return 0;\n      }\n    }\n    if (Types.isInlineInput(elem) && elem instanceof InputConnection) {\n      const connectedBlock = elem.connectedBlock;\n      const innerShape = connectedBlock ?\n          connectedBlock.pathObject.outputShapeType :\n          elem.shape.type;\n      // Special case for value to stack / value to statement blocks.\n      if (connectedBlock && connectedBlock.outputConnection &&\n          (connectedBlock.statementInputCount ||\n           connectedBlock.nextConnection)) {\n        return 0;\n      }\n      // Special case for hexagonal output.\n      if (outerShape === constants.SHAPES.HEXAGONAL &&\n          outerShape !== innerShape) {\n        return 0;\n      }\n      return connectionWidth -\n          this.constants_.SHAPE_IN_SHAPE_PADDING[outerShape][innerShape];\n    } else if (Types.isField(elem) && elem instanceof Field) {\n      // Special case for text inputs.\n      if (outerShape === constants.SHAPES.ROUND &&\n          elem.field instanceof FieldTextInput) {\n        return connectionWidth - (2.75 * constants.GRID_UNIT);\n      }\n      return connectionWidth -\n          this.constants_.SHAPE_IN_SHAPE_PADDING[outerShape][0];\n    } else if (Types.isIcon(elem)) {\n      return this.constants_.SMALL_PADDING;\n    }\n    return 0;\n  }\n\n  /**\n   * Finalize vertical alignment of rows on a block.  In particular, reduce the\n   * implicit spacing when a non-shadow block is connected to any of an input\n   * row's inline inputs.\n   * @protected\n   */\n  finalizeVerticalAlignment_() {\n    if (this.outputConnection) {\n      return;\n    }\n    // Run through every input row on the block and only apply tight nesting\n    // logic to input rows that have a prev and next notch.\n    for (let i = 2; i < this.rows.length - 1; i += 2) {\n      const prevSpacer = /** @type {!SpacerRow} */ (this.rows[i - 1]);\n      const row = this.rows[i];\n      const nextSpacer = /** @type {!SpacerRow} */ (this.rows[i + 1]);\n\n      const firstRow = i === 2;\n      const hasPrevNotch = firstRow ? !!this.topRow.hasPreviousConnection :\n                                      !!prevSpacer.followsStatement;\n      const hasNextNotch = i + 2 >= this.rows.length - 1 ?\n          !!this.bottomRow.hasNextConnection :\n          !!nextSpacer.precedesStatement;\n\n      if (hasPrevNotch) {\n        const elem = row.elements[1];\n        const hasSingleTextOrImageField = row.elements.length === 3 &&\n            elem instanceof Field &&\n            (elem.field instanceof FieldLabel ||\n             elem.field instanceof FieldImage);\n        if (!firstRow && hasSingleTextOrImageField) {\n          // Remove some padding if we have a single image or text field.\n          prevSpacer.height -= this.constants_.SMALL_PADDING;\n          nextSpacer.height -= this.constants_.SMALL_PADDING;\n          row.height -= this.constants_.MEDIUM_PADDING;\n        } else if (!firstRow && !hasNextNotch) {\n          // Add a small padding so the notch doesn't clash with inputs/fields.\n          prevSpacer.height += this.constants_.SMALL_PADDING;\n        } else if (hasNextNotch) {\n          // Determine if the input row has non-shadow connected blocks.\n          let hasNonShadowConnectedBlocks = false;\n          const minVerticalTightNestingHeight = 40;\n          for (let j = 0; j < row.elements.length; j++) {\n            const elem = row.elements[j];\n            if (elem instanceof InputConnection && Types.isInlineInput(elem) &&\n                elem.connectedBlock && !elem.connectedBlock.isShadow() &&\n                elem.connectedBlock.getHeightWidth().height >=\n                    minVerticalTightNestingHeight) {\n              hasNonShadowConnectedBlocks = true;\n              break;\n            }\n          }\n          // Apply tight-nesting if we have both a prev and next notch and the\n          // block has non-shadow connected blocks.\n          if (hasNonShadowConnectedBlocks) {\n            prevSpacer.height -= this.constants_.SMALL_PADDING;\n            nextSpacer.height -= this.constants_.SMALL_PADDING;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @override\n   */\n  finalize_() {\n    this.finalizeOutputConnection_();\n    this.finalizeHorizontalAlignment_();\n    this.finalizeVerticalAlignment_();\n    super.finalize_();\n\n    if (this.rightSide) {\n      this.widthWithChildren += this.rightSide.width;\n    }\n  }\n}\n\nexports.RenderInfo = RenderInfo;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/zelos/info.js?")},
"./core/renderers/zelos/marker_svg.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/renderers/common/marker_svg.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Methods for graphically rendering a marker as SVG.\n */\n\n\n/**\n * Methods for graphically rendering a marker as SVG.\n * @class\n */\ngoog.module('Blockly.zelos.MarkerSvg');\n\nconst dom = goog.require('Blockly.utils.dom');\n/* eslint-disable-next-line no-unused-vars */\nconst {ASTNode} = goog.requireType('Blockly.ASTNode');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider: BaseConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {MarkerSvg: BaseMarkerSvg} = goog.require('Blockly.blockRendering.MarkerSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Marker} = goog.requireType('Blockly.Marker');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderedConnection} = goog.requireType('Blockly.RenderedConnection');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider: ZelosConstantProvider} = goog.requireType('Blockly.zelos.ConstantProvider');\n\n\n/**\n * Class to draw a marker.\n * @extends {BaseMarkerSvg}\n * @alias Blockly.zelos.MarkerSvg\n */\nclass MarkerSvg extends BaseMarkerSvg {\n  /**\n   * @param {!WorkspaceSvg} workspace The workspace the marker belongs to.\n   * @param {!BaseConstantProvider} constants The constants for\n   *     the renderer.\n   * @param {!Marker} marker The marker to draw.\n   */\n  constructor(workspace, constants, marker) {\n    super(workspace, constants, marker);\n\n    /** @type {!ZelosConstantProvider} */\n    this.constants_;\n\n    /**\n     * @type {SVGCircleElement}\n     * @private\n     */\n    this.markerCircle_ = null;\n  }\n\n  /**\n   * Position and display the marker for an input or an output connection.\n   * @param {!ASTNode} curNode The node to draw the marker for.\n   * @private\n   */\n  showWithInputOutput_(curNode) {\n    const block = /** @type {!BlockSvg} */ (curNode.getSourceBlock());\n    const connection =\n        /** @type {!RenderedConnection} */ (curNode.getLocation());\n    const offsetInBlock = connection.getOffsetInBlock();\n\n    this.positionCircle_(offsetInBlock.x, offsetInBlock.y);\n    this.setParent_(block);\n    this.showCurrent_();\n  }\n\n  /**\n   * @override\n   */\n  showWithOutput_(curNode) {\n    this.showWithInputOutput_(curNode);\n  }\n\n  /**\n   * @override\n   */\n  showWithInput_(curNode) {\n    this.showWithInputOutput_(curNode);\n  }\n\n  /**\n   * Draw a rectangle around the block.\n   * @param {!ASTNode} curNode The current node of the marker.\n   */\n  showWithBlock_(curNode) {\n    const block = /** @type {!BlockSvg} */ (curNode.getLocation());\n\n    // Gets the height and width of entire stack.\n    const heightWidth = block.getHeightWidth();\n\n    // Add padding so that being on a stack looks different than being on a\n    // block.\n    this.positionRect_(0, 0, heightWidth.width, heightWidth.height);\n    this.setParent_(block);\n    this.showCurrent_();\n  }\n\n  /**\n   * Position the circle we use for input and output connections.\n   * @param {number} x The x position of the circle.\n   * @param {number} y The y position of the circle.\n   * @private\n   */\n  positionCircle_(x, y) {\n    this.markerCircle_.setAttribute('cx', x);\n    this.markerCircle_.setAttribute('cy', y);\n    this.currentMarkerSvg = this.markerCircle_;\n  }\n\n  /**\n   * @override\n   */\n  hide() {\n    super.hide();\n    this.markerCircle_.style.display = 'none';\n  }\n\n  /**\n   * @override\n   */\n  createDomInternal_() {\n    /* clang-format off */\n    /* This markup will be generated and added to the .svgGroup_:\n    <g>\n      <rect width=\"100\" height=\"5\">\n        <animate attributeType=\"XML\" attributeName=\"fill\" dur=\"1s\"\n          values=\"transparent;transparent;#fff;transparent\" repeatCount=\"indefinite\" />\n      </rect>\n    </g>\n    */\n    /* clang-format on */\n\n    super.createDomInternal_();\n\n    this.markerCircle_ = dom.createSvgElement(\n        Svg.CIRCLE, {\n          'r': this.constants_.CURSOR_RADIUS,\n          'style': 'display: none',\n          'stroke-width': this.constants_.CURSOR_STROKE_WIDTH,\n        },\n        this.markerSvg_);\n\n    // Markers and stack cursors don't blink.\n    if (this.isCursor()) {\n      const blinkProperties = this.getBlinkProperties_();\n      dom.createSvgElement(Svg.ANIMATE, blinkProperties, this.markerCircle_);\n    }\n\n    return this.markerSvg_;\n  }\n\n  /**\n   * @override\n   */\n  applyColour_(curNode) {\n    super.applyColour_(curNode);\n\n    this.markerCircle_.setAttribute('fill', this.colour_);\n    this.markerCircle_.setAttribute('stroke', this.colour_);\n\n    if (this.isCursor()) {\n      const values = this.colour_ + ';transparent;transparent;';\n      this.markerCircle_.firstChild.setAttribute('values', values);\n    }\n  }\n}\n\nexports.MarkerSvg = MarkerSvg;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/zelos/marker_svg.js?")},
"./core/renderers/zelos/measurables/bottom_row.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/bottom_row.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview An object representing the bottom row of a rendered block.\n */\n\n\n/**\n * An object representing the bottom row of a rendered block.\n * @class\n */\ngoog.module('Blockly.zelos.BottomRow');\n\nconst {BottomRow: BaseBottomRow} = goog.require('Blockly.blockRendering.BottomRow');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n\n\n/**\n * An object containing information about what elements are in the bottom row of\n * a block as well as spacing information for the top row.\n * Elements in a bottom row can consist of corners, spacers and next\n * connections.\n * @extends {BaseBottomRow}\n * @alias Blockly.zelos.BottomRow\n */\nclass BottomRow extends BaseBottomRow {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @package\n   */\n  constructor(constants) {\n    super(constants);\n  }\n\n  /**\n   * @override\n   */\n  endsWithElemSpacer() {\n    return false;\n  }\n\n  /**\n   * Render a round corner unless the block has an output connection.\n   * @override\n   */\n  hasLeftSquareCorner(block) {\n    return !!block.outputConnection;\n  }\n\n  /**\n   * Render a round corner unless the block has an output connection.\n   * @override\n   */\n  hasRightSquareCorner(block) {\n    return !!block.outputConnection && !block.statementInputCount &&\n        !block.nextConnection;\n  }\n}\n\nexports.BottomRow = BottomRow;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/zelos/measurables/bottom_row.js?")},
"./core/renderers/zelos/measurables/inputs.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/statement_input.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Zelos specific objects representing inputs with connections on\n * a rendered block.\n */\n\n/**\n * Zelos specific objects representing inputs with connections on\n * a rendered block.\n * @class\n */\ngoog.module('Blockly.zelos.StatementInput');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\n/* eslint-disable-next-line no-unused-vars */\nconst {Input} = goog.requireType('Blockly.Input');\nconst {StatementInput: BaseStatementInput} = goog.require('Blockly.blockRendering.StatementInput');\n\n\n/**\n * An object containing information about the space a statement input takes up\n * during rendering.\n * @extends {BaseStatementInput}\n * @alias Blockly.zelos.StatementInput\n */\nclass StatementInput extends BaseStatementInput {\n  /**\n   * @param {!ConstantProvider} constants The rendering constants provider.\n   * @param {!Input} input The statement input to measure and store information\n   *    for.\n   * @package\n   */\n  constructor(constants, input) {\n    super(constants, input);\n\n    if (this.connectedBlock) {\n      // Find the bottom-most connected block in the stack.\n      let block = this.connectedBlock;\n      let nextBlock;\n      while ((nextBlock = block.getNextBlock())) {\n        block = nextBlock;\n      }\n      if (!block.nextConnection) {\n        this.height = this.connectedBlockHeight;\n        this.connectedBottomNextConnection = true;\n      }\n    }\n  }\n}\n\nexports.StatementInput = StatementInput;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/zelos/measurables/inputs.js?")},
"./core/renderers/zelos/measurables/row_elements.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/base.js\");\n__webpack_require__(\"./core/renderers/measurables/types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Zelos specific objects representing elements in a row of a\n * rendered block.\n */\n\n/**\n * Zelos specific objects representing elements in a row of a\n * rendered block.\n * @class\n */\ngoog.module('Blockly.zelos.RightConnectionShape');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {Measurable} = goog.require('Blockly.blockRendering.Measurable');\nconst {Types} = goog.require('Blockly.blockRendering.Types');\n\n\n/**\n * An object containing information about the space a right connection shape\n * takes up during rendering.\n * @extends {Measurable}\n * @alias Blockly.zelos.RightConnectionShape\n */\nclass RightConnectionShape extends Measurable {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @package\n   */\n  constructor(constants) {\n    super(constants);\n    this.type |= Types.getType('RIGHT_CONNECTION');\n    // Size is dynamic\n    this.height = 0;\n    this.width = 0;\n  }\n}\n\nexports.RightConnectionShape = RightConnectionShape;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/zelos/measurables/row_elements.js?")},
"./core/renderers/zelos/measurables/top_row.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/measurables/top_row.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview An object representing the top row of a rendered block.\n */\n\n\n/**\n * An object representing the top row of a rendered block.\n * @class\n */\ngoog.module('Blockly.zelos.TopRow');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.blockRendering.ConstantProvider');\nconst {TopRow: BaseTopRow} = goog.require('Blockly.blockRendering.TopRow');\n\n\n/**\n * An object containing information about what elements are in the top row of a\n * block as well as sizing information for the top row.\n * Elements in a top row can consist of corners, hats, spacers, and previous\n * connections.\n * After this constructor is called, the row will contain all non-spacer\n * elements it needs.\n * @extends {BaseTopRow}\n * @alias Blockly.zelos.TopRow\n */\nclass TopRow extends BaseTopRow {\n  /**\n   * @param {!ConstantProvider} constants The rendering\n   *   constants provider.\n   * @package\n   */\n  constructor(constants) {\n    super(constants);\n  }\n\n  /**\n   * @override\n   */\n  endsWithElemSpacer() {\n    return false;\n  }\n\n  /**\n   * Render a round corner unless the block has an output connection.\n   * @override\n   */\n  hasLeftSquareCorner(block) {\n    const hasHat =\n        (block.hat ? block.hat === 'cap' : this.constants_.ADD_START_HATS) &&\n        !block.outputConnection && !block.previousConnection;\n    return !!block.outputConnection || hasHat;\n  }\n\n  /**\n   * Render a round corner unless the block has an output connection.\n   * @override\n   */\n  hasRightSquareCorner(block) {\n    return !!block.outputConnection && !block.statementInputCount &&\n        !block.nextConnection;\n  }\n}\n\nexports.TopRow = TopRow;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/zelos/measurables/top_row.js?")},
"./core/renderers/zelos/path_object.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/renderers/common/path_object.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview An object that owns a block's rendering SVG elements.\n */\n\n\n\n/**\n * An object that owns a block's rendering SVG elements.\n * @class\n */\ngoog.module('Blockly.zelos.PathObject');\n\nconst dom = goog.require('Blockly.utils.dom');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConstantProvider} = goog.requireType('Blockly.zelos.ConstantProvider');\nconst {PathObject: BasePathObject} = goog.require('Blockly.blockRendering.PathObject');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Theme} = goog.requireType('Blockly.Theme');\n\n\n/**\n * An object that handles creating and setting each of the SVG elements\n * used by the renderer.\n * @alias Blockly.zelos.PathObject\n */\nclass PathObject extends BasePathObject {\n  /**\n   * @param {!SVGElement} root The root SVG element.\n   * @param {!Theme.BlockStyle} style The style object to use for\n   *     colouring.\n   * @param {!ConstantProvider} constants The renderer's constants.\n   * @package\n   */\n  constructor(root, style, constants) {\n    super(root, style, constants);\n\n    /**\n     * The renderer's constant provider.\n     * @type {!ConstantProvider}\n     */\n    this.constants = constants;\n\n    /**\n     * The selected path of the block.\n     * @type {?SVGElement}\n     * @private\n     */\n    this.svgPathSelected_ = null;\n\n    /**\n     * The outline paths on the block.\n     * @type {!Object<string, !SVGElement>}\n     * @private\n     */\n    this.outlines_ = Object.create(null);\n\n    /**\n     * A set used to determine which outlines were used during a draw pass.  The\n     * set is initialized with a reference to all the outlines in\n     * `this.outlines_`. Every time we use an outline during the draw pass, the\n     * reference is removed from this set.\n     * @type {Object<string, number>}\n     * @private\n     */\n    this.remainingOutlines_ = null;\n\n    /**\n     * The type of block's output connection shape.  This is set when a block\n     * with an output connection is drawn.\n     * @package\n     */\n    this.outputShapeType = null;\n  }\n\n  /**\n   * @override\n   */\n  setPath(pathString) {\n    super.setPath(pathString);\n    if (this.svgPathSelected_) {\n      this.svgPathSelected_.setAttribute('d', pathString);\n    }\n  }\n\n  /**\n   * @override\n   */\n  applyColour(block) {\n    super.applyColour(block);\n    // Set shadow stroke colour.\n    if (block.isShadow() && block.getParent()) {\n      this.svgPath.setAttribute(\n          'stroke', block.getParent().style.colourTertiary);\n    }\n\n    // Apply colour to outlines.\n    for (const key in this.outlines_) {\n      this.outlines_[key].setAttribute('fill', this.style.colourTertiary);\n    }\n  }\n\n  /**\n   * @override\n   */\n  flipRTL() {\n    super.flipRTL();\n    // Mirror each input outline path.\n    for (const key in this.outlines_) {\n      this.outlines_[key].setAttribute('transform', 'scale(-1 1)');\n    }\n  }\n\n  /**\n   * @override\n   */\n  updateSelected(enable) {\n    this.setClass_('blocklySelected', enable);\n    if (enable) {\n      if (!this.svgPathSelected_) {\n        this.svgPathSelected_ =\n            /** @type {!SVGElement} */ (this.svgPath.cloneNode(true));\n        this.svgPathSelected_.setAttribute('fill', 'none');\n        this.svgPathSelected_.setAttribute(\n            'filter', 'url(#' + this.constants.selectedGlowFilterId + ')');\n        this.svgRoot.appendChild(this.svgPathSelected_);\n      }\n    } else {\n      if (this.svgPathSelected_) {\n        this.svgRoot.removeChild(this.svgPathSelected_);\n        this.svgPathSelected_ = null;\n      }\n    }\n  }\n\n  /**\n   * @override\n   */\n  updateReplacementFade(enable) {\n    this.setClass_('blocklyReplaceable', enable);\n    if (enable) {\n      this.svgPath.setAttribute(\n          'filter', 'url(#' + this.constants.replacementGlowFilterId + ')');\n    } else {\n      this.svgPath.removeAttribute('filter');\n    }\n  }\n\n  /**\n   * @override\n   */\n  updateShapeForInputHighlight(conn, enable) {\n    const name = conn.getParentInput().name;\n    const outlinePath = this.getOutlinePath_(name);\n    if (!outlinePath) {\n      return;\n    }\n    if (enable) {\n      outlinePath.setAttribute(\n          'filter', 'url(#' + this.constants.replacementGlowFilterId + ')');\n    } else {\n      outlinePath.removeAttribute('filter');\n    }\n  }\n\n  /**\n   * Method that's called when the drawer is about to draw the block.\n   * @package\n   */\n  beginDrawing() {\n    this.remainingOutlines_ = Object.create(null);\n    for (const key in this.outlines_) {\n      // The value set here isn't used anywhere, we are just using the\n      // object as a Set data structure.\n      this.remainingOutlines_[key] = 1;\n    }\n  }\n\n  /**\n   * Method that's called when the drawer is done drawing.\n   * @package\n   */\n  endDrawing() {\n    // Go through all remaining outlines that were not used this draw pass, and\n    // remove them.\n    if (this.remainingOutlines_) {\n      for (const key in this.remainingOutlines_) {\n        this.removeOutlinePath_(key);\n      }\n    }\n    this.remainingOutlines_ = null;\n  }\n\n  /**\n   * Set the path generated by the renderer for an outline path on the\n   * respective outline path SVG element.\n   * @param {string} name The input name.\n   * @param {string} pathString The path.\n   * @package\n   */\n  setOutlinePath(name, pathString) {\n    const outline = this.getOutlinePath_(name);\n    outline.setAttribute('d', pathString);\n    outline.setAttribute('fill', this.style.colourTertiary);\n  }\n\n  /**\n   * Create's an outline path for the specified input.\n   * @param {string} name The input name.\n   * @return {!SVGElement} The SVG outline path.\n   * @private\n   */\n  getOutlinePath_(name) {\n    if (!this.outlines_[name]) {\n      this.outlines_[name] = dom.createSvgElement(\n          Svg.PATH, {\n            'class': 'blocklyOutlinePath',\n            // IE doesn't like paths without the data definition, set empty\n            // default\n            'd': '',\n          },\n          this.svgRoot);\n    }\n    if (this.remainingOutlines_) {\n      delete this.remainingOutlines_[name];\n    }\n    return this.outlines_[name];\n  }\n\n  /**\n   * Remove an outline path that is associated with the specified input.\n   * @param {string} name The input name.\n   * @private\n   */\n  removeOutlinePath_(name) {\n    this.outlines_[name].parentNode.removeChild(this.outlines_[name]);\n    delete this.outlines_[name];\n  }\n}\n\nexports.PathObject = PathObject;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/zelos/path_object.js?")},
"./core/renderers/zelos/renderer.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/common/block_rendering.js\");\n__webpack_require__(\"./core/connection_type.js\");\n__webpack_require__(\"./core/renderers/zelos/constants.js\");\n__webpack_require__(\"./core/renderers/zelos/drawer.js\");\n__webpack_require__(\"./core/insertion_marker_manager.js\");\n__webpack_require__(\"./core/renderers/zelos/marker_svg.js\");\n__webpack_require__(\"./core/renderers/zelos/path_object.js\");\n__webpack_require__(\"./core/renderers/zelos/info.js\");\n__webpack_require__(\"./core/renderers/common/renderer.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Zelos renderer.\n */\n\n\n/**\n * Zelos renderer.\n * @class\n */\ngoog.module('Blockly.zelos.Renderer');\n\nconst blockRendering = goog.require('Blockly.blockRendering');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {ConnectionType} = goog.require('Blockly.ConnectionType');\nconst {ConstantProvider} = goog.require('Blockly.zelos.ConstantProvider');\nconst {Drawer} = goog.require('Blockly.zelos.Drawer');\nconst {InsertionMarkerManager} = goog.require('Blockly.InsertionMarkerManager');\nconst {MarkerSvg} = goog.require('Blockly.zelos.MarkerSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Marker} = goog.requireType('Blockly.Marker');\nconst {PathObject} = goog.require('Blockly.zelos.PathObject');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderInfo: BaseRenderInfo} = goog.requireType('Blockly.blockRendering.RenderInfo');\nconst {RenderInfo} = goog.require('Blockly.zelos.RenderInfo');\nconst {Renderer: BaseRenderer} = goog.require('Blockly.blockRendering.Renderer');\n/* eslint-disable-next-line no-unused-vars */\nconst {Theme} = goog.requireType('Blockly.Theme');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * The zelos renderer.\n * @extends {BaseRenderer}\n * @alias Blockly.zelos.Renderer\n */\nclass Renderer extends BaseRenderer {\n  /**\n   * @param {string} name The renderer name.\n   * @package\n   */\n  constructor(name) {\n    super(name);\n  }\n\n  /**\n   * Create a new instance of the renderer's constant provider.\n   * @return {!ConstantProvider} The constant provider.\n   * @protected\n   * @override\n   */\n  makeConstants_() {\n    return new ConstantProvider();\n  }\n\n  /**\n   * Create a new instance of the renderer's render info object.\n   * @param {!BlockSvg} block The block to measure.\n   * @return {!RenderInfo} The render info object.\n   * @protected\n   * @override\n   */\n  makeRenderInfo_(block) {\n    return new RenderInfo(this, block);\n  }\n\n  /**\n   * Create a new instance of the renderer's drawer.\n   * @param {!BlockSvg} block The block to render.\n   * @param {!BaseRenderInfo} info An object containing all\n   *   information needed to render this block.\n   * @return {!Drawer} The drawer.\n   * @protected\n   * @override\n   */\n  makeDrawer_(block, info) {\n    return new Drawer(\n        block,\n        /** @type {!RenderInfo} */ (info));\n  }\n\n  /**\n   * Create a new instance of the renderer's cursor drawer.\n   * @param {!WorkspaceSvg} workspace The workspace the cursor belongs to.\n   * @param {!Marker} marker The marker.\n   * @return {!MarkerSvg} The object in charge of drawing\n   *     the marker.\n   * @package\n   * @override\n   */\n  makeMarkerDrawer(workspace, marker) {\n    return new MarkerSvg(workspace, this.getConstants(), marker);\n  }\n\n  /**\n   * Create a new instance of a renderer path object.\n   * @param {!SVGElement} root The root SVG element.\n   * @param {!Theme.BlockStyle} style The style object to use for\n   *     colouring.\n   * @return {!PathObject} The renderer path object.\n   * @package\n   * @override\n   */\n  makePathObject(root, style) {\n    return new PathObject(\n        root, style,\n        /** @type {!ConstantProvider} */ (this.getConstants()));\n  }\n\n  /**\n   * @override\n   */\n  shouldHighlightConnection(conn) {\n    return conn.type !== ConnectionType.INPUT_VALUE &&\n        conn.type !== ConnectionType.OUTPUT_VALUE;\n  }\n\n  /**\n   * @override\n   */\n  getConnectionPreviewMethod(closest, local, topBlock) {\n    if (local.type === ConnectionType.OUTPUT_VALUE) {\n      if (!closest.isConnected()) {\n        return InsertionMarkerManager.PREVIEW_TYPE.INPUT_OUTLINE;\n      }\n      // TODO: Returning this is a total hack, because we don't want to show\n      //   a replacement fade, we want to show an outline affect.\n      //   Sadly zelos does not support showing an outline around filled\n      //   inputs, so we have to pretend like the connected block is getting\n      //   replaced.\n      return InsertionMarkerManager.PREVIEW_TYPE.REPLACEMENT_FADE;\n    }\n\n    return super.getConnectionPreviewMethod(closest, local, topBlock);\n  }\n}\n\nblockRendering.register('zelos', Renderer);\n\nexports.Renderer = Renderer;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/zelos/renderer.js?")},
"./core/renderers/zelos/zelos.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/renderers/zelos/measurables/bottom_row.js\");\n__webpack_require__(\"./core/renderers/zelos/constants.js\");\n__webpack_require__(\"./core/renderers/zelos/drawer.js\");\n__webpack_require__(\"./core/renderers/zelos/marker_svg.js\");\n__webpack_require__(\"./core/renderers/zelos/path_object.js\");\n__webpack_require__(\"./core/renderers/zelos/info.js\");\n__webpack_require__(\"./core/renderers/zelos/renderer.js\");\n__webpack_require__(\"./core/renderers/zelos/measurables/row_elements.js\");\n__webpack_require__(\"./core/renderers/zelos/measurables/inputs.js\");\n__webpack_require__(\"./core/renderers/zelos/measurables/top_row.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Re-exports of Blockly.zelos.* modules.\n */\n\n\n/**\n * Re-exports of Blockly.zelos.* modules.\n * @namespace Blockly.zelos\n */\ngoog.module('Blockly.zelos');\n\nconst {BottomRow} = goog.require('Blockly.zelos.BottomRow');\nconst {ConstantProvider} = goog.require('Blockly.zelos.ConstantProvider');\nconst {Drawer} = goog.require('Blockly.zelos.Drawer');\nconst {MarkerSvg} = goog.require('Blockly.zelos.MarkerSvg');\nconst {PathObject} = goog.require('Blockly.zelos.PathObject');\nconst {RenderInfo} = goog.require('Blockly.zelos.RenderInfo');\nconst {Renderer} = goog.require('Blockly.zelos.Renderer');\nconst {RightConnectionShape} = goog.require('Blockly.zelos.RightConnectionShape');\nconst {StatementInput} = goog.require('Blockly.zelos.StatementInput');\nconst {TopRow} = goog.require('Blockly.zelos.TopRow');\n\nexports.BottomRow = BottomRow;\nexports.ConstantProvider = ConstantProvider;\nexports.Drawer = Drawer;\nexports.MarkerSvg = MarkerSvg;\nexports.PathObject = PathObject;\nexports.RenderInfo = RenderInfo;\nexports.Renderer = Renderer;\nexports.RightConnectionShape = RightConnectionShape;\nexports.StatementInput = StatementInput;\nexports.TopRow = TopRow;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/renderers/zelos/zelos.js?")},
"./core/scrollbar.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/touch.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/utils/svg_math.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2011 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing a scrollbar.\n */\n\n\n/**\n * Object representing a scrollbar.\n * @class\n */\ngoog.module('Blockly.Scrollbar');\n\nconst Touch = goog.require('Blockly.Touch');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst dom = goog.require('Blockly.utils.dom');\nconst svgMath = goog.require('Blockly.utils.svgMath');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\n/* eslint-disable-next-line no-unused-vars */\nconst {Metrics} = goog.requireType('Blockly.utils.Metrics');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * A note on units: most of the numbers that are in CSS pixels are scaled if the\n * scrollbar is in a mutator.\n */\n\n/**\n * Class for a pure SVG scrollbar.\n * This technique offers a scrollbar that is guaranteed to work, but may not\n * look or behave like the system's scrollbars.\n * @alias Blockly.Scrollbar\n */\nclass Scrollbar {\n  /**\n   * @param {!WorkspaceSvg} workspace Workspace to bind the scrollbar to.\n   * @param {boolean} horizontal True if horizontal, false if vertical.\n   * @param {boolean=} opt_pair True if scrollbar is part of a horiz/vert pair.\n   * @param {string=} opt_class A class to be applied to this scrollbar.\n   * @param {number=} opt_margin The margin to apply to this scrollbar.\n   */\n  constructor(workspace, horizontal, opt_pair, opt_class, opt_margin) {\n    /**\n     * The workspace this scrollbar is bound to.\n     * @type {!WorkspaceSvg}\n     * @private\n     */\n    this.workspace_ = workspace;\n    /**\n     * Whether this scrollbar is part of a pair.\n     * @type {boolean}\n     * @private\n     */\n    this.pair_ = opt_pair || false;\n    /**\n     * Whether this is a horizontal scrollbar.\n     * @type {boolean}\n     * @private\n     */\n    this.horizontal_ = horizontal;\n    /**\n     * Margin around the scrollbar (between the scrollbar and the edge of the\n     * viewport in pixels).\n     * @type {number}\n     * @const\n     * @private\n     */\n    this.margin_ = (opt_margin !== undefined) ?\n        opt_margin :\n        Scrollbar.DEFAULT_SCROLLBAR_MARGIN;\n    /**\n     * Previously recorded metrics from the workspace.\n     * @type {?Metrics}\n     * @private\n     */\n    this.oldHostMetrics_ = null;\n    /**\n     * The ratio of handle position offset to workspace content displacement.\n     * @type {?number}\n     * @package\n     */\n    this.ratio = null;\n\n    /**\n     * The location of the origin of the workspace that the scrollbar is in,\n     * measured in CSS pixels relative to the injection div origin.  This is\n     * usually (0, 0).  When the scrollbar is in a flyout it may have a\n     * different origin.\n     * @type {Coordinate}\n     * @private\n     */\n    this.origin_ = new Coordinate(0, 0);\n\n    /**\n     * The position of the mouse along this scrollbar's major axis at the start\n     * of the most recent drag. Units are CSS pixels, with (0, 0) at the top\n     * left of the browser window. For a horizontal scrollbar this is the x\n     * coordinate of the mouse down event; for a vertical scrollbar it's the y\n     * coordinate of the mouse down event.\n     * @type {number}\n     * @private\n     */\n    this.startDragMouse_ = 0;\n\n    /**\n     * The length of the scrollbars (including the handle and the background),\n     * in CSS pixels. This is equivalent to scrollbar background length and the\n     * area within which the scrollbar handle can move.\n     * @type {number}\n     * @private\n     */\n    this.scrollbarLength_ = 0;\n\n    /**\n     * The length of the scrollbar handle in CSS pixels.\n     * @type {number}\n     * @private\n     */\n    this.handleLength_ = 0;\n\n    /**\n     * The offset of the start of the handle from the scrollbar position, in CSS\n     * pixels.\n     * @type {number}\n     * @private\n     */\n    this.handlePosition_ = 0;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.startDragHandle = 0;\n\n    /**\n     * Whether the scrollbar handle is visible.\n     * @type {boolean}\n     * @private\n     */\n    this.isVisible_ = true;\n\n    /**\n     * Whether the workspace containing this scrollbar is visible.\n     * @type {boolean}\n     * @private\n     */\n    this.containerVisible_ = true;\n\n    /**\n     * @type {?SVGRectElement}\n     * @private\n     */\n    this.svgBackground_ = null;\n\n    /**\n     * @type {?SVGRectElement}\n     * @private\n     */\n    this.svgHandle_ = null;\n\n    /**\n     * @type {?SVGSVGElement}\n     * @private\n     */\n    this.outerSvg_ = null;\n\n    /**\n     * @type {?SVGGElement}\n     * @private\n     */\n    this.svgGroup_ = null;\n\n    this.createDom_(opt_class);\n\n    /**\n     * The upper left corner of the scrollbar's SVG group in CSS pixels relative\n     * to the scrollbar's origin.  This is usually relative to the injection div\n     * origin.\n     * @type {Coordinate}\n     * @package\n     */\n    this.position = new Coordinate(0, 0);\n\n    // Store the thickness in a temp variable for readability.\n    const scrollbarThickness = Scrollbar.scrollbarThickness;\n    if (horizontal) {\n      this.svgBackground_.setAttribute('height', scrollbarThickness);\n      this.outerSvg_.setAttribute('height', scrollbarThickness);\n      this.svgHandle_.setAttribute('height', scrollbarThickness - 5);\n      this.svgHandle_.setAttribute('y', 2.5);\n\n      this.lengthAttribute_ = 'width';\n      this.positionAttribute_ = 'x';\n    } else {\n      this.svgBackground_.setAttribute('width', scrollbarThickness);\n      this.outerSvg_.setAttribute('width', scrollbarThickness);\n      this.svgHandle_.setAttribute('width', scrollbarThickness - 5);\n      this.svgHandle_.setAttribute('x', 2.5);\n\n      this.lengthAttribute_ = 'height';\n      this.positionAttribute_ = 'y';\n    }\n    const scrollbar = this;\n    this.onMouseDownBarWrapper_ = browserEvents.conditionalBind(\n        this.svgBackground_, 'mousedown', scrollbar, scrollbar.onMouseDownBar_);\n    this.onMouseDownHandleWrapper_ = browserEvents.conditionalBind(\n        this.svgHandle_, 'mousedown', scrollbar, scrollbar.onMouseDownHandle_);\n  }\n\n  /**\n   * Dispose of this scrollbar.\n   * Unlink from all DOM elements to prevent memory leaks.\n   * @suppress {checkTypes}\n   */\n  dispose() {\n    this.cleanUp_();\n    browserEvents.unbind(this.onMouseDownBarWrapper_);\n    this.onMouseDownBarWrapper_ = null;\n    browserEvents.unbind(this.onMouseDownHandleWrapper_);\n    this.onMouseDownHandleWrapper_ = null;\n\n    dom.removeNode(this.outerSvg_);\n    this.outerSvg_ = null;\n    this.svgGroup_ = null;\n    this.svgBackground_ = null;\n    if (this.svgHandle_) {\n      this.workspace_.getThemeManager().unsubscribe(this.svgHandle_);\n      this.svgHandle_ = null;\n    }\n    this.workspace_ = null;\n  }\n\n  /**\n   * Constrain the handle's length within the minimum (0) and maximum\n   * (scrollbar background) values allowed for the scrollbar.\n   * @param {number} value Value that is potentially out of bounds, in CSS\n   *     pixels.\n   * @return {number} Constrained value, in CSS pixels.\n   * @private\n   */\n  constrainHandleLength_(value) {\n    if (value <= 0 || isNaN(value)) {\n      value = 0;\n    } else {\n      value = Math.min(value, this.scrollbarLength_);\n    }\n    return value;\n  }\n\n  /**\n   * Set the length of the scrollbar's handle and change the SVG attribute\n   * accordingly.\n   * @param {number} newLength The new scrollbar handle length in CSS pixels.\n   * @private\n   */\n  setHandleLength_(newLength) {\n    this.handleLength_ = newLength;\n    this.svgHandle_.setAttribute(this.lengthAttribute_, this.handleLength_);\n  }\n\n  /**\n   * Constrain the handle's position within the minimum (0) and maximum values\n   * allowed for the scrollbar.\n   * @param {number} value Value that is potentially out of bounds, in CSS\n   *     pixels.\n   * @return {number} Constrained value, in CSS pixels.\n   * @private\n   */\n  constrainHandlePosition_(value) {\n    if (value <= 0 || isNaN(value)) {\n      value = 0;\n    } else {\n      // Handle length should never be greater than this.scrollbarLength_.\n      // If the viewSize is greater than or equal to the scrollSize, the\n      // handleLength will end up equal to this.scrollbarLength_.\n      value = Math.min(value, this.scrollbarLength_ - this.handleLength_);\n    }\n    return value;\n  }\n\n  /**\n   * Set the offset of the scrollbar's handle from the scrollbar's position, and\n   * change the SVG attribute accordingly.\n   * @param {number} newPosition The new scrollbar handle offset in CSS pixels.\n   */\n  setHandlePosition(newPosition) {\n    this.handlePosition_ = newPosition;\n    this.svgHandle_.setAttribute(this.positionAttribute_, this.handlePosition_);\n  }\n\n  /**\n   * Set the size of the scrollbar's background and change the SVG attribute\n   * accordingly.\n   * @param {number} newSize The new scrollbar background length in CSS pixels.\n   * @private\n   */\n  setScrollbarLength_(newSize) {\n    this.scrollbarLength_ = newSize;\n    this.outerSvg_.setAttribute(this.lengthAttribute_, this.scrollbarLength_);\n    this.svgBackground_.setAttribute(\n        this.lengthAttribute_, this.scrollbarLength_);\n  }\n\n  /**\n   * Set the position of the scrollbar's SVG group in CSS pixels relative to the\n   * scrollbar's origin.  This sets the scrollbar's location within the\n   * workspace.\n   * @param {number} x The new x coordinate.\n   * @param {number} y The new y coordinate.\n   * @package\n   */\n  setPosition(x, y) {\n    this.position.x = x;\n    this.position.y = y;\n\n    const tempX = this.position.x + this.origin_.x;\n    const tempY = this.position.y + this.origin_.y;\n    const transform = 'translate(' + tempX + 'px,' + tempY + 'px)';\n    dom.setCssTransform(/** @type {!Element} */ (this.outerSvg_), transform);\n  }\n\n  /**\n   * Recalculate the scrollbar's location and its length.\n   * @param {Metrics=} opt_metrics A data structure of from the\n   *     describing all the required dimensions.  If not provided, it will be\n   *     fetched from the host object.\n   */\n  resize(opt_metrics) {\n    // Determine the location, height and width of the host element.\n    let hostMetrics = opt_metrics;\n    if (!hostMetrics) {\n      hostMetrics = this.workspace_.getMetrics();\n      if (!hostMetrics) {\n        // Host element is likely not visible.\n        return;\n      }\n    }\n\n    if (this.oldHostMetrics_ &&\n        Scrollbar.metricsAreEquivalent_(hostMetrics, this.oldHostMetrics_)) {\n      return;\n    }\n\n    if (this.horizontal_) {\n      this.resizeHorizontal_(hostMetrics);\n    } else {\n      this.resizeVertical_(hostMetrics);\n    }\n\n    this.oldHostMetrics_ = hostMetrics;\n\n    // Resizing may have caused some scrolling.\n    this.updateMetrics_();\n  }\n\n  /**\n   * Returns whether the a resizeView is necessary by comparing the passed\n   * hostMetrics with cached old host metrics.\n   * @param {!Metrics} hostMetrics A data structure describing all\n   *     the required dimensions, possibly fetched from the host object.\n   * @return {boolean} Whether a resizeView is necessary.\n   * @private\n   */\n  requiresViewResize_(hostMetrics) {\n    if (!this.oldHostMetrics_) {\n      return true;\n    }\n    return this.oldHostMetrics_.viewWidth !== hostMetrics.viewWidth ||\n        this.oldHostMetrics_.viewHeight !== hostMetrics.viewHeight ||\n        this.oldHostMetrics_.absoluteLeft !== hostMetrics.absoluteLeft ||\n        this.oldHostMetrics_.absoluteTop !== hostMetrics.absoluteTop;\n  }\n\n  /**\n   * Recalculate a horizontal scrollbar's location and length.\n   * @param {!Metrics} hostMetrics A data structure describing all\n   *     the required dimensions, possibly fetched from the host object.\n   * @private\n   */\n  resizeHorizontal_(hostMetrics) {\n    if (this.requiresViewResize_(hostMetrics)) {\n      this.resizeViewHorizontal(hostMetrics);\n    } else {\n      this.resizeContentHorizontal(hostMetrics);\n    }\n  }\n\n  /**\n   * Recalculate a horizontal scrollbar's location on the screen and path\n   * length. This should be called when the layout or size of the window has\n   * changed.\n   * @param {!Metrics} hostMetrics A data structure describing all\n   *     the required dimensions, possibly fetched from the host object.\n   */\n  resizeViewHorizontal(hostMetrics) {\n    let viewSize = hostMetrics.viewWidth - this.margin_ * 2;\n    if (this.pair_) {\n      // Shorten the scrollbar to make room for the corner square.\n      viewSize -= Scrollbar.scrollbarThickness;\n    }\n    this.setScrollbarLength_(Math.max(0, viewSize));\n\n    let xCoordinate = hostMetrics.absoluteLeft + this.margin_;\n    if (this.pair_ && this.workspace_.RTL) {\n      xCoordinate += Scrollbar.scrollbarThickness;\n    }\n\n    // Horizontal toolbar should always be just above the bottom of the\n    // workspace.\n    const yCoordinate = hostMetrics.absoluteTop + hostMetrics.viewHeight -\n        Scrollbar.scrollbarThickness - this.margin_;\n    this.setPosition(xCoordinate, yCoordinate);\n\n    // If the view has been resized, a content resize will also be necessary.\n    // The reverse is not true.\n    this.resizeContentHorizontal(hostMetrics);\n  }\n\n  /**\n   * Recalculate a horizontal scrollbar's location within its path and length.\n   * This should be called when the contents of the workspace have changed.\n   * @param {!Metrics} hostMetrics A data structure describing all\n   *     the required dimensions, possibly fetched from the host object.\n   */\n  resizeContentHorizontal(hostMetrics) {\n    if (hostMetrics.viewWidth >= hostMetrics.scrollWidth) {\n      // viewWidth is often greater than scrollWidth in flyouts and\n      // non-scrollable workspaces.\n      this.setHandleLength_(this.scrollbarLength_);\n      this.setHandlePosition(0);\n      if (!this.pair_) {\n        // The scrollbar isn't needed.\n        // This doesn't apply to scrollbar pairs because interactions with the\n        // corner square aren't handled.\n        this.setVisible(false);\n      }\n      return;\n    } else if (!this.pair_) {\n      // The scrollbar is needed. Only non-paired scrollbars are hidden/shown.\n      this.setVisible(true);\n    }\n\n    // Resize the handle.\n    let handleLength =\n        this.scrollbarLength_ * hostMetrics.viewWidth / hostMetrics.scrollWidth;\n    handleLength = this.constrainHandleLength_(handleLength);\n    this.setHandleLength_(handleLength);\n\n    // Compute the handle offset.\n    // The position of the handle can be between:\n    //     0 and this.scrollbarLength_ - handleLength\n    // If viewLeft === scrollLeft\n    //     then the offset should be 0\n    // If viewRight === scrollRight\n    //     then viewLeft = scrollLeft + scrollWidth - viewWidth\n    //     then the offset should be max offset\n\n    const maxScrollDistance = hostMetrics.scrollWidth - hostMetrics.viewWidth;\n    const contentDisplacement = hostMetrics.viewLeft - hostMetrics.scrollLeft;\n    // Percent of content to the left of our current position.\n    const offsetRatio = contentDisplacement / maxScrollDistance;\n    // Area available to scroll * percent to the left\n    const maxHandleOffset = this.scrollbarLength_ - this.handleLength_;\n    let handleOffset = maxHandleOffset * offsetRatio;\n    handleOffset = this.constrainHandlePosition_(handleOffset);\n    this.setHandlePosition(handleOffset);\n\n    // Compute ratio (for use with set calls, which pass in content\n    // displacement).\n    this.ratio = maxHandleOffset / maxScrollDistance;\n  }\n\n  /**\n   * Recalculate a vertical scrollbar's location and length.\n   * @param {!Metrics} hostMetrics A data structure describing all\n   *     the required dimensions, possibly fetched from the host object.\n   * @private\n   */\n  resizeVertical_(hostMetrics) {\n    if (this.requiresViewResize_(hostMetrics)) {\n      this.resizeViewVertical(hostMetrics);\n    } else {\n      this.resizeContentVertical(hostMetrics);\n    }\n  }\n\n  /**\n   * Recalculate a vertical scrollbar's location on the screen and path length.\n   * This should be called when the layout or size of the window has changed.\n   * @param {!Metrics} hostMetrics A data structure describing all\n   *     the required dimensions, possibly fetched from the host object.\n   */\n  resizeViewVertical(hostMetrics) {\n    let viewSize = hostMetrics.viewHeight - this.margin_ * 2;\n    if (this.pair_) {\n      // Shorten the scrollbar to make room for the corner square.\n      viewSize -= Scrollbar.scrollbarThickness;\n    }\n    this.setScrollbarLength_(Math.max(0, viewSize));\n\n    const xCoordinate = this.workspace_.RTL ?\n        hostMetrics.absoluteLeft + this.margin_ :\n        hostMetrics.absoluteLeft + hostMetrics.viewWidth -\n            Scrollbar.scrollbarThickness - this.margin_;\n\n    const yCoordinate = hostMetrics.absoluteTop + this.margin_;\n    this.setPosition(xCoordinate, yCoordinate);\n\n    // If the view has been resized, a content resize will also be necessary.\n    // The reverse is not true.\n    this.resizeContentVertical(hostMetrics);\n  }\n\n  /**\n   * Recalculate a vertical scrollbar's location within its path and length.\n   * This should be called when the contents of the workspace have changed.\n   * @param {!Metrics} hostMetrics A data structure describing all\n   *     the required dimensions, possibly fetched from the host object.\n   */\n  resizeContentVertical(hostMetrics) {\n    if (hostMetrics.viewHeight >= hostMetrics.scrollHeight) {\n      // viewHeight is often greater than scrollHeight in flyouts and\n      // non-scrollable workspaces.\n      this.setHandleLength_(this.scrollbarLength_);\n      this.setHandlePosition(0);\n      if (!this.pair_) {\n        // The scrollbar isn't needed.\n        // This doesn't apply to scrollbar pairs because interactions with the\n        // corner square aren't handled.\n        this.setVisible(false);\n      }\n      return;\n    } else if (!this.pair_) {\n      // The scrollbar is needed. Only non-paired scrollbars are hidden/shown.\n      this.setVisible(true);\n    }\n\n    // Resize the handle.\n    let handleLength = this.scrollbarLength_ * hostMetrics.viewHeight /\n        hostMetrics.scrollHeight;\n    handleLength = this.constrainHandleLength_(handleLength);\n    this.setHandleLength_(handleLength);\n\n    // Compute the handle offset.\n    // The position of the handle can be between:\n    //     0 and this.scrollbarLength_ - handleLength\n    // If viewTop === scrollTop\n    //     then the offset should be 0\n    // If viewBottom === scrollBottom\n    //     then viewTop = scrollTop + scrollHeight - viewHeight\n    //     then the offset should be max offset\n\n    const maxScrollDistance = hostMetrics.scrollHeight - hostMetrics.viewHeight;\n    const contentDisplacement = hostMetrics.viewTop - hostMetrics.scrollTop;\n    // Percent of content to the left of our current position.\n    const offsetRatio = contentDisplacement / maxScrollDistance;\n    // Area available to scroll * percent to the left\n    const maxHandleOffset = this.scrollbarLength_ - this.handleLength_;\n    let handleOffset = maxHandleOffset * offsetRatio;\n    handleOffset = this.constrainHandlePosition_(handleOffset);\n    this.setHandlePosition(handleOffset);\n\n    // Compute ratio (for use with set calls, which pass in content\n    // displacement).\n    this.ratio = maxHandleOffset / maxScrollDistance;\n  }\n\n  /**\n   * Create all the DOM elements required for a scrollbar.\n   * The resulting widget is not sized.\n   * @param {string=} opt_class A class to be applied to this scrollbar.\n   * @private\n   */\n  createDom_(opt_class) {\n    /* Create the following DOM:\n    <svg class=\"blocklyScrollbarHorizontal  optionalClass\">\n      <g>\n        <rect class=\"blocklyScrollbarBackground\" />\n        <rect class=\"blocklyScrollbarHandle\" rx=\"8\" ry=\"8\" />\n      </g>\n    </svg>\n    */\n    let className =\n        'blocklyScrollbar' + (this.horizontal_ ? 'Horizontal' : 'Vertical');\n    if (opt_class) {\n      className += ' ' + opt_class;\n    }\n    this.outerSvg_ = dom.createSvgElement(Svg.SVG, {'class': className}, null);\n    this.svgGroup_ = dom.createSvgElement(Svg.G, {}, this.outerSvg_);\n    this.svgBackground_ = dom.createSvgElement(\n        Svg.RECT, {'class': 'blocklyScrollbarBackground'}, this.svgGroup_);\n    const radius = Math.floor((Scrollbar.scrollbarThickness - 5) / 2);\n    this.svgHandle_ = dom.createSvgElement(\n        Svg.RECT,\n        {'class': 'blocklyScrollbarHandle', 'rx': radius, 'ry': radius},\n        this.svgGroup_);\n    this.workspace_.getThemeManager().subscribe(\n        this.svgHandle_, 'scrollbarColour', 'fill');\n    this.workspace_.getThemeManager().subscribe(\n        this.svgHandle_, 'scrollbarOpacity', 'fill-opacity');\n    dom.insertAfter(this.outerSvg_, this.workspace_.getParentSvg());\n  }\n\n  /**\n   * Is the scrollbar visible.  Non-paired scrollbars disappear when they aren't\n   * needed.\n   * @return {boolean} True if visible.\n   */\n  isVisible() {\n    return this.isVisible_;\n  }\n\n  /**\n   * Set whether the scrollbar's container is visible and update\n   * display accordingly if visibility has changed.\n   * @param {boolean} visible Whether the container is visible\n   */\n  setContainerVisible(visible) {\n    const visibilityChanged = (visible !== this.containerVisible_);\n\n    this.containerVisible_ = visible;\n    if (visibilityChanged) {\n      this.updateDisplay_();\n    }\n  }\n\n  /**\n   * Set whether the scrollbar is visible.\n   * Only applies to non-paired scrollbars.\n   * @param {boolean} visible True if visible.\n   */\n  setVisible(visible) {\n    const visibilityChanged = (visible !== this.isVisible());\n\n    // Ideally this would also apply to scrollbar pairs, but that's a bigger\n    // headache (due to interactions with the corner square).\n    if (this.pair_) {\n      throw Error('Unable to toggle visibility of paired scrollbars.');\n    }\n    this.isVisible_ = visible;\n    if (visibilityChanged) {\n      this.updateDisplay_();\n    }\n  }\n\n  /**\n   * Update visibility of scrollbar based on whether it thinks it should\n   * be visible and whether its containing workspace is visible.\n   * We cannot rely on the containing workspace being hidden to hide us\n   * because it is not necessarily our parent in the DOM.\n   */\n  updateDisplay_() {\n    let show = true;\n    // Check whether our parent/container is visible.\n    if (!this.containerVisible_) {\n      show = false;\n    } else {\n      show = this.isVisible();\n    }\n    if (show) {\n      this.outerSvg_.setAttribute('display', 'block');\n    } else {\n      this.outerSvg_.setAttribute('display', 'none');\n    }\n  }\n\n  /**\n   * Scroll by one pageful.\n   * Called when scrollbar background is clicked.\n   * @param {!Event} e Mouse down event.\n   * @private\n   */\n  onMouseDownBar_(e) {\n    this.workspace_.markFocused();\n    Touch.clearTouchIdentifier();  // This is really a click.\n    this.cleanUp_();\n    if (browserEvents.isRightButton(e)) {\n      // Right-click.\n      // Scrollbars have no context menu.\n      e.stopPropagation();\n      return;\n    }\n    const mouseXY = browserEvents.mouseToSvg(\n        e, this.workspace_.getParentSvg(),\n        this.workspace_.getInverseScreenCTM());\n    const mouseLocation = this.horizontal_ ? mouseXY.x : mouseXY.y;\n\n    const handleXY =\n        svgMath.getInjectionDivXY(/** @type {!Element} */ (this.svgHandle_));\n    const handleStart = this.horizontal_ ? handleXY.x : handleXY.y;\n    let handlePosition = this.handlePosition_;\n\n    const pageLength = this.handleLength_ * 0.95;\n    if (mouseLocation <= handleStart) {\n      // Decrease the scrollbar's value by a page.\n      handlePosition -= pageLength;\n    } else if (mouseLocation >= handleStart + this.handleLength_) {\n      // Increase the scrollbar's value by a page.\n      handlePosition += pageLength;\n    }\n\n    this.setHandlePosition(this.constrainHandlePosition_(handlePosition));\n\n    this.updateMetrics_();\n    e.stopPropagation();\n    e.preventDefault();\n  }\n\n  /**\n   * Start a dragging operation.\n   * Called when scrollbar handle is clicked.\n   * @param {!Event} e Mouse down event.\n   * @private\n   */\n  onMouseDownHandle_(e) {\n    this.workspace_.markFocused();\n    this.cleanUp_();\n    if (browserEvents.isRightButton(e)) {\n      // Right-click.\n      // Scrollbars have no context menu.\n      e.stopPropagation();\n      return;\n    }\n    // Look up the current translation and record it.\n    this.startDragHandle = this.handlePosition_;\n\n    // Tell the workspace to setup its drag surface since it is about to move.\n    // onMouseMoveHandle will call onScroll which actually tells the workspace\n    // to move.\n    this.workspace_.setupDragSurface();\n\n    // Record the current mouse position.\n    this.startDragMouse_ = this.horizontal_ ? e.clientX : e.clientY;\n    Scrollbar.onMouseUpWrapper_ = browserEvents.conditionalBind(\n        document, 'mouseup', this, this.onMouseUpHandle_);\n    Scrollbar.onMouseMoveWrapper_ = browserEvents.conditionalBind(\n        document, 'mousemove', this, this.onMouseMoveHandle_);\n    e.stopPropagation();\n    e.preventDefault();\n  }\n\n  /**\n   * Drag the scrollbar's handle.\n   * @param {!Event} e Mouse up event.\n   * @private\n   */\n  onMouseMoveHandle_(e) {\n    const currentMouse = this.horizontal_ ? e.clientX : e.clientY;\n    const mouseDelta = currentMouse - this.startDragMouse_;\n    const handlePosition = this.startDragHandle + mouseDelta;\n    // Position the bar.\n    this.setHandlePosition(this.constrainHandlePosition_(handlePosition));\n    this.updateMetrics_();\n  }\n\n  /**\n   * Release the scrollbar handle and reset state accordingly.\n   * @private\n   */\n  onMouseUpHandle_() {\n    // Tell the workspace to clean up now that the workspace is done moving.\n    this.workspace_.resetDragSurface();\n    Touch.clearTouchIdentifier();\n    this.cleanUp_();\n  }\n\n  /**\n   * Hide chaff and stop binding to mouseup and mousemove events.  Call this to\n   * wrap up loose ends associated with the scrollbar.\n   * @private\n   */\n  cleanUp_() {\n    this.workspace_.hideChaff(true);\n    if (Scrollbar.onMouseUpWrapper_) {\n      browserEvents.unbind(Scrollbar.onMouseUpWrapper_);\n      Scrollbar.onMouseUpWrapper_ = null;\n    }\n    if (Scrollbar.onMouseMoveWrapper_) {\n      browserEvents.unbind(Scrollbar.onMouseMoveWrapper_);\n      Scrollbar.onMouseMoveWrapper_ = null;\n    }\n  }\n\n  /**\n   * Helper to calculate the ratio of handle position to scrollbar view size.\n   * @return {number} Ratio.\n   * @package\n   */\n  getRatio_() {\n    const scrollHandleRange = this.scrollbarLength_ - this.handleLength_;\n    let ratio = this.handlePosition_ / scrollHandleRange;\n    if (isNaN(ratio)) {\n      ratio = 0;\n    }\n    return ratio;\n  }\n\n  /**\n   * Updates workspace metrics based on new scroll ratio. Called when scrollbar\n   * is moved.\n   * @private\n   */\n  updateMetrics_() {\n    const ratio = this.getRatio_();\n    const xyRatio = {};\n    if (this.horizontal_) {\n      xyRatio.x = ratio;\n    } else {\n      xyRatio.y = ratio;\n    }\n    this.workspace_.setMetrics(xyRatio);\n  }\n\n  /**\n   * Set the scrollbar handle's position.\n   * @param {number} value The content displacement, relative to the view in\n   *    pixels.\n   * @param {boolean=} updateMetrics Whether to update metrics on this set call.\n   *    Defaults to true.\n   */\n  set(value, updateMetrics) {\n    this.setHandlePosition(this.constrainHandlePosition_(value * this.ratio));\n    if (updateMetrics || updateMetrics === undefined) {\n      this.updateMetrics_();\n    }\n  }\n\n  /**\n   * Record the origin of the workspace that the scrollbar is in, in pixels\n   * relative to the injection div origin. This is for times when the scrollbar\n   * is used in an object whose origin isn't the same as the main workspace\n   * (e.g. in a flyout.)\n   * @param {number} x The x coordinate of the scrollbar's origin, in CSS\n   *     pixels.\n   * @param {number} y The y coordinate of the scrollbar's origin, in CSS\n   *     pixels.\n   */\n  setOrigin(x, y) {\n    this.origin_ = new Coordinate(x, y);\n  }\n\n  /**\n   * @param {!Metrics} first An object containing computed\n   *     measurements of a workspace.\n   * @param {!Metrics} second Another object containing computed\n   *     measurements of a workspace.\n   * @return {boolean} Whether the two sets of metrics are equivalent.\n   * @private\n   */\n  static metricsAreEquivalent_(first, second) {\n    return (\n        first.viewWidth === second.viewWidth &&\n        first.viewHeight === second.viewHeight &&\n        first.viewLeft === second.viewLeft &&\n        first.viewTop === second.viewTop &&\n        first.absoluteTop === second.absoluteTop &&\n        first.absoluteLeft === second.absoluteLeft &&\n        first.scrollWidth === second.scrollWidth &&\n        first.scrollHeight === second.scrollHeight &&\n        first.scrollLeft === second.scrollLeft &&\n        first.scrollTop === second.scrollTop);\n  }\n}\n\n/**\n * Width of vertical scrollbar or height of horizontal scrollbar in CSS pixels.\n * Scrollbars should be larger on touch devices.\n */\nScrollbar.scrollbarThickness = 15;\n\nif (Touch.TOUCH_ENABLED) {\n  Scrollbar.scrollbarThickness = 25;\n}\n\n/**\n * Default margin around the scrollbar (between the scrollbar and the edge of\n * the viewport in pixels).\n * @type {number}\n * @const\n * @package\n */\nScrollbar.DEFAULT_SCROLLBAR_MARGIN = 0.5;\n\nexports.Scrollbar = Scrollbar;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/scrollbar.js?")},
"./core/scrollbar_pair.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/scrollbar.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2011 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing a pair of scrollbars.\n */\n\n\n/**\n * Object representing a pair of scrollbars.\n * @class\n */\ngoog.module('Blockly.ScrollbarPair');\n\nconst dom = goog.require('Blockly.utils.dom');\nconst eventUtils = goog.require('Blockly.Events.utils');\n/* eslint-disable-next-line no-unused-vars */\nconst {Metrics} = goog.requireType('Blockly.utils.Metrics');\nconst {Scrollbar} = goog.require('Blockly.Scrollbar');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * Class for a pair of scrollbars.  Horizontal and vertical.\n * @alias Blockly.ScrollbarPair\n */\nconst ScrollbarPair = class {\n  /**\n   * @param {!WorkspaceSvg} workspace Workspace to bind the scrollbars to.\n   * @param {boolean=} addHorizontal Whether to add a horizontal scrollbar.\n   *    Defaults to true.\n   * @param {boolean=} addVertical Whether to add a vertical scrollbar. Defaults\n   *    to true.\n   * @param {string=} opt_class A class to be applied to these scrollbars.\n   * @param {number=} opt_margin The margin to apply to these scrollbars.\n   */\n  constructor(workspace, addHorizontal, addVertical, opt_class, opt_margin) {\n    /**\n     * The workspace this scrollbar pair is bound to.\n     * @type {!WorkspaceSvg}\n     * @private\n     */\n    this.workspace_ = workspace;\n\n    addHorizontal = addHorizontal === undefined ? true : addHorizontal;\n    addVertical = addVertical === undefined ? true : addVertical;\n    const isPair = addHorizontal && addVertical;\n\n    if (addHorizontal) {\n      this.hScroll =\n          new Scrollbar(workspace, true, isPair, opt_class, opt_margin);\n    }\n    if (addVertical) {\n      this.vScroll =\n          new Scrollbar(workspace, false, isPair, opt_class, opt_margin);\n    }\n\n    if (isPair) {\n      this.corner_ = dom.createSvgElement(\n          Svg.RECT, {\n            'height': Scrollbar.scrollbarThickness,\n            'width': Scrollbar.scrollbarThickness,\n            'class': 'blocklyScrollbarBackground',\n          },\n          null);\n      dom.insertAfter(this.corner_, workspace.getBubbleCanvas());\n    }\n\n    /**\n     * Previously recorded metrics from the workspace.\n     * @type {?Metrics}\n     * @private\n     */\n    this.oldHostMetrics_ = null;\n  }\n\n  /**\n   * Dispose of this pair of scrollbars.\n   * Unlink from all DOM elements to prevent memory leaks.\n   * @suppress {checkTypes}\n   */\n  dispose() {\n    dom.removeNode(this.corner_);\n    this.corner_ = null;\n    this.workspace_ = null;\n    this.oldHostMetrics_ = null;\n    if (this.hScroll) {\n      this.hScroll.dispose();\n      this.hScroll = null;\n    }\n    if (this.vScroll) {\n      this.vScroll.dispose();\n      this.vScroll = null;\n    }\n  }\n\n  /**\n   * Recalculate both of the scrollbars' locations and lengths.\n   * Also reposition the corner rectangle.\n   */\n  resize() {\n    // Look up the host metrics once, and use for both scrollbars.\n    const hostMetrics = this.workspace_.getMetrics();\n    if (!hostMetrics) {\n      // Host element is likely not visible.\n      return;\n    }\n\n    // Only change the scrollbars if there has been a change in metrics.\n    let resizeH = false;\n    let resizeV = false;\n    if (!this.oldHostMetrics_ ||\n        this.oldHostMetrics_.viewWidth !== hostMetrics.viewWidth ||\n        this.oldHostMetrics_.viewHeight !== hostMetrics.viewHeight ||\n        this.oldHostMetrics_.absoluteTop !== hostMetrics.absoluteTop ||\n        this.oldHostMetrics_.absoluteLeft !== hostMetrics.absoluteLeft) {\n      // The window has been resized or repositioned.\n      resizeH = true;\n      resizeV = true;\n    } else {\n      // Has the content been resized or moved?\n      if (!this.oldHostMetrics_ ||\n          this.oldHostMetrics_.scrollWidth !== hostMetrics.scrollWidth ||\n          this.oldHostMetrics_.viewLeft !== hostMetrics.viewLeft ||\n          this.oldHostMetrics_.scrollLeft !== hostMetrics.scrollLeft) {\n        resizeH = true;\n      }\n      if (!this.oldHostMetrics_ ||\n          this.oldHostMetrics_.scrollHeight !== hostMetrics.scrollHeight ||\n          this.oldHostMetrics_.viewTop !== hostMetrics.viewTop ||\n          this.oldHostMetrics_.scrollTop !== hostMetrics.scrollTop) {\n        resizeV = true;\n      }\n    }\n\n    if (resizeH || resizeV) {\n      try {\n        eventUtils.disable();\n        if (this.hScroll && resizeH) {\n          this.hScroll.resize(hostMetrics);\n        }\n        if (this.vScroll && resizeV) {\n          this.vScroll.resize(hostMetrics);\n        }\n      } finally {\n        eventUtils.enable();\n      }\n      this.workspace_.maybeFireViewportChangeEvent();\n    }\n\n    if (this.hScroll && this.vScroll) {\n      // Reposition the corner square.\n      if (!this.oldHostMetrics_ ||\n          this.oldHostMetrics_.viewWidth !== hostMetrics.viewWidth ||\n          this.oldHostMetrics_.absoluteLeft !== hostMetrics.absoluteLeft) {\n        this.corner_.setAttribute('x', this.vScroll.position.x);\n      }\n      if (!this.oldHostMetrics_ ||\n          this.oldHostMetrics_.viewHeight !== hostMetrics.viewHeight ||\n          this.oldHostMetrics_.absoluteTop !== hostMetrics.absoluteTop) {\n        this.corner_.setAttribute('y', this.hScroll.position.y);\n      }\n    }\n\n    // Cache the current metrics to potentially short-cut the next resize event.\n    this.oldHostMetrics_ = hostMetrics;\n  }\n\n  /**\n   * Returns whether scrolling horizontally is enabled.\n   * @return {boolean} True if horizontal scroll is enabled.\n   */\n  canScrollHorizontally() {\n    return !!this.hScroll;\n  }\n\n  /**\n   * Returns whether scrolling vertically is enabled.\n   * @return {boolean} True if vertical scroll is enabled.\n   */\n  canScrollVertically() {\n    return !!this.vScroll;\n  }\n\n  /**\n   * Record the origin of the workspace that the scrollbar is in, in pixels\n   * relative to the injection div origin. This is for times when the scrollbar\n   * is used in an object whose origin isn't the same as the main workspace\n   * (e.g. in a flyout.)\n   * @param {number} x The x coordinate of the scrollbar's origin, in CSS\n   *     pixels.\n   * @param {number} y The y coordinate of the scrollbar's origin, in CSS\n   *     pixels.\n   * @package\n   */\n  setOrigin(x, y) {\n    if (this.hScroll) {\n      this.hScroll.setOrigin(x, y);\n    }\n    if (this.vScroll) {\n      this.vScroll.setOrigin(x, y);\n    }\n  }\n\n  /**\n   * Set the handles of both scrollbars.\n   * @param {number} x The horizontal content displacement, relative to the view\n   *    in pixels.\n   * @param {number} y The vertical content displacement, relative to the view\n   *     in\n   *    pixels.\n   * @param {boolean} updateMetrics Whether to update metrics on this set call.\n   *    Defaults to true.\n   */\n  set(x, y, updateMetrics) {\n    // This function is equivalent to:\n    //   this.hScroll.set(x);\n    //   this.vScroll.set(y);\n    // However, that calls setMetrics twice which causes a chain of\n    // getAttribute->setAttribute->getAttribute resulting in an extra layout\n    // pass. Combining them speeds up rendering.\n    if (this.hScroll) {\n      this.hScroll.set(x, false);\n    }\n    if (this.vScroll) {\n      this.vScroll.set(y, false);\n    }\n\n    if (updateMetrics || updateMetrics === undefined) {\n      // Update metrics.\n      const xyRatio = {};\n      if (this.hScroll) {\n        xyRatio.x = this.hScroll.getRatio_();\n      }\n      if (this.vScroll) {\n        xyRatio.y = this.vScroll.getRatio_();\n      }\n      this.workspace_.setMetrics(xyRatio);\n    }\n  }\n\n  /**\n   * Set the handle of the horizontal scrollbar to be at a certain position in\n   *    CSS pixels relative to its parents.\n   * @param {number} x Horizontal scroll value.\n   */\n  setX(x) {\n    if (this.hScroll) {\n      this.hScroll.set(x, true);\n    }\n  }\n\n  /**\n   * Set the handle of the vertical scrollbar to be at a certain position in\n   *    CSS pixels relative to its parents.\n   * @param {number} y Vertical scroll value.\n   */\n  setY(y) {\n    if (this.vScroll) {\n      this.vScroll.set(y, true);\n    }\n  }\n\n  /**\n   * Set whether this scrollbar's container is visible.\n   * @param {boolean} visible Whether the container is visible.\n   */\n  setContainerVisible(visible) {\n    if (this.hScroll) {\n      this.hScroll.setContainerVisible(visible);\n    }\n    if (this.vScroll) {\n      this.vScroll.setContainerVisible(visible);\n    }\n  }\n\n  /**\n   * If any of the scrollbars are visible. Non-paired scrollbars may disappear\n   * when they aren't needed.\n   * @return {boolean} True if visible.\n   */\n  isVisible() {\n    let isVisible = false;\n    if (this.hScroll) {\n      isVisible = this.hScroll.isVisible();\n    }\n    if (this.vScroll) {\n      isVisible = isVisible || this.vScroll.isVisible();\n    }\n    return isVisible;\n  }\n\n  /**\n   * Recalculates the scrollbars' locations within their path and length.\n   * This should be called when the contents of the workspace have changed.\n   * @param {!Metrics} hostMetrics A data structure describing all\n   *     the required dimensions, possibly fetched from the host object.\n   */\n  resizeContent(hostMetrics) {\n    if (this.hScroll) {\n      this.hScroll.resizeContentHorizontal(hostMetrics);\n    }\n    if (this.vScroll) {\n      this.vScroll.resizeContentVertical(hostMetrics);\n    }\n  }\n\n  /**\n   * Recalculates the scrollbars' locations on the screen and path length.\n   * This should be called when the layout or size of the window has changed.\n   * @param {!Metrics} hostMetrics A data structure describing all\n   *     the required dimensions, possibly fetched from the host object.\n   */\n  resizeView(hostMetrics) {\n    if (this.hScroll) {\n      this.hScroll.resizeViewHorizontal(hostMetrics);\n    }\n    if (this.vScroll) {\n      this.vScroll.resizeViewVertical(hostMetrics);\n    }\n  }\n};\n\nexports.ScrollbarPair = ScrollbarPair;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/scrollbar_pair.js?")},
"./core/serialization/blocks.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/xml.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/serialization/priorities.js\");\n__webpack_require__(\"./core/serialization/registry.js\");\n__webpack_require__(\"./core/serialization/exceptions.js\");\n__webpack_require__(\"./core/interfaces/i_serializer.js\");\n__webpack_require__(\"./core/utils/size.js\");\n__webpack_require__(\"./core/input_types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Handles serializing blocks to plain JavaScript objects only\n * containing state.\n */\n\n\n/**\n * Handles serializing blocks to plain JavaScript objects only containing state.\n * @namespace Blockly.serialization.blocks\n */\ngoog.module('Blockly.serialization.blocks');\n\nconst Xml = goog.require('Blockly.Xml');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst priorities = goog.require('Blockly.serialization.priorities');\nconst serializationRegistry = goog.require('Blockly.serialization.registry');\nconst {BadConnectionCheck, MissingBlockType, MissingConnection, RealChildOfShadow} = goog.require('Blockly.serialization.exceptions');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n// eslint-disable-next-line no-unused-vars\nconst {Connection} = goog.requireType('Blockly.Connection');\n// eslint-disable-next-line no-unused-vars\nconst {ISerializer} = goog.require('Blockly.serialization.ISerializer');\nconst {Size} = goog.require('Blockly.utils.Size');\n// eslint-disable-next-line no-unused-vars\nconst {Workspace} = goog.requireType('Blockly.Workspace');\nconst {inputTypes} = goog.require('Blockly.inputTypes');\n\n\n// TODO(#5160): Remove this once lint is fixed.\n/* eslint-disable no-use-before-define */\n\n/**\n * Represents the state of a connection.\n * @typedef {{\n *   shadow: (!State|undefined),\n *   block: (!State|undefined)\n * }}\n * @alias Blockly.serialization.blocks.ConnectionState\n */\nlet ConnectionState;\nexports.ConnectionState = ConnectionState;\n\n/**\n * Represents the state of a given block.\n * @typedef {{\n *     type: string,\n *     id: (string|undefined),\n *     x: (number|undefined),\n *     y: (number|undefined),\n *     collapsed: (boolean|undefined),\n *     enabled: (boolean|undefined),\n *     inline: (boolean|undefined),\n *     data: (string|undefined),\n *     extraState: (*|undefined),\n *     icons: (!Object<string, *>|undefined),\n *     fields: (!Object<string, *>|undefined),\n *     inputs: (!Object<string, !ConnectionState>|undefined),\n *     next: (!ConnectionState|undefined)\n * }}\n * @alias Blockly.serialization.blocks.State\n */\nlet State;\nexports.State = State;\n\n/**\n * Returns the state of the given block as a plain JavaScript object.\n * @param {!Block} block The block to serialize.\n * @param {{addCoordinates: (boolean|undefined), addInputBlocks:\n *     (boolean|undefined), addNextBlocks: (boolean|undefined),\n *     doFullSerialization: (boolean|undefined)}=} param1\n *     addCoordinates: If true, the coordinates of the block are added to the\n *       serialized state. False by default.\n *     addinputBlocks: If true, children of the block which are connected to\n *       inputs will be serialized. True by default.\n *     addNextBlocks: If true, children of the block which are connected to the\n *       block's next connection (if it exists) will be serialized.\n *       True by default.\n *     doFullSerialization: If true, fields that normally just save a reference\n *       to some external state (eg variables) will instead serialize all of the\n *       info about that state. This supports deserializing the block into a\n *       workspace where that state doesn't yet exist. True by default.\n * @return {?State} The serialized state of the block, or null if the block\n *     could not be serialied (eg it was an insertion marker).\n * @alias Blockly.serialization.blocks.save\n */\nconst save = function(block, {\n  addCoordinates = false,\n  addInputBlocks = true,\n  addNextBlocks = true,\n  doFullSerialization = true,\n} = {}) {\n  if (block.isInsertionMarker()) {\n    return null;\n  }\n\n  const state = {\n    'type': block.type,\n    'id': block.id,\n  };\n\n  if (addCoordinates) {\n    saveCoords(block, state);\n  }\n  saveAttributes(block, state);\n  saveExtraState(block, state);\n  saveIcons(block, state);\n  saveFields(block, state, doFullSerialization);\n  if (addInputBlocks) {\n    saveInputBlocks(block, state, doFullSerialization);\n  }\n  if (addNextBlocks) {\n    saveNextBlocks(block, state, doFullSerialization);\n  }\n\n  return state;\n};\nexports.save = save;\n\n/**\n * Adds attributes to the given state object based on the state of the block.\n * Eg collapsed, disabled, inline, etc.\n * @param {!Block} block The block to base the attributes on.\n * @param {!State} state The state object to append to.\n */\nconst saveAttributes = function(block, state) {\n  if (block.isCollapsed()) {\n    state['collapsed'] = true;\n  }\n  if (!block.isEnabled()) {\n    state['enabled'] = false;\n  }\n  if (block.inputsInline !== undefined &&\n      block.inputsInline !== block.inputsInlineDefault) {\n    state['inline'] = block.inputsInline;\n  }\n  // Data is a nullable string, so we don't need to worry about falsy values.\n  if (block.data) {\n    state['data'] = block.data;\n  }\n};\n\n/**\n * Adds the coordinates of the given block to the given state object.\n * @param {!Block} block The block to base the coordinates on.\n * @param {!State} state The state object to append to.\n */\nconst saveCoords = function(block, state) {\n  const workspace = block.workspace;\n  const xy = block.getRelativeToSurfaceXY();\n  state['x'] = Math.round(workspace.RTL ? workspace.getWidth() - xy.x : xy.x);\n  state['y'] = Math.round(xy.y);\n};\n\n/**\n * Adds any extra state the block may provide to the given state object.\n * @param {!Block} block The block to serialize the extra state of.\n * @param {!State} state The state object to append to.\n */\nconst saveExtraState = function(block, state) {\n  if (block.saveExtraState) {\n    const extraState = block.saveExtraState();\n    if (extraState !== null) {\n      state['extraState'] = extraState;\n    }\n  } else if (block.mutationToDom) {\n    const extraState = block.mutationToDom();\n    if (extraState !== null) {\n      state['extraState'] =\n          Xml.domToText(extraState)\n              .replace(\n                  ' xmlns=\"https://developers.google.com/blockly/xml\"', '');\n    }\n  }\n};\n\n/**\n * Adds the state of all of the icons on the block to the given state object.\n * @param {!Block} block The block to serialize the icon state of.\n * @param {!State} state The state object to append to.\n */\nconst saveIcons = function(block, state) {\n  // TODO(#2105): Remove this logic and put it in the icon.\n  if (block.getCommentText()) {\n    state['icons'] = {\n      'comment': {\n        'text': block.getCommentText(),\n        'pinned': block.commentModel.pinned,\n        'height': Math.round(block.commentModel.size.height),\n        'width': Math.round(block.commentModel.size.width),\n      },\n    };\n  }\n};\n\n/**\n * Adds the state of all of the fields on the block to the given state object.\n * @param {!Block} block The block to serialize the field state of.\n * @param {!State} state The state object to append to.\n * @param {boolean} doFullSerialization Whether or not to serialize the full\n *     state of the field (rather than possibly saving a reference to some\n *     state).\n */\nconst saveFields = function(block, state, doFullSerialization) {\n  const fields = Object.create(null);\n  for (let i = 0; i < block.inputList.length; i++) {\n    const input = block.inputList[i];\n    for (let j = 0; j < input.fieldRow.length; j++) {\n      const field = input.fieldRow[j];\n      if (field.isSerializable()) {\n        fields[field.name] = field.saveState(doFullSerialization);\n      }\n    }\n  }\n  if (Object.keys(fields).length) {\n    state['fields'] = fields;\n  }\n};\n\n/**\n * Adds the state of all of the child blocks of the given block (which are\n * connected to inputs) to the given state object.\n * @param {!Block} block The block to serialize the input blocks of.\n * @param {!State} state The state object to append to.\n * @param {boolean} doFullSerialization Whether or not to do full serialization.\n */\nconst saveInputBlocks = function(block, state, doFullSerialization) {\n  const inputs = Object.create(null);\n  for (let i = 0; i < block.inputList.length; i++) {\n    const input = block.inputList[i];\n    if (input.type === inputTypes.DUMMY) {\n      continue;\n    }\n    const connectionState = saveConnection(\n        /** @type {!Connection} */ (input.connection), doFullSerialization);\n    if (connectionState) {\n      inputs[input.name] = connectionState;\n    }\n  }\n\n  if (Object.keys(inputs).length) {\n    state['inputs'] = inputs;\n  }\n};\n\n/**\n * Adds the state of all of the next blocks of the given block to the given\n * state object.\n * @param {!Block} block The block to serialize the next blocks of.\n * @param {!State} state The state object to append to.\n * @param {boolean} doFullSerialization Whether or not to do full serialization.\n */\nconst saveNextBlocks = function(block, state, doFullSerialization) {\n  if (!block.nextConnection) {\n    return;\n  }\n  const connectionState =\n      saveConnection(block.nextConnection, doFullSerialization);\n  if (connectionState) {\n    state['next'] = connectionState;\n  }\n};\n\n/**\n * Returns the state of the given connection (ie the state of any connected\n * shadow or real blocks).\n * @param {!Connection} connection The connection to serialize the connected\n *     blocks of.\n * @return {?ConnectionState} An object containing the state of any connected\n *     shadow block, or any connected real block.\n * @param {boolean} doFullSerialization Whether or not to do full serialization.\n */\nconst saveConnection = function(connection, doFullSerialization) {\n  const shadow = connection.getShadowState(true);\n  const child = connection.targetBlock();\n  if (!shadow && !child) {\n    return null;\n  }\n  const state = Object.create(null);\n  if (shadow) {\n    state['shadow'] = shadow;\n  }\n  if (child && !child.isShadow()) {\n    state['block'] = save(child, {doFullSerialization});\n  }\n  return state;\n};\n\n/**\n * Loads the block represented by the given state into the given workspace.\n * @param {!State} state The state of a block to deserialize into the workspace.\n * @param {!Workspace} workspace The workspace to add the block to.\n * @param {{recordUndo: (boolean|undefined)}=} param1\n *     recordUndo: If true, events triggered by this function will be undo-able\n *       by the user. False by default.\n * @return {!Block} The block that was just loaded.\n * @alias Blockly.serialization.blocks.append\n */\nconst append = function(state, workspace, {recordUndo = false} = {}) {\n  return appendInternal(state, workspace, {recordUndo});\n};\nexports.append = append;\n\n/**\n * Loads the block represented by the given state into the given workspace.\n * This is defined internally so that the extra parameters don't clutter our\n * external API.\n * But it is exported so that other places within Blockly can call it directly\n * with the extra parameters.\n * @param {!State} state The state of a block to deserialize into the workspace.\n * @param {!Workspace} workspace The workspace to add the block to.\n * @param {{parentConnection: (!Connection|undefined), isShadow:\n *     (boolean|undefined), recordUndo: (boolean|undefined)}=} param1\n *     parentConnection: If provided, the system will attempt to connect the\n *       block to this connection after it is created. Undefined by default.\n *     isShadow: If true, the block will be set to a shadow block after it is\n *       created. False by default.\n *     recordUndo: If true, events triggered by this function will be undo-able\n *       by the user. False by default.\n * @return {!Block} The block that was just appended.\n * @alias Blockly.serialization.blocks.appendInternal\n * @package\n */\nconst appendInternal = function(state, workspace, {\n  parentConnection = undefined,\n  isShadow = false,\n  recordUndo = false,\n} = {}) {\n  const prevRecordUndo = eventUtils.getRecordUndo();\n  eventUtils.setRecordUndo(recordUndo);\n  const existingGroup = eventUtils.getGroup();\n  if (!existingGroup) {\n    eventUtils.setGroup(true);\n  }\n  eventUtils.disable();\n\n  const block = appendPrivate(state, workspace, {parentConnection, isShadow});\n\n  eventUtils.enable();\n  eventUtils.fire(new (eventUtils.get(eventUtils.BLOCK_CREATE))(block));\n  eventUtils.setGroup(existingGroup);\n  eventUtils.setRecordUndo(prevRecordUndo);\n\n  // Adding connections to the connection db is expensive. This defers that\n  // operation to decrease load time.\n  if (workspace.rendered) {\n    const blockSvg = /** @type {!BlockSvg} */ (block);\n    setTimeout(() => {\n      if (!blockSvg.disposed) {\n        blockSvg.setConnectionTracking(true);\n      }\n    }, 1);\n  }\n\n  return block;\n};\nexports.appendInternal = appendInternal;\n\n/**\n * Loads the block represented by the given state into the given workspace.\n * This is defined privately so that it can be called recursively without firing\n * eroneous events. Events (and other things we only want to occur on the top\n * block) are handled by appendInternal.\n * @param {!State} state The state of a block to deserialize into the workspace.\n * @param {!Workspace} workspace The workspace to add the block to.\n * @param {{parentConnection: (!Connection|undefined),\n *     isShadow: (boolean|undefined)}=} param1\n *     parentConnection: If provided, the system will attempt to connect the\n *       block to this connection after it is created. Undefined by default.\n *     isShadow: The block will be set to a shadow block after it is created.\n *       False by default.\n * @return {!Block} The block that was just appended.\n */\nconst appendPrivate = function(state, workspace, {\n  parentConnection = undefined,\n  isShadow = false,\n} = {}) {\n  if (!state['type']) {\n    throw new MissingBlockType(state);\n  }\n\n  const block = workspace.newBlock(state['type'], state['id']);\n  block.setShadow(isShadow);\n  loadCoords(block, state);\n  loadAttributes(block, state);\n  loadExtraState(block, state);\n  tryToConnectParent(parentConnection, block, state);\n  loadIcons(block, state);\n  loadFields(block, state);\n  loadInputBlocks(block, state);\n  loadNextBlocks(block, state);\n  initBlock(block, workspace.rendered);\n\n  return block;\n};\n\n/**\n * Applies any coordinate information available on the state object to the\n * block.\n * @param {!Block} block The block to set the position of.\n * @param {!State} state The state object to reference.\n */\nconst loadCoords = function(block, state) {\n  let x = state['x'] === undefined ? 0 : state['x'];\n  const y = state['y'] === undefined ? 0 : state['y'];\n\n  const workspace = block.workspace;\n  x = workspace.RTL ? workspace.getWidth() - x : x;\n\n  block.moveBy(x, y);\n};\n\n/**\n * Applies any attribute information available on the state object to the block.\n * @param {!Block} block The block to set the attributes of.\n * @param {!State} state The state object to reference.\n */\nconst loadAttributes = function(block, state) {\n  if (state['collapsed']) {\n    block.setCollapsed(true);\n  }\n  if (state['enabled'] === false) {\n    block.setEnabled(false);\n  }\n  if (state['inline'] !== undefined) {\n    block.setInputsInline(state['inline']);\n  }\n  if (state['data'] !== undefined) {\n    block.data = state['data'];\n  }\n};\n\n/**\n * Applies any extra state information available on the state object to the\n * block.\n * @param {!Block} block The block to set the extra state of.\n * @param {!State} state The state object to reference.\n */\nconst loadExtraState = function(block, state) {\n  if (!state['extraState']) {\n    return;\n  }\n  if (block.loadExtraState) {\n    block.loadExtraState(state['extraState']);\n  } else {\n    block.domToMutation(Xml.textToDom(state['extraState']));\n  }\n};\n\n/**\n * Attempts to connect the block to the parent connection, if it exists.\n * @param {(!Connection|undefined)} parentConnection The parent connection to\n *     try to connect the block to.\n * @param {!Block} child The block to try to connect to the parent.\n * @param {!State} state The state which defines the given block\n */\nconst tryToConnectParent = function(parentConnection, child, state) {\n  if (!parentConnection) {\n    return;\n  }\n\n  if (parentConnection.getSourceBlock().isShadow() && !child.isShadow()) {\n    throw new RealChildOfShadow(state);\n  }\n\n  let connected = false;\n  let childConnection;\n  if (parentConnection.type === inputTypes.VALUE) {\n    childConnection = child.outputConnection;\n    if (!childConnection) {\n      throw new MissingConnection('output', child, state);\n    }\n    connected = parentConnection.connect(childConnection);\n  } else {  // Statement type.\n    childConnection = child.previousConnection;\n    if (!childConnection) {\n      throw new MissingConnection('previous', child, state);\n    }\n    connected = parentConnection.connect(childConnection);\n  }\n\n  if (!connected) {\n    const checker = child.workspace.connectionChecker;\n    throw new BadConnectionCheck(\n        checker.getErrorMessage(\n            checker.canConnectWithReason(\n                childConnection, parentConnection, false),\n            childConnection, parentConnection),\n        parentConnection.type === inputTypes.VALUE ? 'output connection' :\n                                                     'previous connection',\n        child, state);\n  }\n};\n\n/**\n * Applies icon state to the icons on the block, based on the given state\n * object.\n * @param {!Block} block The block to set the icon state of.\n * @param {!State} state The state object to reference.\n */\nconst loadIcons = function(block, state) {\n  if (!state['icons']) {\n    return;\n  }\n  // TODO(#2105): Remove this logic and put it in the icon.\n  const comment = state['icons']['comment'];\n  if (comment) {\n    block.setCommentText(comment['text']);\n    // Load if saved. (Cleaned unnecessary attributes when in the trashcan.)\n    if ('pinned' in comment) {\n      block.commentModel.pinned = comment['pinned'];\n    }\n    if ('width' in comment && 'height' in comment) {\n      block.commentModel.size = new Size(comment['width'], comment['height']);\n    }\n    if (comment['pinned'] && block.rendered && !block.isInFlyout) {\n      // Give the block a chance to be positioned and rendered before showing.\n      const blockSvg = /** @type {!BlockSvg} */ (block);\n      setTimeout(() => blockSvg.getCommentIcon().setVisible(true), 1);\n    }\n  }\n};\n\n/**\n * Applies any field information available on the state object to the block.\n * @param {!Block} block The block to set the field state of.\n * @param {!State} state The state object to reference.\n */\nconst loadFields = function(block, state) {\n  if (!state['fields']) {\n    return;\n  }\n  const keys = Object.keys(state['fields']);\n  for (let i = 0; i < keys.length; i++) {\n    const fieldName = keys[i];\n    const fieldState = state['fields'][fieldName];\n    const field = block.getField(fieldName);\n    if (!field) {\n      console.warn(\n          `Ignoring non-existant field ${fieldName} in block ${block.type}`);\n      continue;\n    }\n    field.loadState(fieldState);\n  }\n};\n\n/**\n * Creates any child blocks (attached to inputs) defined by the given state\n * and attaches them to the given block.\n * @param {!Block} block The block to attach input blocks to.\n * @param {!State} state The state object to reference.\n */\nconst loadInputBlocks = function(block, state) {\n  if (!state['inputs']) {\n    return;\n  }\n  const keys = Object.keys(state['inputs']);\n  for (let i = 0; i < keys.length; i++) {\n    const inputName = keys[i];\n    const input = block.getInput(inputName);\n    if (!input || !input.connection) {\n      throw new MissingConnection(inputName, block, state);\n    }\n    loadConnection(input.connection, state['inputs'][inputName]);\n  }\n};\n\n/**\n * Creates any next blocks defined by the given state and attaches them to the\n * given block.\n * @param {!Block} block The block to attach next blocks to.\n * @param {!State} state The state object to reference.\n */\nconst loadNextBlocks = function(block, state) {\n  if (!state['next']) {\n    return;\n  }\n  if (!block.nextConnection) {\n    throw new MissingConnection('next', block, state);\n  }\n  loadConnection(block.nextConnection, state['next']);\n};\n\n/**\n * Applies the state defined by connectionState to the given connection, ie\n * assigns shadows and attaches child blocks.\n * @param {!Connection} connection The connection to deserialize the\n *     connected blocks of.\n * @param {!ConnectionState} connectionState The object containing the state of\n *     any connected shadow block, or any connected real block.\n */\nconst loadConnection = function(connection, connectionState) {\n  if (connectionState['shadow']) {\n    connection.setShadowState(connectionState['shadow']);\n  }\n  if (connectionState['block']) {\n    appendPrivate(\n        connectionState['block'], connection.getSourceBlock().workspace,\n        {parentConnection: connection});\n  }\n};\n\n// TODO(#5146): Remove this from the serialization system.\n/**\n * Initializes the give block, eg init the model, inits the svg, renders, etc.\n * @param {!Block} block The block to initialize.\n * @param {boolean} rendered Whether the block is a rendered or headless block.\n */\nconst initBlock = function(block, rendered) {\n  if (rendered) {\n    const blockSvg = /** @type {!BlockSvg} */ (block);\n    // Adding connections to the connection db is expensive. This defers that\n    // operation to decrease load time.\n    blockSvg.setConnectionTracking(false);\n\n    blockSvg.initSvg();\n    blockSvg.render(false);\n  } else {\n    block.initModel();\n  }\n};\n\n// Alias to disambiguate saving within the serializer.\nconst saveBlock = save;\n\n/**\n * Serializer for saving and loading block state.\n * @implements {ISerializer}\n * @alias Blockly.serialization.blocks.BlockSerializer\n */\nclass BlockSerializer {\n  /* eslint-disable-next-line require-jsdoc */\n  constructor() {\n    /**\n     * The priority for deserializing blocks.\n     * @type {number}\n     */\n    this.priority = priorities.BLOCKS;\n  }\n\n  /**\n   * Serializes the blocks of the given workspace.\n   * @param {!Workspace} workspace The workspace to save the blocks of.\n   * @return {?{languageVersion: number, blocks:!Array<!State>}} The state of\n   *     the workspace's blocks, or null if there are no blocks.\n   */\n  save(workspace) {\n    const blockStates = [];\n    for (const block of workspace.getTopBlocks(false)) {\n      const state =\n          saveBlock(block, {addCoordinates: true, doFullSerialization: false});\n      if (state) {\n        blockStates.push(state);\n      }\n    }\n    if (blockStates.length) {\n      return {\n        'languageVersion': 0,  // Currently unused.\n        'blocks': blockStates,\n      };\n    }\n    return null;\n  }\n\n  /**\n   * Deserializes the blocks defined by the given state into the given\n   * workspace.\n   * @param {{languageVersion: number, blocks:!Array<!State>}} state The state\n   *     of the blocks to deserialize.\n   * @param {!Workspace} workspace The workspace to deserialize into.\n   */\n  load(state, workspace) {\n    const blockStates = state['blocks'];\n    for (const state of blockStates) {\n      append(state, workspace, {recordUndo: eventUtils.getRecordUndo()});\n    }\n  }\n\n  /**\n   * Disposes of any blocks that exist on the workspace.\n   * @param {!Workspace} workspace The workspace to clear the blocks of.\n   */\n  clear(workspace) {\n    // Cannot use workspace.clear() because that also removes variables.\n    for (const block of workspace.getTopBlocks(false)) {\n      block.dispose(false);\n    }\n  }\n}\n\nserializationRegistry.register('blocks', new BlockSerializer());\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/serialization/blocks.js?")},
"./core/serialization/exceptions.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Contains custom errors thrown by the serialization system.\n */\n\n\n/**\n * Contains custom errors thrown by the serialization system.\n * @namespace Blockly.serialization.exceptions\n */\ngoog.module('Blockly.serialization.exceptions');\n\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\n// eslint-disable-next-line no-unused-vars\nconst {State} = goog.requireType('Blockly.serialization.blocks');\n\n\n/**\n * @alias Blockly.serialization.exceptions.DeserializationError\n */\nclass DeserializationError extends Error {}\nexports.DeserializationError = DeserializationError;\n\n/**\n * Represents an error where the serialized state is expected to provide a\n * block type, but it is not provided.\n * @alias Blockly.serialization.exceptions.MissingBlockType\n */\nclass MissingBlockType extends DeserializationError {\n  /**\n   * @param {!State} state The state object which is missing the block type.\n   * @package\n   */\n  constructor(state) {\n    super(`Expected to find a 'type' property, defining the block type`);\n\n    /**\n     * The state object containing the bad name.\n     * @type {!State}\n     */\n    this.state = state;\n  }\n}\nexports.MissingBlockType = MissingBlockType;\n\n/**\n * Represents an error where deserialization encountered a block that did\n * not have a connection that was defined in the serialized state.\n * @alias Blockly.serialization.exceptions.MissingConnection\n */\nclass MissingConnection extends DeserializationError {\n  /**\n   * @param {string} connection The name of the connection that is missing. E.g.\n   *     'IF0', or 'next'.\n   * @param {!Block} block The block missing the connection.\n   * @param {!State} state The state object containing the bad connection.\n   * @package\n   */\n  constructor(connection, block, state) {\n    super(`The block ${block.toDevString()} is missing a(n) ${connection}\nconnection`);\n\n    /**\n     * The block missing the connection.\n     * @type {!Block}\n     */\n    this.block = block;\n\n    /**\n     * The state object containing the bad name.\n     * @type {!State}\n     */\n    this.state = state;\n  }\n}\nexports.MissingConnection = MissingConnection;\n\n/**\n * Represents an error where deserialization tried to connect two connections\n * that were not compatible.\n * @alias Blockly.serialization.exceptions.BadConnectionCheck\n */\nclass BadConnectionCheck extends DeserializationError {\n  /**\n   * @param {string} reason The reason the connections were not compatible.\n   * @param {string} childConnection The name of the incompatible child\n   *     connection. E.g. 'output' or 'previous'.\n   * @param {!Block} childBlock The child block that could not connect\n   *     to its parent.\n   * @param {!State} childState The state object representing the child block.\n   * @package\n   */\n  constructor(reason, childConnection, childBlock, childState) {\n    super(`The block ${childBlock.toDevString()} could not connect its\n${childConnection} to its parent, because: ${reason}`);\n\n    /**\n     * The block that could not connect to its parent.\n     * @type {!Block}\n     */\n    this.childBlock = childBlock;\n\n    /**\n     * The state object representing the block that could not connect to its\n     * parent.\n     * @type {!State}\n     */\n    this.childState = childState;\n  }\n}\nexports.BadConnectionCheck = BadConnectionCheck;\n\n/**\n * Represents an error where deserialization encountered a real block as it\n * was deserializing children of a shadow.\n * This is an error because it is an invariant of Blockly that shadow blocks\n * do not have real children.\n * @alias Blockly.serialization.exceptions.RealChildOfShadow\n */\nclass RealChildOfShadow extends DeserializationError {\n  /**\n   * @param {!State} state The state object representing the real block.\n   * @package\n   */\n  constructor(state) {\n    super(`Encountered a real block which is defined as a child of a shadow\nblock. It is an invariant of Blockly that shadow blocks only have shadow\nchildren`);\n\n    /**\n     * The state object representing the real block.\n     * @type {!State}\n     */\n    this.state = state;\n  }\n}\nexports.RealChildOfShadow = RealChildOfShadow;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/serialization/exceptions.js?")},
"./core/serialization/priorities.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The top level namespace for priorities of plugin serializers.\n * Includes constants for the priorities of different plugin\n * serializers. Higher priorities are deserialized first.\n */\n\n\n\n/**\n * The top level namespace for priorities of plugin serializers.\n * Includes constants for the priorities of different plugin serializers. Higher\n * priorities are deserialized first.\n * @namespace Blockly.serialization.priorities\n */\ngoog.module('Blockly.serialization.priorities');\n\n\n/**\n * The priority for deserializing variables.\n * @type {number}\n * @const\n * @alias Blockly.serialization.priorities.VARIABLES\n */\nexports.VARIABLES = 100;\n\n/**\n * The priority for deserializing blocks.\n * @type {number}\n * @const\n * @alias Blockly.serialization.priorities.BLOCKS\n */\nexports.BLOCKS = 50;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/serialization/priorities.js?")},
"./core/serialization/registry.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/registry.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Contains functions registering serializers (eg blocks,\n * variables, plugins, etc).\n */\n\n\n/**\n * Contains functions registering serializers (eg blocks, variables, plugins,\n * etc).\n * @namespace Blockly.serialization.registry\n */\ngoog.module('Blockly.serialization.registry');\n\nconst registry = goog.require('Blockly.registry');\n// eslint-disable-next-line no-unused-vars\nconst {ISerializer} = goog.requireType('Blockly.serialization.ISerializer');\n\n\n/**\n * Registers the given serializer so that it can be used for serialization and\n * deserialization.\n * @param {string} name The name of the serializer to register.\n * @param {ISerializer} serializer The serializer to register.\n * @alias Blockly.serialization.registry.register\n */\nconst register = function(name, serializer) {\n  registry.register(registry.Type.SERIALIZER, name, serializer);\n};\nexports.register = register;\n\n/**\n * Unregisters the serializer associated with the given name.\n * @param {string} name The name of the serializer to unregister.\n * @alias Blockly.serialization.registry.unregister\n */\nconst unregister = function(name) {\n  registry.unregister(registry.Type.SERIALIZER, name);\n};\nexports.unregister = unregister;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/serialization/registry.js?")},
"./core/serialization/variables.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/serialization/priorities.js\");\n__webpack_require__(\"./core/serialization/registry.js\");\n__webpack_require__(\"./core/interfaces/i_serializer.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Handles serializing variables to plain JavaScript objects, only\n * containing state.\n */\n\n\n/**\n * Handles serializing variables to plain JavaScript objects, only containing\n * state.\n * @namespace Blockly.serialization.variables\n */\ngoog.module('Blockly.serialization.variables');\n\nconst priorities = goog.require('Blockly.serialization.priorities');\nconst serializationRegistry = goog.require('Blockly.serialization.registry');\n// eslint-disable-next-line no-unused-vars\nconst {ISerializer} = goog.require('Blockly.serialization.ISerializer');\n// eslint-disable-next-line no-unused-vars\nconst {Workspace} = goog.requireType('Blockly.Workspace');\n\n\n/**\n * Represents the state of a given variable.\n * @typedef {{\n *   name: string,\n *   id: string,\n *   type: (string|undefined)\n * }}\n * @alias Blockly.serialization.variables.State\n */\nlet State;\nexports.State = State;\n\n/**\n * Serializer for saving and loading variable state.\n * @implements {ISerializer}\n * @alias Blockly.serialization.variables.VariableSerializer\n */\nclass VariableSerializer {\n  /* eslint-disable-next-line require-jsdoc */\n  constructor() {\n    /**\n     * The priority for deserializing variables.\n     * @type {number}\n     */\n    this.priority = priorities.VARIABLES;\n  }\n\n  /**\n   * Serializes the variables of the given workspace.\n   * @param {!Workspace} workspace The workspace to save the variables of.\n   * @return {?Array<!State>} The state of the workspace's variables, or null\n   *     if there are no variables.\n   */\n  save(workspace) {\n    const variableStates = [];\n    for (const variable of workspace.getAllVariables()) {\n      const state = {\n        'name': variable.name,\n        'id': variable.getId(),\n      };\n      if (variable.type) {\n        state['type'] = variable.type;\n      }\n      variableStates.push(state);\n    }\n    return variableStates.length ? variableStates : null;\n  }\n\n  /**\n   * Deserializes the variable defined by the given state into the given\n   * workspace.\n   * @param {!Array<!State>} state The state of the variables to deserialize.\n   * @param {!Workspace} workspace The workspace to deserialize into.\n   */\n  load(state, workspace) {\n    for (const varState of state) {\n      workspace.createVariable(\n          varState['name'], varState['type'], varState['id']);\n    }\n  }\n\n  /**\n   * Disposes of any variables that exist on the workspace.\n   * @param {!Workspace} workspace The workspace to clear the variables of.\n   */\n  clear(workspace) {\n    workspace.getVariableMap().clear();\n  }\n}\n\nserializationRegistry.register('variables', new VariableSerializer());\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/serialization/variables.js?")},
"./core/serialization/workspaces.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/workspace.js\");\n__webpack_require__(\"./core/workspace_svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Contains top-level functions for serializing workspaces to\n * plain JavaScript objects.\n */\n\n\n/**\n * Contains top-level functions for serializing workspaces to plain JavaScript\n * objects.\n * @namespace Blockly.serialization.workspaces\n */\ngoog.module('Blockly.serialization.workspaces');\n\nconst dom = goog.require('Blockly.utils.dom');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\n// eslint-disable-next-line no-unused-vars\nconst {Workspace} = goog.require('Blockly.Workspace');\nconst {WorkspaceSvg} = goog.require('Blockly.WorkspaceSvg');\n\n\n/**\n * Returns the state of the workspace as a plain JavaScript object.\n * @param {!Workspace} workspace The workspace to serialize.\n * @return {!Object<string, *>} The serialized state of the workspace.\n * @alias Blockly.serialization.workspaces.save\n */\nconst save = function(workspace) {\n  const state = Object.create(null);\n  const serializerMap = registry.getAllItems(registry.Type.SERIALIZER, true);\n  for (const key in serializerMap) {\n    const save = serializerMap[key].save(workspace);\n    if (save) {\n      state[key] = save;\n    }\n  }\n  return state;\n};\nexports.save = save;\n\n/**\n * Loads the variable represented by the given state into the given workspace.\n * @param {!Object<string, *>} state The state of the workspace to deserialize\n *     into the workspace.\n * @param {!Workspace} workspace The workspace to add the new state to.\n * @param {{recordUndo: (boolean|undefined)}=} param1\n *     recordUndo: If true, events triggered by this function will be undo-able\n *       by the user. False by default.\n * @alias Blockly.serialization.workspaces.load\n */\nconst load = function(state, workspace, {recordUndo = false} = {}) {\n  const serializerMap = registry.getAllItems(registry.Type.SERIALIZER, true);\n  if (!serializerMap) {\n    return;\n  }\n\n  const deserializers = Object.entries(serializerMap)\n                            .sort((a, b) => b[1].priority - a[1].priority);\n\n  const prevRecordUndo = eventUtils.getRecordUndo();\n  eventUtils.setRecordUndo(recordUndo);\n  const existingGroup = eventUtils.getGroup();\n  if (!existingGroup) {\n    eventUtils.setGroup(true);\n  }\n\n  dom.startTextWidthCache();\n  if (workspace instanceof WorkspaceSvg) {\n    workspace.setResizesEnabled(false);\n  }\n\n  // We want to trigger clearing in reverse priority order so plugins don't end\n  // up missing dependencies.\n  for (const [, deserializer] of deserializers.reverse()) {\n    deserializer.clear(workspace);\n  }\n\n  // reverse() is destructive, so we have to re-reverse to correct the order.\n  for (let [name, deserializer] of deserializers.reverse()) {\n    name = /** @type {string} */ (name);\n    const pluginState = state[name];\n    if (pluginState) {\n      deserializer.load(state[name], workspace);\n    }\n  }\n\n  if (workspace instanceof WorkspaceSvg) {\n    workspace.setResizesEnabled(true);\n  }\n  dom.stopTextWidthCache();\n\n  eventUtils.fire(new (eventUtils.get(eventUtils.FINISHED_LOADING))(workspace));\n\n  eventUtils.setGroup(existingGroup);\n  eventUtils.setRecordUndo(prevRecordUndo);\n};\nexports.load = load;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/serialization/workspaces.js?")},
"./core/shortcut_items.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/clipboard.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/gesture.js\");\n__webpack_require__(\"./core/utils/keycodes.js\");\n__webpack_require__(\"./core/shortcut_registry.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Registers default keyboard shortcuts.\n */\n\n\n/**\n * Registers default keyboard shortcuts.\n * @namespace Blockly.ShortcutItems\n */\ngoog.module('Blockly.ShortcutItems');\n\nconst clipboard = goog.require('Blockly.clipboard');\nconst common = goog.require('Blockly.common');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {Gesture} = goog.require('Blockly.Gesture');\n/* eslint-disable-next-line no-unused-vars */\nconst {ICopyable} = goog.requireType('Blockly.ICopyable');\nconst {KeyCodes} = goog.require('Blockly.utils.KeyCodes');\nconst {ShortcutRegistry} = goog.require('Blockly.ShortcutRegistry');\n\n\n/**\n * Object holding the names of the default shortcut items.\n * @enum {string}\n * @alias Blockly.ShortcutItems.names\n */\nconst names = {\n  ESCAPE: 'escape',\n  DELETE: 'delete',\n  COPY: 'copy',\n  CUT: 'cut',\n  PASTE: 'paste',\n  UNDO: 'undo',\n  REDO: 'redo',\n};\nexports.names = names;\n\n/**\n * Keyboard shortcut to hide chaff on escape.\n * @alias Blockly.ShortcutItems.registerEscape\n */\nconst registerEscape = function() {\n  /** @type {!ShortcutRegistry.KeyboardShortcut} */\n  const escapeAction = {\n    name: names.ESCAPE,\n    preconditionFn: function(workspace) {\n      return !workspace.options.readOnly;\n    },\n    callback: function(workspace) {\n      workspace.hideChaff();\n      return true;\n    },\n  };\n  ShortcutRegistry.registry.register(escapeAction);\n  ShortcutRegistry.registry.addKeyMapping(KeyCodes.ESC, escapeAction.name);\n};\nexports.registerEscape = registerEscape;\n\n/**\n * Keyboard shortcut to delete a block on delete or backspace\n * @alias Blockly.ShortcutItems.registerDelete\n */\nconst registerDelete = function() {\n  /** @type {!ShortcutRegistry.KeyboardShortcut} */\n  const deleteShortcut = {\n    name: names.DELETE,\n    preconditionFn: function(workspace) {\n      const selected = common.getSelected();\n      return !workspace.options.readOnly && selected && selected.isDeletable();\n    },\n    callback: function(workspace, e) {\n      // Delete or backspace.\n      // Stop the browser from going back to the previous page.\n      // Do this first to prevent an error in the delete code from resulting in\n      // data loss.\n      e.preventDefault();\n      // Don't delete while dragging.  Jeez.\n      if (Gesture.inProgress()) {\n        return false;\n      }\n      (/** @type {!BlockSvg} */ (common.getSelected())).checkAndDelete();\n      return true;\n    },\n  };\n  ShortcutRegistry.registry.register(deleteShortcut);\n  ShortcutRegistry.registry.addKeyMapping(KeyCodes.DELETE, deleteShortcut.name);\n  ShortcutRegistry.registry.addKeyMapping(\n      KeyCodes.BACKSPACE, deleteShortcut.name);\n};\nexports.registerDelete = registerDelete;\n\n/**\n * Keyboard shortcut to copy a block on ctrl+c, cmd+c, or alt+c.\n * @alias Blockly.ShortcutItems.registerCopy\n */\nconst registerCopy = function() {\n  /** @type {!ShortcutRegistry.KeyboardShortcut} */\n  const copyShortcut = {\n    name: names.COPY,\n    preconditionFn: function(workspace) {\n      const selected = common.getSelected();\n      return !workspace.options.readOnly && !Gesture.inProgress() && selected &&\n          selected.isDeletable() && selected.isMovable();\n    },\n    callback: function(workspace, e) {\n      // Prevent the default copy behavior, which may beep or otherwise indicate\n      // an error due to the lack of a selection.\n      e.preventDefault();\n      workspace.hideChaff();\n      clipboard.copy(/** @type {!ICopyable} */ (common.getSelected()));\n      return true;\n    },\n  };\n  ShortcutRegistry.registry.register(copyShortcut);\n\n  const ctrlC = ShortcutRegistry.registry.createSerializedKey(\n      KeyCodes.C, [KeyCodes.CTRL]);\n  ShortcutRegistry.registry.addKeyMapping(ctrlC, copyShortcut.name);\n\n  const altC =\n      ShortcutRegistry.registry.createSerializedKey(KeyCodes.C, [KeyCodes.ALT]);\n  ShortcutRegistry.registry.addKeyMapping(altC, copyShortcut.name);\n\n  const metaC = ShortcutRegistry.registry.createSerializedKey(\n      KeyCodes.C, [KeyCodes.META]);\n  ShortcutRegistry.registry.addKeyMapping(metaC, copyShortcut.name);\n};\nexports.registerCopy = registerCopy;\n\n/**\n * Keyboard shortcut to copy and delete a block on ctrl+x, cmd+x, or alt+x.\n * @alias Blockly.ShortcutItems.registerCut\n */\nconst registerCut = function() {\n  /** @type {!ShortcutRegistry.KeyboardShortcut} */\n  const cutShortcut = {\n    name: names.CUT,\n    preconditionFn: function(workspace) {\n      const selected = common.getSelected();\n      return !workspace.options.readOnly && !Gesture.inProgress() && selected &&\n          selected.isDeletable() && selected.isMovable() &&\n          !selected.workspace.isFlyout;\n    },\n    callback: function() {\n      const selected = common.getSelected();\n      if (!selected) {\n        // Shouldn't happen but appeases the type system\n        return false;\n      }\n      clipboard.copy(selected);\n      (/** @type {!BlockSvg} */ (selected)).checkAndDelete();\n      return true;\n    },\n  };\n\n  ShortcutRegistry.registry.register(cutShortcut);\n\n  const ctrlX = ShortcutRegistry.registry.createSerializedKey(\n      KeyCodes.X, [KeyCodes.CTRL]);\n  ShortcutRegistry.registry.addKeyMapping(ctrlX, cutShortcut.name);\n\n  const altX =\n      ShortcutRegistry.registry.createSerializedKey(KeyCodes.X, [KeyCodes.ALT]);\n  ShortcutRegistry.registry.addKeyMapping(altX, cutShortcut.name);\n\n  const metaX = ShortcutRegistry.registry.createSerializedKey(\n      KeyCodes.X, [KeyCodes.META]);\n  ShortcutRegistry.registry.addKeyMapping(metaX, cutShortcut.name);\n};\nexports.registerCut = registerCut;\n\n/**\n * Keyboard shortcut to paste a block on ctrl+v, cmd+v, or alt+v.\n * @alias Blockly.ShortcutItems.registerPaste\n */\nconst registerPaste = function() {\n  /** @type {!ShortcutRegistry.KeyboardShortcut} */\n  const pasteShortcut = {\n    name: names.PASTE,\n    preconditionFn: function(workspace) {\n      return !workspace.options.readOnly && !Gesture.inProgress();\n    },\n    callback: function() {\n      return clipboard.paste();\n    },\n  };\n\n  ShortcutRegistry.registry.register(pasteShortcut);\n\n  const ctrlV = ShortcutRegistry.registry.createSerializedKey(\n      KeyCodes.V, [KeyCodes.CTRL]);\n  ShortcutRegistry.registry.addKeyMapping(ctrlV, pasteShortcut.name);\n\n  const altV =\n      ShortcutRegistry.registry.createSerializedKey(KeyCodes.V, [KeyCodes.ALT]);\n  ShortcutRegistry.registry.addKeyMapping(altV, pasteShortcut.name);\n\n  const metaV = ShortcutRegistry.registry.createSerializedKey(\n      KeyCodes.V, [KeyCodes.META]);\n  ShortcutRegistry.registry.addKeyMapping(metaV, pasteShortcut.name);\n};\nexports.registerPaste = registerPaste;\n\n/**\n * Keyboard shortcut to undo the previous action on ctrl+z, cmd+z, or alt+z.\n * @alias Blockly.ShortcutItems.registerUndo\n */\nconst registerUndo = function() {\n  /** @type {!ShortcutRegistry.KeyboardShortcut} */\n  const undoShortcut = {\n    name: names.UNDO,\n    preconditionFn: function(workspace) {\n      return !workspace.options.readOnly && !Gesture.inProgress();\n    },\n    callback: function(workspace) {\n      // 'z' for undo 'Z' is for redo.\n      workspace.hideChaff();\n      workspace.undo(false);\n      return true;\n    },\n  };\n  ShortcutRegistry.registry.register(undoShortcut);\n\n  const ctrlZ = ShortcutRegistry.registry.createSerializedKey(\n      KeyCodes.Z, [KeyCodes.CTRL]);\n  ShortcutRegistry.registry.addKeyMapping(ctrlZ, undoShortcut.name);\n\n  const altZ =\n      ShortcutRegistry.registry.createSerializedKey(KeyCodes.Z, [KeyCodes.ALT]);\n  ShortcutRegistry.registry.addKeyMapping(altZ, undoShortcut.name);\n\n  const metaZ = ShortcutRegistry.registry.createSerializedKey(\n      KeyCodes.Z, [KeyCodes.META]);\n  ShortcutRegistry.registry.addKeyMapping(metaZ, undoShortcut.name);\n};\nexports.registerUndo = registerUndo;\n\n/**\n * Keyboard shortcut to redo the previous action on ctrl+shift+z, cmd+shift+z,\n * or alt+shift+z.\n * @alias Blockly.ShortcutItems.registerRedo\n */\nconst registerRedo = function() {\n  /** @type {!ShortcutRegistry.KeyboardShortcut} */\n  const redoShortcut = {\n    name: names.REDO,\n    preconditionFn: function(workspace) {\n      return !Gesture.inProgress() && !workspace.options.readOnly;\n    },\n    callback: function(workspace) {\n      // 'z' for undo 'Z' is for redo.\n      workspace.hideChaff();\n      workspace.undo(true);\n      return true;\n    },\n  };\n  ShortcutRegistry.registry.register(redoShortcut);\n\n  const ctrlShiftZ = ShortcutRegistry.registry.createSerializedKey(\n      KeyCodes.Z, [KeyCodes.SHIFT, KeyCodes.CTRL]);\n  ShortcutRegistry.registry.addKeyMapping(ctrlShiftZ, redoShortcut.name);\n\n  const altShiftZ = ShortcutRegistry.registry.createSerializedKey(\n      KeyCodes.Z, [KeyCodes.SHIFT, KeyCodes.ALT]);\n  ShortcutRegistry.registry.addKeyMapping(altShiftZ, redoShortcut.name);\n\n  const metaShiftZ = ShortcutRegistry.registry.createSerializedKey(\n      KeyCodes.Z, [KeyCodes.SHIFT, KeyCodes.META]);\n  ShortcutRegistry.registry.addKeyMapping(metaShiftZ, redoShortcut.name);\n\n  // Ctrl-y is redo in Windows.  Command-y is never valid on Macs.\n  const ctrlY = ShortcutRegistry.registry.createSerializedKey(\n      KeyCodes.Y, [KeyCodes.CTRL]);\n  ShortcutRegistry.registry.addKeyMapping(ctrlY, redoShortcut.name);\n};\nexports.registerRedo = registerRedo;\n\n/**\n * Registers all default keyboard shortcut item. This should be called once per\n * instance of KeyboardShortcutRegistry.\n * @alias Blockly.ShortcutItems.registerDefaultShortcuts\n * @package\n */\nconst registerDefaultShortcuts = function() {\n  registerEscape();\n  registerDelete();\n  registerCopy();\n  registerCut();\n  registerPaste();\n  registerUndo();\n  registerRedo();\n};\nexports.registerDefaultShortcuts = registerDefaultShortcuts;\n\nregisterDefaultShortcuts();\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/shortcut_items.js?")},
"./core/shortcut_registry.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/object.js\");\n__webpack_require__(\"./core/utils/keycodes.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The namespace used to keep track of keyboard shortcuts and the\n * key codes used to execute those shortcuts.\n */\n\n\n/**\n * The namespace used to keep track of keyboard shortcuts and the\n * key codes used to execute those shortcuts.\n * @class\n */\ngoog.module('Blockly.ShortcutRegistry');\n\nconst object = goog.require('Blockly.utils.object');\nconst {KeyCodes} = goog.require('Blockly.utils.KeyCodes');\n/* eslint-disable-next-line no-unused-vars */\nconst {Workspace} = goog.requireType('Blockly.Workspace');\n\n\n/**\n * Class for the registry of keyboard shortcuts. This is intended to be a\n * singleton. You should not create a new instance, and only access this class\n * from ShortcutRegistry.registry.\n * @alias Blockly.ShortcutRegistry\n */\nclass ShortcutRegistry {\n  /**\n   * Resets the existing ShortcutRegistry singleton.\n   */\n  constructor() {\n    this.reset();\n  }\n\n  /**\n   * Clear and recreate the registry and keyMap.\n   */\n  reset() {\n    /**\n     * Registry of all keyboard shortcuts, keyed by name of shortcut.\n     * @type {!Object<string, !ShortcutRegistry.KeyboardShortcut>}\n     * @private\n     */\n    this.registry_ = Object.create(null);\n\n    /**\n     * Map of key codes to an array of shortcut names.\n     * @type {!Object<string, !Array<string>>}\n     * @private\n     */\n    this.keyMap_ = Object.create(null);\n  }\n\n  /**\n   * Registers a keyboard shortcut.\n   * @param {!ShortcutRegistry.KeyboardShortcut} shortcut The\n   *     shortcut for this key code.\n   * @param {boolean=} opt_allowOverrides True to prevent a warning when\n   *     overriding an already registered item.\n   * @throws {Error} if a shortcut with the same name already exists.\n   * @public\n   */\n  register(shortcut, opt_allowOverrides) {\n    const registeredShortcut = this.registry_[shortcut.name];\n    if (registeredShortcut && !opt_allowOverrides) {\n      throw new Error(\n          'Shortcut with name \"' + shortcut.name + '\" already exists.');\n    }\n    this.registry_[shortcut.name] = shortcut;\n  }\n\n  /**\n   * Unregisters a keyboard shortcut registered with the given key code. This\n   * will also remove any key mappings that reference this shortcut.\n   * @param {string} shortcutName The name of the shortcut to unregister.\n   * @return {boolean} True if an item was unregistered, false otherwise.\n   * @public\n   */\n  unregister(shortcutName) {\n    const shortcut = this.registry_[shortcutName];\n\n    if (!shortcut) {\n      console.warn(\n          'Keyboard shortcut with name \"' + shortcutName + '\" not found.');\n      return false;\n    }\n\n    this.removeAllKeyMappings(shortcutName);\n\n    delete this.registry_[shortcutName];\n    return true;\n  }\n\n  /**\n   * Adds a mapping between a keycode and a keyboard shortcut.\n   * @param {string|KeyCodes} keyCode The key code for the keyboard\n   *     shortcut. If registering a key code with a modifier (ex: ctrl+c) use\n   *     ShortcutRegistry.registry.createSerializedKey;\n   * @param {string} shortcutName The name of the shortcut to execute when the\n   *     given keycode is pressed.\n   * @param {boolean=} opt_allowCollision True to prevent an error when adding a\n   *     shortcut to a key that is already mapped to a shortcut.\n   * @throws {Error} if the given key code is already mapped to a shortcut.\n   * @public\n   */\n  addKeyMapping(keyCode, shortcutName, opt_allowCollision) {\n    keyCode = String(keyCode);\n    const shortcutNames = this.keyMap_[keyCode];\n    if (shortcutNames && !opt_allowCollision) {\n      throw new Error(\n          'Shortcut with name \"' + shortcutName + '\" collides with shortcuts ' +\n          shortcutNames.toString());\n    } else if (shortcutNames && opt_allowCollision) {\n      shortcutNames.unshift(shortcutName);\n    } else {\n      this.keyMap_[keyCode] = [shortcutName];\n    }\n  }\n\n  /**\n   * Removes a mapping between a keycode and a keyboard shortcut.\n   * @param {string} keyCode The key code for the keyboard shortcut. If\n   *     registering a key code with a modifier (ex: ctrl+c) use\n   *     ShortcutRegistry.registry.createSerializedKey;\n   * @param {string} shortcutName The name of the shortcut to execute when the\n   *     given keycode is pressed.\n   * @param {boolean=} opt_quiet True to not console warn when there is no\n   *     shortcut to remove.\n   * @return {boolean} True if a key mapping was removed, false otherwise.\n   * @public\n   */\n  removeKeyMapping(keyCode, shortcutName, opt_quiet) {\n    const shortcutNames = this.keyMap_[keyCode];\n\n    if (!shortcutNames && !opt_quiet) {\n      console.warn(\n          'No keyboard shortcut with name \"' + shortcutName +\n          '\" registered with key code \"' + keyCode + '\"');\n      return false;\n    }\n\n    const shortcutIdx = shortcutNames.indexOf(shortcutName);\n    if (shortcutIdx > -1) {\n      shortcutNames.splice(shortcutIdx, 1);\n      if (shortcutNames.length === 0) {\n        delete this.keyMap_[keyCode];\n      }\n      return true;\n    }\n    if (!opt_quiet) {\n      console.warn(\n          'No keyboard shortcut with name \"' + shortcutName +\n          '\" registered with key code \"' + keyCode + '\"');\n    }\n    return false;\n  }\n\n  /**\n   * Removes all the key mappings for a shortcut with the given name.\n   * Useful when changing the default key mappings and the key codes registered\n   * to the shortcut are unknown.\n   * @param {string} shortcutName The name of the shortcut to remove from the\n   *     key map.\n   * @public\n   */\n  removeAllKeyMappings(shortcutName) {\n    for (const keyCode in this.keyMap_) {\n      this.removeKeyMapping(keyCode, shortcutName, true);\n    }\n  }\n\n  /**\n   * Sets the key map. Setting the key map will override any default key\n   * mappings.\n   * @param {!Object<string, !Array<string>>} keyMap The object with key code to\n   *     shortcut names.\n   * @public\n   */\n  setKeyMap(keyMap) {\n    this.keyMap_ = keyMap;\n  }\n\n  /**\n   * Gets the current key map.\n   * @return {!Object<string,!Array<!ShortcutRegistry.KeyboardShortcut>>}\n   *     The object holding key codes to ShortcutRegistry.KeyboardShortcut.\n   * @public\n   */\n  getKeyMap() {\n    return object.deepMerge(Object.create(null), this.keyMap_);\n  }\n\n  /**\n   * Gets the registry of keyboard shortcuts.\n   * @return {!Object<string, !ShortcutRegistry.KeyboardShortcut>}\n   *     The registry of keyboard shortcuts.\n   * @public\n   */\n  getRegistry() {\n    return object.deepMerge(Object.create(null), this.registry_);\n  }\n\n  /**\n   * Handles key down events.\n   * @param {!Workspace} workspace The main workspace where the event was\n   *     captured.\n   * @param {!Event} e The key down event.\n   * @return {boolean} True if the event was handled, false otherwise.\n   * @public\n   */\n  onKeyDown(workspace, e) {\n    const key = this.serializeKeyEvent_(e);\n    const shortcutNames = this.getShortcutNamesByKeyCode(key);\n    if (!shortcutNames) {\n      return false;\n    }\n    for (let i = 0, shortcutName; (shortcutName = shortcutNames[i]); i++) {\n      const shortcut = this.registry_[shortcutName];\n      if (!shortcut.preconditionFn || shortcut.preconditionFn(workspace)) {\n        // If the key has been handled, stop processing shortcuts.\n        if (shortcut.callback && shortcut.callback(workspace, e, shortcut)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the shortcuts registered to the given key code.\n   * @param {string} keyCode The serialized key code.\n   * @return {!Array<string>|undefined} The list of shortcuts to call when the\n   *     given keyCode is used. Undefined if no shortcuts exist.\n   * @public\n   */\n  getShortcutNamesByKeyCode(keyCode) {\n    return this.keyMap_[keyCode] || [];\n  }\n\n  /**\n   * Gets the serialized key codes that the shortcut with the given name is\n   * registered under.\n   * @param {string} shortcutName The name of the shortcut.\n   * @return {!Array<string>} An array with all the key codes the shortcut is\n   *     registered under.\n   * @public\n   */\n  getKeyCodesByShortcutName(shortcutName) {\n    const keys = [];\n    for (const keyCode in this.keyMap_) {\n      const shortcuts = this.keyMap_[keyCode];\n      const shortcutIdx = shortcuts.indexOf(shortcutName);\n      if (shortcutIdx > -1) {\n        keys.push(keyCode);\n      }\n    }\n    return keys;\n  }\n\n  /**\n   * Serializes a key event.\n   * @param {!Event} e A key down event.\n   * @return {string} The serialized key code for the given event.\n   * @private\n   */\n  serializeKeyEvent_(e) {\n    let serializedKey = '';\n    for (const modifier in ShortcutRegistry.modifierKeys) {\n      if (e.getModifierState(modifier)) {\n        if (serializedKey !== '') {\n          serializedKey += '+';\n        }\n        serializedKey += modifier;\n      }\n    }\n    if (serializedKey !== '' && e.keyCode) {\n      serializedKey = serializedKey + '+' + e.keyCode;\n    } else if (e.keyCode) {\n      serializedKey = e.keyCode.toString();\n    }\n    return serializedKey;\n  }\n\n  /**\n   * Checks whether any of the given modifiers are not valid.\n   * @param {!Array<string>} modifiers List of modifiers to be used with the\n   *     key.\n   * @throws {Error} if the modifier is not in the valid modifiers list.\n   * @private\n   */\n  checkModifiers_(modifiers) {\n    const validModifiers = object.values(ShortcutRegistry.modifierKeys);\n    for (let i = 0, modifier; (modifier = modifiers[i]); i++) {\n      if (validModifiers.indexOf(modifier) < 0) {\n        throw new Error(modifier + ' is not a valid modifier key.');\n      }\n    }\n  }\n\n  /**\n   * Creates the serialized key code that will be used in the key map.\n   * @param {number} keyCode Number code representing the key.\n   * @param {?Array<string>} modifiers List of modifier key codes to be used\n   *     with the key. All valid modifiers can be found in the\n   *     ShortcutRegistry.modifierKeys.\n   * @return {string} The serialized key code for the given modifiers and key.\n   * @public\n   */\n  createSerializedKey(keyCode, modifiers) {\n    let serializedKey = '';\n\n    if (modifiers) {\n      this.checkModifiers_(modifiers);\n      for (const modifier in ShortcutRegistry.modifierKeys) {\n        const modifierKeyCode = ShortcutRegistry.modifierKeys[modifier];\n        if (modifiers.indexOf(modifierKeyCode) > -1) {\n          if (serializedKey !== '') {\n            serializedKey += '+';\n          }\n          serializedKey += modifier;\n        }\n      }\n    }\n\n    if (serializedKey !== '' && keyCode) {\n      serializedKey = serializedKey + '+' + keyCode;\n    } else if (keyCode) {\n      serializedKey = keyCode.toString();\n    }\n    return serializedKey;\n  }\n}\n\n/**\n * Enum of valid modifiers.\n * @enum {!KeyCodes}\n */\nShortcutRegistry.modifierKeys = {\n  'Shift': KeyCodes.SHIFT,\n  'Control': KeyCodes.CTRL,\n  'Alt': KeyCodes.ALT,\n  'Meta': KeyCodes.META,\n};\n\n/**\n * A keyboard shortcut.\n * @typedef {{\n *    callback: ((function(!Workspace, Event,\n * !ShortcutRegistry.KeyboardShortcut):boolean)|undefined),\n *    name: string,\n *    preconditionFn: ((function(!Workspace):boolean)|undefined),\n *    metadata: (Object|undefined)\n * }}\n */\nShortcutRegistry.KeyboardShortcut;\n\n// Creates and assigns the singleton instance.\nconst registry = new ShortcutRegistry();\nShortcutRegistry.registry = registry;\n\nexports.ShortcutRegistry = ShortcutRegistry;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/shortcut_registry.js?")},
"./core/sprites.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Holds constants that have to do with the sprites that create\n * the trashcan and zoom controls.\n */\n\n\n/**\n * Holds constants that have to do with the sprites that create the trashcan\n * and zoom controls.\n */\ngoog.module('Blockly.sprite');\n\n\n/**\n * Contains the path to a single png tat holds the images for the trashcan\n * as well as the zoom controls.\n * @const {!Object}\n * @alias Blockly.sprite.SPRITE\n */\nconst SPRITE = {\n  width: 96,\n  height: 124,\n  url: 'sprites.png',\n};\nexports.SPRITE = SPRITE;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/sprites.js?")},
"./core/theme.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/object.js\");\n__webpack_require__(\"./core/registry.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing a theme.\n */\n\n\n/**\n * The class representing a theme.\n * @class\n */\ngoog.module('Blockly.Theme');\n\nconst object = goog.require('Blockly.utils.object');\nconst registry = goog.require('Blockly.registry');\n\n\n/**\n * Class for a theme.\n * @alias Blockly.Theme\n */\nclass Theme {\n  /**\n   * @param {string} name Theme name.\n   * @param {!Object<string, Theme.BlockStyle>=} opt_blockStyles A map\n   *     from style names (strings) to objects with style attributes for blocks.\n   * @param {!Object<string, Theme.CategoryStyle>=} opt_categoryStyles A\n   *     map from style names (strings) to objects with style attributes for\n   *     categories.\n   * @param {!Theme.ComponentStyle=} opt_componentStyles A map of Blockly\n   *     component names to style value.\n   */\n  constructor(name, opt_blockStyles, opt_categoryStyles, opt_componentStyles) {\n    /**\n     * The theme name. This can be used to reference a specific theme in CSS.\n     * @type {string}\n     */\n    this.name = name;\n\n    /**\n     * The block styles map.\n     * @type {!Object<string, !Theme.BlockStyle>}\n     * @package\n     */\n    this.blockStyles = opt_blockStyles || Object.create(null);\n\n    /**\n     * The category styles map.\n     * @type {!Object<string, Theme.CategoryStyle>}\n     * @package\n     */\n    this.categoryStyles = opt_categoryStyles || Object.create(null);\n\n    /**\n     * The UI components styles map.\n     * @type {!Theme.ComponentStyle}\n     * @package\n     */\n    this.componentStyles = opt_componentStyles ||\n        (/** @type {Theme.ComponentStyle} */ (Object.create(null)));\n\n    /**\n     * The font style.\n     * @type {!Theme.FontStyle}\n     * @package\n     */\n    this.fontStyle = /** @type {Theme.FontStyle} */ (Object.create(null));\n\n    /**\n     * Whether or not to add a 'hat' on top of all blocks with no previous or\n     * output connections.\n     * @type {?boolean}\n     * @package\n     */\n    this.startHats = null;\n\n    // Register the theme by name.\n    registry.register(registry.Type.THEME, name, this);\n  }\n  /**\n   * Gets the class name that identifies this theme.\n   * @return {string} The CSS class name.\n   * @package\n   */\n  getClassName() {\n    return this.name + '-theme';\n  }\n  /**\n   * Overrides or adds a style to the blockStyles map.\n   * @param {string} blockStyleName The name of the block style.\n   * @param {Theme.BlockStyle} blockStyle The block style.\n   */\n  setBlockStyle(blockStyleName, blockStyle) {\n    this.blockStyles[blockStyleName] = blockStyle;\n  }\n  /**\n   * Overrides or adds a style to the categoryStyles map.\n   * @param {string} categoryStyleName The name of the category style.\n   * @param {Theme.CategoryStyle} categoryStyle The category style.\n   */\n  setCategoryStyle(categoryStyleName, categoryStyle) {\n    this.categoryStyles[categoryStyleName] = categoryStyle;\n  }\n  /**\n   * Gets the style for a given Blockly UI component.  If the style value is a\n   * string, we attempt to find the value of any named references.\n   * @param {string} componentName The name of the component.\n   * @return {?string} The style value.\n   */\n  getComponentStyle(componentName) {\n    const style = this.componentStyles[componentName];\n    if (style && typeof style === 'string' &&\n        this.getComponentStyle(/** @type {string} */ (style))) {\n      return this.getComponentStyle(/** @type {string} */ (style));\n    }\n    return style ? String(style) : null;\n  }\n  /**\n   * Configure a specific Blockly UI component with a style value.\n   * @param {string} componentName The name of the component.\n   * @param {*} styleValue The style value.\n   */\n  setComponentStyle(componentName, styleValue) {\n    this.componentStyles[componentName] = styleValue;\n  }\n  /**\n   * Configure a theme's font style.\n   * @param {Theme.FontStyle} fontStyle The font style.\n   */\n  setFontStyle(fontStyle) {\n    this.fontStyle = fontStyle;\n  }\n  /**\n   * Configure a theme's start hats.\n   * @param {boolean} startHats True if the theme enables start hats, false\n   *     otherwise.\n   */\n  setStartHats(startHats) {\n    this.startHats = startHats;\n  }\n  /**\n   * Define a new Blockly theme.\n   * @param {string} name The name of the theme.\n   * @param {!Object} themeObj An object containing theme properties.\n   * @return {!Theme} A new Blockly theme.\n   */\n  static defineTheme(name, themeObj) {\n    const theme = new Theme(name);\n    let base = themeObj['base'];\n    if (base) {\n      if (typeof base === 'string') {\n        base = registry.getObject(registry.Type.THEME, base);\n      }\n      if (base instanceof Theme) {\n        object.deepMerge(theme, base);\n        theme.name = name;\n      }\n    }\n\n    object.deepMerge(theme.blockStyles, themeObj['blockStyles']);\n    object.deepMerge(theme.categoryStyles, themeObj['categoryStyles']);\n    object.deepMerge(theme.componentStyles, themeObj['componentStyles']);\n    object.deepMerge(theme.fontStyle, themeObj['fontStyle']);\n    if (themeObj['startHats'] !== null) {\n      theme.startHats = themeObj['startHats'];\n    }\n\n    return theme;\n  }\n}\n\n/**\n * A block style.\n * @typedef {{\n *            colourPrimary:string,\n *            colourSecondary:string,\n *            colourTertiary:string,\n *            hat:string\n *          }}\n */\nTheme.BlockStyle;\n\n/**\n * A category style.\n * @typedef {{\n *            colour:string\n *          }}\n */\nTheme.CategoryStyle;\n\n/**\n * A component style.\n * @typedef {{\n *            workspaceBackgroundColour:?string,\n *            toolboxBackgroundColour:?string,\n *            toolboxForegroundColour:?string,\n *            flyoutBackgroundColour:?string,\n *            flyoutForegroundColour:?string,\n *            flyoutOpacity:?number,\n *            scrollbarColour:?string,\n *            scrollbarOpacity:?number,\n *            insertionMarkerColour:?string,\n *            insertionMarkerOpacity:?number,\n *            markerColour:?string,\n *            cursorColour:?string,\n *            selectedGlowColour:?string,\n *            selectedGlowOpacity:?number,\n *            replacementGlowColour:?string,\n *            replacementGlowOpacity:?number\n *          }}\n */\nTheme.ComponentStyle;\n\n/**\n * A font style.\n * @typedef {{\n *            family:?string,\n *            weight:?string,\n *            size:?number\n *          }}\n */\nTheme.FontStyle;\n\nexports.Theme = Theme;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/theme.js?")},
"./core/theme/classic.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/theme.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Classic theme.\n * Contains multi-coloured border to create shadow effect.\n */\n\n\n/**\n * Classic theme.\n * Contains multi-coloured border to create shadow effect.\n * @namespace Blockly.Themes.Classic\n */\ngoog.module('Blockly.Themes.Classic');\n\nconst {Theme} = goog.require('Blockly.Theme');\n\n\nconst defaultBlockStyles = {\n  'colour_blocks': {'colourPrimary': '20'},\n  'list_blocks': {'colourPrimary': '260'},\n  'logic_blocks': {'colourPrimary': '210'},\n  'loop_blocks': {'colourPrimary': '120'},\n  'math_blocks': {'colourPrimary': '230'},\n  'procedure_blocks': {'colourPrimary': '290'},\n  'text_blocks': {'colourPrimary': '160'},\n  'variable_blocks': {'colourPrimary': '330'},\n  'variable_dynamic_blocks': {'colourPrimary': '310'},\n  'hat_blocks': {'colourPrimary': '330', 'hat': 'cap'},\n};\n\nconst categoryStyles = {\n  'colour_category': {'colour': '20'},\n  'list_category': {'colour': '260'},\n  'logic_category': {'colour': '210'},\n  'loop_category': {'colour': '120'},\n  'math_category': {'colour': '230'},\n  'procedure_category': {'colour': '290'},\n  'text_category': {'colour': '160'},\n  'variable_category': {'colour': '330'},\n  'variable_dynamic_category': {'colour': '310'},\n};\n\n/**\n * Classic theme.\n * Contains multi-coloured border to create shadow effect.\n * @type {Theme}\n * @alias Blockly.Themes.Classic\n */\nconst Classic = new Theme('classic', defaultBlockStyles, categoryStyles);\n\nexports.Classic = Classic;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/theme/classic.js?")},
"./core/theme/themes.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/theme/classic.js\");\n__webpack_require__(\"./core/theme/zelos.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Namespace for themes.\n */\n\n\n/**\n * Namespace for themes.\n * @namespace Blockly.Themes\n */\ngoog.module('Blockly.Themes');\n\nconst {Classic} = goog.require('Blockly.Themes.Classic');\nconst {Zelos} = goog.require('Blockly.Themes.Zelos');\n\n\nexports.Classic = Classic;\nexports.Zelos = Zelos;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/theme/themes.js?")},
"./core/theme/zelos.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/theme.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Zelos theme.\n */\n\n\n/**\n * Zelos theme.\n * @namespace Blockly.Themes.Zelos\n */\ngoog.module('Blockly.Themes.Zelos');\n\nconst {Theme} = goog.require('Blockly.Theme');\n\n\nconst defaultBlockStyles = {\n  'colour_blocks': {\n    'colourPrimary': '#CF63CF',\n    'colourSecondary': '#C94FC9',\n    'colourTertiary': '#BD42BD',\n  },\n  'list_blocks': {\n    'colourPrimary': '#9966FF',\n    'colourSecondary': '#855CD6',\n    'colourTertiary': '#774DCB',\n  },\n  'logic_blocks': {\n    'colourPrimary': '#4C97FF',\n    'colourSecondary': '#4280D7',\n    'colourTertiary': '#3373CC',\n  },\n  'loop_blocks': {\n    'colourPrimary': '#0fBD8C',\n    'colourSecondary': '#0DA57A',\n    'colourTertiary': '#0B8E69',\n  },\n  'math_blocks': {\n    'colourPrimary': '#59C059',\n    'colourSecondary': '#46B946',\n    'colourTertiary': '#389438',\n  },\n  'procedure_blocks': {\n    'colourPrimary': '#FF6680',\n    'colourSecondary': '#FF4D6A',\n    'colourTertiary': '#FF3355',\n  },\n  'text_blocks': {\n    'colourPrimary': '#FFBF00',\n    'colourSecondary': '#E6AC00',\n    'colourTertiary': '#CC9900',\n  },\n  'variable_blocks': {\n    'colourPrimary': '#FF8C1A',\n    'colourSecondary': '#FF8000',\n    'colourTertiary': '#DB6E00',\n  },\n  'variable_dynamic_blocks': {\n    'colourPrimary': '#FF8C1A',\n    'colourSecondary': '#FF8000',\n    'colourTertiary': '#DB6E00',\n  },\n  'hat_blocks': {\n    'colourPrimary': '#4C97FF',\n    'colourSecondary': '#4280D7',\n    'colourTertiary': '#3373CC',\n    'hat': 'cap',\n  },\n};\n\nconst categoryStyles = {\n  'colour_category': {'colour': '#CF63CF'},\n  'list_category': {'colour': '#9966FF'},\n  'logic_category': {'colour': '#4C97FF'},\n  'loop_category': {'colour': '#0fBD8C'},\n  'math_category': {'colour': '#59C059'},\n  'procedure_category': {'colour': '#FF6680'},\n  'text_category': {'colour': '#FFBF00'},\n  'variable_category': {'colour': '#FF8C1A'},\n  'variable_dynamic_category': {'colour': '#FF8C1A'},\n};\n\n/**\n * Zelos theme.\n * @type {Theme}\n * @alias Blockly.Themes.Zelos\n */\nconst Zelos = new Theme('zelos', defaultBlockStyles, categoryStyles);\n\nexports.Zelos = Zelos;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/theme/zelos.js?")},
"./core/theme_manager.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/array.js\");\n__webpack_require__(\"./core/utils/dom.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object in charge of storing and updating a workspace theme\n *     and UI components.\n */\n\n\n/**\n * Object in charge of storing and updating a workspace theme\n *     and UI components.\n * @class\n */\ngoog.module('Blockly.ThemeManager');\n\nconst arrayUtils = goog.require('Blockly.utils.array');\nconst dom = goog.require('Blockly.utils.dom');\n/* eslint-disable-next-line no-unused-vars */\nconst {Theme} = goog.requireType('Blockly.Theme');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Workspace} = goog.requireType('Blockly.Workspace');\n\n\n/**\n * Class for storing and updating a workspace's theme and UI components.\n * @alias Blockly.ThemeManager\n */\nclass ThemeManager {\n  /**\n   * @param {!WorkspaceSvg} workspace The main workspace.\n   * @param {!Theme} theme The workspace theme.\n   * @package\n   */\n  constructor(workspace, theme) {\n    /**\n     * The main workspace.\n     * @type {!WorkspaceSvg}\n     * @private\n     */\n    this.workspace_ = workspace;\n\n    /**\n     * The Blockly theme to use.\n     * @type {!Theme}\n     * @private\n     */\n    this.theme_ = theme;\n\n    /**\n     * A list of workspaces that are subscribed to this theme.\n     * @type {!Array<Workspace>}\n     * @private\n     */\n    this.subscribedWorkspaces_ = [];\n\n    /**\n     * A map of subscribed UI components, keyed by component name.\n     * @type {!Object<string, !Array<!ThemeManager.Component>>}\n     * @private\n     */\n    this.componentDB_ = Object.create(null);\n  }\n\n  /**\n   * Get the workspace theme.\n   * @return {!Theme} The workspace theme.\n   * @package\n   */\n  getTheme() {\n    return this.theme_;\n  }\n\n  /**\n   * Set the workspace theme, and refresh the workspace and all components.\n   * @param {!Theme} theme The workspace theme.\n   * @package\n   */\n  setTheme(theme) {\n    const prevTheme = this.theme_;\n    this.theme_ = theme;\n\n    // Set the theme name onto the injection div.\n    const injectionDiv = this.workspace_.getInjectionDiv();\n    if (injectionDiv) {\n      if (prevTheme) {\n        dom.removeClass(injectionDiv, prevTheme.getClassName());\n      }\n      dom.addClass(injectionDiv, this.theme_.getClassName());\n    }\n\n    // Refresh all subscribed workspaces.\n    for (let i = 0, workspace; (workspace = this.subscribedWorkspaces_[i]);\n         i++) {\n      /** @type {!WorkspaceSvg} */ (workspace).refreshTheme();\n    }\n\n    // Refresh all registered Blockly UI components.\n    for (let i = 0, keys = Object.keys(this.componentDB_), key; (key = keys[i]);\n         i++) {\n      for (let j = 0, component; (component = this.componentDB_[key][j]); j++) {\n        const element = component.element;\n        const propertyName = component.propertyName;\n        const style = this.theme_ && this.theme_.getComponentStyle(key);\n        element.style[propertyName] = style || '';\n      }\n    }\n\n    for (const workspace of this.subscribedWorkspaces_) {\n      /** @type {!WorkspaceSvg} */ (workspace).hideChaff();\n    }\n  }\n\n  /**\n   * Subscribe a workspace to changes to the selected theme.  If a new theme is\n   * set, the workspace is called to refresh its blocks.\n   * @param {!Workspace} workspace The workspace to subscribe.\n   * @package\n   */\n  subscribeWorkspace(workspace) {\n    this.subscribedWorkspaces_.push(workspace);\n  }\n\n  /**\n   * Unsubscribe a workspace to changes to the selected theme.\n   * @param {!Workspace} workspace The workspace to unsubscribe.\n   * @package\n   */\n  unsubscribeWorkspace(workspace) {\n    if (!arrayUtils.removeElem(this.subscribedWorkspaces_, workspace)) {\n      throw Error(\n          'Cannot unsubscribe a workspace that hasn\\'t been subscribed.');\n    }\n  }\n\n  /**\n   * Subscribe an element to changes to the selected theme.  If a new theme is\n   * selected, the element's style is refreshed with the new theme's style.\n   * @param {!Element} element The element to subscribe.\n   * @param {string} componentName The name used to identify the component. This\n   *     must be the same name used to configure the style in the Theme object.\n   * @param {string} propertyName The inline style property name to update.\n   * @package\n   */\n  subscribe(element, componentName, propertyName) {\n    if (!this.componentDB_[componentName]) {\n      this.componentDB_[componentName] = [];\n    }\n\n    // Add the element to our component map.\n    this.componentDB_[componentName].push(\n        {element: element, propertyName: propertyName});\n\n    // Initialize the element with its corresponding theme style.\n    const style = this.theme_ && this.theme_.getComponentStyle(componentName);\n    element.style[propertyName] = style || '';\n  }\n\n  /**\n   * Unsubscribe an element to changes to the selected theme.\n   * @param {Element} element The element to unsubscribe.\n   * @package\n   */\n  unsubscribe(element) {\n    if (!element) {\n      return;\n    }\n    // Go through all component, and remove any references to this element.\n    const componentNames = Object.keys(this.componentDB_);\n    for (let c = 0, componentName; (componentName = componentNames[c]); c++) {\n      const elements = this.componentDB_[componentName];\n      for (let i = elements.length - 1; i >= 0; i--) {\n        if (elements[i].element === element) {\n          elements.splice(i, 1);\n        }\n      }\n      // Clean up the component map entry if the list is empty.\n      if (!this.componentDB_[componentName].length) {\n        delete this.componentDB_[componentName];\n      }\n    }\n  }\n\n  /**\n   * Dispose of this theme manager.\n   * @package\n   * @suppress {checkTypes}\n   */\n  dispose() {\n    this.owner_ = null;\n    this.theme_ = null;\n    this.subscribedWorkspaces_ = null;\n    this.componentDB_ = null;\n  }\n}\n\n/**\n * A Blockly UI component type.\n * @typedef {{\n *            element:!Element,\n *            propertyName:string\n *          }}\n */\nThemeManager.Component;\n\nexports.ThemeManager = ThemeManager;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/theme_manager.js?")},
"./core/toolbox/category.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/css.js\");\n__webpack_require__(\"./core/utils/aria.js\");\n__webpack_require__(\"./core/utils/colour.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/utils/object.js\");\n__webpack_require__(\"./core/utils/parsing.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/utils/toolbox.js\");\n__webpack_require__(\"./core/interfaces/i_selectable_toolbox_item.js\");\n__webpack_require__(\"./core/toolbox/toolbox_item.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A toolbox category used to organize blocks in the toolbox.\n */\n\n\n/**\n * A toolbox category used to organize blocks in the toolbox.\n * @class\n */\ngoog.module('Blockly.ToolboxCategory');\n\nconst Css = goog.require('Blockly.Css');\nconst aria = goog.require('Blockly.utils.aria');\nconst colourUtils = goog.require('Blockly.utils.colour');\nconst dom = goog.require('Blockly.utils.dom');\nconst object = goog.require('Blockly.utils.object');\nconst parsing = goog.require('Blockly.utils.parsing');\nconst registry = goog.require('Blockly.registry');\nconst toolbox = goog.require('Blockly.utils.toolbox');\n/* eslint-disable-next-line no-unused-vars */\nconst {ICollapsibleToolboxItem} = goog.requireType('Blockly.ICollapsibleToolboxItem');\n/* eslint-disable-next-line no-unused-vars */\nconst {ISelectableToolboxItem} = goog.require('Blockly.ISelectableToolboxItem');\n/* eslint-disable-next-line no-unused-vars */\nconst {IToolbox} = goog.requireType('Blockly.IToolbox');\nconst {ToolboxItem} = goog.require('Blockly.ToolboxItem');\n\n\n/**\n * Class for a category in a toolbox.\n * @implements {ISelectableToolboxItem}\n * @alias Blockly.ToolboxCategory\n */\nclass ToolboxCategory extends ToolboxItem {\n  /**\n   * @param {!toolbox.CategoryInfo} categoryDef The information needed\n   *     to create a category in the toolbox.\n   * @param {!IToolbox} toolbox The parent toolbox for the category.\n   * @param {ICollapsibleToolboxItem=} opt_parent The parent category or null if\n   *     the category does not have a parent.\n   */\n  constructor(categoryDef, toolbox, opt_parent) {\n    super(categoryDef, toolbox, opt_parent);\n\n    /** @type {!toolbox.CategoryInfo} */\n    this.toolboxItemDef_;\n\n    /**\n     * The name that will be displayed on the category.\n     * @type {string}\n     * @protected\n     */\n    this.name_ = '';\n\n    /**\n     * The colour of the category.\n     * @type {string}\n     * @protected\n     */\n    this.colour_ = '';\n\n    /**\n     * The html container for the category.\n     * @type {?HTMLDivElement}\n     * @protected\n     */\n    this.htmlDiv_ = null;\n\n    /**\n     * The html element for the category row.\n     * @type {?HTMLDivElement}\n     * @protected\n     */\n    this.rowDiv_ = null;\n\n    /**\n     * The html element that holds children elements of the category row.\n     * @type {?HTMLDivElement}\n     * @protected\n     */\n    this.rowContents_ = null;\n\n    /**\n     * The html element for the toolbox icon.\n     * @type {?Element}\n     * @protected\n     */\n    this.iconDom_ = null;\n\n    /**\n     * The html element for the toolbox label.\n     * @type {?Element}\n     * @protected\n     */\n    this.labelDom_ = null;\n\n    /**\n     * All the css class names that are used to create a category.\n     * @type {!ToolboxCategory.CssConfig}\n     * @protected\n     */\n    this.cssConfig_ = this.makeDefaultCssConfig_();\n\n    /**\n     * True if the category is meant to be hidden, false otherwise.\n     * @type {boolean}\n     * @protected\n     */\n    this.isHidden_ = false;\n\n    /**\n     * True if this category is disabled, false otherwise.\n     * @type {boolean}\n     * @protected\n     */\n    this.isDisabled_ = false;\n\n    /**\n     * The flyout items for this category.\n     * @type {string|!toolbox.FlyoutItemInfoArray}\n     * @protected\n     */\n    this.flyoutItems_ = [];\n  }\n\n  /**\n   * Initializes the toolbox item.\n   * This includes creating the DOM and updating the state of any items based\n   * on the info object.\n   * Init should be called immediately after the construction of the toolbox\n   * item, to ensure that the category contents are properly parsed.\n   * @override\n   */\n  init() {\n    this.parseCategoryDef_(this.toolboxItemDef_);\n    this.parseContents_(this.toolboxItemDef_);\n    this.createDom_();\n    if (this.toolboxItemDef_['hidden'] === 'true') {\n      this.hide();\n    }\n  }\n\n\n  /**\n   * Creates an object holding the default classes for a category.\n   * @return {!ToolboxCategory.CssConfig} The configuration object holding\n   *    all the CSS classes for a category.\n   * @protected\n   */\n  makeDefaultCssConfig_() {\n    return {\n      'container': 'blocklyToolboxCategory',\n      'row': 'blocklyTreeRow',\n      'rowcontentcontainer': 'blocklyTreeRowContentContainer',\n      'icon': 'blocklyTreeIcon',\n      'label': 'blocklyTreeLabel',\n      'contents': 'blocklyToolboxContents',\n      'selected': 'blocklyTreeSelected',\n      'openicon': 'blocklyTreeIconOpen',\n      'closedicon': 'blocklyTreeIconClosed',\n    };\n  }\n\n  /**\n   * Parses the contents array depending on if the category is a dynamic\n   * category, or if its contents are meant to be shown in the flyout.\n   * @param {!toolbox.CategoryInfo} categoryDef The information needed\n   *     to create a category.\n   * @protected\n   */\n  parseContents_(categoryDef) {\n    const contents = categoryDef['contents'];\n\n    if (categoryDef['custom']) {\n      this.flyoutItems_ = categoryDef['custom'];\n    } else if (contents) {\n      for (let i = 0; i < contents.length; i++) {\n        const itemDef = contents[i];\n        const flyoutItem =\n            /** @type {toolbox.FlyoutItemInfo} */ (itemDef);\n        this.flyoutItems_.push(flyoutItem);\n      }\n    }\n  }\n\n  /**\n   * Parses the non-contents parts of the category def.\n   * @param {!toolbox.CategoryInfo} categoryDef The information needed to create\n   *     a category.\n   * @protected\n   */\n  parseCategoryDef_(categoryDef) {\n    this.name_ = parsing.replaceMessageReferences(categoryDef['name']);\n    this.colour_ = this.getColour_(categoryDef);\n    object.mixin(\n        this.cssConfig_, categoryDef['cssconfig'] || categoryDef['cssConfig']);\n  }\n\n  /**\n   * Creates the DOM for the category.\n   * @return {!HTMLDivElement} The parent element for the category.\n   * @protected\n   */\n  createDom_() {\n    this.htmlDiv_ = this.createContainer_();\n    aria.setRole(this.htmlDiv_, aria.Role.TREEITEM);\n    aria.setState(\n        /** @type {!HTMLDivElement} */ (this.htmlDiv_), aria.State.SELECTED,\n        false);\n    aria.setState(\n        /** @type {!HTMLDivElement} */ (this.htmlDiv_), aria.State.LEVEL,\n        this.level_);\n\n    this.rowDiv_ = this.createRowContainer_();\n    this.rowDiv_.style.pointerEvents = 'auto';\n    this.htmlDiv_.appendChild(this.rowDiv_);\n\n    this.rowContents_ = this.createRowContentsContainer_();\n    this.rowContents_.style.pointerEvents = 'none';\n    this.rowDiv_.appendChild(this.rowContents_);\n\n    this.iconDom_ = this.createIconDom_();\n    aria.setRole(this.iconDom_, aria.Role.PRESENTATION);\n    this.rowContents_.appendChild(this.iconDom_);\n\n    this.labelDom_ = this.createLabelDom_(this.name_);\n    this.rowContents_.appendChild(this.labelDom_);\n    aria.setState(\n        /** @type {!Element} */ (this.htmlDiv_), aria.State.LABELLEDBY,\n        this.labelDom_.getAttribute('id'));\n\n    this.addColourBorder_(this.colour_);\n\n    return this.htmlDiv_;\n  }\n\n  /**\n   * Creates the container that holds the row and any subcategories.\n   * @return {!HTMLDivElement} The div that holds the icon and the label.\n   * @protected\n   */\n  createContainer_() {\n    const container =\n        /** @type {!HTMLDivElement} */ (document.createElement('div'));\n    dom.addClass(container, this.cssConfig_['container']);\n    return container;\n  }\n\n  /**\n   * Creates the parent of the contents container. All clicks will happen on\n   * this div.\n   * @return {!HTMLDivElement} The div that holds the contents container.\n   * @protected\n   */\n  createRowContainer_() {\n    const rowDiv =\n        /** @type {!HTMLDivElement} */ (document.createElement('div'));\n    dom.addClass(rowDiv, this.cssConfig_['row']);\n    let nestedPadding = ToolboxCategory.nestedPadding * this.getLevel();\n    nestedPadding = nestedPadding.toString() + 'px';\n    this.workspace_.RTL ? rowDiv.style.paddingRight = nestedPadding :\n                          rowDiv.style.paddingLeft = nestedPadding;\n    return rowDiv;\n  }\n\n  /**\n   * Creates the container for the label and icon.\n   * This is necessary so we can set all subcategory pointer events to none.\n   * @return {!HTMLDivElement} The div that holds the icon and the label.\n   * @protected\n   */\n  createRowContentsContainer_() {\n    const contentsContainer =\n        /** @type {!HTMLDivElement} */ (document.createElement('div'));\n    dom.addClass(contentsContainer, this.cssConfig_['rowcontentcontainer']);\n    return contentsContainer;\n  }\n\n  /**\n   * Creates the span that holds the category icon.\n   * @return {!Element} The span that holds the category icon.\n   * @protected\n   */\n  createIconDom_() {\n    const toolboxIcon = document.createElement('span');\n    if (!this.parentToolbox_.isHorizontal()) {\n      dom.addClass(toolboxIcon, this.cssConfig_['icon']);\n    }\n\n    toolboxIcon.style.display = 'inline-block';\n    return toolboxIcon;\n  }\n\n  /**\n   * Creates the span that holds the category label.\n   * This should have an ID for accessibility purposes.\n   * @param {string} name The name of the category.\n   * @return {!Element} The span that holds the category label.\n   * @protected\n   */\n  createLabelDom_(name) {\n    const toolboxLabel = document.createElement('span');\n    toolboxLabel.setAttribute('id', this.getId() + '.label');\n    toolboxLabel.textContent = name;\n    dom.addClass(toolboxLabel, this.cssConfig_['label']);\n    return toolboxLabel;\n  }\n\n  /**\n   * Updates the colour for this category.\n   * @public\n   */\n  refreshTheme() {\n    this.colour_ = this.getColour_(/** @type {toolbox.CategoryInfo} **/\n                                   (this.toolboxItemDef_));\n    this.addColourBorder_(this.colour_);\n  }\n\n  /**\n   * Add the strip of colour to the toolbox category.\n   * @param {string} colour The category colour.\n   * @protected\n   */\n  addColourBorder_(colour) {\n    if (colour) {\n      const border =\n          ToolboxCategory.borderWidth + 'px solid ' + (colour || '#ddd');\n      if (this.workspace_.RTL) {\n        this.rowDiv_.style.borderRight = border;\n      } else {\n        this.rowDiv_.style.borderLeft = border;\n      }\n    }\n  }\n\n  /**\n   * Gets either the colour or the style for a category.\n   * @param {!toolbox.CategoryInfo} categoryDef The object holding\n   *    information on the category.\n   * @return {string} The hex colour for the category.\n   * @protected\n   */\n  getColour_(categoryDef) {\n    const styleName =\n        categoryDef['categorystyle'] || categoryDef['categoryStyle'];\n    const colour = categoryDef['colour'];\n\n    if (colour && styleName) {\n      console.warn(\n          'Toolbox category \"' + this.name_ +\n          '\" must not have both a style and a colour');\n    } else if (styleName) {\n      return this.getColourfromStyle_(styleName);\n    } else {\n      return this.parseColour_(colour);\n    }\n    return '';\n  }\n\n  /**\n   * Sets the colour for the category using the style name and returns the new\n   * colour as a hex string.\n   * @param {string} styleName Name of the style.\n   * @return {string} The hex colour for the category.\n   * @private\n   */\n  getColourfromStyle_(styleName) {\n    const theme = this.workspace_.getTheme();\n    if (styleName && theme) {\n      const style = theme.categoryStyles[styleName];\n      if (style && style.colour) {\n        return this.parseColour_(style.colour);\n      } else {\n        console.warn(\n            'Style \"' + styleName + '\" must exist and contain a colour value');\n      }\n    }\n    return '';\n  }\n\n  /**\n   * Gets the HTML element that is clickable.\n   * The parent toolbox element receives clicks. The parent toolbox will add an\n   * ID to this element so it can pass the onClick event to the correct\n   * toolboxItem.\n   * @return {!Element} The HTML element that receives clicks.\n   * @public\n   */\n  getClickTarget() {\n    return /** @type {!Element} */ (this.rowDiv_);\n  }\n\n  /**\n   * Parses the colour on the category.\n   * @param {number|string} colourValue HSV hue value (0 to 360), #RRGGBB\n   *     string, or a message reference string pointing to one of those two\n   *     values.\n   * @return {string} The hex colour for the category.\n   * @private\n   */\n  parseColour_(colourValue) {\n    // Decode the colour for any potential message references\n    // (eg. `%{BKY_MATH_HUE}`).\n    const colour = parsing.replaceMessageReferences(colourValue);\n    if (colour == null || colour === '') {\n      // No attribute. No colour.\n      return '';\n    } else {\n      const hue = Number(colour);\n      if (!isNaN(hue)) {\n        return colourUtils.hueToHex(hue);\n      } else {\n        const hex = colourUtils.parse(colour);\n        if (hex) {\n          return hex;\n        } else {\n          console.warn(\n              'Toolbox category \"' + this.name_ +\n              '\" has unrecognized colour attribute: ' + colour);\n          return '';\n        }\n      }\n    }\n  }\n\n  /**\n   * Adds appropriate classes to display an open icon.\n   * @param {?Element} iconDiv The div that holds the icon.\n   * @protected\n   */\n  openIcon_(iconDiv) {\n    if (!iconDiv) {\n      return;\n    }\n    dom.removeClasses(iconDiv, this.cssConfig_['closedicon']);\n    dom.addClass(iconDiv, this.cssConfig_['openicon']);\n  }\n\n  /**\n   * Adds appropriate classes to display a closed icon.\n   * @param {?Element} iconDiv The div that holds the icon.\n   * @protected\n   */\n  closeIcon_(iconDiv) {\n    if (!iconDiv) {\n      return;\n    }\n    dom.removeClasses(iconDiv, this.cssConfig_['openicon']);\n    dom.addClass(iconDiv, this.cssConfig_['closedicon']);\n  }\n\n  /**\n   * Sets whether the category is visible or not.\n   * For a category to be visible its parent category must also be expanded.\n   * @param {boolean} isVisible True if category should be visible.\n   * @protected\n   */\n  setVisible_(isVisible) {\n    this.htmlDiv_.style.display = isVisible ? 'block' : 'none';\n    this.isHidden_ = !isVisible;\n\n    if (this.parentToolbox_.getSelectedItem() === this) {\n      this.parentToolbox_.clearSelection();\n    }\n  }\n\n  /**\n   * Hide the category.\n   */\n  hide() {\n    this.setVisible_(false);\n  }\n\n  /**\n   * Show the category. Category will only appear if its parent category is also\n   * expanded.\n   */\n  show() {\n    this.setVisible_(true);\n  }\n\n  /**\n   * Whether the category is visible.\n   * A category is only visible if all of its ancestors are expanded and\n   * isHidden_ is false.\n   * @return {boolean} True if the category is visible, false otherwise.\n   * @public\n   */\n  isVisible() {\n    return !this.isHidden_ && this.allAncestorsExpanded_();\n  }\n\n  /**\n   * Whether all ancestors of a category (parent and parent's parent, etc.) are\n   * expanded.\n   * @return {boolean} True only if every ancestor is expanded\n   * @protected\n   */\n  allAncestorsExpanded_() {\n    let category = this;\n    while (category.getParent()) {\n      category = category.getParent();\n      if (!category.isExpanded()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @override\n   */\n  isSelectable() {\n    return this.isVisible() && !this.isDisabled_;\n  }\n\n  /**\n   * Handles when the toolbox item is clicked.\n   * @param {!Event} _e Click event to handle.\n   * @public\n   */\n  onClick(_e) {\n    // No-op\n  }\n\n  /**\n   * Sets the current category as selected.\n   * @param {boolean} isSelected True if this category is selected, false\n   *     otherwise.\n   * @public\n   */\n  setSelected(isSelected) {\n    if (isSelected) {\n      const defaultColour =\n          this.parseColour_(ToolboxCategory.defaultBackgroundColour);\n      this.rowDiv_.style.backgroundColor = this.colour_ || defaultColour;\n      dom.addClass(this.rowDiv_, this.cssConfig_['selected']);\n    } else {\n      this.rowDiv_.style.backgroundColor = '';\n      dom.removeClass(this.rowDiv_, this.cssConfig_['selected']);\n    }\n    aria.setState(\n        /** @type {!Element} */ (this.htmlDiv_), aria.State.SELECTED,\n        isSelected);\n  }\n\n  /**\n   * Sets whether the category is disabled.\n   * @param {boolean} isDisabled True to disable the category, false otherwise.\n   */\n  setDisabled(isDisabled) {\n    this.isDisabled_ = isDisabled;\n    this.getDiv().setAttribute('disabled', isDisabled);\n    isDisabled ? this.getDiv().setAttribute('disabled', 'true') :\n                 this.getDiv().removeAttribute('disabled');\n  }\n\n  /**\n   * Gets the name of the category. Used for emitting events.\n   * @return {string} The name of the toolbox item.\n   * @public\n   */\n  getName() {\n    return this.name_;\n  }\n\n  /**\n   * @override\n   */\n  getParent() {\n    return this.parent_;\n  }\n\n  /**\n   * @override\n   */\n  getDiv() {\n    return this.htmlDiv_;\n  }\n\n  /**\n   * Gets the contents of the category. These are items that are meant to be\n   * displayed in the flyout.\n   * @return {!toolbox.FlyoutItemInfoArray|string} The definition\n   *     of items to be displayed in the flyout.\n   * @public\n   */\n  getContents() {\n    return this.flyoutItems_;\n  }\n\n  /**\n   * Updates the contents to be displayed in the flyout.\n   * If the flyout is open when the contents are updated, refreshSelection on\n   * the toolbox must also be called.\n   * @param {!toolbox.FlyoutDefinition|string} contents The contents\n   *     to be displayed in the flyout. A string can be supplied to create a\n   *     dynamic category.\n   * @public\n   */\n  updateFlyoutContents(contents) {\n    this.flyoutItems_ = [];\n\n    if (typeof contents === 'string') {\n      this.toolboxItemDef_['custom'] = contents;\n    } else {\n      // Removes old custom field when contents is updated.\n      delete this.toolboxItemDef_['custom'];\n      this.toolboxItemDef_['contents'] =\n          toolbox.convertFlyoutDefToJsonArray(contents);\n    }\n    this.parseContents_(\n        /** @type {toolbox.CategoryInfo} */ (this.toolboxItemDef_));\n  }\n\n  /**\n   * @override\n   */\n  dispose() {\n    dom.removeNode(this.htmlDiv_);\n  }\n}\n\n/**\n * All the CSS class names that are used to create a category.\n * @typedef {{\n *            container:(string|undefined),\n *            row:(string|undefined),\n *            rowcontentcontainer:(string|undefined),\n *            icon:(string|undefined),\n *            label:(string|undefined),\n *            selected:(string|undefined),\n *            openicon:(string|undefined),\n *            closedicon:(string|undefined)\n *          }}\n */\nToolboxCategory.CssConfig;\n\n/**\n * Name used for registering a toolbox category.\n * @type {string}\n */\nToolboxCategory.registrationName = 'category';\n\n/**\n * The number of pixels to move the category over at each nested level.\n * @type {number}\n */\nToolboxCategory.nestedPadding = 19;\n\n/**\n * The width in pixels of the strip of colour next to each category.\n * @type {number}\n */\nToolboxCategory.borderWidth = 8;\n\n/**\n * The default colour of the category. This is used as the background colour of\n * the category when it is selected.\n * @type {string}\n */\nToolboxCategory.defaultBackgroundColour = '#57e';\n\n/**\n * CSS for Toolbox.  See css.js for use.\n */\nCss.register(`\n.blocklyTreeRow:not(.blocklyTreeSelected):hover {\n  background-color: rgba(255, 255, 255, .2);\n}\n\n.blocklyToolboxDiv[layout=\"h\"] .blocklyToolboxCategory {\n  margin: 1px 5px 1px 0;\n}\n\n.blocklyToolboxDiv[dir=\"RTL\"][layout=\"h\"] .blocklyToolboxCategory {\n  margin: 1px 0 1px 5px;\n}\n\n.blocklyTreeRow {\n  height: 22px;\n  line-height: 22px;\n  margin-bottom: 3px;\n  padding-right: 8px;\n  white-space: nowrap;\n}\n\n.blocklyToolboxDiv[dir=\"RTL\"] .blocklyTreeRow {\n  margin-left: 8px;\n  padding-right: 0;\n}\n\n.blocklyTreeIcon {\n  background-image: url(<<<PATH>>>/sprites.png);\n  height: 16px;\n  vertical-align: middle;\n  visibility: hidden;\n  width: 16px;\n}\n\n.blocklyTreeIconClosed {\n  background-position: -32px -1px;\n}\n\n.blocklyToolboxDiv[dir=\"RTL\"] .blocklyTreeIconClosed {\n  background-position: 0 -1px;\n}\n\n.blocklyTreeSelected>.blocklyTreeIconClosed {\n  background-position: -32px -17px;\n}\n\n.blocklyToolboxDiv[dir=\"RTL\"] .blocklyTreeSelected>.blocklyTreeIconClosed {\n  background-position: 0 -17px;\n}\n\n.blocklyTreeIconOpen {\n  background-position: -16px -1px;\n}\n\n.blocklyTreeSelected>.blocklyTreeIconOpen {\n  background-position: -16px -17px;\n}\n\n.blocklyTreeLabel {\n  cursor: default;\n  font: 16px sans-serif;\n  padding: 0 3px;\n  vertical-align: middle;\n}\n\n.blocklyToolboxDelete .blocklyTreeLabel {\n  cursor: url(\"<<<PATH>>>/handdelete.cur\"), auto;\n}\n\n.blocklyTreeSelected .blocklyTreeLabel {\n  color: #fff;\n}\n`);\n\nregistry.register(\n    registry.Type.TOOLBOX_ITEM, ToolboxCategory.registrationName,\n    ToolboxCategory);\n\nexports.ToolboxCategory = ToolboxCategory;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/toolbox/category.js?")},
"./core/toolbox/collapsible_category.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/aria.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/utils/toolbox.js\");\n__webpack_require__(\"./core/interfaces/i_collapsible_toolbox_item.js\");\n__webpack_require__(\"./core/toolbox/category.js\");\n__webpack_require__(\"./core/toolbox/separator.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A toolbox category used to organize blocks in the toolbox.\n */\n\n\n/**\n * A toolbox category used to organize blocks in the toolbox.\n * @class\n */\ngoog.module('Blockly.CollapsibleToolboxCategory');\n\nconst aria = goog.require('Blockly.utils.aria');\nconst dom = goog.require('Blockly.utils.dom');\nconst registry = goog.require('Blockly.registry');\nconst toolbox = goog.require('Blockly.utils.toolbox');\n/* eslint-disable-next-line no-unused-vars */\nconst {ICollapsibleToolboxItem} = goog.require('Blockly.ICollapsibleToolboxItem');\n/* eslint-disable-next-line no-unused-vars */\nconst {IToolboxItem} = goog.requireType('Blockly.IToolboxItem');\n/* eslint-disable-next-line no-unused-vars */\nconst {IToolbox} = goog.requireType('Blockly.IToolbox');\nconst {ToolboxCategory} = goog.require('Blockly.ToolboxCategory');\nconst {ToolboxSeparator} = goog.require('Blockly.ToolboxSeparator');\n\n\n/**\n * Class for a category in a toolbox that can be collapsed.\n * @implements {ICollapsibleToolboxItem}\n * @alias Blockly.CollapsibleToolboxCategory\n */\nclass CollapsibleToolboxCategory extends ToolboxCategory {\n  /**\n   * @param {!toolbox.CategoryInfo} categoryDef The information needed\n   *     to create a category in the toolbox.\n   * @param {!IToolbox} toolbox The parent toolbox for the category.\n   * @param {ICollapsibleToolboxItem=} opt_parent The parent category or null if\n   *     the category does not have a parent.\n   */\n  constructor(categoryDef, toolbox, opt_parent) {\n    super(categoryDef, toolbox, opt_parent);\n\n    /**\n     * Container for any child categories.\n     * @type {?HTMLDivElement}\n     * @protected\n     */\n    this.subcategoriesDiv_ = null;\n\n    /**\n     * Whether or not the category should display its subcategories.\n     * @type {boolean}\n     * @protected\n     */\n    this.expanded_ = false;\n\n    /**\n     * The child toolbox items for this category.\n     * @type {!Array<!IToolboxItem>}\n     * @protected\n     */\n    this.toolboxItems_ = [];\n  }\n\n  /**\n   * @override\n   */\n  makeDefaultCssConfig_() {\n    const cssConfig = super.makeDefaultCssConfig_();\n    cssConfig['contents'] = 'blocklyToolboxContents';\n    return cssConfig;\n  }\n\n  /**\n   * @override\n   */\n  parseContents_(categoryDef) {\n    const contents = categoryDef['contents'];\n    let prevIsFlyoutItem = true;\n\n    if (categoryDef['custom']) {\n      this.flyoutItems_ = categoryDef['custom'];\n    } else if (contents) {\n      for (let i = 0; i < contents.length; i++) {\n        const itemDef = contents[i];\n        // Separators can exist as either a flyout item or a toolbox item so\n        // decide where it goes based on the type of the previous item.\n        if (!registry.hasItem(registry.Type.TOOLBOX_ITEM, itemDef['kind']) ||\n            (itemDef['kind'].toLowerCase() ===\n                 ToolboxSeparator.registrationName &&\n             prevIsFlyoutItem)) {\n          const flyoutItem = /** @type {toolbox.FlyoutItemInfo} */ (itemDef);\n          this.flyoutItems_.push(flyoutItem);\n          prevIsFlyoutItem = true;\n        } else {\n          this.createToolboxItem_(itemDef);\n          prevIsFlyoutItem = false;\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates a toolbox item and adds it to the list of toolbox items.\n   * @param {!toolbox.ToolboxItemInfo} itemDef The information needed\n   *     to create a toolbox item.\n   * @private\n   */\n  createToolboxItem_(itemDef) {\n    let registryName = itemDef['kind'];\n    const categoryDef = /** @type {!toolbox.CategoryInfo} */ (itemDef);\n\n    // Categories that are collapsible are created using a class registered\n    // under a different name.\n    if (registryName.toUpperCase() == 'CATEGORY' &&\n        toolbox.isCategoryCollapsible(categoryDef)) {\n      registryName = CollapsibleToolboxCategory.registrationName;\n    }\n    const ToolboxItemClass =\n        registry.getClass(registry.Type.TOOLBOX_ITEM, registryName);\n    const toolboxItem =\n        new ToolboxItemClass(itemDef, this.parentToolbox_, this);\n    this.toolboxItems_.push(toolboxItem);\n  }\n\n  /**\n   * @override\n   */\n  init() {\n    super.init();\n\n    this.setExpanded(\n        this.toolboxItemDef_['expanded'] === 'true' ||\n        this.toolboxItemDef_['expanded']);\n  }\n\n  /**\n   * @override\n   */\n  createDom_() {\n    super.createDom_();\n\n    const subCategories = this.getChildToolboxItems();\n    this.subcategoriesDiv_ = this.createSubCategoriesDom_(subCategories);\n    aria.setRole(this.subcategoriesDiv_, aria.Role.GROUP);\n    this.htmlDiv_.appendChild(this.subcategoriesDiv_);\n\n    return this.htmlDiv_;\n  }\n\n  /**\n   * @override\n   */\n  createIconDom_() {\n    const toolboxIcon = document.createElement('span');\n    if (!this.parentToolbox_.isHorizontal()) {\n      dom.addClass(toolboxIcon, this.cssConfig_['icon']);\n      toolboxIcon.style.visibility = 'visible';\n    }\n\n    toolboxIcon.style.display = 'inline-block';\n    return toolboxIcon;\n  }\n\n  /**\n   * Create the DOM for all subcategories.\n   * @param {!Array<!IToolboxItem>} subcategories The subcategories.\n   * @return {!HTMLDivElement} The div holding all the subcategories.\n   * @protected\n   */\n  createSubCategoriesDom_(subcategories) {\n    const contentsContainer =\n        /** @type {!HTMLDivElement} */ (document.createElement('div'));\n    dom.addClass(contentsContainer, this.cssConfig_['contents']);\n\n    for (let i = 0; i < subcategories.length; i++) {\n      const newCategory = subcategories[i];\n      newCategory.init();\n      const newCategoryDiv = newCategory.getDiv();\n      contentsContainer.appendChild(newCategoryDiv);\n      if (newCategory.getClickTarget) {\n        newCategory.getClickTarget().setAttribute('id', newCategory.getId());\n      }\n    }\n    return contentsContainer;\n  }\n\n  /**\n   * Opens or closes the current category.\n   * @param {boolean} isExpanded True to expand the category, false to close.\n   * @public\n   */\n  setExpanded(isExpanded) {\n    if (this.expanded_ === isExpanded) {\n      return;\n    }\n    this.expanded_ = isExpanded;\n    if (isExpanded) {\n      this.subcategoriesDiv_.style.display = 'block';\n      this.openIcon_(this.iconDom_);\n    } else {\n      this.subcategoriesDiv_.style.display = 'none';\n      this.closeIcon_(this.iconDom_);\n    }\n    aria.setState(\n        /** @type {!HTMLDivElement} */ (this.htmlDiv_), aria.State.EXPANDED,\n        isExpanded);\n\n    this.parentToolbox_.handleToolboxItemResize();\n  }\n\n  /**\n   * @override\n   */\n  setVisible_(isVisible) {\n    this.htmlDiv_.style.display = isVisible ? 'block' : 'none';\n    const childToolboxItems = this.getChildToolboxItems();\n    for (let i = 0; i < childToolboxItems.length; i++) {\n      const child = childToolboxItems[i];\n      child.setVisible_(isVisible);\n    }\n    this.isHidden_ = !isVisible;\n\n    if (this.parentToolbox_.getSelectedItem() === this) {\n      this.parentToolbox_.clearSelection();\n    }\n  }\n\n  /**\n   * Whether the category is expanded to show its child subcategories.\n   * @return {boolean} True if the toolbox item shows its children, false if it\n   *     is collapsed.\n   * @public\n   */\n  isExpanded() {\n    return this.expanded_;\n  }\n\n  /**\n   * @override\n   */\n  isCollapsible() {\n    return true;\n  }\n\n  /**\n   * @override\n   */\n  onClick(_e) {\n    this.toggleExpanded();\n  }\n\n  /**\n   * Toggles whether or not the category is expanded.\n   * @public\n   */\n  toggleExpanded() {\n    this.setExpanded(!this.expanded_);\n  }\n\n  /**\n   * @override\n   */\n  getDiv() {\n    return this.htmlDiv_;\n  }\n\n  /**\n   * Gets any children toolbox items. (ex. Gets the subcategories)\n   * @return {!Array<!IToolboxItem>} The child toolbox items.\n   */\n  getChildToolboxItems() {\n    return this.toolboxItems_;\n  }\n}\n\n/**\n * All the CSS class names that are used to create a collapsible\n * category. This is all the properties from the regular category plus contents.\n * @typedef {{\n *            container:?string,\n *            row:?string,\n *            rowcontentcontainer:?string,\n *            icon:?string,\n *            label:?string,\n *            selected:?string,\n *            openicon:?string,\n *            closedicon:?string,\n *            contents:?string\n *          }}\n */\nCollapsibleToolboxCategory.CssConfig;\n\n/**\n * Name used for registering a collapsible toolbox category.\n * @type {string}\n * @override\n */\nCollapsibleToolboxCategory.registrationName = 'collapsibleCategory';\n\n\nregistry.register(\n    registry.Type.TOOLBOX_ITEM, CollapsibleToolboxCategory.registrationName,\n    CollapsibleToolboxCategory);\n\nexports.CollapsibleToolboxCategory = CollapsibleToolboxCategory;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/toolbox/collapsible_category.js?")},
"./core/toolbox/separator.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/css.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/utils/object.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/toolbox/toolbox_item.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A separator used for separating toolbox categories.\n */\n\n\n/**\n * A separator used for separating toolbox categories.\n * @class\n */\ngoog.module('Blockly.ToolboxSeparator');\n\nconst Css = goog.require('Blockly.Css');\nconst dom = goog.require('Blockly.utils.dom');\nconst object = goog.require('Blockly.utils.object');\nconst registry = goog.require('Blockly.registry');\n/* eslint-disable-next-line no-unused-vars */\nconst toolbox = goog.requireType('Blockly.utils.toolbox');\n/* eslint-disable-next-line no-unused-vars */\nconst {IToolbox} = goog.requireType('Blockly.IToolbox');\nconst {ToolboxItem} = goog.require('Blockly.ToolboxItem');\n\n\n/**\n * Class for a toolbox separator. This is the thin visual line that appears on\n * the toolbox. This item is not interactable.\n * @extends {ToolboxItem}\n * @alias Blockly.ToolboxSeparator\n */\nclass ToolboxSeparator extends ToolboxItem {\n  /**\n   * @param {!toolbox.SeparatorInfo} separatorDef The information\n   *     needed to create a separator.\n   * @param {!IToolbox} toolbox The parent toolbox for the separator.\n   */\n  constructor(separatorDef, toolbox) {\n    super(separatorDef, toolbox);\n    /**\n     * All the CSS class names that are used to create a separator.\n     * @type {!ToolboxSeparator.CssConfig}\n     * @protected\n     */\n    this.cssConfig_ = {'container': 'blocklyTreeSeparator'};\n\n    /**\n     * @type {?HTMLDivElement}\n     * @private\n     */\n    this.htmlDiv_ = null;\n\n    const cssConfig = separatorDef['cssconfig'] || separatorDef['cssConfig'];\n    object.mixin(this.cssConfig_, cssConfig);\n  }\n\n  /**\n   * @override\n   */\n  init() {\n    this.createDom_();\n  }\n\n  /**\n   * Creates the DOM for a separator.\n   * @return {!HTMLDivElement} The parent element for the separator.\n   * @protected\n   */\n  createDom_() {\n    const container =\n        /** @type {!HTMLDivElement} */ (document.createElement('div'));\n    dom.addClass(container, this.cssConfig_['container']);\n    this.htmlDiv_ = container;\n    return container;\n  }\n\n  /**\n   * @override\n   */\n  getDiv() {\n    return /** @type {!HTMLDivElement} */ (this.htmlDiv_);\n  }\n\n  /**\n   * @override\n   */\n  dispose() {\n    dom.removeNode(/** @type {!HTMLDivElement} */ (this.htmlDiv_));\n  }\n}\n\n/**\n * All the CSS class names that are used to create a separator.\n * @typedef {{\n *            container:(string|undefined)\n *          }}\n */\nToolboxSeparator.CssConfig;\n\n/**\n * Name used for registering a toolbox separator.\n * @type {string}\n */\nToolboxSeparator.registrationName = 'sep';\n\n/**\n * CSS for Toolbox.  See css.js for use.\n */\nCss.register(`\n.blocklyTreeSeparator {\n  border-bottom: solid #e5e5e5 1px;\n  height: 0;\n  margin: 5px 0;\n}\n\n.blocklyToolboxDiv[layout=\"h\"] .blocklyTreeSeparator {\n  border-right: solid #e5e5e5 1px;\n  border-bottom: none;\n  height: auto;\n  margin: 0 5px 0 5px;\n  padding: 5px 0;\n  width: 0;\n}\n`);\n\nregistry.register(\n    registry.Type.TOOLBOX_ITEM, ToolboxSeparator.registrationName,\n    ToolboxSeparator);\n\nexports.ToolboxSeparator = ToolboxSeparator;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/toolbox/separator.js?")},
"./core/toolbox/toolbox.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/css.js\");\n__webpack_require__(\"./core/touch.js\");\n__webpack_require__(\"./core/utils/aria.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/utils/toolbox.js\");\n__webpack_require__(\"./core/block_svg.js\");\n__webpack_require__(\"./core/toolbox/collapsible_category.js\");\n__webpack_require__(\"./core/component_manager.js\");\n__webpack_require__(\"./core/delete_area.js\");\n__webpack_require__(\"./core/interfaces/i_autohideable.js\");\n__webpack_require__(\"./core/interfaces/i_keyboard_accessible.js\");\n__webpack_require__(\"./core/interfaces/i_styleable.js\");\n__webpack_require__(\"./core/interfaces/i_toolbox.js\");\n__webpack_require__(\"./core/utils/keycodes.js\");\n__webpack_require__(\"./core/options.js\");\n__webpack_require__(\"./core/utils/rect.js\");\n__webpack_require__(\"./core/events/events_toolbox_item_select.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Toolbox from whence to create blocks.\n */\n\n\n/**\n * Toolbox from whence to create blocks.\n * @class\n */\ngoog.module('Blockly.Toolbox');\n\nconst Css = goog.require('Blockly.Css');\nconst Touch = goog.require('Blockly.Touch');\nconst aria = goog.require('Blockly.utils.aria');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst common = goog.require('Blockly.common');\nconst dom = goog.require('Blockly.utils.dom');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst toolbox = goog.require('Blockly.utils.toolbox');\nconst {BlockSvg} = goog.require('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlocklyOptions} = goog.requireType('Blockly.BlocklyOptions');\nconst {CollapsibleToolboxCategory} = goog.require('Blockly.CollapsibleToolboxCategory');\nconst {ComponentManager} = goog.require('Blockly.ComponentManager');\nconst {DeleteArea} = goog.require('Blockly.DeleteArea');\n/* eslint-disable-next-line no-unused-vars */\nconst {IAutoHideable} = goog.require('Blockly.IAutoHideable');\n/* eslint-disable-next-line no-unused-vars */\nconst {ICollapsibleToolboxItem} = goog.requireType('Blockly.ICollapsibleToolboxItem');\n/* eslint-disable-next-line no-unused-vars */\nconst {IDraggable} = goog.requireType('Blockly.IDraggable');\n/* eslint-disable-next-line no-unused-vars */\nconst {IFlyout} = goog.requireType('Blockly.IFlyout');\n/* eslint-disable-next-line no-unused-vars */\nconst {IKeyboardAccessible} = goog.require('Blockly.IKeyboardAccessible');\n/* eslint-disable-next-line no-unused-vars */\nconst {ISelectableToolboxItem} = goog.requireType('Blockly.ISelectableToolboxItem');\n/* eslint-disable-next-line no-unused-vars */\nconst {IStyleable} = goog.require('Blockly.IStyleable');\n/* eslint-disable-next-line no-unused-vars */\nconst {IToolboxItem} = goog.requireType('Blockly.IToolboxItem');\n/* eslint-disable-next-line no-unused-vars */\nconst {IToolbox} = goog.require('Blockly.IToolbox');\nconst {KeyCodes} = goog.require('Blockly.utils.KeyCodes');\nconst {Options} = goog.require('Blockly.Options');\nconst {Rect} = goog.require('Blockly.utils.Rect');\n/* eslint-disable-next-line no-unused-vars */\nconst {ShortcutRegistry} = goog.requireType('Blockly.ShortcutRegistry');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.ToolboxItemSelect');\n\n\n/**\n * Class for a Toolbox.\n * Creates the toolbox's DOM.\n * @implements {IAutoHideable}\n * @implements {IKeyboardAccessible}\n * @implements {IStyleable}\n * @implements {IToolbox}\n * @extends {DeleteArea}\n * @alias Blockly.Toolbox\n */\nclass Toolbox extends DeleteArea {\n  /**\n   * @param {!WorkspaceSvg} workspace The workspace in which to create new\n   *     blocks.\n   */\n  constructor(workspace) {\n    super();\n\n    /**\n     * The workspace this toolbox is on.\n     * @type {!WorkspaceSvg}\n     * @protected\n     */\n    this.workspace_ = workspace;\n\n    /**\n     * The unique id for this component that is used to register with the\n     * ComponentManager.\n     * @type {string}\n     */\n    this.id = 'toolbox';\n\n    /**\n     * The JSON describing the contents of this toolbox.\n     * @type {!toolbox.ToolboxInfo}\n     * @protected\n     */\n    this.toolboxDef_ = workspace.options.languageTree || {'contents': []};\n\n    /**\n     * Whether the toolbox should be laid out horizontally.\n     * @type {boolean}\n     * @private\n     */\n    this.horizontalLayout_ = workspace.options.horizontalLayout;\n\n    /**\n     * The html container for the toolbox.\n     * @type {?HTMLDivElement}\n     */\n    this.HtmlDiv = null;\n\n    /**\n     * The html container for the contents of a toolbox.\n     * @type {?HTMLDivElement}\n     * @protected\n     */\n    this.contentsDiv_ = null;\n\n    /**\n     * Whether the Toolbox is visible.\n     * @type {boolean}\n     * @protected\n     */\n    this.isVisible_ = false;\n\n    /**\n     * The list of items in the toolbox.\n     * @type {!Array<!IToolboxItem>}\n     * @protected\n     */\n    this.contents_ = [];\n\n    /**\n     * The width of the toolbox.\n     * @type {number}\n     * @protected\n     */\n    this.width_ = 0;\n\n    /**\n     * The height of the toolbox.\n     * @type {number}\n     * @protected\n     */\n    this.height_ = 0;\n\n    /**\n     * Is RTL vs LTR.\n     * @type {boolean}\n     */\n    this.RTL = workspace.options.RTL;\n\n    /**\n     * The flyout for the toolbox.\n     * @type {?IFlyout}\n     * @private\n     */\n    this.flyout_ = null;\n\n    /**\n     * A map from toolbox item IDs to toolbox items.\n     * @type {!Object<string, !IToolboxItem>}\n     * @protected\n     */\n    this.contentMap_ = Object.create(null);\n\n    /**\n     * Position of the toolbox and flyout relative to the workspace.\n     * @type {!toolbox.Position}\n     */\n    this.toolboxPosition = workspace.options.toolboxPosition;\n\n    /**\n     * The currently selected item.\n     * @type {?ISelectableToolboxItem}\n     * @protected\n     */\n    this.selectedItem_ = null;\n\n    /**\n     * The previously selected item.\n     * @type {?ISelectableToolboxItem}\n     * @protected\n     */\n    this.previouslySelectedItem_ = null;\n\n    /**\n     * Array holding info needed to unbind event handlers.\n     * Used for disposing.\n     * Ex: [[node, name, func], [node, name, func]].\n     * @type {!Array<!browserEvents.Data>}\n     * @protected\n     */\n    this.boundEvents_ = [];\n  }\n\n  /**\n   * Handles the given keyboard shortcut.\n   * @param {!ShortcutRegistry.KeyboardShortcut} _shortcut The shortcut to be\n   *     handled.\n   * @return {boolean} True if the shortcut has been handled, false otherwise.\n   * @public\n   */\n  onShortcut(_shortcut) {\n    return false;\n  }\n\n  /**\n   * Initializes the toolbox\n   * @public\n   */\n  init() {\n    const workspace = this.workspace_;\n    const svg = workspace.getParentSvg();\n\n    this.flyout_ = this.createFlyout_();\n\n    this.HtmlDiv = this.createDom_(this.workspace_);\n    dom.insertAfter(this.flyout_.createDom('svg'), svg);\n    this.setVisible(true);\n    this.flyout_.init(workspace);\n\n    this.render(this.toolboxDef_);\n    const themeManager = workspace.getThemeManager();\n    themeManager.subscribe(\n        this.HtmlDiv, 'toolboxBackgroundColour', 'background-color');\n    themeManager.subscribe(this.HtmlDiv, 'toolboxForegroundColour', 'color');\n    this.workspace_.getComponentManager().addComponent({\n      component: this,\n      weight: 1,\n      capabilities: [\n        ComponentManager.Capability.AUTOHIDEABLE,\n        ComponentManager.Capability.DELETE_AREA,\n        ComponentManager.Capability.DRAG_TARGET,\n      ],\n    });\n  }\n\n  /**\n   * Creates the DOM for the toolbox.\n   * @param {!WorkspaceSvg} workspace The workspace this toolbox is on.\n   * @return {!HTMLDivElement} The HTML container for the toolbox.\n   * @protected\n   */\n  createDom_(workspace) {\n    const svg = workspace.getParentSvg();\n\n    const container = this.createContainer_();\n\n    this.contentsDiv_ = this.createContentsContainer_();\n    this.contentsDiv_.tabIndex = 0;\n    aria.setRole(this.contentsDiv_, aria.Role.TREE);\n    container.appendChild(this.contentsDiv_);\n\n    svg.parentNode.insertBefore(container, svg);\n\n    this.attachEvents_(container, this.contentsDiv_);\n    return container;\n  }\n\n  /**\n   * Creates the container div for the toolbox.\n   * @return {!HTMLDivElement} The HTML container for the toolbox.\n   * @protected\n   */\n  createContainer_() {\n    const toolboxContainer =\n        /** @type {!HTMLDivElement} */ (document.createElement('div'));\n    toolboxContainer.setAttribute('layout', this.isHorizontal() ? 'h' : 'v');\n    dom.addClass(toolboxContainer, 'blocklyToolboxDiv');\n    dom.addClass(toolboxContainer, 'blocklyNonSelectable');\n    toolboxContainer.setAttribute('dir', this.RTL ? 'RTL' : 'LTR');\n    return toolboxContainer;\n  }\n\n  /**\n   * Creates the container for all the contents in the toolbox.\n   * @return {!HTMLDivElement} The HTML container for the toolbox contents.\n   * @protected\n   */\n  createContentsContainer_() {\n    const contentsContainer =\n        /** @type {!HTMLDivElement} */ (document.createElement('div'));\n    dom.addClass(contentsContainer, 'blocklyToolboxContents');\n    if (this.isHorizontal()) {\n      contentsContainer.style.flexDirection = 'row';\n    }\n    return contentsContainer;\n  }\n\n  /**\n   * Adds event listeners to the toolbox container div.\n   * @param {!HTMLDivElement} container The HTML container for the toolbox.\n   * @param {!HTMLDivElement} contentsContainer The HTML container for the\n   *     contents of the toolbox.\n   * @protected\n   */\n  attachEvents_(container, contentsContainer) {\n    // Clicking on toolbox closes popups.\n    const clickEvent = browserEvents.conditionalBind(\n        container, 'click', this, this.onClick_,\n        /* opt_noCaptureIdentifier */ false,\n        /* opt_noPreventDefault */ true);\n    this.boundEvents_.push(clickEvent);\n\n    const keyDownEvent = browserEvents.conditionalBind(\n        contentsContainer, 'keydown', this, this.onKeyDown_,\n        /* opt_noCaptureIdentifier */ false,\n        /* opt_noPreventDefault */ true);\n    this.boundEvents_.push(keyDownEvent);\n  }\n\n  /**\n   * Handles on click events for when the toolbox or toolbox items are clicked.\n   * @param {!Event} e Click event to handle.\n   * @protected\n   */\n  onClick_(e) {\n    if (browserEvents.isRightButton(e) || e.target === this.HtmlDiv) {\n      // Close flyout.\n      /** @type {!WorkspaceSvg} */ (common.getMainWorkspace()).hideChaff(false);\n    } else {\n      const targetElement = e.target;\n      const itemId = targetElement.getAttribute('id');\n      if (itemId) {\n        const item = this.getToolboxItemById(itemId);\n        if (item.isSelectable()) {\n          this.setSelectedItem(item);\n          item.onClick(e);\n        }\n      }\n      // Just close popups.\n      /** @type {!WorkspaceSvg} */ (common.getMainWorkspace()).hideChaff(true);\n    }\n    Touch.clearTouchIdentifier();  // Don't block future drags.\n  }\n\n  /**\n   * Handles key down events for the toolbox.\n   * @param {!KeyboardEvent} e The key down event.\n   * @protected\n   */\n  onKeyDown_(e) {\n    let handled = false;\n    switch (e.keyCode) {\n      case KeyCodes.DOWN:\n        handled = this.selectNext_();\n        break;\n      case KeyCodes.UP:\n        handled = this.selectPrevious_();\n        break;\n      case KeyCodes.LEFT:\n        handled = this.selectParent_();\n        break;\n      case KeyCodes.RIGHT:\n        handled = this.selectChild_();\n        break;\n      case KeyCodes.ENTER:\n      case KeyCodes.SPACE:\n        if (this.selectedItem_ && this.selectedItem_.isCollapsible()) {\n          const collapsibleItem =\n              /** @type {!ICollapsibleToolboxItem} */ (this.selectedItem_);\n          collapsibleItem.toggleExpanded();\n          handled = true;\n        }\n        break;\n      default:\n        handled = false;\n        break;\n    }\n    if (!handled && this.selectedItem_ && this.selectedItem_.onKeyDown) {\n      handled = this.selectedItem_.onKeyDown(e);\n    }\n\n    if (handled) {\n      e.preventDefault();\n    }\n  }\n\n  /**\n   * Creates the flyout based on the toolbox layout.\n   * @return {!IFlyout} The flyout for the toolbox.\n   * @throws {Error} If missing a require for `Blockly.HorizontalFlyout`,\n   *     `Blockly.VerticalFlyout`, and no flyout plugin is specified.\n   * @protected\n   */\n  createFlyout_() {\n    const workspace = this.workspace_;\n    // TODO (#4247): Look into adding a makeFlyout method to Blockly Options.\n    const workspaceOptions = new Options(\n        /** @type {!BlocklyOptions} */\n        ({\n          'parentWorkspace': workspace,\n          'rtl': workspace.RTL,\n          'oneBasedIndex': workspace.options.oneBasedIndex,\n          'horizontalLayout': workspace.horizontalLayout,\n          'renderer': workspace.options.renderer,\n          'rendererOverrides': workspace.options.rendererOverrides,\n          'move': {\n            'scrollbars': true,\n          },\n        }));\n    // Options takes in either 'end' or 'start'. This has already been parsed to\n    // be either 0 or 1, so set it after.\n    workspaceOptions.toolboxPosition = workspace.options.toolboxPosition;\n    let FlyoutClass = null;\n    if (workspace.horizontalLayout) {\n      FlyoutClass = registry.getClassFromOptions(\n          registry.Type.FLYOUTS_HORIZONTAL_TOOLBOX, workspace.options, true);\n    } else {\n      FlyoutClass = registry.getClassFromOptions(\n          registry.Type.FLYOUTS_VERTICAL_TOOLBOX, workspace.options, true);\n    }\n    return new FlyoutClass(workspaceOptions);\n  }\n\n  /**\n   * Fills the toolbox with new toolbox items and removes any old contents.\n   * @param {!toolbox.ToolboxInfo} toolboxDef Object holding information\n   *     for creating a toolbox.\n   * @package\n   */\n  render(toolboxDef) {\n    this.toolboxDef_ = toolboxDef;\n    for (let i = 0; i < this.contents_.length; i++) {\n      const toolboxItem = this.contents_[i];\n      if (toolboxItem) {\n        toolboxItem.dispose();\n      }\n    }\n    this.contents_ = [];\n    this.contentMap_ = Object.create(null);\n    this.renderContents_(toolboxDef['contents']);\n    this.position();\n    this.handleToolboxItemResize();\n  }\n\n  /**\n   * Adds all the toolbox items to the toolbox.\n   * @param {!Array<!toolbox.ToolboxItemInfo>} toolboxDef Array\n   *     holding objects containing information on the contents of the toolbox.\n   * @protected\n   */\n  renderContents_(toolboxDef) {\n    // This is for performance reasons. By using document fragment we only have\n    // to add to the DOM once.\n    const fragment = document.createDocumentFragment();\n    for (let i = 0; i < toolboxDef.length; i++) {\n      const toolboxItemDef = toolboxDef[i];\n      this.createToolboxItem_(toolboxItemDef, fragment);\n    }\n    this.contentsDiv_.appendChild(fragment);\n  }\n\n  /**\n   * Creates and renders the toolbox item.\n   * @param {!toolbox.ToolboxItemInfo} toolboxItemDef Any information\n   *    that can be used to create an item in the toolbox.\n   * @param {!DocumentFragment} fragment The document fragment to add the child\n   *     toolbox elements to.\n   * @private\n   */\n  createToolboxItem_(toolboxItemDef, fragment) {\n    let registryName = toolboxItemDef['kind'];\n\n    // Categories that are collapsible are created using a class registered\n    // under a different name.\n    if (registryName.toUpperCase() === 'CATEGORY' &&\n        toolbox.isCategoryCollapsible(\n            /** @type {!toolbox.CategoryInfo} */ (toolboxItemDef))) {\n      registryName = CollapsibleToolboxCategory.registrationName;\n    }\n\n    const ToolboxItemClass = registry.getClass(\n        registry.Type.TOOLBOX_ITEM, registryName.toLowerCase());\n    if (ToolboxItemClass) {\n      const toolboxItem = new ToolboxItemClass(toolboxItemDef, this);\n      toolboxItem.init();\n      this.addToolboxItem_(toolboxItem);\n      const toolboxItemDom = toolboxItem.getDiv();\n      if (toolboxItemDom) {\n        fragment.appendChild(toolboxItemDom);\n      }\n      // Adds the ID to the HTML element that can receive a click.\n      // This is used in onClick_ to find the toolboxItem that was clicked.\n      if (toolboxItem.getClickTarget()) {\n        toolboxItem.getClickTarget().setAttribute('id', toolboxItem.getId());\n      }\n    }\n  }\n\n  /**\n   * Adds an item to the toolbox.\n   * @param {!IToolboxItem} toolboxItem The item in the toolbox.\n   * @protected\n   */\n  addToolboxItem_(toolboxItem) {\n    this.contents_.push(toolboxItem);\n    this.contentMap_[toolboxItem.getId()] = toolboxItem;\n    if (toolboxItem.isCollapsible()) {\n      const collapsibleItem = /** @type {ICollapsibleToolboxItem} */\n          (toolboxItem);\n      const childToolboxItems = collapsibleItem.getChildToolboxItems();\n      for (let i = 0; i < childToolboxItems.length; i++) {\n        const child = childToolboxItems[i];\n        this.addToolboxItem_(child);\n      }\n    }\n  }\n\n  /**\n   * Gets the items in the toolbox.\n   * @return {!Array<!IToolboxItem>} The list of items in the toolbox.\n   * @public\n   */\n  getToolboxItems() {\n    return this.contents_;\n  }\n\n  /**\n   * Adds a style on the toolbox. Usually used to change the cursor.\n   * @param {string} style The name of the class to add.\n   * @package\n   */\n  addStyle(style) {\n    dom.addClass(/** @type {!Element} */ (this.HtmlDiv), style);\n  }\n\n  /**\n   * Removes a style from the toolbox. Usually used to change the cursor.\n   * @param {string} style The name of the class to remove.\n   * @package\n   */\n  removeStyle(style) {\n    dom.removeClass(/** @type {!Element} */ (this.HtmlDiv), style);\n  }\n\n  /**\n   * Returns the bounding rectangle of the drag target area in pixel units\n   * relative to viewport.\n   * @return {?Rect} The component's bounding box. Null if drag\n   *   target area should be ignored.\n   */\n  getClientRect() {\n    if (!this.HtmlDiv || !this.isVisible_) {\n      return null;\n    }\n\n    // BIG_NUM is offscreen padding so that blocks dragged beyond the toolbox\n    // area are still deleted.  Must be smaller than Infinity, but larger than\n    // the largest screen size.\n    const BIG_NUM = 10000000;\n    const toolboxRect = this.HtmlDiv.getBoundingClientRect();\n\n    const top = toolboxRect.top;\n    const bottom = top + toolboxRect.height;\n    const left = toolboxRect.left;\n    const right = left + toolboxRect.width;\n\n    // Assumes that the toolbox is on the SVG edge.  If this changes\n    // (e.g. toolboxes in mutators) then this code will need to be more complex.\n    if (this.toolboxPosition === toolbox.Position.TOP) {\n      return new Rect(-BIG_NUM, bottom, -BIG_NUM, BIG_NUM);\n    } else if (this.toolboxPosition === toolbox.Position.BOTTOM) {\n      return new Rect(top, BIG_NUM, -BIG_NUM, BIG_NUM);\n    } else if (this.toolboxPosition === toolbox.Position.LEFT) {\n      return new Rect(-BIG_NUM, BIG_NUM, -BIG_NUM, right);\n    } else {  // Right\n      return new Rect(-BIG_NUM, BIG_NUM, left, BIG_NUM);\n    }\n  }\n\n  /**\n   * Returns whether the provided block or bubble would be deleted if dropped on\n   * this area.\n   * This method should check if the element is deletable and is always called\n   * before onDragEnter/onDragOver/onDragExit.\n   * @param {!IDraggable} element The block or bubble currently being\n   *   dragged.\n   * @param {boolean} _couldConnect Whether the element could could connect to\n   *     another.\n   * @return {boolean} Whether the element provided would be deleted if dropped\n   *     on this area.\n   * @override\n   */\n  wouldDelete(element, _couldConnect) {\n    if (element instanceof BlockSvg) {\n      const block = /** @type {BlockSvg} */ (element);\n      // Prefer dragging to the toolbox over connecting to other blocks.\n      this.updateWouldDelete_(!block.getParent() && block.isDeletable());\n    } else {\n      this.updateWouldDelete_(element.isDeletable());\n    }\n    return this.wouldDelete_;\n  }\n\n  /**\n   * Handles when a cursor with a block or bubble enters this drag target.\n   * @param {!IDraggable} _dragElement The block or bubble currently being\n   *   dragged.\n   * @override\n   */\n  onDragEnter(_dragElement) {\n    this.updateCursorDeleteStyle_(true);\n  }\n\n  /**\n   * Handles when a cursor with a block or bubble exits this drag target.\n   * @param {!IDraggable} _dragElement The block or bubble currently being\n   *   dragged.\n   * @override\n   */\n  onDragExit(_dragElement) {\n    this.updateCursorDeleteStyle_(false);\n  }\n\n  /**\n   * Handles when a block or bubble is dropped on this component.\n   * Should not handle delete here.\n   * @param {!IDraggable} _dragElement The block or bubble currently being\n   *   dragged.\n   * @override\n   */\n  onDrop(_dragElement) {\n    this.updateCursorDeleteStyle_(false);\n  }\n\n  /**\n   * Updates the internal wouldDelete_ state.\n   * @param {boolean} wouldDelete The new value for the wouldDelete state.\n   * @protected\n   * @override\n   */\n  updateWouldDelete_(wouldDelete) {\n    if (wouldDelete === this.wouldDelete_) {\n      return;\n    }\n    // This logic handles updating the deleteStyle properly if the delete state\n    // changes while the block is over the Toolbox. This could happen if the\n    // implementation of wouldDeleteBlock depends on the couldConnect parameter\n    // or if the isDeletable property of the block currently being dragged\n    // changes during the drag.\n    this.updateCursorDeleteStyle_(false);\n    this.wouldDelete_ = wouldDelete;\n    this.updateCursorDeleteStyle_(true);\n  }\n\n  /**\n   * Adds or removes the CSS style of the cursor over the toolbox based whether\n   * the block or bubble over it is expected to be deleted if dropped (using the\n   * internal this.wouldDelete_ property).\n   * @param {boolean} addStyle Whether the style should be added or removed.\n   * @protected\n   */\n  updateCursorDeleteStyle_(addStyle) {\n    const style =\n        this.wouldDelete_ ? 'blocklyToolboxDelete' : 'blocklyToolboxGrab';\n    if (addStyle) {\n      this.addStyle(style);\n    } else {\n      this.removeStyle(style);\n    }\n  }\n\n  /**\n   * Gets the toolbox item with the given ID.\n   * @param {string} id The ID of the toolbox item.\n   * @return {?IToolboxItem} The toolbox item with the given ID, or null\n   *     if no item exists.\n   * @public\n   */\n  getToolboxItemById(id) {\n    return this.contentMap_[id] || null;\n  }\n\n  /**\n   * Gets the width of the toolbox.\n   * @return {number} The width of the toolbox.\n   * @public\n   */\n  getWidth() {\n    return this.width_;\n  }\n\n  /**\n   * Gets the height of the toolbox.\n   * @return {number} The width of the toolbox.\n   * @public\n   */\n  getHeight() {\n    return this.height_;\n  }\n\n  /**\n   * Gets the toolbox flyout.\n   * @return {?IFlyout} The toolbox flyout.\n   * @public\n   */\n  getFlyout() {\n    return this.flyout_;\n  }\n\n  /**\n   * Gets the workspace for the toolbox.\n   * @return {!WorkspaceSvg} The parent workspace for the toolbox.\n   * @public\n   */\n  getWorkspace() {\n    return this.workspace_;\n  }\n\n  /**\n   * Gets the selected item.\n   * @return {?ISelectableToolboxItem} The selected item, or null if no item is\n   *     currently selected.\n   * @public\n   */\n  getSelectedItem() {\n    return this.selectedItem_;\n  }\n\n  /**\n   * Gets the previously selected item.\n   * @return {?ISelectableToolboxItem} The previously selected item, or null if\n   *     no item was previously selected.\n   * @public\n   */\n  getPreviouslySelectedItem() {\n    return this.previouslySelectedItem_;\n  }\n\n  /**\n   * Gets whether or not the toolbox is horizontal.\n   * @return {boolean} True if the toolbox is horizontal, false if the toolbox\n   *     is vertical.\n   * @public\n   */\n  isHorizontal() {\n    return this.horizontalLayout_;\n  }\n\n  /**\n   * Positions the toolbox based on whether it is a horizontal toolbox and\n   * whether the workspace is in rtl.\n   * @public\n   */\n  position() {\n    const workspaceMetrics = this.workspace_.getMetrics();\n    const toolboxDiv = this.HtmlDiv;\n    if (!toolboxDiv) {\n      // Not initialized yet.\n      return;\n    }\n\n    if (this.horizontalLayout_) {\n      toolboxDiv.style.left = '0';\n      toolboxDiv.style.height = 'auto';\n      toolboxDiv.style.width = '100%';\n      this.height_ = toolboxDiv.offsetHeight;\n      this.width_ = workspaceMetrics.viewWidth;\n      if (this.toolboxPosition === toolbox.Position.TOP) {\n        toolboxDiv.style.top = '0';\n      } else {  // Bottom\n        toolboxDiv.style.bottom = '0';\n      }\n    } else {\n      if (this.toolboxPosition === toolbox.Position.RIGHT) {\n        toolboxDiv.style.right = '0';\n      } else {  // Left\n        toolboxDiv.style.left = '0';\n      }\n      toolboxDiv.style.height = '100%';\n      this.width_ = toolboxDiv.offsetWidth;\n      this.height_ = workspaceMetrics.viewHeight;\n    }\n    this.flyout_.position();\n  }\n\n  /**\n   * Handles resizing the toolbox when a toolbox item resizes.\n   * @package\n   */\n  handleToolboxItemResize() {\n    // Reposition the workspace so that (0,0) is in the correct position\n    // relative to the new absolute edge (ie toolbox edge).\n    const workspace = this.workspace_;\n    const rect = this.HtmlDiv.getBoundingClientRect();\n    const newX = this.toolboxPosition === toolbox.Position.LEFT ?\n        workspace.scrollX + rect.width :\n        workspace.scrollX;\n    const newY = this.toolboxPosition === toolbox.Position.TOP ?\n        workspace.scrollY + rect.height :\n        workspace.scrollY;\n    workspace.translate(newX, newY);\n\n    // Even though the div hasn't changed size, the visible workspace\n    // surface of the workspace has, so we may need to reposition everything.\n    common.svgResize(workspace);\n  }\n\n  /**\n   * Unhighlights any previously selected item.\n   * @public\n   */\n  clearSelection() {\n    this.setSelectedItem(null);\n  }\n\n  /**\n   * Updates the category colours and background colour of selected categories.\n   * @package\n   */\n  refreshTheme() {\n    for (let i = 0; i < this.contents_.length; i++) {\n      const child = this.contents_[i];\n      if (child.refreshTheme) {\n        child.refreshTheme();\n      }\n    }\n  }\n\n  /**\n   * Updates the flyout's content without closing it.  Should be used in\n   * response to a change in one of the dynamic categories, such as variables or\n   * procedures.\n   * @public\n   */\n  refreshSelection() {\n    if (this.selectedItem_ && this.selectedItem_.isSelectable() &&\n        this.selectedItem_.getContents().length) {\n      this.flyout_.show(this.selectedItem_.getContents());\n    }\n  }\n\n  /**\n   * Shows or hides the toolbox.\n   * @param {boolean} isVisible True if toolbox should be visible.\n   * @public\n   */\n  setVisible(isVisible) {\n    if (this.isVisible_ === isVisible) {\n      return;\n    }\n\n    this.HtmlDiv.style.display = isVisible ? 'block' : 'none';\n    this.isVisible_ = isVisible;\n    // Invisible toolbox is ignored as drag targets and must have the drag\n    // target updated.\n    this.workspace_.recordDragTargets();\n  }\n\n  /**\n   * Hides the component. Called in WorkspaceSvg.hideChaff.\n   * @param {boolean} onlyClosePopups Whether only popups should be closed.\n   *     Flyouts should not be closed if this is true.\n   */\n  autoHide(onlyClosePopups) {\n    if (!onlyClosePopups && this.flyout_ && this.flyout_.autoClose) {\n      this.clearSelection();\n    }\n  }\n\n  /**\n   * Sets the given item as selected.\n   * No-op if the item is not selectable.\n   * @param {?IToolboxItem} newItem The toolbox item to select.\n   * @public\n   */\n  setSelectedItem(newItem) {\n    const oldItem = this.selectedItem_;\n\n    if ((!newItem && !oldItem) || (newItem && !newItem.isSelectable())) {\n      return;\n    }\n    newItem = /** @type {ISelectableToolboxItem} */ (newItem);\n\n    if (this.shouldDeselectItem_(oldItem, newItem) && oldItem !== null) {\n      this.deselectItem_(oldItem);\n    }\n\n    if (this.shouldSelectItem_(oldItem, newItem) && newItem !== null) {\n      this.selectItem_(oldItem, newItem);\n    }\n\n    this.updateFlyout_(oldItem, newItem);\n    this.fireSelectEvent_(oldItem, newItem);\n  }\n\n  /**\n   * Decides whether the old item should be deselected.\n   * @param {?ISelectableToolboxItem} oldItem The previously selected\n   *     toolbox item.\n   * @param {?ISelectableToolboxItem} newItem The newly selected toolbox\n   *     item.\n   * @return {boolean} True if the old item should be deselected, false\n   *     otherwise.\n   * @protected\n   */\n  shouldDeselectItem_(oldItem, newItem) {\n    // Deselect the old item unless the old item is collapsible and has been\n    // previously clicked on.\n    return oldItem !== null &&\n        (!oldItem.isCollapsible() || oldItem !== newItem);\n  }\n\n  /**\n   * Decides whether the new item should be selected.\n   * @param {?ISelectableToolboxItem} oldItem The previously selected\n   *     toolbox item.\n   * @param {?ISelectableToolboxItem} newItem The newly selected toolbox\n   *     item.\n   * @return {boolean} True if the new item should be selected, false otherwise.\n   * @protected\n   */\n  shouldSelectItem_(oldItem, newItem) {\n    // Select the new item unless the old item equals the new item.\n    return newItem !== null && newItem !== oldItem;\n  }\n\n  /**\n   * Deselects the given item, marks it as unselected, and updates aria state.\n   * @param {!ISelectableToolboxItem} item The previously selected\n   *     toolbox item which should be deselected.\n   * @protected\n   */\n  deselectItem_(item) {\n    this.selectedItem_ = null;\n    this.previouslySelectedItem_ = item;\n    item.setSelected(false);\n    aria.setState(\n        /** @type {!Element} */ (this.contentsDiv_),\n        aria.State.ACTIVEDESCENDANT, '');\n  }\n\n  /**\n   * Selects the given item, marks it selected, and updates aria state.\n   * @param {?ISelectableToolboxItem} oldItem The previously selected\n   *     toolbox item.\n   * @param {!ISelectableToolboxItem} newItem The newly selected toolbox\n   *     item.\n   * @protected\n   */\n  selectItem_(oldItem, newItem) {\n    this.selectedItem_ = newItem;\n    this.previouslySelectedItem_ = oldItem;\n    newItem.setSelected(true);\n    aria.setState(\n        /** @type {!Element} */ (this.contentsDiv_),\n        aria.State.ACTIVEDESCENDANT, newItem.getId());\n  }\n\n  /**\n   * Selects the toolbox item by its position in the list of toolbox items.\n   * @param {number} position The position of the item to select.\n   * @public\n   */\n  selectItemByPosition(position) {\n    if (position > -1 && position < this.contents_.length) {\n      const item = this.contents_[position];\n      if (item.isSelectable()) {\n        this.setSelectedItem(item);\n      }\n    }\n  }\n\n  /**\n   * Decides whether to hide or show the flyout depending on the selected item.\n   * @param {?ISelectableToolboxItem} oldItem The previously selected toolbox\n   *     item.\n   * @param {?ISelectableToolboxItem} newItem The newly selected toolbox item.\n   * @protected\n   */\n  updateFlyout_(oldItem, newItem) {\n    if (!newItem || (oldItem === newItem && !newItem.isCollapsible()) ||\n        !newItem.getContents().length) {\n      this.flyout_.hide();\n    } else {\n      this.flyout_.show(newItem.getContents());\n      this.flyout_.scrollToStart();\n    }\n  }\n\n  /**\n   * Emits an event when a new toolbox item is selected.\n   * @param {?ISelectableToolboxItem} oldItem The previously selected\n   *     toolbox item.\n   * @param {?ISelectableToolboxItem} newItem The newly selected toolbox\n   *     item.\n   * @private\n   */\n  fireSelectEvent_(oldItem, newItem) {\n    const oldElement = oldItem && oldItem.getName();\n    let newElement = newItem && newItem.getName();\n    // In this case the toolbox closes, so the newElement should be null.\n    if (oldItem === newItem) {\n      newElement = null;\n    }\n    const event = new (eventUtils.get(eventUtils.TOOLBOX_ITEM_SELECT))(\n        oldElement, newElement, this.workspace_.id);\n    eventUtils.fire(event);\n  }\n\n  /**\n   * Closes the current item if it is expanded, or selects the parent.\n   * @return {boolean} True if a parent category was selected, false otherwise.\n   * @private\n   */\n  selectParent_() {\n    if (!this.selectedItem_) {\n      return false;\n    }\n\n    if (this.selectedItem_.isCollapsible() && this.selectedItem_.isExpanded()) {\n      const collapsibleItem =\n          /** @type {!ICollapsibleToolboxItem} */ (this.selectedItem_);\n      collapsibleItem.setExpanded(false);\n      return true;\n    } else if (\n        this.selectedItem_.getParent() &&\n        this.selectedItem_.getParent().isSelectable()) {\n      this.setSelectedItem(this.selectedItem_.getParent());\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Selects the first child of the currently selected item, or nothing if the\n   * toolbox item has no children.\n   * @return {boolean} True if a child category was selected, false otherwise.\n   * @private\n   */\n  selectChild_() {\n    if (!this.selectedItem_ || !this.selectedItem_.isCollapsible()) {\n      return false;\n    }\n    const collapsibleItem = /** @type {ICollapsibleToolboxItem} */\n        (this.selectedItem_);\n    if (!collapsibleItem.isExpanded()) {\n      collapsibleItem.setExpanded(true);\n      return true;\n    } else {\n      this.selectNext_();\n      return true;\n    }\n  }\n\n  /**\n   * Selects the next visible toolbox item.\n   * @return {boolean} True if a next category was selected, false otherwise.\n   * @private\n   */\n  selectNext_() {\n    if (!this.selectedItem_) {\n      return false;\n    }\n\n    let nextItemIdx = this.contents_.indexOf(this.selectedItem_) + 1;\n    if (nextItemIdx > -1 && nextItemIdx < this.contents_.length) {\n      let nextItem = this.contents_[nextItemIdx];\n      while (nextItem && !nextItem.isSelectable()) {\n        nextItem = this.contents_[++nextItemIdx];\n      }\n      if (nextItem && nextItem.isSelectable()) {\n        this.setSelectedItem(nextItem);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Selects the previous visible toolbox item.\n   * @return {boolean} True if a previous category was selected, false\n   *     otherwise.\n   * @private\n   */\n  selectPrevious_() {\n    if (!this.selectedItem_) {\n      return false;\n    }\n\n    let prevItemIdx = this.contents_.indexOf(this.selectedItem_) - 1;\n    if (prevItemIdx > -1 && prevItemIdx < this.contents_.length) {\n      let prevItem = this.contents_[prevItemIdx];\n      while (prevItem && !prevItem.isSelectable()) {\n        prevItem = this.contents_[--prevItemIdx];\n      }\n      if (prevItem && prevItem.isSelectable()) {\n        this.setSelectedItem(prevItem);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Disposes of this toolbox.\n   * @public\n   */\n  dispose() {\n    this.workspace_.getComponentManager().removeComponent('toolbox');\n    this.flyout_.dispose();\n    for (let i = 0; i < this.contents_.length; i++) {\n      const toolboxItem = this.contents_[i];\n      toolboxItem.dispose();\n    }\n\n    for (let j = 0; j < this.boundEvents_.length; j++) {\n      browserEvents.unbind(this.boundEvents_[j]);\n    }\n    this.boundEvents_ = [];\n    this.contents_ = [];\n\n    this.workspace_.getThemeManager().unsubscribe(this.HtmlDiv);\n    dom.removeNode(this.HtmlDiv);\n  }\n}\n\n/**\n * CSS for Toolbox.  See css.js for use.\n */\nCss.register(`\n.blocklyToolboxDelete {\n  cursor: url(\"<<<PATH>>>/handdelete.cur\"), auto;\n}\n\n.blocklyToolboxGrab {\n  cursor: url(\"<<<PATH>>>/handclosed.cur\"), auto;\n  cursor: grabbing;\n  cursor: -webkit-grabbing;\n}\n\n/* Category tree in Toolbox. */\n.blocklyToolboxDiv {\n  background-color: #ddd;\n  overflow-x: visible;\n  overflow-y: auto;\n  padding: 4px 0 4px 0;\n  position: absolute;\n  z-index: 70;  /* so blocks go under toolbox when dragging */\n  -webkit-tap-highlight-color: transparent;  /* issue #1345 */\n}\n\n.blocklyToolboxContents {\n  display: flex;\n  flex-wrap: wrap;\n  flex-direction: column;\n}\n\n.blocklyToolboxContents:focus {\n  outline: none;\n}\n`);\n\nregistry.register(registry.Type.TOOLBOX, registry.DEFAULT, Toolbox);\n\nexports.Toolbox = Toolbox;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/toolbox/toolbox.js?")},
"./core/toolbox/toolbox_item.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/idgenerator.js\");\n__webpack_require__(\"./core/interfaces/i_toolbox_item.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview An item in the toolbox.\n */\n\n\n/**\n * An item in the toolbox.\n * @class\n */\ngoog.module('Blockly.ToolboxItem');\n\nconst idGenerator = goog.require('Blockly.utils.idGenerator');\n/* eslint-disable-next-line no-unused-vars */\nconst toolbox = goog.requireType('Blockly.utils.toolbox');\n/* eslint-disable-next-line no-unused-vars */\nconst {ICollapsibleToolboxItem} = goog.requireType('Blockly.ICollapsibleToolboxItem');\n/* eslint-disable-next-line no-unused-vars */\nconst {IToolboxItem} = goog.require('Blockly.IToolboxItem');\n/* eslint-disable-next-line no-unused-vars */\nconst {IToolbox} = goog.requireType('Blockly.IToolbox');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * Class for an item in the toolbox.\n * @implements {IToolboxItem}\n * @alias Blockly.ToolboxItem\n */\nclass ToolboxItem {\n  /**\n   * @param {!toolbox.ToolboxItemInfo} toolboxItemDef The JSON defining\n   *     the toolbox item.\n   * @param {!IToolbox} toolbox The toolbox that holds the toolbox item.\n   * @param {ICollapsibleToolboxItem=} opt_parent The parent toolbox item\n   *     or null if the category does not have a parent.\n   */\n  constructor(toolboxItemDef, toolbox, opt_parent) {\n    /**\n     * The id for the category.\n     * @type {string}\n     * @protected\n     */\n    this.id_ = toolboxItemDef['toolboxitemid'] || idGenerator.getNextUniqueId();\n\n    /**\n     * The parent of the category.\n     * @type {?ICollapsibleToolboxItem}\n     * @protected\n     */\n    this.parent_ = opt_parent || null;\n\n    /**\n     * The level that the category is nested at.\n     * @type {number}\n     * @protected\n     */\n    this.level_ = this.parent_ ? this.parent_.getLevel() + 1 : 0;\n\n    /**\n     * The JSON definition of the toolbox item.\n     * @type {?toolbox.ToolboxItemInfo}\n     * @protected\n     */\n    this.toolboxItemDef_ = toolboxItemDef;\n\n    /**\n     * The toolbox this category belongs to.\n     * @type {!IToolbox}\n     * @protected\n     */\n    this.parentToolbox_ = toolbox;\n\n    /**\n     * The workspace of the parent toolbox.\n     * @type {!WorkspaceSvg}\n     * @protected\n     */\n    this.workspace_ = this.parentToolbox_.getWorkspace();\n  }\n\n  /**\n   * Initializes the toolbox item.\n   * This includes creating the DOM and updating the state of any items based\n   * on the info object.\n   * @public\n   */\n  init() {\n    // No-op by default.\n  }\n\n  /**\n   * Gets the div for the toolbox item.\n   * @return {?Element} The div for the toolbox item.\n   * @public\n   */\n  getDiv() {\n    return null;\n  }\n\n  /**\n   * Gets the HTML element that is clickable.\n   * The parent toolbox element receives clicks. The parent toolbox will add an\n   * ID to this element so it can pass the onClick event to the correct\n   * toolboxItem.\n   * @return {?Element} The HTML element that receives clicks, or null if this\n   *     item should not receive clicks.\n   * @public\n   */\n  getClickTarget() {\n    return null;\n  }\n\n  /**\n   * Gets a unique identifier for this toolbox item.\n   * @return {string} The ID for the toolbox item.\n   * @public\n   */\n  getId() {\n    return this.id_;\n  }\n\n  /**\n   * Gets the parent if the toolbox item is nested.\n   * @return {?IToolboxItem} The parent toolbox item, or null if\n   *     this toolbox item is not nested.\n   * @public\n   */\n  getParent() {\n    return null;\n  }\n\n  /**\n   * Gets the nested level of the category.\n   * @return {number} The nested level of the category.\n   * @package\n   */\n  getLevel() {\n    return this.level_;\n  }\n\n  /**\n   * Whether the toolbox item is selectable.\n   * @return {boolean} True if the toolbox item can be selected.\n   * @public\n   */\n  isSelectable() {\n    return false;\n  }\n\n  /**\n   * Whether the toolbox item is collapsible.\n   * @return {boolean} True if the toolbox item is collapsible.\n   * @public\n   */\n  isCollapsible() {\n    return false;\n  }\n\n  /**\n   * Dispose of this toolbox item. No-op by default.\n   * @public\n   */\n  dispose() {}\n}\n\nexports.ToolboxItem = ToolboxItem;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/toolbox/toolbox_item.js?")},
"./core/tooltip.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/string.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/utils/deprecation.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2011 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\n\n/**\n * Library to create tooltips for Blockly.\n * First, call createDom() after onload.\n * Second, set the 'tooltip' property on any SVG element that needs a tooltip.\n * If the tooltip is a string, or a function that returns a string, that message\n * will be displayed. If the tooltip is an SVG element, then that object's\n * tooltip will be used. Third, call bindMouseEvents(e) passing the SVG element.\n * @namespace Blockly.Tooltip\n */\ngoog.module('Blockly.Tooltip');\n\nconst blocklyString = goog.require('Blockly.utils.string');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst common = goog.require('Blockly.common');\nconst deprecation = goog.require('Blockly.utils.deprecation');\n\n\n/**\n * A type which can define a tooltip.\n * Either a string, an object containing a tooltip property, or a function which\n * returns either a string, or another arbitrarily nested function which\n * eventually unwinds to a string.\n * @typedef {string|{tooltip}|function(): (string|!Function)}\n * @alias Blockly.Tooltip.TipInfo\n */\nlet TipInfo;\nexports.TipInfo = TipInfo;\n\n/**\n * A function that renders custom tooltip UI.\n * 1st parameter: the div element to render content into.\n * 2nd parameter: the element being moused over (i.e., the element for which the\n * tooltip should be shown).\n * @typedef {function(!Element, !Element)}\n * @alias Blockly.Tooltip.CustomTooltip\n */\nlet CustomTooltip;\nexports.CustomTooltip = CustomTooltip;\n\n/**\n * An optional function that renders custom tooltips into the provided DIV. If\n * this is defined, the function will be called instead of rendering the default\n * tooltip UI.\n * @type {!CustomTooltip|undefined}\n */\nlet customTooltip = undefined;\n\n/**\n * Sets a custom function that will be called if present instead of the default\n * tooltip UI.\n * @param {!CustomTooltip} customFn A custom tooltip used to render an alternate\n *     tooltip UI.\n * @alias Blockly.Tooltip.setCustomTooltip\n */\nconst setCustomTooltip = function(customFn) {\n  customTooltip = customFn;\n};\nexports.setCustomTooltip = setCustomTooltip;\n\n/**\n * Gets the custom tooltip function.\n * @returns {!CustomTooltip|undefined} The custom tooltip function, if defined.\n */\nconst getCustomTooltip = function() {\n  return customTooltip;\n};\nexports.getCustomTooltip = getCustomTooltip;\n\n/**\n * Is a tooltip currently showing?\n * @type {boolean}\n */\nlet visible = false;\n\n/**\n * Returns whether or not a tooltip is showing\n * @returns {boolean} True if a tooltip is showing\n * @alias Blockly.Tooltip.isVisible\n */\nconst isVisible = function() {\n  return visible;\n};\nexports.isVisible = isVisible;\n\nObject.defineProperties(exports, {\n  /**\n   * Is a tooltip currently showing?\n   * @name Blockly.Tooltip.visible\n   * @type {boolean}\n   * @deprecated Use Blockly.Tooltip.isVisible() instead.  (September\n   *     2021)\n   * @suppress {checkTypes}\n   */\n  visible: {\n    get: function() {\n      deprecation.warn(\n          'Blockly.Tooltip.visible', 'September 2021', 'September 2022',\n          'Blockly.Tooltip.isVisible()');\n      return isVisible();\n    },\n  },\n});\n\n/**\n * Is someone else blocking the tooltip from being shown?\n * @type {boolean}\n */\nlet blocked = false;\n\n/**\n * Maximum width (in characters) of a tooltip.\n * @alias Blockly.Tooltip.LIMIT\n */\nconst LIMIT = 50;\nexports.LIMIT = LIMIT;\n\n/**\n * PID of suspended thread to clear tooltip on mouse out.\n */\nlet mouseOutPid = 0;\n\n/**\n * PID of suspended thread to show the tooltip.\n */\nlet showPid = 0;\n\n/**\n * Last observed X location of the mouse pointer (freezes when tooltip appears).\n */\nlet lastX = 0;\n\n/**\n * Last observed Y location of the mouse pointer (freezes when tooltip appears).\n */\nlet lastY = 0;\n\n/**\n * Current element being pointed at.\n * @type {Element}\n */\nlet element = null;\n\n/**\n * Once a tooltip has opened for an element, that element is 'poisoned' and\n * cannot respawn a tooltip until the pointer moves over a different element.\n * @type {Element}\n */\nlet poisonedElement = null;\n\n/**\n * Horizontal offset between mouse cursor and tooltip.\n * @alias Blockly.Tooltip.OFFSET_X\n */\nconst OFFSET_X = 0;\nexports.OFFSET_X = OFFSET_X;\n\n/**\n * Vertical offset between mouse cursor and tooltip.\n * @alias Blockly.Tooltip.OFFSET_Y\n */\nconst OFFSET_Y = 10;\nexports.OFFSET_Y = OFFSET_Y;\n\n/**\n * Radius mouse can move before killing tooltip.\n * @alias Blockly.Tooltip.RADIUS_OK\n */\nconst RADIUS_OK = 10;\nexports.RADIUS_OK = RADIUS_OK;\n\n/**\n * Delay before tooltip appears.\n * @alias Blockly.Tooltip.HOVER_MS\n */\nconst HOVER_MS = 750;\nexports.HOVER_MS = HOVER_MS;\n\n/**\n * Horizontal padding between tooltip and screen edge.\n * @alias Blockly.Tooltip.MARGINS\n */\nconst MARGINS = 5;\nexports.MARGINS = MARGINS;\n\n/**\n * The HTML container.  Set once by createDom.\n * @type {?HTMLDivElement}\n */\nlet DIV = null;\n\n/**\n * Returns the HTML tooltip container.\n * @returns {?HTMLDivElement} The HTML tooltip container.\n * @alias Blockly.Tooltip.getDiv\n */\nconst getDiv = function() {\n  return DIV;\n};\nexports.getDiv = getDiv;\n\nObject.defineProperties(exports, {\n  /**\n   * The HTML container.  Set once by createDom.\n   * @name Blockly.Tooltip.DIV\n   * @type {HTMLDivElement}\n   * @deprecated Use Blockly.Tooltip.getDiv() and .setDiv().\n   *     (September 2021)\n   * @suppress {checkTypes}\n   */\n  DIV: {\n    get: function() {\n      deprecation.warn(\n          'Blockly.Tooltip.DIV', 'September 2021', 'September 2022',\n          'Blockly.Tooltip.getDiv()');\n      return getDiv();\n    },\n  },\n});\n\n/**\n * Returns the tooltip text for the given element.\n * @param {?Object} object The object to get the tooltip text of.\n * @return {string} The tooltip text of the element.\n * @alias Blockly.Tooltip.getTooltipOfObject\n */\nconst getTooltipOfObject = function(object) {\n  const obj = getTargetObject(object);\n  if (obj) {\n    let tooltip = obj.tooltip;\n    while (typeof tooltip === 'function') {\n      tooltip = tooltip();\n    }\n    if (typeof tooltip !== 'string') {\n      throw Error('Tooltip function must return a string.');\n    }\n    return tooltip;\n  }\n  return '';\n};\nexports.getTooltipOfObject = getTooltipOfObject;\n\n/**\n * Returns the target object that the given object is targeting for its\n * tooltip. Could be the object itself.\n * @param {?Object} obj The object are trying to find the target tooltip\n *     object of.\n * @return {?{tooltip}} The target tooltip object.\n */\nconst getTargetObject = function(obj) {\n  while (obj && obj.tooltip) {\n    if ((typeof obj.tooltip === 'string') ||\n        (typeof obj.tooltip === 'function')) {\n      return obj;\n    }\n    obj = obj.tooltip;\n  }\n  return null;\n};\n\n/**\n * Create the tooltip div and inject it onto the page.\n * @alias Blockly.Tooltip.createDom\n */\nconst createDom = function() {\n  if (DIV) {\n    return;  // Already created.\n  }\n  // Create an HTML container for popup overlays (e.g. editor widgets).\n  DIV = /** @type {!HTMLDivElement} */ (document.createElement('div'));\n  DIV.className = 'blocklyTooltipDiv';\n  const container = common.getParentContainer() || document.body;\n  container.appendChild(DIV);\n};\nexports.createDom = createDom;\n\n/**\n * Binds the required mouse events onto an SVG element.\n * @param {!Element} element SVG element onto which tooltip is to be bound.\n * @alias Blockly.Tooltip.bindMouseEvents\n */\nconst bindMouseEvents = function(element) {\n  element.mouseOverWrapper_ =\n      browserEvents.bind(element, 'mouseover', null, onMouseOver);\n  element.mouseOutWrapper_ =\n      browserEvents.bind(element, 'mouseout', null, onMouseOut);\n\n  // Don't use bindEvent_ for mousemove since that would create a\n  // corresponding touch handler, even though this only makes sense in the\n  // context of a mouseover/mouseout.\n  element.addEventListener('mousemove', onMouseMove, false);\n};\nexports.bindMouseEvents = bindMouseEvents;\n\n/**\n * Unbinds tooltip mouse events from the SVG element.\n * @param {!Element} element SVG element onto which tooltip is bound.\n * @alias Blockly.Tooltip.unbindMouseEvents\n */\nconst unbindMouseEvents = function(element) {\n  if (!element) {\n    return;\n  }\n  browserEvents.unbind(element.mouseOverWrapper_);\n  browserEvents.unbind(element.mouseOutWrapper_);\n  element.removeEventListener('mousemove', onMouseMove);\n};\nexports.unbindMouseEvents = unbindMouseEvents;\n\n/**\n * Hide the tooltip if the mouse is over a different object.\n * Initialize the tooltip to potentially appear for this object.\n * @param {!Event} e Mouse event.\n */\nconst onMouseOver = function(e) {\n  if (blocked) {\n    // Someone doesn't want us to show tooltips.\n    return;\n  }\n  // If the tooltip is an object, treat it as a pointer to the next object in\n  // the chain to look at.  Terminate when a string or function is found.\n  const newElement = /** @type {Element} */ (getTargetObject(e.currentTarget));\n  if (element !== newElement) {\n    hide();\n    poisonedElement = null;\n    element = newElement;\n  }\n  // Forget about any immediately preceding mouseOut event.\n  clearTimeout(mouseOutPid);\n};\n\n/**\n * Hide the tooltip if the mouse leaves the object and enters the workspace.\n * @param {!Event} _e Mouse event.\n */\nconst onMouseOut = function(_e) {\n  if (blocked) {\n    // Someone doesn't want us to show tooltips.\n    return;\n  }\n  // Moving from one element to another (overlapping or with no gap) generates\n  // a mouseOut followed instantly by a mouseOver.  Fork off the mouseOut\n  // event and kill it if a mouseOver is received immediately.\n  // This way the task only fully executes if mousing into the void.\n  mouseOutPid = setTimeout(function() {\n    element = null;\n    poisonedElement = null;\n    hide();\n  }, 1);\n  clearTimeout(showPid);\n};\n\n/**\n * When hovering over an element, schedule a tooltip to be shown.  If a tooltip\n * is already visible, hide it if the mouse strays out of a certain radius.\n * @param {!Event} e Mouse event.\n */\nconst onMouseMove = function(e) {\n  if (!element || !element.tooltip) {\n    // No tooltip here to show.\n    return;\n  } else if (blocked) {\n    // Someone doesn't want us to show tooltips.  We are probably handling a\n    // user gesture, such as a click or drag.\n    return;\n  }\n  if (visible) {\n    // Compute the distance between the mouse position when the tooltip was\n    // shown and the current mouse position.  Pythagorean theorem.\n    const dx = lastX - e.pageX;\n    const dy = lastY - e.pageY;\n    if (Math.sqrt(dx * dx + dy * dy) > RADIUS_OK) {\n      hide();\n    }\n  } else if (poisonedElement !== element) {\n    // The mouse moved, clear any previously scheduled tooltip.\n    clearTimeout(showPid);\n    // Maybe this time the mouse will stay put.  Schedule showing of tooltip.\n    lastX = e.pageX;\n    lastY = e.pageY;\n    showPid = setTimeout(show, HOVER_MS);\n  }\n};\n\n/**\n * Dispose of the tooltip.\n * @alias Blockly.Tooltip.dispose\n * @package\n */\nconst dispose = function() {\n  element = null;\n  poisonedElement = null;\n  hide();\n};\nexports.dispose = dispose;\n\n/**\n * Hide the tooltip.\n * @alias Blockly.Tooltip.hide\n */\nconst hide = function() {\n  if (visible) {\n    visible = false;\n    if (DIV) {\n      DIV.style.display = 'none';\n    }\n  }\n  if (showPid) {\n    clearTimeout(showPid);\n  }\n};\nexports.hide = hide;\n\n/**\n * Hide any in-progress tooltips and block showing new tooltips until the next\n * call to unblock().\n * @alias Blockly.Tooltip.block\n * @package\n */\nconst block = function() {\n  hide();\n  blocked = true;\n};\nexports.block = block;\n\n/**\n * Unblock tooltips: allow them to be scheduled and shown according to their own\n * logic.\n * @alias Blockly.Tooltip.unblock\n * @package\n */\nconst unblock = function() {\n  blocked = false;\n};\nexports.unblock = unblock;\n\n/**\n * Renders the tooltip content into the tooltip div.\n */\nconst renderContent = function() {\n  if (!DIV || !element) {\n    // This shouldn't happen, but if it does, we can't render.\n    return;\n  }\n  if (typeof customTooltip === 'function') {\n    customTooltip(DIV, element);\n  } else {\n    renderDefaultContent();\n  }\n};\n\n/**\n * Renders the default tooltip UI.\n */\nconst renderDefaultContent = function() {\n  let tip = getTooltipOfObject(element);\n  tip = blocklyString.wrap(tip, LIMIT);\n  // Create new text, line by line.\n  const lines = tip.split('\\n');\n  for (let i = 0; i < lines.length; i++) {\n    const div = /** @type {!HTMLDivElement} */ (document.createElement('div'));\n    div.appendChild(document.createTextNode(lines[i]));\n    DIV.appendChild(div);\n  }\n};\n\n/**\n * Gets the coordinates for the tooltip div, taking into account the edges of\n * the screen to prevent showing the tooltip offscreen.\n * @param {boolean} rtl True if the tooltip should be in right-to-left layout.\n * @returns {{x: number, y: number}} Coordinates at which the tooltip div should\n *     be placed.\n */\nconst getPosition = function(rtl) {\n  // Position the tooltip just below the cursor.\n  const windowWidth = document.documentElement.clientWidth;\n  const windowHeight = document.documentElement.clientHeight;\n\n  let anchorX = lastX;\n  if (rtl) {\n    anchorX -= OFFSET_X + DIV.offsetWidth;\n  } else {\n    anchorX += OFFSET_X;\n  }\n\n  let anchorY = lastY + OFFSET_Y;\n  if (anchorY + DIV.offsetHeight > windowHeight + window.scrollY) {\n    // Falling off the bottom of the screen; shift the tooltip up.\n    anchorY -= DIV.offsetHeight + 2 * OFFSET_Y;\n  }\n\n  if (rtl) {\n    // Prevent falling off left edge in RTL mode.\n    anchorX = Math.max(MARGINS - window.scrollX, anchorX);\n  } else {\n    if (anchorX + DIV.offsetWidth >\n        windowWidth + window.scrollX - 2 * MARGINS) {\n      // Falling off the right edge of the screen;\n      // clamp the tooltip on the edge.\n      anchorX = windowWidth - DIV.offsetWidth - 2 * MARGINS;\n    }\n  }\n\n  return {x: anchorX, y: anchorY};\n};\n\n/**\n * Create the tooltip and show it.\n */\nconst show = function() {\n  if (blocked) {\n    // Someone doesn't want us to show tooltips.\n    return;\n  }\n  poisonedElement = element;\n  if (!DIV) {\n    return;\n  }\n  // Erase all existing text.\n  DIV.textContent = '';\n\n  // Add new content.\n  renderContent();\n\n  // Display the tooltip.\n  const rtl = /** @type {{RTL: boolean}} */ (element).RTL;\n  DIV.style.direction = rtl ? 'rtl' : 'ltr';\n  DIV.style.display = 'block';\n  visible = true;\n\n  const {x, y} = getPosition(rtl);\n  DIV.style.left = x + 'px';\n  DIV.style.top = y + 'px';\n};\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/tooltip.js?")},
"./core/touch.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/string.js\");\n__webpack_require__(\"./core/utils/global.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Touch handling for Blockly.\n */\n\n\n/**\n * Touch handling for Blockly.\n * @namespace Blockly.Touch\n */\ngoog.module('Blockly.Touch');\n\nconst utilsString = goog.require('Blockly.utils.string');\n/* eslint-disable-next-line no-unused-vars */\nconst {Gesture} = goog.requireType('Blockly.Gesture');\nconst {globalThis} = goog.require('Blockly.utils.global');\n\n\n/**\n * Length in ms for a touch to become a long press.\n * @const\n */\nconst LONGPRESS = 750;\n\n/**\n * Whether touch is enabled in the browser.\n * Copied from Closure's goog.events.BrowserFeature.TOUCH_ENABLED\n * @const\n */\nconst TOUCH_ENABLED =\n    ('ontouchstart' in globalThis ||\n     !!(globalThis['document'] && document.documentElement &&\n        'ontouchstart' in document.documentElement) ||\n     // IE10 uses non-standard touch events, so it has a different check.\n     !!(globalThis['navigator'] &&\n        (globalThis['navigator']['maxTouchPoints'] ||\n         globalThis['navigator']['msMaxTouchPoints'])));\nexports.TOUCH_ENABLED = TOUCH_ENABLED;\n\n/**\n * Which touch events are we currently paying attention to?\n * @type {?string}\n */\nlet touchIdentifier_ = null;\n\n/**\n * The TOUCH_MAP lookup dictionary specifies additional touch events to fire,\n * in conjunction with mouse events.\n * @type {Object}\n * @alias Blockly.Touch.TOUCH_MAP\n */\nlet TOUCH_MAP = {};\nif (globalThis['PointerEvent']) {\n  TOUCH_MAP = {\n    'mousedown': ['pointerdown'],\n    'mouseenter': ['pointerenter'],\n    'mouseleave': ['pointerleave'],\n    'mousemove': ['pointermove'],\n    'mouseout': ['pointerout'],\n    'mouseover': ['pointerover'],\n    'mouseup': ['pointerup', 'pointercancel'],\n    'touchend': ['pointerup'],\n    'touchcancel': ['pointercancel'],\n  };\n} else if (TOUCH_ENABLED) {\n  TOUCH_MAP = {\n    'mousedown': ['touchstart'],\n    'mousemove': ['touchmove'],\n    'mouseup': ['touchend', 'touchcancel'],\n  };\n}\nexports.TOUCH_MAP = TOUCH_MAP;\n\n/**\n * PID of queued long-press task.\n */\nlet longPid_ = 0;\n\n/**\n * Context menus on touch devices are activated using a long-press.\n * Unfortunately the contextmenu touch event is currently (2015) only supported\n * by Chrome.  This function is fired on any touchstart event, queues a task,\n * which after about a second opens the context menu.  The tasks is killed\n * if the touch event terminates early.\n * @param {!Event} e Touch start event.\n * @param {Gesture} gesture The gesture that triggered this longStart.\n * @alias Blockly.Touch.longStart\n * @package\n */\nconst longStart = function(e, gesture) {\n  longStop();\n  // Punt on multitouch events.\n  if (e.changedTouches && e.changedTouches.length !== 1) {\n    return;\n  }\n  longPid_ = setTimeout(function() {\n    // Additional check to distinguish between touch events and pointer events\n    if (e.changedTouches) {\n      // TouchEvent\n      e.button = 2;  // Simulate a right button click.\n      // e was a touch event.  It needs to pretend to be a mouse event.\n      e.clientX = e.changedTouches[0].clientX;\n      e.clientY = e.changedTouches[0].clientY;\n    }\n\n    // Let the gesture route the right-click correctly.\n    if (gesture) {\n      gesture.handleRightClick(e);\n    }\n  }, LONGPRESS);\n};\nexports.longStart = longStart;\n\n/**\n * Nope, that's not a long-press.  Either touchend or touchcancel was fired,\n * or a drag hath begun.  Kill the queued long-press task.\n * @alias Blockly.Touch.longStop\n * @package\n */\nconst longStop = function() {\n  if (longPid_) {\n    clearTimeout(longPid_);\n    longPid_ = 0;\n  }\n};\nexports.longStop = longStop;\n\n/**\n * Clear the touch identifier that tracks which touch stream to pay attention\n * to.  This ends the current drag/gesture and allows other pointers to be\n * captured.\n * @alias Blockly.Touch.clearTouchIdentifier\n */\nconst clearTouchIdentifier = function() {\n  touchIdentifier_ = null;\n};\nexports.clearTouchIdentifier = clearTouchIdentifier;\n\n/**\n * Decide whether Blockly should handle or ignore this event.\n * Mouse and touch events require special checks because we only want to deal\n * with one touch stream at a time.  All other events should always be handled.\n * @param {!Event} e The event to check.\n * @return {boolean} True if this event should be passed through to the\n *     registered handler; false if it should be blocked.\n * @alias Blockly.Touch.shouldHandleEvent\n */\nconst shouldHandleEvent = function(e) {\n  return !isMouseOrTouchEvent(e) || checkTouchIdentifier(e);\n};\nexports.shouldHandleEvent = shouldHandleEvent;\n\n/**\n * Get the touch identifier from the given event.  If it was a mouse event, the\n * identifier is the string 'mouse'.\n * @param {!Event} e Mouse event or touch event.\n * @return {string} The touch identifier from the first changed touch, if\n *     defined.  Otherwise 'mouse'.\n * @alias Blockly.Touch.getTouchIdentifierFromEvent\n */\nconst getTouchIdentifierFromEvent = function(e) {\n  return e.pointerId !== undefined ? e.pointerId :\n      (e.changedTouches && e.changedTouches[0] &&\n       e.changedTouches[0].identifier !== undefined &&\n       e.changedTouches[0].identifier !== null) ?\n                                     e.changedTouches[0].identifier :\n                                     'mouse';\n};\nexports.getTouchIdentifierFromEvent = getTouchIdentifierFromEvent;\n\n/**\n * Check whether the touch identifier on the event matches the current saved\n * identifier.  If there is no identifier, that means it's a mouse event and\n * we'll use the identifier \"mouse\".  This means we won't deal well with\n * multiple mice being used at the same time.  That seems okay.\n * If the current identifier was unset, save the identifier from the\n * event.  This starts a drag/gesture, during which touch events with other\n * identifiers will be silently ignored.\n * @param {!Event} e Mouse event or touch event.\n * @return {boolean} Whether the identifier on the event matches the current\n *     saved identifier.\n * @alias Blockly.Touch.checkTouchIdentifier\n */\nconst checkTouchIdentifier = function(e) {\n  const identifier = getTouchIdentifierFromEvent(e);\n\n  // if (touchIdentifier_) is insufficient because Android touch\n  // identifiers may be zero.\n  if (touchIdentifier_ !== undefined && touchIdentifier_ !== null) {\n    // We're already tracking some touch/mouse event.  Is this from the same\n    // source?\n    return touchIdentifier_ === identifier;\n  }\n  if (e.type === 'mousedown' || e.type === 'touchstart' ||\n      e.type === 'pointerdown') {\n    // No identifier set yet, and this is the start of a drag.  Set it and\n    // return.\n    touchIdentifier_ = identifier;\n    return true;\n  }\n  // There was no identifier yet, but this wasn't a start event so we're going\n  // to ignore it.  This probably means that another drag finished while this\n  // pointer was down.\n  return false;\n};\nexports.checkTouchIdentifier = checkTouchIdentifier;\n\n/**\n * Set an event's clientX and clientY from its first changed touch.  Use this to\n * make a touch event work in a mouse event handler.\n * @param {!Event} e A touch event.\n * @alias Blockly.Touch.setClientFromTouch\n */\nconst setClientFromTouch = function(e) {\n  if (utilsString.startsWith(e.type, 'touch') && e.changedTouches) {\n    // Map the touch event's properties to the event.\n    const touchPoint = e.changedTouches[0];\n    e.clientX = touchPoint.clientX;\n    e.clientY = touchPoint.clientY;\n  }\n};\nexports.setClientFromTouch = setClientFromTouch;\n\n/**\n * Check whether a given event is a mouse or touch event.\n * @param {!Event} e An event.\n * @return {boolean} True if it is a mouse or touch event; false otherwise.\n * @alias Blockly.Touch.isMouseOrTouchEvent\n */\nconst isMouseOrTouchEvent = function(e) {\n  return utilsString.startsWith(e.type, 'touch') ||\n      utilsString.startsWith(e.type, 'mouse') ||\n      utilsString.startsWith(e.type, 'pointer');\n};\nexports.isMouseOrTouchEvent = isMouseOrTouchEvent;\n\n/**\n * Check whether a given event is a touch event or a pointer event.\n * @param {!Event} e An event.\n * @return {boolean} True if it is a touch event; false otherwise.\n * @alias Blockly.Touch.isTouchEvent\n */\nconst isTouchEvent = function(e) {\n  return utilsString.startsWith(e.type, 'touch') ||\n      utilsString.startsWith(e.type, 'pointer');\n};\nexports.isTouchEvent = isTouchEvent;\n\n/**\n * Split an event into an array of events, one per changed touch or mouse\n * point.\n * @param {!Event} e A mouse event or a touch event with one or more changed\n * touches.\n * @return {!Array<!Event>} An array of mouse or touch events.  Each touch\n *     event will have exactly one changed touch.\n * @alias Blockly.Touch.splitEventByTouches\n */\nconst splitEventByTouches = function(e) {\n  const events = [];\n  if (e.changedTouches) {\n    for (let i = 0; i < e.changedTouches.length; i++) {\n      const newEvent = {\n        type: e.type,\n        changedTouches: [e.changedTouches[i]],\n        target: e.target,\n        stopPropagation: function() {\n          e.stopPropagation();\n        },\n        preventDefault: function() {\n          e.preventDefault();\n        },\n      };\n      events[i] = newEvent;\n    }\n  } else {\n    events.push(e);\n  }\n  return events;\n};\nexports.splitEventByTouches = splitEventByTouches;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/touch.js?")},
"./core/touch_gesture.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/touch.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/gesture.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class extends Gesture to support pinch to zoom\n * for both pointer and touch events.\n */\n\n\n/**\n * The class extends Gesture to support pinch to zoom\n * for both pointer and touch events.\n * @class\n */\ngoog.module('Blockly.TouchGesture');\n\nconst Touch = goog.require('Blockly.Touch');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\nconst {Gesture} = goog.require('Blockly.Gesture');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/*\n * Note: In this file \"start\" refers to touchstart, mousedown, and pointerstart\n * events.  \"End\" refers to touchend, mouseup, and pointerend events.\n */\n\n\n/**\n * A multiplier used to convert the gesture scale to a zoom in delta.\n * @const\n */\nconst ZOOM_IN_MULTIPLIER = 5;\n\n/**\n * A multiplier used to convert the gesture scale to a zoom out delta.\n * @const\n */\nconst ZOOM_OUT_MULTIPLIER = 6;\n\n/**\n * Class for one gesture.\n * @extends {Gesture}\n * @alias Blockly.TouchGesture\n */\nclass TouchGesture extends Gesture {\n  /**\n   * @param {!Event} e The event that kicked off this gesture.\n   * @param {!WorkspaceSvg} creatorWorkspace The workspace that created\n   *     this gesture and has a reference to it.\n   */\n  constructor(e, creatorWorkspace) {\n    super(e, creatorWorkspace);\n\n    /**\n     * Boolean for whether or not this gesture is a multi-touch gesture.\n     * @type {boolean}\n     * @private\n     */\n    this.isMultiTouch_ = false;\n\n    /**\n     * A map of cached points used for tracking multi-touch gestures.\n     * @type {!Object<number|string, Coordinate>}\n     * @private\n     */\n    this.cachedPoints_ = Object.create(null);\n\n    /**\n     * This is the ratio between the starting distance between the touch points\n     * and the most recent distance between the touch points.\n     * Scales between 0 and 1 mean the most recent zoom was a zoom out.\n     * Scales above 1.0 mean the most recent zoom was a zoom in.\n     * @type {number}\n     * @private\n     */\n    this.previousScale_ = 0;\n\n    /**\n     * The starting distance between two touch points.\n     * @type {number}\n     * @private\n     */\n    this.startDistance_ = 0;\n\n    /**\n     * A handle to use to unbind the second touch start or pointer down listener\n     * at the end of a drag.\n     * Opaque data returned from Blockly.bindEventWithChecks_.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onStartWrapper_ = null;\n\n    /**\n     * Boolean for whether or not the workspace supports pinch-zoom.\n     * @type {?boolean}\n     * @private\n     */\n    this.isPinchZoomEnabled_ = null;\n  }\n\n  /**\n   * Start a gesture: update the workspace to indicate that a gesture is in\n   * progress and bind mousemove and mouseup handlers.\n   * @param {!Event} e A mouse down, touch start or pointer down event.\n   * @package\n   */\n  doStart(e) {\n    this.isPinchZoomEnabled_ = this.startWorkspace_.options.zoomOptions &&\n        this.startWorkspace_.options.zoomOptions.pinch;\n    super.doStart(e);\n    if (!this.isEnding_ && Touch.isTouchEvent(e)) {\n      this.handleTouchStart(e);\n    }\n  }\n\n  /**\n   * Bind gesture events.\n   * Overriding the gesture definition of this function, binding the same\n   * functions for onMoveWrapper_ and onUpWrapper_ but passing\n   * opt_noCaptureIdentifier.\n   * In addition, binding a second mouse down event to detect multi-touch\n   * events.\n   * @param {!Event} e A mouse down or touch start event.\n   * @package\n   */\n  bindMouseEvents(e) {\n    this.onStartWrapper_ = browserEvents.conditionalBind(\n        document, 'mousedown', null, this.handleStart.bind(this),\n        /* opt_noCaptureIdentifier */ true);\n    this.onMoveWrapper_ = browserEvents.conditionalBind(\n        document, 'mousemove', null, this.handleMove.bind(this),\n        /* opt_noCaptureIdentifier */ true);\n    this.onUpWrapper_ = browserEvents.conditionalBind(\n        document, 'mouseup', null, this.handleUp.bind(this),\n        /* opt_noCaptureIdentifier */ true);\n\n    e.preventDefault();\n    e.stopPropagation();\n  }\n\n  /**\n   * Handle a mouse down, touch start, or pointer down event.\n   * @param {!Event} e A mouse down, touch start, or pointer down event.\n   * @package\n   */\n  handleStart(e) {\n    if (this.isDragging()) {\n      // A drag has already started, so this can no longer be a pinch-zoom.\n      return;\n    }\n    if (Touch.isTouchEvent(e)) {\n      this.handleTouchStart(e);\n\n      if (this.isMultiTouch()) {\n        Touch.longStop();\n      }\n    }\n  }\n\n  /**\n   * Handle a mouse move, touch move, or pointer move event.\n   * @param {!Event} e A mouse move, touch move, or pointer move event.\n   * @package\n   */\n  handleMove(e) {\n    if (this.isDragging()) {\n      // We are in the middle of a drag, only handle the relevant events\n      if (Touch.shouldHandleEvent(e)) {\n        super.handleMove(e);\n      }\n      return;\n    }\n    if (this.isMultiTouch()) {\n      if (Touch.isTouchEvent(e)) {\n        this.handleTouchMove(e);\n      }\n      Touch.longStop();\n    } else {\n      super.handleMove(e);\n    }\n  }\n\n  /**\n   * Handle a mouse up, touch end, or pointer up event.\n   * @param {!Event} e A mouse up, touch end, or pointer up event.\n   * @package\n   */\n  handleUp(e) {\n    if (Touch.isTouchEvent(e) && !this.isDragging()) {\n      this.handleTouchEnd(e);\n    }\n    if (!this.isMultiTouch() || this.isDragging()) {\n      if (!Touch.shouldHandleEvent(e)) {\n        return;\n      }\n      super.handleUp(e);\n    } else {\n      e.preventDefault();\n      e.stopPropagation();\n\n      this.dispose();\n    }\n  }\n\n  /**\n   * Whether this gesture is part of a multi-touch gesture.\n   * @return {boolean} Whether this gesture is part of a multi-touch gesture.\n   * @package\n   */\n  isMultiTouch() {\n    return this.isMultiTouch_;\n  }\n\n  /**\n   * Sever all links from this object.\n   * @package\n   */\n  dispose() {\n    super.dispose();\n\n    if (this.onStartWrapper_) {\n      browserEvents.unbind(this.onStartWrapper_);\n    }\n  }\n\n  /**\n   * Handle a touch start or pointer down event and keep track of current\n   * pointers.\n   * @param {!Event} e A touch start, or pointer down event.\n   * @package\n   */\n  handleTouchStart(e) {\n    const pointerId = Touch.getTouchIdentifierFromEvent(e);\n    // store the pointerId in the current list of pointers\n    this.cachedPoints_[pointerId] = this.getTouchPoint(e);\n    const pointers = Object.keys(this.cachedPoints_);\n    // If two pointers are down, store info\n    if (pointers.length === 2) {\n      const point0 =\n          /** @type {!Coordinate} */ (this.cachedPoints_[pointers[0]]);\n      const point1 =\n          /** @type {!Coordinate} */ (this.cachedPoints_[pointers[1]]);\n      this.startDistance_ = Coordinate.distance(point0, point1);\n      this.isMultiTouch_ = true;\n      e.preventDefault();\n    }\n  }\n\n  /**\n   * Handle a touch move or pointer move event and zoom in/out if two pointers\n   * are on the screen.\n   * @param {!Event} e A touch move, or pointer move event.\n   * @package\n   */\n  handleTouchMove(e) {\n    const pointerId = Touch.getTouchIdentifierFromEvent(e);\n    // Update the cache\n    this.cachedPoints_[pointerId] = this.getTouchPoint(e);\n\n    const pointers = Object.keys(this.cachedPoints_);\n    if (this.isPinchZoomEnabled_ && pointers.length === 2) {\n      this.handlePinch_(e);\n    } else {\n      super.handleMove(e);\n    }\n  }\n\n  /**\n   * Handle pinch zoom gesture.\n   * @param {!Event} e A touch move, or pointer move event.\n   * @private\n   */\n  handlePinch_(e) {\n    const pointers = Object.keys(this.cachedPoints_);\n    // Calculate the distance between the two pointers\n    const point0 = /** @type {!Coordinate} */ (this.cachedPoints_[pointers[0]]);\n    const point1 = /** @type {!Coordinate} */ (this.cachedPoints_[pointers[1]]);\n    const moveDistance = Coordinate.distance(point0, point1);\n    const scale = moveDistance / this.startDistance_;\n\n    if (this.previousScale_ > 0 && this.previousScale_ < Infinity) {\n      const gestureScale = scale - this.previousScale_;\n      const delta = gestureScale > 0 ? gestureScale * ZOOM_IN_MULTIPLIER :\n                                       gestureScale * ZOOM_OUT_MULTIPLIER;\n      const workspace = this.startWorkspace_;\n      const position = browserEvents.mouseToSvg(\n          e, workspace.getParentSvg(), workspace.getInverseScreenCTM());\n      workspace.zoom(position.x, position.y, delta);\n    }\n    this.previousScale_ = scale;\n    e.preventDefault();\n  }\n\n  /**\n   * Handle a touch end or pointer end event and end the gesture.\n   * @param {!Event} e A touch end, or pointer end event.\n   * @package\n   */\n  handleTouchEnd(e) {\n    const pointerId = Touch.getTouchIdentifierFromEvent(e);\n    if (this.cachedPoints_[pointerId]) {\n      delete this.cachedPoints_[pointerId];\n    }\n    if (Object.keys(this.cachedPoints_).length < 2) {\n      this.cachedPoints_ = Object.create(null);\n      this.previousScale_ = 0;\n    }\n  }\n\n  /**\n   * Helper function returning the current touch point coordinate.\n   * @param {!Event} e A touch or pointer event.\n   * @return {?Coordinate} The current touch point coordinate\n   * @package\n   */\n  getTouchPoint(e) {\n    if (!this.startWorkspace_) {\n      return null;\n    }\n    return new Coordinate(\n        (e.changedTouches ? e.changedTouches[0].pageX : e.pageX),\n        (e.changedTouches ? e.changedTouches[0].pageY : e.pageY));\n  }\n}\n\nexports.TouchGesture = TouchGesture;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/touch_gesture.js?")},
"./core/trashcan.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/utils/toolbox.js\");\n__webpack_require__(\"./core/positionable_helpers.js\");\n__webpack_require__(\"./core/component_manager.js\");\n__webpack_require__(\"./core/delete_area.js\");\n__webpack_require__(\"./core/interfaces/i_autohideable.js\");\n__webpack_require__(\"./core/interfaces/i_positionable.js\");\n__webpack_require__(\"./core/options.js\");\n__webpack_require__(\"./core/utils/rect.js\");\n__webpack_require__(\"./core/utils/size.js\");\n__webpack_require__(\"./core/sprites.js\");\n__webpack_require__(\"./core/utils/svg.js\");\n__webpack_require__(\"./core/events/events_trashcan_open.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2011 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing a trash can icon.\n */\n\n\n/**\n * Object representing a trash can icon.\n * @class\n */\ngoog.module('Blockly.Trashcan');\n\n/* eslint-disable-next-line no-unused-vars */\nconst blocks = goog.requireType('Blockly.serialization.blocks');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst dom = goog.require('Blockly.utils.dom');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst toolbox = goog.require('Blockly.utils.toolbox');\nconst uiPosition = goog.require('Blockly.uiPosition');\n/* eslint-disable-next-line no-unused-vars */\nconst {Abstract} = goog.requireType('Blockly.Events.Abstract');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockDelete} = goog.requireType('Blockly.Events.BlockDelete');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlocklyOptions} = goog.requireType('Blockly.BlocklyOptions');\nconst {ComponentManager} = goog.require('Blockly.ComponentManager');\nconst {DeleteArea} = goog.require('Blockly.DeleteArea');\n/* eslint-disable-next-line no-unused-vars */\nconst {IAutoHideable} = goog.require('Blockly.IAutoHideable');\n/* eslint-disable-next-line no-unused-vars */\nconst {IDraggable} = goog.requireType('Blockly.IDraggable');\n/* eslint-disable-next-line no-unused-vars */\nconst {IFlyout} = goog.requireType('Blockly.IFlyout');\n/* eslint-disable-next-line no-unused-vars */\nconst {IPositionable} = goog.require('Blockly.IPositionable');\n/* eslint-disable-next-line no-unused-vars */\nconst {MetricsManager} = goog.requireType('Blockly.MetricsManager');\nconst {Options} = goog.require('Blockly.Options');\nconst {Rect} = goog.require('Blockly.utils.Rect');\nconst {Size} = goog.require('Blockly.utils.Size');\nconst {SPRITE} = goog.require('Blockly.sprite');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.TrashcanOpen');\n\n\n/**\n * Class for a trash can.\n * @implements {IAutoHideable}\n * @implements {IPositionable}\n * @extends {DeleteArea}\n * @alias Blockly.Trashcan\n */\nclass Trashcan extends DeleteArea {\n  /**\n   * @param {!WorkspaceSvg} workspace The workspace to sit in.\n   */\n  constructor(workspace) {\n    super();\n    /**\n     * The workspace the trashcan sits in.\n     * @type {!WorkspaceSvg}\n     * @private\n     */\n    this.workspace_ = workspace;\n\n    /**\n     * The unique id for this component that is used to register with the\n     * ComponentManager.\n     * @type {string}\n     */\n    this.id = 'trashcan';\n\n    /**\n     * A list of JSON (stored as strings) representing blocks in the trashcan.\n     * @type {!Array<string>}\n     * @private\n     */\n    this.contents_ = [];\n\n    /**\n     * The trashcan flyout.\n     * @type {IFlyout}\n     * @package\n     */\n    this.flyout = null;\n\n    if (this.workspace_.options.maxTrashcanContents <= 0) {\n      return;\n    }\n\n    /**\n     * Current open/close state of the lid.\n     * @type {boolean}\n     */\n    this.isLidOpen = false;\n\n    /**\n     * The minimum openness of the lid. Used to indicate if the trashcan\n     * contains blocks.\n     * @type {number}\n     * @private\n     */\n    this.minOpenness_ = 0;\n\n    /**\n     * The SVG group containing the trash can.\n     * @type {SVGElement}\n     * @private\n     */\n    this.svgGroup_ = null;\n\n    /**\n     * The SVG image element of the trash can lid.\n     * @type {SVGElement}\n     * @private\n     */\n    this.svgLid_ = null;\n\n    /**\n     * Task ID of opening/closing animation.\n     * @type {number}\n     * @private\n     */\n    this.lidTask_ = 0;\n\n    /**\n     * Current state of lid opening (0.0 = closed, 1.0 = open).\n     * @type {number}\n     * @private\n     */\n    this.lidOpen_ = 0;\n\n    /**\n     * Left coordinate of the trash can.\n     * @type {number}\n     * @private\n     */\n    this.left_ = 0;\n\n    /**\n     * Top coordinate of the trash can.\n     * @type {number}\n     * @private\n     */\n    this.top_ = 0;\n\n    /**\n     * Whether this trash can has been initialized.\n     * @type {boolean}\n     * @private\n     */\n    this.initialized_ = false;\n\n    // Create flyout options.\n    const flyoutWorkspaceOptions = new Options(\n        /** @type {!BlocklyOptions} */\n        ({\n          'scrollbars': true,\n          'parentWorkspace': this.workspace_,\n          'rtl': this.workspace_.RTL,\n          'oneBasedIndex': this.workspace_.options.oneBasedIndex,\n          'renderer': this.workspace_.options.renderer,\n          'rendererOverrides': this.workspace_.options.rendererOverrides,\n          'move': {\n            'scrollbars': true,\n          },\n        }));\n    // Create vertical or horizontal flyout.\n    if (this.workspace_.horizontalLayout) {\n      flyoutWorkspaceOptions.toolboxPosition =\n          this.workspace_.toolboxPosition === toolbox.Position.TOP ?\n          toolbox.Position.BOTTOM :\n          toolbox.Position.TOP;\n      const HorizontalFlyout = registry.getClassFromOptions(\n          registry.Type.FLYOUTS_HORIZONTAL_TOOLBOX, this.workspace_.options,\n          true);\n      this.flyout = new HorizontalFlyout(flyoutWorkspaceOptions);\n    } else {\n      flyoutWorkspaceOptions.toolboxPosition =\n          this.workspace_.toolboxPosition === toolbox.Position.RIGHT ?\n          toolbox.Position.LEFT :\n          toolbox.Position.RIGHT;\n      const VerticalFlyout = registry.getClassFromOptions(\n          registry.Type.FLYOUTS_VERTICAL_TOOLBOX, this.workspace_.options,\n          true);\n      this.flyout = new VerticalFlyout(flyoutWorkspaceOptions);\n    }\n    this.workspace_.addChangeListener(this.onDelete_.bind(this));\n  }\n\n  /**\n   * Create the trash can elements.\n   * @return {!SVGElement} The trash can's SVG group.\n   */\n  createDom() {\n    /* Here's the markup that will be generated:\n    <g class=\"blocklyTrash\">\n      <clippath id=\"blocklyTrashBodyClipPath837493\">\n        <rect width=\"47\" height=\"45\" y=\"15\"></rect>\n      </clippath>\n      <image width=\"64\" height=\"92\" y=\"-32\" xlink:href=\"media/sprites.png\"\n          clip-path=\"url(#blocklyTrashBodyClipPath837493)\"></image>\n      <clippath id=\"blocklyTrashLidClipPath837493\">\n        <rect width=\"47\" height=\"15\"></rect>\n      </clippath>\n      <image width=\"84\" height=\"92\" y=\"-32\" xlink:href=\"media/sprites.png\"\n          clip-path=\"url(#blocklyTrashLidClipPath837493)\"></image>\n    </g>\n    */\n    this.svgGroup_ =\n        dom.createSvgElement(Svg.G, {'class': 'blocklyTrash'}, null);\n    let clip;\n    const rnd = String(Math.random()).substring(2);\n    clip = dom.createSvgElement(\n        Svg.CLIPPATH, {'id': 'blocklyTrashBodyClipPath' + rnd}, this.svgGroup_);\n    dom.createSvgElement(\n        Svg.RECT, {'width': WIDTH, 'height': BODY_HEIGHT, 'y': LID_HEIGHT},\n        clip);\n    const body = dom.createSvgElement(\n        Svg.IMAGE, {\n          'width': SPRITE.width,\n          'x': -SPRITE_LEFT,\n          'height': SPRITE.height,\n          'y': -SPRITE_TOP,\n          'clip-path': 'url(#blocklyTrashBodyClipPath' + rnd + ')',\n        },\n        this.svgGroup_);\n    body.setAttributeNS(\n        dom.XLINK_NS, 'xlink:href',\n        this.workspace_.options.pathToMedia + SPRITE.url);\n\n    clip = dom.createSvgElement(\n        Svg.CLIPPATH, {'id': 'blocklyTrashLidClipPath' + rnd}, this.svgGroup_);\n    dom.createSvgElement(\n        Svg.RECT, {'width': WIDTH, 'height': LID_HEIGHT}, clip);\n    this.svgLid_ = dom.createSvgElement(\n        Svg.IMAGE, {\n          'width': SPRITE.width,\n          'x': -SPRITE_LEFT,\n          'height': SPRITE.height,\n          'y': -SPRITE_TOP,\n          'clip-path': 'url(#blocklyTrashLidClipPath' + rnd + ')',\n        },\n        this.svgGroup_);\n    this.svgLid_.setAttributeNS(\n        dom.XLINK_NS, 'xlink:href',\n        this.workspace_.options.pathToMedia + SPRITE.url);\n\n    // bindEventWithChecks_ quashes events too aggressively. See:\n    // https://groups.google.com/forum/#!topic/blockly/QF4yB9Wx00s\n    // Using bindEventWithChecks_ for blocking mousedown causes issue in mobile.\n    // See #4303\n    browserEvents.bind(\n        this.svgGroup_, 'mousedown', this, this.blockMouseDownWhenOpenable_);\n    browserEvents.bind(this.svgGroup_, 'mouseup', this, this.click);\n    // Bind to body instead of this.svgGroup_ so that we don't get lid jitters\n    browserEvents.bind(body, 'mouseover', this, this.mouseOver_);\n    browserEvents.bind(body, 'mouseout', this, this.mouseOut_);\n    this.animateLid_();\n    return this.svgGroup_;\n  }\n\n  /**\n   * Initializes the trash can.\n   */\n  init() {\n    if (this.workspace_.options.maxTrashcanContents > 0) {\n      dom.insertAfter(\n          this.flyout.createDom(Svg.SVG), this.workspace_.getParentSvg());\n      this.flyout.init(this.workspace_);\n    }\n    this.workspace_.getComponentManager().addComponent({\n      component: this,\n      weight: 1,\n      capabilities: [\n        ComponentManager.Capability.AUTOHIDEABLE,\n        ComponentManager.Capability.DELETE_AREA,\n        ComponentManager.Capability.DRAG_TARGET,\n        ComponentManager.Capability.POSITIONABLE,\n      ],\n    });\n    this.initialized_ = true;\n    this.setLidOpen(false);\n  }\n\n  /**\n   * Dispose of this trash can.\n   * Unlink from all DOM elements to prevent memory leaks.\n   * @suppress {checkTypes}\n   */\n  dispose() {\n    this.workspace_.getComponentManager().removeComponent('trashcan');\n    if (this.svgGroup_) {\n      dom.removeNode(this.svgGroup_);\n      this.svgGroup_ = null;\n    }\n    this.svgLid_ = null;\n    this.workspace_ = null;\n    clearTimeout(this.lidTask_);\n  }\n\n  /**\n   * Whether the trashcan has contents.\n   * @return {boolean} True if the trashcan has contents.\n   * @private\n   */\n  hasContents_() {\n    return !!this.contents_.length;\n  }\n\n  /**\n   * Returns true if the trashcan contents-flyout is currently open.\n   * @return {boolean} True if the trashcan contents-flyout is currently open.\n   */\n  contentsIsOpen() {\n    return !!this.flyout && this.flyout.isVisible();\n  }\n\n  /**\n   * Opens the trashcan flyout.\n   */\n  openFlyout() {\n    if (this.contentsIsOpen()) {\n      return;\n    }\n    const contents = this.contents_.map(function(string) {\n      return JSON.parse(string);\n    });\n    this.flyout.show(contents);\n    this.fireUiEvent_(true);\n  }\n\n  /**\n   * Closes the trashcan flyout.\n   */\n  closeFlyout() {\n    if (!this.contentsIsOpen()) {\n      return;\n    }\n    this.flyout.hide();\n    this.fireUiEvent_(false);\n    this.workspace_.recordDragTargets();\n  }\n\n  /**\n   * Hides the component. Called in WorkspaceSvg.hideChaff.\n   * @param {boolean} onlyClosePopups Whether only popups should be closed.\n   *     Flyouts should not be closed if this is true.\n   */\n  autoHide(onlyClosePopups) {\n    // For now the trashcan flyout always autocloses because it overlays the\n    // trashcan UI (no trashcan to click to close it).\n    if (!onlyClosePopups && this.flyout) {\n      this.closeFlyout();\n    }\n  }\n\n  /**\n   * Empties the trashcan's contents. If the contents-flyout is currently open\n   * it will be closed.\n   */\n  emptyContents() {\n    if (!this.hasContents_()) {\n      return;\n    }\n    this.contents_.length = 0;\n    this.setMinOpenness_(0);\n    this.closeFlyout();\n  }\n\n  /**\n   * Positions the trashcan.\n   * It is positioned in the opposite corner to the corner the\n   * categories/toolbox starts at.\n   * @param {!MetricsManager.UiMetrics} metrics The workspace metrics.\n   * @param {!Array<!Rect>} savedPositions List of rectangles that\n   *     are already on the workspace.\n   */\n  position(metrics, savedPositions) {\n    // Not yet initialized.\n    if (!this.initialized_) {\n      return;\n    }\n\n    const cornerPosition =\n        uiPosition.getCornerOppositeToolbox(this.workspace_, metrics);\n\n    const height = BODY_HEIGHT + LID_HEIGHT;\n    const startRect = uiPosition.getStartPositionRect(\n        cornerPosition, new Size(WIDTH, height), MARGIN_HORIZONTAL,\n        MARGIN_VERTICAL, metrics, this.workspace_);\n\n    const verticalPosition = cornerPosition.vertical;\n    const bumpDirection = verticalPosition === uiPosition.verticalPosition.TOP ?\n        uiPosition.bumpDirection.DOWN :\n        uiPosition.bumpDirection.UP;\n    const positionRect = uiPosition.bumpPositionRect(\n        startRect, MARGIN_VERTICAL, bumpDirection, savedPositions);\n\n    this.top_ = positionRect.top;\n    this.left_ = positionRect.left;\n    this.svgGroup_.setAttribute(\n        'transform', 'translate(' + this.left_ + ',' + this.top_ + ')');\n  }\n\n  /**\n   * Returns the bounding rectangle of the UI element in pixel units relative to\n   * the Blockly injection div.\n   * @return {?Rect} The UI elements's bounding box. Null if\n   *   bounding box should be ignored by other UI elements.\n   */\n  getBoundingRectangle() {\n    const bottom = this.top_ + BODY_HEIGHT + LID_HEIGHT;\n    const right = this.left_ + WIDTH;\n    return new Rect(this.top_, bottom, this.left_, right);\n  }\n\n  /**\n   * Returns the bounding rectangle of the drag target area in pixel units\n   * relative to viewport.\n   * @return {?Rect} The component's bounding box. Null if drag\n   *   target area should be ignored.\n   */\n  getClientRect() {\n    if (!this.svgGroup_) {\n      return null;\n    }\n\n    const trashRect = this.svgGroup_.getBoundingClientRect();\n    const top = trashRect.top + SPRITE_TOP - MARGIN_HOTSPOT;\n    const bottom = top + LID_HEIGHT + BODY_HEIGHT + 2 * MARGIN_HOTSPOT;\n    const left = trashRect.left + SPRITE_LEFT - MARGIN_HOTSPOT;\n    const right = left + WIDTH + 2 * MARGIN_HOTSPOT;\n    return new Rect(top, bottom, left, right);\n  }\n\n  /**\n   * Handles when a cursor with a block or bubble is dragged over this drag\n   * target.\n   * @param {!IDraggable} _dragElement The block or bubble currently being\n   *   dragged.\n   * @override\n   */\n  onDragOver(_dragElement) {\n    this.setLidOpen(this.wouldDelete_);\n  }\n\n  /**\n   * Handles when a cursor with a block or bubble exits this drag target.\n   * @param {!IDraggable} _dragElement The block or bubble currently being\n   *   dragged.\n   * @override\n   */\n  onDragExit(_dragElement) {\n    this.setLidOpen(false);\n  }\n\n  /**\n   * Handles when a block or bubble is dropped on this component.\n   * Should not handle delete here.\n   * @param {!IDraggable} _dragElement The block or bubble currently being\n   *   dragged.\n   * @override\n   */\n  onDrop(_dragElement) {\n    setTimeout(this.setLidOpen.bind(this, false), 100);\n  }\n\n  /**\n   * Flip the lid open or shut.\n   * @param {boolean} state True if open.\n   * @package\n   */\n  setLidOpen(state) {\n    if (this.isLidOpen === state) {\n      return;\n    }\n    clearTimeout(this.lidTask_);\n    this.isLidOpen = state;\n    this.animateLid_();\n  }\n\n  /**\n   * Rotate the lid open or closed by one step.  Then wait and recurse.\n   * @private\n   */\n  animateLid_() {\n    const frames = ANIMATION_FRAMES;\n\n    const delta = 1 / (frames + 1);\n    this.lidOpen_ += this.isLidOpen ? delta : -delta;\n    this.lidOpen_ = Math.min(Math.max(this.lidOpen_, this.minOpenness_), 1);\n\n    this.setLidAngle_(this.lidOpen_ * MAX_LID_ANGLE);\n\n    // Linear interpolation between min and max.\n    const opacity = OPACITY_MIN + this.lidOpen_ * (OPACITY_MAX - OPACITY_MIN);\n    this.svgGroup_.style.opacity = opacity;\n\n    if (this.lidOpen_ > this.minOpenness_ && this.lidOpen_ < 1) {\n      this.lidTask_ =\n          setTimeout(this.animateLid_.bind(this), ANIMATION_LENGTH / frames);\n    }\n  }\n\n  /**\n   * Set the angle of the trashcan's lid.\n   * @param {number} lidAngle The angle at which to set the lid.\n   * @private\n   */\n  setLidAngle_(lidAngle) {\n    const openAtRight =\n        this.workspace_.toolboxPosition === toolbox.Position.RIGHT ||\n        (this.workspace_.horizontalLayout && this.workspace_.RTL);\n    this.svgLid_.setAttribute(\n        'transform',\n        'rotate(' + (openAtRight ? -lidAngle : lidAngle) + ',' +\n            (openAtRight ? 4 : WIDTH - 4) + ',' + (LID_HEIGHT - 2) + ')');\n  }\n\n  /**\n   * Sets the minimum openness of the trashcan lid. If the lid is currently\n   * closed, this will update lid's position.\n   * @param {number} newMin The new minimum openness of the lid. Should be\n   *     between 0 and 1.\n   * @private\n   */\n  setMinOpenness_(newMin) {\n    this.minOpenness_ = newMin;\n    if (!this.isLidOpen) {\n      this.setLidAngle_(newMin * MAX_LID_ANGLE);\n    }\n  }\n\n  /**\n   * Flip the lid shut.\n   * Called externally after a drag.\n   */\n  closeLid() {\n    this.setLidOpen(false);\n  }\n\n  /**\n   * Inspect the contents of the trash.\n   */\n  click() {\n    if (!this.hasContents_()) {\n      return;\n    }\n    this.openFlyout();\n  }\n\n  /**\n   * Fires a UI event for trashcan flyout open or close.\n   * @param {boolean} trashcanOpen Whether the flyout is opening.\n   * @private\n   */\n  fireUiEvent_(trashcanOpen) {\n    const uiEvent = new (eventUtils.get(eventUtils.TRASHCAN_OPEN))(\n        trashcanOpen, this.workspace_.id);\n    eventUtils.fire(uiEvent);\n  }\n\n  /**\n   * Prevents a workspace scroll and click event if the trashcan has blocks.\n   * @param {!Event} e A mouse down event.\n   * @private\n   */\n  blockMouseDownWhenOpenable_(e) {\n    if (!this.contentsIsOpen() && this.hasContents_()) {\n      e.stopPropagation();  // Don't start a workspace scroll.\n    }\n  }\n\n  /**\n   * Indicate that the trashcan can be clicked (by opening it) if it has blocks.\n   * @private\n   */\n  mouseOver_() {\n    if (this.hasContents_()) {\n      this.setLidOpen(true);\n    }\n  }\n\n  /**\n   * Close the lid of the trashcan if it was open (Vis. it was indicating it had\n   *    blocks).\n   * @private\n   */\n  mouseOut_() {\n    // No need to do a .hasBlocks check here because if it doesn't the trashcan\n    // won't be open in the first place, and setOpen won't run.\n    this.setLidOpen(false);\n  }\n\n  /**\n   * Handle a BLOCK_DELETE event. Adds deleted blocks oldXml to the content\n   * array.\n   * @param {!Abstract} event Workspace event.\n   * @private\n   */\n  onDelete_(event) {\n    if (this.workspace_.options.maxTrashcanContents <= 0 ||\n        event.type !== eventUtils.BLOCK_DELETE) {\n      return;\n    }\n    const deleteEvent = /** @type {!BlockDelete} */ (event);\n    if (event.type === eventUtils.BLOCK_DELETE && !deleteEvent.wasShadow) {\n      const cleanedJson = this.cleanBlockJson_(deleteEvent.oldJson);\n      if (this.contents_.indexOf(cleanedJson) !== -1) {\n        return;\n      }\n      this.contents_.unshift(cleanedJson);\n      while (this.contents_.length >\n             this.workspace_.options.maxTrashcanContents) {\n        this.contents_.pop();\n      }\n\n      this.setMinOpenness_(HAS_BLOCKS_LID_ANGLE);\n    }\n  }\n\n  /**\n   * Converts JSON representing a block into text that can be stored in the\n   * content array.\n   * @param {!blocks.State} json A JSON representation of\n   *     a block's state.\n   * @return {string} Text representing the JSON, cleaned of all unnecessary\n   *     attributes.\n   * @private\n   */\n  cleanBlockJson_(json) {\n    // Create a deep copy.\n    json = /** @type {!blocks.State} */ (JSON.parse(JSON.stringify(json)));\n\n    /**\n     * Reshape JSON into a nicer format.\n     * @param {!blocks.State} json The JSON to clean.\n     */\n    function cleanRec(json) {\n      if (!json) {\n        return;\n      }\n\n      delete json['id'];\n      delete json['x'];\n      delete json['y'];\n      delete json['enabled'];\n\n      if (json['icons'] && json['icons']['comment']) {\n        const comment = json['icons']['comment'];\n        delete comment['height'];\n        delete comment['width'];\n        delete comment['pinned'];\n      }\n\n      const inputs = json['inputs'];\n      for (const name in inputs) {\n        const input = inputs[name];\n        cleanRec(input['block']);\n        cleanRec(input['shadow']);\n      }\n      if (json['next']) {\n        const next = json['next'];\n        cleanRec(next['block']);\n        cleanRec(next['shadow']);\n      }\n    }\n\n    cleanRec(json);\n    json['kind'] = 'BLOCK';\n    return JSON.stringify(json);\n  }\n}\n\n/**\n * Width of both the trash can and lid images.\n */\nconst WIDTH = 47;\n\n/**\n * Height of the trashcan image (minus lid).\n */\nconst BODY_HEIGHT = 44;\n\n/**\n * Height of the lid image.\n */\nconst LID_HEIGHT = 16;\n\n/**\n * Distance between trashcan and bottom or top edge of workspace.\n */\nconst MARGIN_VERTICAL = 20;\n\n/**\n * Distance between trashcan and right or left edge of workspace.\n */\nconst MARGIN_HORIZONTAL = 20;\n\n/**\n * Extent of hotspot on all sides beyond the size of the image.\n */\nconst MARGIN_HOTSPOT = 10;\n\n/**\n * Location of trashcan in sprite image.\n */\nconst SPRITE_LEFT = 0;\n\n/**\n * Location of trashcan in sprite image.\n */\nconst SPRITE_TOP = 32;\n\n/**\n * The openness of the lid when the trashcan contains blocks.\n *    (0.0 = closed, 1.0 = open)\n */\nconst HAS_BLOCKS_LID_ANGLE = 0.1;\n\n/**\n * The length of the lid open/close animation in milliseconds.\n */\nconst ANIMATION_LENGTH = 80;\n\n/**\n * The number of frames in the animation.\n */\nconst ANIMATION_FRAMES = 4;\n\n/**\n * The minimum (resting) opacity of the trashcan and lid.\n */\nconst OPACITY_MIN = 0.4;\n\n/**\n * The maximum (hovered) opacity of the trashcan and lid.\n */\nconst OPACITY_MAX = 0.8;\n\n/**\n * The maximum angle the trashcan lid can opens to. At the end of the open\n * animation the lid will be open to this angle.\n */\nconst MAX_LID_ANGLE = 45;\n\nexports.Trashcan = Trashcan;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/trashcan.js?")},
"./core/utils.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/aria.js\");\n__webpack_require__(\"./core/utils/array.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/utils/colour.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/utils/deprecation.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/extensions.js\");\n__webpack_require__(\"./core/utils/global.js\");\n__webpack_require__(\"./core/utils/idgenerator.js\");\n__webpack_require__(\"./core/utils/math.js\");\n__webpack_require__(\"./core/utils/object.js\");\n__webpack_require__(\"./core/utils/parsing.js\");\n__webpack_require__(\"./core/utils/string.js\");\n__webpack_require__(\"./core/utils/style.js\");\n__webpack_require__(\"./core/utils/svg_math.js\");\n__webpack_require__(\"./core/utils/svg_paths.js\");\n__webpack_require__(\"./core/utils/toolbox.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\n__webpack_require__(\"./core/utils/xml.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/utils/keycodes.js\");\n__webpack_require__(\"./core/utils/metrics.js\");\n__webpack_require__(\"./core/utils/rect.js\");\n__webpack_require__(\"./core/utils/size.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility methods.\n */\n\n\n/**\n * Utility methods.\n * @namespace Blockly.utils\n */\ngoog.module('Blockly.utils');\n\nconst aria = goog.require('Blockly.utils.aria');\nconst arrayUtils = goog.require('Blockly.utils.array');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst colourUtils = goog.require('Blockly.utils.colour');\nconst common = goog.require('Blockly.common');\nconst deprecation = goog.require('Blockly.utils.deprecation');\nconst dom = goog.require('Blockly.utils.dom');\nconst extensions = goog.require('Blockly.Extensions');\nconst global = goog.require('Blockly.utils.global');\nconst idGenerator = goog.require('Blockly.utils.idGenerator');\nconst math = goog.require('Blockly.utils.math');\nconst object = goog.require('Blockly.utils.object');\nconst parsing = goog.require('Blockly.utils.parsing');\nconst stringUtils = goog.require('Blockly.utils.string');\nconst style = goog.require('Blockly.utils.style');\nconst svgMath = goog.require('Blockly.utils.svgMath');\nconst svgPaths = goog.require('Blockly.utils.svgPaths');\nconst toolbox = goog.require('Blockly.utils.toolbox');\nconst userAgent = goog.require('Blockly.utils.userAgent');\nconst xmlUtils = goog.require('Blockly.utils.xml');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\nconst {KeyCodes} = goog.require('Blockly.utils.KeyCodes');\nconst {Metrics} = goog.require('Blockly.utils.Metrics');\nconst {Rect} = goog.require('Blockly.utils.Rect');\nconst {Size} = goog.require('Blockly.utils.Size');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\nexports.aria = aria;\nexports.colour = colourUtils;\nexports.Coordinate = Coordinate;\nexports.deprecation = deprecation;\nexports.dom = dom;\nexports.global = global.globalThis;\nexports.idGenerator = idGenerator;\nexports.KeyCodes = KeyCodes;\nexports.math = math;\nexports.Metrics = Metrics;\nexports.object = object;\nexports.parsing = parsing;\nexports.Rect = Rect;\nexports.Size = Size;\nexports.string = stringUtils;\nexports.style = style;\nexports.Svg = Svg;\nexports.svgPaths = svgPaths;\nexports.svgMath = svgMath;\nexports.toolbox = toolbox;\nexports.userAgent = userAgent;\nexports.xml = xmlUtils;\n\n/**\n * Halts the propagation of the event without doing anything else.\n * @param {!Event} e An event.\n * @deprecated\n * @alias Blockly.utils.noEvent\n */\nconst noEvent = function(e) {\n  deprecation.warn('Blockly.utils.noEvent', 'September 2021', 'September 2022');\n  // This event has been handled.  No need to bubble up to the document.\n  e.preventDefault();\n  e.stopPropagation();\n};\nexports.noEvent = noEvent;\n\n/**\n * Returns true if this event is targeting a text input widget?\n * @param {!Event} e An event.\n * @return {boolean} True if text input.\n * @deprecated Use Blockly.browserEvents.isTargetInput instead.\n * @alias Blockly.utils.isTargetInput\n */\nconst isTargetInput = function(e) {\n  deprecation.warn(\n      'Blockly.utils.isTargetInput', 'September 2021', 'September 2022',\n      'Blockly.browserEvents.isTargetInput');\n  return browserEvents.isTargetInput(e);\n};\nexports.isTargetInput = isTargetInput;\n\n/**\n * Return the coordinates of the top-left corner of this element relative to\n * its parent.  Only for SVG elements and children (e.g. rect, g, path).\n * @param {!Element} element SVG element to find the coordinates of.\n * @return {!Coordinate} Object with .x and .y properties.\n * @deprecated\n * @alias Blockly.utils.getRelativeXY\n */\nconst getRelativeXY = function(element) {\n  deprecation.warn(\n      'Blockly.utils.getRelativeXY', 'December 2021', 'December 2022',\n      'Blockly.utils.svgMath.getRelativeXY');\n  return svgMath.getRelativeXY(element);\n};\nexports.getRelativeXY = getRelativeXY;\n\n/**\n * Return the coordinates of the top-left corner of this element relative to\n * the div Blockly was injected into.\n * @param {!Element} element SVG element to find the coordinates of. If this is\n *     not a child of the div Blockly was injected into, the behaviour is\n *     undefined.\n * @return {!Coordinate} Object with .x and .y properties.\n * @deprecated\n * @alias Blockly.utils.getInjectionDivXY_\n */\nconst getInjectionDivXY = function(element) {\n  deprecation.warn(\n      'Blockly.utils.getInjectionDivXY_', 'December 2021', 'December 2022',\n      'Blockly.utils.svgMath.getInjectionDivXY');\n  return svgMath.getInjectionDivXY(element);\n};\nexports.getInjectionDivXY_ = getInjectionDivXY;\n\n/**\n * Returns true this event is a right-click.\n * @param {!Event} e Mouse event.\n * @return {boolean} True if right-click.\n * @deprecated Use Blockly.browserEvents.isRightButton instead.\n * @alias Blockly.utils.isRightButton\n */\nconst isRightButton = function(e) {\n  deprecation.warn(\n      'Blockly.utils.isRightButton', 'September 2021', 'September 2022',\n      'Blockly.browserEvents.isRightButton');\n  return browserEvents.isRightButton(e);\n};\nexports.isRightButton = isRightButton;\n\n/**\n * Returns the converted coordinates of the given mouse event.\n * The origin (0,0) is the top-left corner of the Blockly SVG.\n * @param {!Event} e Mouse event.\n * @param {!Element} svg SVG element.\n * @param {?SVGMatrix} matrix Inverted screen CTM to use.\n * @return {!SVGPoint} Object with .x and .y properties.\n * @deprecated Use Blockly.browserEvents.mouseToSvg instead;\n * @alias Blockly.utils.mouseToSvg\n */\nconst mouseToSvg = function(e, svg, matrix) {\n  deprecation.warn(\n      'Blockly.utils.mouseToSvg', 'September 2021', 'September 2022',\n      'Blockly.browserEvents.mouseToSvg');\n  return browserEvents.mouseToSvg(e, svg, matrix);\n};\nexports.mouseToSvg = mouseToSvg;\n\n/**\n * Returns the scroll delta of a mouse event in pixel units.\n * @param {!Event} e Mouse event.\n * @return {{x: number, y: number}} Scroll delta object with .x and .y\n *    properties.\n * @deprecated Use Blockly.browserEvents.getScrollDeltaPixels instead.\n * @alias Blockly.utils.getScrollDeltaPixels\n */\nconst getScrollDeltaPixels = function(e) {\n  deprecation.warn(\n      'Blockly.utils.getScrollDeltaPixels', 'September 2021', 'September 2022',\n      'Blockly.browserEvents.getScrollDeltaPixels');\n  return browserEvents.getScrollDeltaPixels(e);\n};\nexports.getScrollDeltaPixels = getScrollDeltaPixels;\n\n/**\n * Parse a string with any number of interpolation tokens (%1, %2, ...).\n * It will also replace string table references (e.g., %{bky_my_msg} and\n * %{BKY_MY_MSG} will both be replaced with the value in\n * Msg['MY_MSG']). Percentage sign characters '%' may be self-escaped\n * (e.g., '%%').\n * @param {string} message Text which might contain string table references and\n *     interpolation tokens.\n * @return {!Array<string|number>} Array of strings and numbers.\n * @deprecated\n * @alias Blockly.utils.tokenizeInterpolation\n */\nconst tokenizeInterpolation = function(message) {\n  deprecation.warn(\n      'Blockly.utils.tokenizeInterpolation', 'December 2021', 'December 2022',\n      'Blockly.utils.parsing.tokenizeInterpolation');\n  return parsing.tokenizeInterpolation(message);\n};\nexports.tokenizeInterpolation = tokenizeInterpolation;\n\n/**\n * Replaces string table references in a message, if the message is a string.\n * For example, \"%{bky_my_msg}\" and \"%{BKY_MY_MSG}\" will both be replaced with\n * the value in Msg['MY_MSG'].\n * @param {string|?} message Message, which may be a string that contains\n *     string table references.\n * @return {string} String with message references replaced.\n * @deprecated\n * @alias Blockly.utils.replaceMessageReferences\n */\nconst replaceMessageReferences = function(message) {\n  deprecation.warn(\n      'Blockly.utils.replaceMessageReferences', 'December 2021',\n      'December 2022', 'Blockly.utils.parsing.replaceMessageReferences');\n  return parsing.replaceMessageReferences(message);\n};\nexports.replaceMessageReferences = replaceMessageReferences;\n\n/**\n * Validates that any %{MSG_KEY} references in the message refer to keys of\n * the Msg string table.\n * @param {string} message Text which might contain string table references.\n * @return {boolean} True if all message references have matching values.\n *     Otherwise, false.\n * @deprecated\n * @alias Blockly.utils.checkMessageReferences\n */\nconst checkMessageReferences = function(message) {\n  deprecation.warn(\n      'Blockly.utils.checkMessageReferences', 'December 2021', 'December 2022',\n      'Blockly.utils.parsing.checkMessageReferences');\n  return parsing.checkMessageReferences(message);\n};\nexports.checkMessageReferences = checkMessageReferences;\n\n/**\n * Generate a unique ID.\n * @return {string} A globally unique ID string.\n * @deprecated Use Blockly.utils.idGenerator.genUid instead.\n * @alias Blockly.utils.genUid\n */\nconst genUid = function() {\n  deprecation.warn(\n      'Blockly.utils.genUid', 'September 2021', 'September 2022',\n      'Blockly.utils.idGenerator.genUid');\n  return idGenerator.genUid();\n};\nexports.genUid = genUid;\n\n/**\n * Check if 3D transforms are supported by adding an element\n * and attempting to set the property.\n * @return {boolean} True if 3D transforms are supported.\n * @deprecated\n * @alias Blockly.utils.is3dSupported\n */\nconst is3dSupported = function() {\n  deprecation.warn(\n      'Blockly.utils.is3dSupported', 'December 2021', 'December 2022',\n      'Blockly.utils.svgMath.is3dSupported');\n  return svgMath.is3dSupported();\n};\nexports.is3dSupported = is3dSupported;\n\n/**\n * Get the position of the current viewport in window coordinates.  This takes\n * scroll into account.\n * @return {!Rect} An object containing window width, height, and\n *     scroll position in window coordinates.\n * @alias Blockly.utils.getViewportBBox\n * @deprecated\n * @package\n */\nconst getViewportBBox = function() {\n  deprecation.warn(\n      'Blockly.utils.getViewportBBox', 'December 2021', 'December 2022',\n      'Blockly.utils.svgMath.getViewportBBox');\n  return svgMath.getViewportBBox();\n};\nexports.getViewportBBox = getViewportBBox;\n\n/**\n * Removes the first occurrence of a particular value from an array.\n * @param {!Array} arr Array from which to remove value.\n * @param {*} value Value to remove.\n * @return {boolean} True if an element was removed.\n * @alias Blockly.utils.arrayRemove\n * @deprecated\n * @package\n */\nconst arrayRemove = function(arr, value) {\n  deprecation.warn(\n      'Blockly.utils.arrayRemove', 'December 2021', 'December 2022');\n  return arrayUtils.removeElem(arr, value);\n};\nexports.arrayRemove = arrayRemove;\n\n/**\n * Gets the document scroll distance as a coordinate object.\n * Copied from Closure's goog.dom.getDocumentScroll.\n * @return {!Coordinate} Object with values 'x' and 'y'.\n * @deprecated\n * @alias Blockly.utils.getDocumentScroll\n */\nconst getDocumentScroll = function() {\n  deprecation.warn(\n      'Blockly.utils.getDocumentScroll', 'December 2021', 'December 2022',\n      'Blockly.utils.svgMath.getDocumentScroll');\n  return svgMath.getDocumentScroll();\n};\nexports.getDocumentScroll = getDocumentScroll;\n\n/**\n * Get a map of all the block's descendants mapping their type to the number of\n *    children with that type.\n * @param {!Block} block The block to map.\n * @param {boolean=} opt_stripFollowing Optionally ignore all following\n *    statements (blocks that are not inside a value or statement input\n *    of the block).\n * @return {!Object} Map of types to type counts for descendants of the bock.\n * @deprecated\n * @alias Blockly.utils.getBlockTypeCounts\n */\nconst getBlockTypeCounts = function(block, opt_stripFollowing) {\n  deprecation.warn(\n      'Blockly.utils.getBlockTypeCounts', 'December 2021', 'December 2022',\n      'Blockly.common.getBlockTypeCounts');\n  return common.getBlockTypeCounts(block, opt_stripFollowing);\n};\nexports.getBlockTypeCounts = getBlockTypeCounts;\n\n/**\n * Converts screen coordinates to workspace coordinates.\n * @param {!WorkspaceSvg} ws The workspace to find the coordinates on.\n * @param {!Coordinate} screenCoordinates The screen coordinates to\n * be converted to workspace coordinates\n * @deprecated\n * @return {!Coordinate} The workspace coordinates.\n */\nconst screenToWsCoordinates = function(ws, screenCoordinates) {\n  deprecation.warn(\n      'Blockly.utils.screenToWsCoordinates', 'December 2021', 'December 2022',\n      'Blockly.utils.svgMath.screenToWsCoordinates');\n  return svgMath.screenToWsCoordinates(ws, screenCoordinates);\n};\nexports.screenToWsCoordinates = screenToWsCoordinates;\n\n/**\n * Parse a block colour from a number or string, as provided in a block\n * definition.\n * @param {number|string} colour HSV hue value (0 to 360), #RRGGBB string,\n *     or a message reference string pointing to one of those two values.\n * @return {{hue: ?number, hex: string}} An object containing the colour as\n *     a #RRGGBB string, and the hue if the input was an HSV hue value.\n * @throws {Error} If the colour cannot be parsed.\n * @deprecated\n * @alias Blockly.utils.parseBlockColour\n */\nconst parseBlockColour = function(colour) {\n  deprecation.warn(\n      'Blockly.utils.parseBlockColour', 'December 2021', 'December 2022',\n      'Blockly.utils.parsing.parseBlockColour');\n  return parsing.parseBlockColour(colour);\n};\nexports.parseBlockColour = parseBlockColour;\n\n/**\n * Calls a function after the page has loaded, possibly immediately.\n * @param {function()} fn Function to run.\n * @throws Error Will throw if no global document can be found (e.g., Node.js).\n * @deprecated\n * @alias Blockly.utils.runAfterPageLoad\n */\nconst runAfterPageLoad = function(fn) {\n  deprecation.warn(\n      'Blockly.utils.runAfterPageLoad', 'December 2021', 'December 2022');\n  extensions.runAfterPageLoad(fn);\n};\nexports.runAfterPageLoad = runAfterPageLoad;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils.js?")},
"./core/utils/aria.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview ARIA-related constants and utilities.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n */\n\n\n/**\n * ARIA-related constants and utilities.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n * @namespace Blockly.utils.aria\n */\ngoog.module('Blockly.utils.aria');\n\n\n/** ARIA states/properties prefix. */\nconst ARIA_PREFIX = 'aria-';\n\n/** ARIA role attribute. */\nconst ROLE_ATTRIBUTE = 'role';\n\n/**\n * ARIA role values.\n * Copied from Closure's goog.a11y.aria.Role\n * @enum {string}\n * @alias Blockly.utils.aria.Role\n */\nconst Role = {\n  // ARIA role for an interactive control of tabular data.\n  GRID: 'grid',\n\n  // ARIA role for a cell in a grid.\n  GRIDCELL: 'gridcell',\n\n  // ARIA role for a group of related elements like tree item siblings.\n  GROUP: 'group',\n\n  // ARIA role for a listbox.\n  LISTBOX: 'listbox',\n\n  // ARIA role for a popup menu.\n  MENU: 'menu',\n\n  // ARIA role for menu item elements.\n  MENUITEM: 'menuitem',\n\n  // ARIA role for a checkbox box element inside a menu.\n  MENUITEMCHECKBOX: 'menuitemcheckbox',\n\n  // ARIA role for option items that are  children of combobox, listbox, menu,\n  // radiogroup, or tree elements.\n  OPTION: 'option',\n\n  // ARIA role for ignorable cosmetic elements with no semantic significance.\n  PRESENTATION: 'presentation',\n\n  // ARIA role for a row of cells in a grid.\n  ROW: 'row',\n\n  // ARIA role for a tree.\n  TREE: 'tree',\n\n  // ARIA role for a tree item that sometimes may be expanded or collapsed.\n  TREEITEM: 'treeitem',\n};\nexports.Role = Role;\n\n/**\n * ARIA states and properties.\n * Copied from Closure's goog.a11y.aria.State\n * @enum {string}\n * @alias Blockly.utils.aria.State\n */\nconst State = {\n  // ARIA property for setting the currently active descendant of an element,\n  // for example the selected item in a list box. Value: ID of an element.\n  ACTIVEDESCENDANT: 'activedescendant',\n\n  // ARIA property defines the total number of columns in a table, grid, or\n  // treegrid.\n  // Value: integer.\n  COLCOUNT: 'colcount',\n\n  // ARIA state for a disabled item. Value: one of {true, false}.\n  DISABLED: 'disabled',\n\n  // ARIA state for setting whether the element like a tree node is expanded.\n  // Value: one of {true, false, undefined}.\n  EXPANDED: 'expanded',\n\n  // ARIA state indicating that the entered value does not conform. Value:\n  // one of {false, true, 'grammar', 'spelling'}\n  INVALID: 'invalid',\n\n  // ARIA property that provides a label to override any other text, value, or\n  // contents used to describe this element. Value: string.\n  LABEL: 'label',\n\n  // ARIA property for setting the element which labels another element.\n  // Value: space-separated IDs of elements.\n  LABELLEDBY: 'labelledby',\n\n  // ARIA property for setting the level of an element in the hierarchy.\n  // Value: integer.\n  LEVEL: 'level',\n\n  // ARIA property indicating if the element is horizontal or vertical.\n  // Value: one of {'vertical', 'horizontal'}.\n  ORIENTATION: 'orientation',\n\n  // ARIA property that defines an element's number of position in a list.\n  // Value: integer.\n  POSINSET: 'posinset',\n\n  // ARIA property defines the total number of rows in a table, grid, or\n  // treegrid.\n  // Value: integer.\n  ROWCOUNT: 'rowcount',\n\n  // ARIA state for setting the currently selected item in the list.\n  // Value: one of {true, false, undefined}.\n  SELECTED: 'selected',\n\n  // ARIA property defining the number of items in a list. Value: integer.\n  SETSIZE: 'setsize',\n\n  // ARIA property for slider maximum value. Value: number.\n  VALUEMAX: 'valuemax',\n\n  // ARIA property for slider minimum value. Value: number.\n  VALUEMIN: 'valuemin',\n};\nexports.State = State;\n\n/**\n * Sets the role of an element.\n *\n * Similar to Closure's goog.a11y.aria\n *\n * @param {!Element} element DOM node to set role of.\n * @param {!Role} roleName Role name.\n * @alias Blockly.utils.aria.setRole\n */\nconst setRole = function(element, roleName) {\n  element.setAttribute(ROLE_ATTRIBUTE, roleName);\n};\nexports.setRole = setRole;\n\n/**\n * Sets the state or property of an element.\n * Copied from Closure's goog.a11y.aria\n * @param {!Element} element DOM node where we set state.\n * @param {!State} stateName State attribute being set.\n *     Automatically adds prefix 'aria-' to the state name if the attribute is\n *     not an extra attribute.\n * @param {string|boolean|number|!Array<string>} value Value\n * for the state attribute.\n * @alias Blockly.utils.aria.setState\n */\nconst setState = function(element, stateName, value) {\n  if (Array.isArray(value)) {\n    value = value.join(' ');\n  }\n  const attrStateName = ARIA_PREFIX + stateName;\n  element.setAttribute(attrStateName, value);\n};\nexports.setState = setState;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/aria.js?")},
"./core/utils/array.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility methods related to arrays.\n */\n\n\n/**\n * @namespace Blockly.utils.array\n */\ngoog.module('Blockly.utils.array');\n\n\n/**\n * Removes the first occurrence of a particular value from an array.\n * @param {!Array} arr Array from which to remove value.\n * @param {*} value Value to remove.\n * @return {boolean} True if an element was removed.\n * @alias Blockly.array.removeElem\n * @package\n */\nconst removeElem = function(arr, value) {\n  const i = arr.indexOf(value);\n  if (i === -1) {\n    return false;\n  }\n  arr.splice(i, 1);\n  return true;\n};\nexports.removeElem = removeElem;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/array.js?")},
"./core/utils/colour.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility methods for colour manipulation.\n */\n\n\n/**\n * Utility methods for colour manipulation.\n * @namespace Blockly.utils.colour\n */\ngoog.module('Blockly.utils.colour');\n\n/**\n * The richness of block colours, regardless of the hue.\n * Must be in the range of 0 (inclusive) to 1 (exclusive).\n * @alias Blockly.utils.colour.hsvSaturation\n * @package\n */\nlet hsvSaturation = 0.45;\n\n/**\n * Get the richness of block colours, regardless of the hue.\n * @alias Blockly.utils.colour.getHsvSaturation\n * @return {number} The current richness.\n * @package\n */\nconst getHsvSaturation = function() {\n  return hsvSaturation;\n};\nexports.getHsvSaturation = getHsvSaturation;\n\n/**\n * Set the richness of block colours, regardless of the hue.\n * @param {number} newSaturation The new richness, in the range of  0\n *     (inclusive) to 1 (exclusive)\n * @alias Blockly.utils.colour.setHsvSaturation\n * @package\n */\nconst setHsvSaturation = function(newSaturation) {\n  hsvSaturation = newSaturation;\n};\nexports.setHsvSaturation = setHsvSaturation;\n\n/**\n * The intensity of block colours, regardless of the hue.\n * Must be in the range of 0 (inclusive) to 1 (exclusive).\n * @alias Blockly.utils.colour.hsvValue\n * @package\n */\nlet hsvValue = 0.65;\n\n/**\n * Get the intensity of block colours, regardless of the hue.\n * @alias Blockly.utils.colour.getHsvValue\n * @return {number} The current intensity.\n * @package\n */\nconst getHsvValue = function() {\n  return hsvValue;\n};\nexports.getHsvValue = getHsvValue;\n\n/**\n * Set the intensity of block colours, regardless of the hue.\n * @param {number} newValue The new intensity, in the range of  0\n *     (inclusive) to 1 (exclusive)\n * @alias Blockly.utils.colour.setHsvValue\n * @package\n */\nconst setHsvValue = function(newValue) {\n  hsvValue = newValue;\n};\nexports.setHsvValue = setHsvValue;\n\n/**\n * Parses a colour from a string.\n * .parse('red') -> '#ff0000'\n * .parse('#f00') -> '#ff0000'\n * .parse('#ff0000') -> '#ff0000'\n * .parse('0xff0000') -> '#ff0000'\n * .parse('rgb(255, 0, 0)') -> '#ff0000'\n * @param {string|number} str Colour in some CSS format.\n * @return {?string} A string containing a hex representation of the colour,\n *   or null if can't be parsed.\n * @alias Blockly.utils.colour.parse\n */\nconst parse = function(str) {\n  str = String(str).toLowerCase().trim();\n  let hex = names[str];\n  if (hex) {\n    // e.g. 'red'\n    return hex;\n  }\n  hex = str.substring(0, 2) === '0x' ? '#' + str.substring(2) : str;\n  hex = hex[0] === '#' ? hex : '#' + hex;\n  if (/^#[0-9a-f]{6}$/.test(hex)) {\n    // e.g. '#00ff88'\n    return hex;\n  }\n  if (/^#[0-9a-f]{3}$/.test(hex)) {\n    // e.g. '#0f8'\n    return ['#', hex[1], hex[1], hex[2], hex[2], hex[3], hex[3]].join('');\n  }\n  const rgb = str.match(/^(?:rgb)?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/);\n  if (rgb) {\n    // e.g. 'rgb(0, 128, 255)'\n    const r = Number(rgb[1]);\n    const g = Number(rgb[2]);\n    const b = Number(rgb[3]);\n    if (r >= 0 && r < 256 && g >= 0 && g < 256 && b >= 0 && b < 256) {\n      return rgbToHex(r, g, b);\n    }\n  }\n  return null;\n};\nexports.parse = parse;\n\n/**\n * Converts a colour from RGB to hex representation.\n * @param {number} r Amount of red, int between 0 and 255.\n * @param {number} g Amount of green, int between 0 and 255.\n * @param {number} b Amount of blue, int between 0 and 255.\n * @return {string} Hex representation of the colour.\n * @alias Blockly.utils.colour.rgbToHex\n */\nconst rgbToHex = function(r, g, b) {\n  const rgb = (r << 16) | (g << 8) | b;\n  if (r < 0x10) {\n    return '#' + (0x1000000 | rgb).toString(16).substr(1);\n  }\n  return '#' + rgb.toString(16);\n};\nexports.rgbToHex = rgbToHex;\n\n/**\n * Converts a colour to RGB.\n * @param {string} colour String representing colour in any\n *     colour format ('#ff0000', 'red', '0xff000', etc).\n * @return {!Array<number>} RGB representation of the colour.\n * @alias Blockly.utils.colour.hexToRgb\n */\nconst hexToRgb = function(colour) {\n  const hex = parse(colour);\n  if (!hex) {\n    return [0, 0, 0];\n  }\n\n  const rgb = parseInt(hex.substr(1), 16);\n  const r = rgb >> 16;\n  const g = (rgb >> 8) & 255;\n  const b = rgb & 255;\n\n  return [r, g, b];\n};\nexports.hexToRgb = hexToRgb;\n\n/**\n * Converts an HSV triplet to hex representation.\n * @param {number} h Hue value in [0, 360].\n * @param {number} s Saturation value in [0, 1].\n * @param {number} v Brightness in [0, 255].\n * @return {string} Hex representation of the colour.\n * @alias Blockly.utils.colour.hsvToHex\n */\nconst hsvToHex = function(h, s, v) {\n  let red = 0;\n  let green = 0;\n  let blue = 0;\n  if (s === 0) {\n    red = v;\n    green = v;\n    blue = v;\n  } else {\n    const sextant = Math.floor(h / 60);\n    const remainder = (h / 60) - sextant;\n    const val1 = v * (1 - s);\n    const val2 = v * (1 - (s * remainder));\n    const val3 = v * (1 - (s * (1 - remainder)));\n    switch (sextant) {\n      case 1:\n        red = val2;\n        green = v;\n        blue = val1;\n        break;\n      case 2:\n        red = val1;\n        green = v;\n        blue = val3;\n        break;\n      case 3:\n        red = val1;\n        green = val2;\n        blue = v;\n        break;\n      case 4:\n        red = val3;\n        green = val1;\n        blue = v;\n        break;\n      case 5:\n        red = v;\n        green = val1;\n        blue = val2;\n        break;\n      case 6:\n      case 0:\n        red = v;\n        green = val3;\n        blue = val1;\n        break;\n    }\n  }\n  return rgbToHex(Math.floor(red), Math.floor(green), Math.floor(blue));\n};\nexports.hsvToHex = hsvToHex;\n\n/**\n * Blend two colours together, using the specified factor to indicate the\n * weight given to the first colour.\n * @param {string} colour1 First colour.\n * @param {string} colour2 Second colour.\n * @param {number} factor The weight to be given to colour1 over colour2.\n *     Values should be in the range [0, 1].\n * @return {?string} Combined colour represented in hex.\n * @alias Blockly.utils.colour.blend\n */\nconst blend = function(colour1, colour2, factor) {\n  const hex1 = parse(colour1);\n  if (!hex1) {\n    return null;\n  }\n  const hex2 = parse(colour2);\n  if (!hex2) {\n    return null;\n  }\n  const rgb1 = hexToRgb(hex1);\n  const rgb2 = hexToRgb(hex2);\n  const r = Math.round(rgb2[0] + factor * (rgb1[0] - rgb2[0]));\n  const g = Math.round(rgb2[1] + factor * (rgb1[1] - rgb2[1]));\n  const b = Math.round(rgb2[2] + factor * (rgb1[2] - rgb2[2]));\n  return rgbToHex(r, g, b);\n};\nexports.blend = blend;\n\n/**\n * A map that contains the 16 basic colour keywords as defined by W3C:\n * https://www.w3.org/TR/2018/REC-css-color-3-20180619/#html4\n * The keys of this map are the lowercase \"readable\" names of the colours,\n * while the values are the \"hex\" values.\n *\n * @type {!Object<string, string>}\n * @alias Blockly.utils.colour.names\n */\nconst names = {\n  'aqua': '#00ffff',\n  'black': '#000000',\n  'blue': '#0000ff',\n  'fuchsia': '#ff00ff',\n  'gray': '#808080',\n  'green': '#008000',\n  'lime': '#00ff00',\n  'maroon': '#800000',\n  'navy': '#000080',\n  'olive': '#808000',\n  'purple': '#800080',\n  'red': '#ff0000',\n  'silver': '#c0c0c0',\n  'teal': '#008080',\n  'white': '#ffffff',\n  'yellow': '#ffff00',\n};\nexports.names = names;\n\n/**\n * Convert a hue (HSV model) into an RGB hex triplet.\n * @param {number} hue Hue on a colour wheel (0-360).\n * @return {string} RGB code, e.g. '#5ba65b'.\n * @alias Blockly.utils.colour.hueToHex\n */\nconst hueToHex = function(hue) {\n  return hsvToHex(hue, hsvSaturation, hsvValue * 255);\n};\nexports.hueToHex = hueToHex;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/colour.js?")},
"./core/utils/coordinate.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility methods for coordinate manipulation.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n */\n\n\n/**\n * Utility methods for coordinate manipulation.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n * @class\n */\ngoog.module('Blockly.utils.Coordinate');\n\n/**\n * Class for representing coordinates and positions.\n * @alias Blockly.utils.Coordinate\n */\nconst Coordinate = class {\n  /**\n   * @param {number} x Left.\n   * @param {number} y Top.\n   */\n  constructor(x, y) {\n    /**\n     * X-value\n     * @type {number}\n     */\n    this.x = x;\n\n    /**\n     * Y-value\n     * @type {number}\n     */\n    this.y = y;\n  }\n\n  /**\n   * Creates a new copy of this coordinate.\n   * @return {!Coordinate} A copy of this coordinate.\n   */\n  clone() {\n    return new Coordinate(this.x, this.y);\n  }\n\n  /**\n   * Scales this coordinate by the given scale factor.\n   * @param {number} s The scale factor to use for both x and y dimensions.\n   * @return {!Coordinate} This coordinate after scaling.\n   */\n  scale(s) {\n    this.x *= s;\n    this.y *= s;\n    return this;\n  }\n\n  /**\n   * Translates this coordinate by the given offsets.\n   * respectively.\n   * @param {number} tx The value to translate x by.\n   * @param {number} ty The value to translate y by.\n   * @return {!Coordinate} This coordinate after translating.\n   */\n  translate(tx, ty) {\n    this.x += tx;\n    this.y += ty;\n    return this;\n  }\n\n  /**\n   * Compares coordinates for equality.\n   * @param {?Coordinate} a A Coordinate.\n   * @param {?Coordinate} b A Coordinate.\n   * @return {boolean} True iff the coordinates are equal, or if both are null.\n   */\n  static equals(a, b) {\n    if (a === b) {\n      return true;\n    }\n    if (!a || !b) {\n      return false;\n    }\n    return a.x === b.x && a.y === b.y;\n  }\n\n  /**\n   * Returns the distance between two coordinates.\n   * @param {!Coordinate} a A Coordinate.\n   * @param {!Coordinate} b A Coordinate.\n   * @return {number} The distance between `a` and `b`.\n   */\n  static distance(a, b) {\n    const dx = a.x - b.x;\n    const dy = a.y - b.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  /**\n   * Returns the magnitude of a coordinate.\n   * @param {!Coordinate} a A Coordinate.\n   * @return {number} The distance between the origin and `a`.\n   */\n  static magnitude(a) {\n    return Math.sqrt(a.x * a.x + a.y * a.y);\n  }\n\n  /**\n   * Returns the difference between two coordinates as a new\n   * Coordinate.\n   * @param {!Coordinate|!SVGPoint} a An x/y coordinate.\n   * @param {!Coordinate|!SVGPoint} b An x/y coordinate.\n   * @return {!Coordinate} A Coordinate representing the difference\n   *     between `a` and `b`.\n   */\n  static difference(a, b) {\n    return new Coordinate(a.x - b.x, a.y - b.y);\n  }\n\n  /**\n   * Returns the sum of two coordinates as a new Coordinate.\n   * @param {!Coordinate|!SVGPoint} a An x/y coordinate.\n   * @param {!Coordinate|!SVGPoint} b An x/y coordinate.\n   * @return {!Coordinate} A Coordinate representing the sum of\n   *     the two coordinates.\n   */\n  static sum(a, b) {\n    return new Coordinate(a.x + b.x, a.y + b.y);\n  }\n};\n\nexports.Coordinate = Coordinate;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/coordinate.js?")},
"./core/utils/deprecation.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Helper function for warning developers about deprecations.\n * This method is not specific to Blockly.\n */\n\n\n/**\n * Helper function for warning developers about deprecations.\n * This method is not specific to Blockly.\n * @namespace Blockly.utils.deprecation\n */\ngoog.module('Blockly.utils.deprecation');\n\n\n/**\n * Warn developers that a function or property is deprecated.\n * @param {string} name The name of the function or property.\n * @param {string} deprecationDate The date of deprecation.\n *     Prefer 'month yyyy' or 'quarter yyyy' format.\n * @param {string} deletionDate The date of deletion, in the same format as the\n *     deprecation date.\n * @param {string=} opt_use The name of a function or property to use instead,\n *     if any.\n * @alias Blockly.utils.deprecation.warn\n * @package\n */\nconst warn = function(name, deprecationDate, deletionDate, opt_use) {\n  let msg = name + ' was deprecated on ' + deprecationDate +\n      ' and will be deleted on ' + deletionDate + '.';\n  if (opt_use) {\n    msg += '\\nUse ' + opt_use + ' instead.';\n  }\n  console.warn(msg);\n};\nexports.warn = warn;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/deprecation.js?")},
"./core/utils/dom.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility methods for DOM manipulation.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n */\n\n\n/**\n * Utility methods for DOM manipulation.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n * @namespace Blockly.utils.dom\n */\ngoog.module('Blockly.utils.dom');\n\nconst userAgent = goog.require('Blockly.utils.userAgent');\n/* eslint-disable-next-line no-unused-vars */\nconst {Svg} = goog.requireType('Blockly.utils.Svg');\n\n\n/**\n * Required name space for SVG elements.\n * @const\n * @alias Blockly.utils.dom.SVG_NS\n */\nconst SVG_NS = 'http://www.w3.org/2000/svg';\nexports.SVG_NS = SVG_NS;\n\n/**\n * Required name space for HTML elements.\n * @const\n * @alias Blockly.utils.dom.HTML_NS\n */\nconst HTML_NS = 'http://www.w3.org/1999/xhtml';\nexports.HTML_NS = HTML_NS;\n\n/**\n * Required name space for XLINK elements.\n * @const\n * @alias Blockly.utils.dom.XLINK_NS\n */\nconst XLINK_NS = 'http://www.w3.org/1999/xlink';\nexports.XLINK_NS = XLINK_NS;\n\n/**\n * Node type constants.\n * https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n * @enum {number}\n * @alias Blockly.utils.dom.NodeType\n */\nconst NodeType = {\n  ELEMENT_NODE: 1,\n  TEXT_NODE: 3,\n  COMMENT_NODE: 8,\n  DOCUMENT_POSITION_CONTAINED_BY: 16,\n};\nexports.NodeType = NodeType;\n\n/**\n * Temporary cache of text widths.\n * @type {Object}\n * @private\n */\nlet cacheWidths = null;\n\n/**\n * Number of current references to cache.\n * @type {number}\n * @private\n */\nlet cacheReference = 0;\n\n/**\n * A HTML canvas context used for computing text width.\n * @type {CanvasRenderingContext2D}\n * @private\n */\nlet canvasContext = null;\n\n/**\n * Helper method for creating SVG elements.\n * @param {string|Svg<T>} name Element's tag name.\n * @param {!Object} attrs Dictionary of attribute names and values.\n * @param {Element=} opt_parent Optional parent on which to append the element.\n * @return {T} Newly created SVG element.  The return type is {!SVGElement} if\n *     name is a string or a more specific type if it a member of Svg.\n * @template T\n * @alias Blockly.utils.dom.createSvgElement\n */\nconst createSvgElement = function(name, attrs, opt_parent) {\n  const e = /** @type {T} */\n      (document.createElementNS(SVG_NS, String(name)));\n  for (const key in attrs) {\n    e.setAttribute(key, attrs[key]);\n  }\n  // IE defines a unique attribute \"runtimeStyle\", it is NOT applied to\n  // elements created with createElementNS. However, Closure checks for IE\n  // and assumes the presence of the attribute and crashes.\n  if (document.body.runtimeStyle) {  // Indicates presence of IE-only attr.\n    e.runtimeStyle = e.currentStyle = e.style;\n  }\n  if (opt_parent) {\n    opt_parent.appendChild(e);\n  }\n  return e;\n};\nexports.createSvgElement = createSvgElement;\n\n/**\n * Add a CSS class to a element.\n * Similar to Closure's goog.dom.classes.add, except it handles SVG elements.\n * @param {!Element} element DOM element to add class to.\n * @param {string} className Name of class to add.\n * @return {boolean} True if class was added, false if already present.\n * @alias Blockly.utils.dom.addClass\n */\nconst addClass = function(element, className) {\n  let classes = element.getAttribute('class') || '';\n  if ((' ' + classes + ' ').indexOf(' ' + className + ' ') !== -1) {\n    return false;\n  }\n  if (classes) {\n    classes += ' ';\n  }\n  element.setAttribute('class', classes + className);\n  return true;\n};\nexports.addClass = addClass;\n\n/**\n * Removes multiple calsses from an element.\n * @param {!Element} element DOM element to remove classes from.\n * @param {string} classNames A string of one or multiple class names for an\n *    element.\n * @alias Blockly.utils.dom.removeClasses\n */\nconst removeClasses = function(element, classNames) {\n  const classList = classNames.split(' ');\n  for (let i = 0; i < classList.length; i++) {\n    removeClass(element, classList[i]);\n  }\n};\nexports.removeClasses = removeClasses;\n\n/**\n * Remove a CSS class from a element.\n * Similar to Closure's goog.dom.classes.remove, except it handles SVG elements.\n * @param {!Element} element DOM element to remove class from.\n * @param {string} className Name of class to remove.\n * @return {boolean} True if class was removed, false if never present.\n * @alias Blockly.utils.dom.removeClass\n */\nconst removeClass = function(element, className) {\n  const classes = element.getAttribute('class');\n  if ((' ' + classes + ' ').indexOf(' ' + className + ' ') === -1) {\n    return false;\n  }\n  const classList = classes.split(/\\s+/);\n  for (let i = 0; i < classList.length; i++) {\n    if (!classList[i] || classList[i] === className) {\n      classList.splice(i, 1);\n      i--;\n    }\n  }\n  if (classList.length) {\n    element.setAttribute('class', classList.join(' '));\n  } else {\n    element.removeAttribute('class');\n  }\n  return true;\n};\nexports.removeClass = removeClass;\n\n/**\n * Checks if an element has the specified CSS class.\n * Similar to Closure's goog.dom.classes.has, except it handles SVG elements.\n * @param {!Element} element DOM element to check.\n * @param {string} className Name of class to check.\n * @return {boolean} True if class exists, false otherwise.\n * @alias Blockly.utils.dom.hasClass\n */\nconst hasClass = function(element, className) {\n  const classes = element.getAttribute('class');\n  return (' ' + classes + ' ').indexOf(' ' + className + ' ') !== -1;\n};\nexports.hasClass = hasClass;\n\n/**\n * Removes a node from its parent. No-op if not attached to a parent.\n * @param {?Node} node The node to remove.\n * @return {?Node} The node removed if removed; else, null.\n * @alias Blockly.utils.dom.removeNode\n */\n// Copied from Closure goog.dom.removeNode\nconst removeNode = function(node) {\n  return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n};\nexports.removeNode = removeNode;\n\n/**\n * Insert a node after a reference node.\n * Contrast with node.insertBefore function.\n * @param {!Element} newNode New element to insert.\n * @param {!Element} refNode Existing element to precede new node.\n * @alias Blockly.utils.dom.insertAfter\n */\nconst insertAfter = function(newNode, refNode) {\n  const siblingNode = refNode.nextSibling;\n  const parentNode = refNode.parentNode;\n  if (!parentNode) {\n    throw Error('Reference node has no parent.');\n  }\n  if (siblingNode) {\n    parentNode.insertBefore(newNode, siblingNode);\n  } else {\n    parentNode.appendChild(newNode);\n  }\n};\nexports.insertAfter = insertAfter;\n\n/**\n * Whether a node contains another node.\n * @param {!Node} parent The node that should contain the other node.\n * @param {!Node} descendant The node to test presence of.\n * @return {boolean} Whether the parent node contains the descendant node.\n * @alias Blockly.utils.dom.containsNode\n */\nconst containsNode = function(parent, descendant) {\n  return !!(\n      parent.compareDocumentPosition(descendant) &\n      NodeType.DOCUMENT_POSITION_CONTAINED_BY);\n};\nexports.containsNode = containsNode;\n\n/**\n * Sets the CSS transform property on an element. This function sets the\n * non-vendor-prefixed and vendor-prefixed versions for backwards compatibility\n * with older browsers. See https://caniuse.com/#feat=transforms2d\n * @param {!Element} element Element to which the CSS transform will be applied.\n * @param {string} transform The value of the CSS `transform` property.\n * @alias Blockly.utils.dom.setCssTransform\n */\nconst setCssTransform = function(element, transform) {\n  element.style['transform'] = transform;\n  element.style['-webkit-transform'] = transform;\n};\nexports.setCssTransform = setCssTransform;\n\n/**\n * Start caching text widths. Every call to this function MUST also call\n * stopTextWidthCache. Caches must not survive between execution threads.\n * @alias Blockly.utils.dom.startTextWidthCache\n */\nconst startTextWidthCache = function() {\n  cacheReference++;\n  if (!cacheWidths) {\n    cacheWidths = Object.create(null);\n  }\n};\nexports.startTextWidthCache = startTextWidthCache;\n\n/**\n * Stop caching field widths. Unless caching was already on when the\n * corresponding call to startTextWidthCache was made.\n * @alias Blockly.utils.dom.stopTextWidthCache\n */\nconst stopTextWidthCache = function() {\n  cacheReference--;\n  if (!cacheReference) {\n    cacheWidths = null;\n  }\n};\nexports.stopTextWidthCache = stopTextWidthCache;\n\n/**\n * Gets the width of a text element, caching it in the process.\n * @param {!Element} textElement An SVG 'text' element.\n * @return {number} Width of element.\n * @alias Blockly.utils.dom.getTextWidth\n */\nconst getTextWidth = function(textElement) {\n  const key = textElement.textContent + '\\n' + textElement.className.baseVal;\n  let width;\n\n  // Return the cached width if it exists.\n  if (cacheWidths) {\n    width = cacheWidths[key];\n    if (width) {\n      return width;\n    }\n  }\n\n  // Attempt to compute fetch the width of the SVG text element.\n  try {\n    if (userAgent.IE || userAgent.EDGE) {\n      width = textElement.getBBox().width;\n    } else {\n      width = textElement.getComputedTextLength();\n    }\n  } catch (e) {\n    // In other cases where we fail to get the computed text. Instead, use an\n    // approximation and do not cache the result. At some later point in time\n    // when the block is inserted into the visible DOM, this method will be\n    // called again and, at that point in time, will not throw an exception.\n    return textElement.textContent.length * 8;\n  }\n\n  // Cache the computed width and return.\n  if (cacheWidths) {\n    cacheWidths[key] = width;\n  }\n  return width;\n};\nexports.getTextWidth = getTextWidth;\n\n/**\n * Gets the width of a text element using a faster method than `getTextWidth`.\n * This method requires that we know the text element's font family and size in\n * advance. Similar to `getTextWidth`, we cache the width we compute.\n * @param {!Element} textElement An SVG 'text' element.\n * @param {number} fontSize The font size to use.\n * @param {string} fontWeight The font weight to use.\n * @param {string} fontFamily The font family to use.\n * @return {number} Width of element.\n * @alias Blockly.utils.dom.getFastTextWidth\n */\nconst getFastTextWidth = function(\n    textElement, fontSize, fontWeight, fontFamily) {\n  return getFastTextWidthWithSizeString(\n      textElement, fontSize + 'pt', fontWeight, fontFamily);\n};\nexports.getFastTextWidth = getFastTextWidth;\n\n/**\n * Gets the width of a text element using a faster method than `getTextWidth`.\n * This method requires that we know the text element's font family and size in\n * advance. Similar to `getTextWidth`, we cache the width we compute.\n * This method is similar to ``getFastTextWidth`` but expects the font size\n * parameter to be a string.\n * @param {!Element} textElement An SVG 'text' element.\n * @param {string} fontSize The font size to use.\n * @param {string} fontWeight The font weight to use.\n * @param {string} fontFamily The font family to use.\n * @return {number} Width of element.\n * @alias Blockly.utils.dom.getFastTextWidthWithSizeString\n */\nconst getFastTextWidthWithSizeString = function(\n    textElement, fontSize, fontWeight, fontFamily) {\n  const text = textElement.textContent;\n  const key = text + '\\n' + textElement.className.baseVal;\n  let width;\n\n  // Return the cached width if it exists.\n  if (cacheWidths) {\n    width = cacheWidths[key];\n    if (width) {\n      return width;\n    }\n  }\n\n  if (!canvasContext) {\n    // Inject the canvas element used for computing text widths.\n    const computeCanvas = document.createElement('canvas');\n    computeCanvas.className = 'blocklyComputeCanvas';\n    document.body.appendChild(computeCanvas);\n\n    // Initialize the HTML canvas context and set the font.\n    // The context font must match blocklyText's fontsize and font-family\n    // set in CSS.\n    canvasContext = computeCanvas.getContext('2d');\n  }\n  // Set the desired font size and family.\n  canvasContext.font = fontWeight + ' ' + fontSize + ' ' + fontFamily;\n\n  // Measure the text width using the helper canvas context.\n  width = canvasContext.measureText(text).width;\n\n  // Cache the computed width and return.\n  if (cacheWidths) {\n    cacheWidths[key] = width;\n  }\n  return width;\n};\nexports.getFastTextWidthWithSizeString = getFastTextWidthWithSizeString;\n\n/**\n * Measure a font's metrics. The height and baseline values.\n * @param {string} text Text to measure the font dimensions of.\n * @param {string} fontSize The font size to use.\n * @param {string} fontWeight The font weight to use.\n * @param {string} fontFamily The font family to use.\n * @return {{height: number, baseline: number}} Font measurements.\n * @alias Blockly.utils.dom.measureFontMetrics\n */\nconst measureFontMetrics = function(text, fontSize, fontWeight, fontFamily) {\n  const span = document.createElement('span');\n  span.style.font = fontWeight + ' ' + fontSize + ' ' + fontFamily;\n  span.textContent = text;\n\n  const block = /** @type {!HTMLDivElement} */ (document.createElement('div'));\n  block.style.width = '1px';\n  block.style.height = 0;\n\n  const div = /** @type {!HTMLDivElement} */ (document.createElement('div'));\n  div.setAttribute('style', 'position: fixed; top: 0; left: 0; display: flex;');\n  div.appendChild(span);\n  div.appendChild(block);\n\n  document.body.appendChild(div);\n  const result = {\n    height: 0,\n    baseline: 0,\n  };\n  try {\n    div.style.alignItems = 'baseline';\n    result.baseline = block.offsetTop - span.offsetTop;\n    div.style.alignItems = 'flex-end';\n    result.height = block.offsetTop - span.offsetTop;\n  } finally {\n    document.body.removeChild(div);\n  }\n  return result;\n};\nexports.measureFontMetrics = measureFontMetrics;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/dom.js?")},
"./core/utils/global.js":function(c,a,b){eval("/* WEBPACK VAR INJECTION */(function(global) {__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Provides a reference to the global object.\n */\n\n\n/**\n * Provides a reference to the global object.\n * @namespace Blockly.utils.global\n */\ngoog.module('Blockly.utils.global');\n\n\n/* eslint-disable no-undef, no-invalid-this */\n\n/**\n * Reference to the global object.\n *\n * More info on this implementation here:\n * https://docs.google.com/document/d/1NAeW4Wk7I7FV0Y2tcUFvQdGMc89k2vdgSXInw8_nvCI\n */\nexports.globalThis = (function() {  // Not \"let globalThis\" to avoid shadowing.\n  if (typeof globalThis === 'object') {\n    return globalThis;\n  }\n  if (typeof self === 'object') {\n    return self;\n  }\n  if (typeof window === 'object') {\n    return window;\n  }\n  if (typeof global === 'object') {\n    return global;\n  }\n  return this;\n})();\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./core/utils/global.js?")},
"./core/utils/idgenerator.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Generators for unique IDs.\n */\n\n\n/**\n * Generators for unique IDs.\n * @namespace Blockly.utils.idGenerator\n */\ngoog.module('Blockly.utils.idGenerator');\n\n\n/**\n * Namespace object for internal implementations we want to be able to\n * stub in tests.\n * @ignore\n */\nconst internal = {};\nexports.TEST_ONLY = internal;\n\n/**\n * Next unique ID to use.\n * @type {number}\n */\nlet nextId = 0;\n\n/**\n * Generate the next unique element IDs.\n * IDs are compatible with the HTML4 id attribute restrictions:\n * Use only ASCII letters, digits, '_', '-' and '.'\n *\n * For UUIDs use genUid (below) instead; this ID generator should\n * primarily be used for IDs that end up in the DOM.\n *\n * @return {string} The next unique identifier.\n * @alias Blockly.utils.idGenerator.getNextUniqueId\n */\nconst getNextUniqueId = function() {\n  return 'blockly-' + (nextId++).toString(36);\n};\nexports.getNextUniqueId = getNextUniqueId;\n\n/**\n * Legal characters for the universally unique IDs.  Should be all on\n * a US keyboard.  No characters that conflict with XML or JSON.\n * Requests to remove additional 'problematic' characters from this\n * soup will be denied.  That's your failure to properly escape in\n * your own environment.  Issues #251, #625, #682, #1304.\n */\nconst soup = '!#$%()*+,-./:;=?@[]^_`{|}~' +\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\n/**\n * Generate a random unique ID.  This should be globally unique.\n * 87 characters ^ 20 length > 128 bits (better than a UUID).\n * @return {string} A globally unique ID string.\n */\ninternal.genUid = function() {\n  const length = 20;\n  const soupLength = soup.length;\n  const id = [];\n  for (let i = 0; i < length; i++) {\n    id[i] = soup.charAt(Math.random() * soupLength);\n  }\n  return id.join('');\n};\n\n/**\n * Generate a random unique ID.\n * @see internal.genUid\n * @return {string} A globally unique ID string.\n * @alias Blockly.utils.idGenerator.genUid\n */\nconst genUid = function() {\n  return internal.genUid();\n};\nexports.genUid = genUid;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/idgenerator.js?")},
"./core/utils/keycodes.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Constant declarations for common key codes.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n */\n\n\n/**\n * Constant declarations for common key codes.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n * @namespace Blockly.utils.KeyCodes\n */\ngoog.module('Blockly.utils.KeyCodes');\n\n\n/**\n * Key codes for common characters.\n *\n * Copied from Closure's goog.events.KeyCodes\n *\n * This list is not localized and therefore some of the key codes are not\n * correct for non US keyboard layouts. See comments below.\n *\n * @enum {number}\n * @alias Blockly.utils.KeyCodes\n */\nconst KeyCodes = {\n  WIN_KEY_FF_LINUX: 0,\n  MAC_ENTER: 3,\n  BACKSPACE: 8,\n  TAB: 9,\n  NUM_CENTER: 12,  // NUMLOCK on FF/Safari Mac\n  ENTER: 13,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  PAUSE: 19,\n  CAPS_LOCK: 20,\n  ESC: 27,\n  SPACE: 32,\n  PAGE_UP: 33,    // also NUM_NORTH_EAST\n  PAGE_DOWN: 34,  // also NUM_SOUTH_EAST\n  END: 35,        // also NUM_SOUTH_WEST\n  HOME: 36,       // also NUM_NORTH_WEST\n  LEFT: 37,       // also NUM_WEST\n  UP: 38,         // also NUM_NORTH\n  RIGHT: 39,      // also NUM_EAST\n  DOWN: 40,       // also NUM_SOUTH\n  PLUS_SIGN: 43,  // NOT numpad plus\n  PRINT_SCREEN: 44,\n  INSERT: 45,  // also NUM_INSERT\n  DELETE: 46,  // also NUM_DELETE\n  ZERO: 48,\n  ONE: 49,\n  TWO: 50,\n  THREE: 51,\n  FOUR: 52,\n  FIVE: 53,\n  SIX: 54,\n  SEVEN: 55,\n  EIGHT: 56,\n  NINE: 57,\n  FF_SEMICOLON: 59,  // Firefox (Gecko) fires this for semicolon instead of 186\n  FF_EQUALS: 61,     // Firefox (Gecko) fires this for equals instead of 187\n  FF_DASH: 173,      // Firefox (Gecko) fires this for dash instead of 189\n  // Firefox (Gecko) fires this for # on UK keyboards, rather than\n  // Shift+SINGLE_QUOTE.\n  FF_HASH: 163,\n  QUESTION_MARK: 63,  // needs localization\n  AT_SIGN: 64,\n  A: 65,\n  B: 66,\n  C: 67,\n  D: 68,\n  E: 69,\n  F: 70,\n  G: 71,\n  H: 72,\n  I: 73,\n  J: 74,\n  K: 75,\n  L: 76,\n  M: 77,\n  N: 78,\n  O: 79,\n  P: 80,\n  Q: 81,\n  R: 82,\n  S: 83,\n  T: 84,\n  U: 85,\n  V: 86,\n  W: 87,\n  X: 88,\n  Y: 89,\n  Z: 90,\n  META: 91,  // WIN_KEY_LEFT\n  WIN_KEY_RIGHT: 92,\n  CONTEXT_MENU: 93,\n  NUM_ZERO: 96,\n  NUM_ONE: 97,\n  NUM_TWO: 98,\n  NUM_THREE: 99,\n  NUM_FOUR: 100,\n  NUM_FIVE: 101,\n  NUM_SIX: 102,\n  NUM_SEVEN: 103,\n  NUM_EIGHT: 104,\n  NUM_NINE: 105,\n  NUM_MULTIPLY: 106,\n  NUM_PLUS: 107,\n  NUM_MINUS: 109,\n  NUM_PERIOD: 110,\n  NUM_DIVISION: 111,\n  F1: 112,\n  F2: 113,\n  F3: 114,\n  F4: 115,\n  F5: 116,\n  F6: 117,\n  F7: 118,\n  F8: 119,\n  F9: 120,\n  F10: 121,\n  F11: 122,\n  F12: 123,\n  NUMLOCK: 144,\n  SCROLL_LOCK: 145,\n\n  // OS-specific media keys like volume controls and browser controls.\n  FIRST_MEDIA_KEY: 166,\n  LAST_MEDIA_KEY: 183,\n\n  SEMICOLON: 186,             // needs localization\n  DASH: 189,                  // needs localization\n  EQUALS: 187,                // needs localization\n  COMMA: 188,                 // needs localization\n  PERIOD: 190,                // needs localization\n  SLASH: 191,                 // needs localization\n  APOSTROPHE: 192,            // needs localization\n  TILDE: 192,                 // needs localization\n  SINGLE_QUOTE: 222,          // needs localization\n  OPEN_SQUARE_BRACKET: 219,   // needs localization\n  BACKSLASH: 220,             // needs localization\n  CLOSE_SQUARE_BRACKET: 221,  // needs localization\n  WIN_KEY: 224,\n  MAC_FF_META:\n      224,  // Firefox (Gecko) fires this for the meta key instead of 91\n  MAC_WK_CMD_LEFT: 91,   // WebKit Left Command key fired, same as META\n  MAC_WK_CMD_RIGHT: 93,  // WebKit Right Command key fired, different from META\n  WIN_IME: 229,\n\n  // \"Reserved for future use\". Some programs (e.g. the SlingPlayer 2.4 ActiveX\n  // control) fire this as a hacky way to disable screensavers.\n  VK_NONAME: 252,\n\n  // We've seen users whose machines fire this keycode at regular one\n  // second intervals. The common thread among these users is that\n  // they're all using Dell Inspiron laptops, so we suspect that this\n  // indicates a hardware/bios problem.\n  // http://en.community.dell.com/support-forums/laptop/f/3518/p/19285957/19523128.aspx\n  PHANTOM: 255,\n};\n\nexports.KeyCodes = KeyCodes;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/keycodes.js?")},
"./core/utils/math.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility methods for math.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n */\n\n\n/**\n * Utility methods for math.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n * @namespace Blockly.utils.math\n */\ngoog.module('Blockly.utils.math');\n\n\n/**\n * Converts degrees to radians.\n * Copied from Closure's goog.math.toRadians.\n * @param {number} angleDegrees Angle in degrees.\n * @return {number} Angle in radians.\n * @alias Blockly.utils.math.toRadians\n */\nconst toRadians = function(angleDegrees) {\n  return angleDegrees * Math.PI / 180;\n};\nexports.toRadians = toRadians;\n\n/**\n * Converts radians to degrees.\n * Copied from Closure's goog.math.toDegrees.\n * @param {number} angleRadians Angle in radians.\n * @return {number} Angle in degrees.\n * @alias Blockly.utils.math.toDegrees\n */\nconst toDegrees = function(angleRadians) {\n  return angleRadians * 180 / Math.PI;\n};\nexports.toDegrees = toDegrees;\n\n/**\n * Clamp the provided number between the lower bound and the upper bound.\n * @param {number} lowerBound The desired lower bound.\n * @param {number} number The number to clamp.\n * @param {number} upperBound The desired upper bound.\n * @return {number} The clamped number.\n * @alias Blockly.utils.math.clamp\n */\nconst clamp = function(lowerBound, number, upperBound) {\n  if (upperBound < lowerBound) {\n    const temp = upperBound;\n    upperBound = lowerBound;\n    lowerBound = temp;\n  }\n  return Math.max(lowerBound, Math.min(number, upperBound));\n};\nexports.clamp = clamp;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/math.js?")},
"./core/utils/metrics.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Workspace metrics definitions.\n */\n\n\n/**\n * Workspace metrics definitions.\n * @namespace Blockly.utils.Metrics\n */\ngoog.module('Blockly.utils.Metrics');\n\n\n/**\n * @record\n * @alias Blockly.utils.Metrics\n */\nconst Metrics = function() {};\n\n/**\n * Height of the visible portion of the workspace.\n * @type {number}\n */\nMetrics.prototype.viewHeight;\n\n/**\n * Width of the visible portion of the workspace.\n * @type {number}\n */\nMetrics.prototype.viewWidth;\n\n/**\n * Height of the content.\n * @type {number}\n */\nMetrics.prototype.contentHeight;\n\n/**\n * Width of the content.\n * @type {number}\n */\nMetrics.prototype.contentWidth;\n\n/**\n * Height of the scroll area.\n * @type {number}\n */\nMetrics.prototype.scrollHeight;\n\n/**\n * Width of the scroll area.\n * @type {number}\n */\nMetrics.prototype.scrollWidth;\n\n/**\n * Top-edge of the visible portion of the workspace, relative to the workspace\n * origin.\n * @type {number}\n */\nMetrics.prototype.viewTop;\n\n/**\n * Left-edge of the visible portion of the workspace, relative to the workspace\n * origin.\n * @type {number}\n */\nMetrics.prototype.viewLeft;\n\n/**\n * Top-edge of the content, relative to the workspace origin.\n * @type {number}\n */\nMetrics.prototype.contentTop;\n\n/**\n * Left-edge of the content relative to the workspace origin.\n * @type {number}\n */\nMetrics.prototype.contentLeft;\n\n/**\n * Top-edge of the scroll area, relative to the workspace origin.\n * @type {number}\n */\nMetrics.prototype.scrollTop;\n\n/**\n * Left-edge of the scroll area relative to the workspace origin.\n * @type {number}\n */\nMetrics.prototype.scrollLeft;\n\n/**\n * Top-edge of the visible portion of the workspace, relative to the blocklyDiv.\n * @type {number}\n */\nMetrics.prototype.absoluteTop;\n\n/**\n * Left-edge of the visible portion of the workspace, relative to the\n * blocklyDiv.\n * @type {number}\n */\nMetrics.prototype.absoluteLeft;\n\n/**\n * Height of the Blockly div (the view + the toolbox, simple of otherwise).\n * @type {number}\n */\nMetrics.prototype.svgHeight;\n\n/**\n * Width of the Blockly div (the view + the toolbox, simple or otherwise).\n * @type {number}\n */\nMetrics.prototype.svgWidth;\n\n/**\n * Width of the toolbox, if it exists.  Otherwise zero.\n * @type {number}\n */\nMetrics.prototype.toolboxWidth;\n\n/**\n * Height of the toolbox, if it exists.  Otherwise zero.\n * @type {number}\n */\nMetrics.prototype.toolboxHeight;\n\n/**\n * Top, bottom, left or right. Use TOOLBOX_AT constants to compare.\n * @type {number}\n */\nMetrics.prototype.toolboxPosition;\n\n/**\n * Width of the flyout if it is always open.  Otherwise zero.\n * @type {number}\n */\nMetrics.prototype.flyoutWidth;\n\n/**\n * Height of the flyout if it is always open.  Otherwise zero.\n * @type {number}\n */\nMetrics.prototype.flyoutHeight;\n\nexports.Metrics = Metrics;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/metrics.js?")},
"./core/utils/object.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility methods for objects.\n */\n\n\n/**\n * Utility methods for objects.\n * @namespace Blockly.utils.object\n */\ngoog.module('Blockly.utils.object');\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n * @param {!Function} childCtor Child class.\n * @param {!Function} parentCtor Parent class.\n * @suppress {strictMissingProperties} superClass_ is not defined on Function.\n * @alias Blockly.utils.object.inherits\n */\nconst inherits = function(childCtor, parentCtor) {\n  // Set a .superClass_ property so that methods can call parent methods\n  // without hard-coding the parent class name.\n  // Could be replaced by ES6's super().\n  childCtor.superClass_ = parentCtor.prototype;\n\n  // Link the child class to the parent class so that static methods inherit.\n  Object.setPrototypeOf(childCtor, parentCtor);\n\n  // Replace the child constructor's prototype object with an instance\n  // of the parent class.\n  childCtor.prototype = Object.create(parentCtor.prototype);\n  childCtor.prototype.constructor = childCtor;\n  // Alternatively, one could use this instead:\n  // Object.setPrototypeOf(childCtor.prototype, parentCtor.prototype);\n};\nexports.inherits = inherits;\n\n/**\n * Copies all the members of a source object to a target object.\n * @param {!Object} target Target.\n * @param {!Object} source Source.\n * @alias Blockly.utils.object.mixin\n */\nconst mixin = function(target, source) {\n  for (const x in source) {\n    target[x] = source[x];\n  }\n};\nexports.mixin = mixin;\n\n/**\n * Complete a deep merge of all members of a source object with a target object.\n * @param {!Object} target Target.\n * @param {!Object} source Source.\n * @return {!Object} The resulting object.\n * @alias Blockly.utils.object.deepMerge\n */\nconst deepMerge = function(target, source) {\n  for (const x in source) {\n    if (source[x] !== null && typeof source[x] === 'object') {\n      target[x] = deepMerge(target[x] || Object.create(null), source[x]);\n    } else {\n      target[x] = source[x];\n    }\n  }\n  return target;\n};\nexports.deepMerge = deepMerge;\n\n/**\n * Returns an array of a given object's own enumerable property values.\n * @param {!Object} obj Object containing values.\n * @return {!Array} Array of values.\n * @alias Blockly.utils.object.values\n */\nconst values = function(obj) {\n  if (Object.values) {\n    return Object.values(obj);\n  }\n  // Fallback for IE.\n  return Object.keys(obj).map(function(e) {\n    return obj[e];\n  });\n};\nexports.values = values;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/object.js?")},
"./core/utils/parsing.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/colour.js\");\n__webpack_require__(\"./core/utils/string.js\");\n__webpack_require__(\"./core/msg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility methods related to block and message parsing.\n */\n\n\n/**\n * @namespace Blockly.utils.parsing\n */\ngoog.module('Blockly.utils.parsing');\n\nconst colourUtils = goog.require('Blockly.utils.colour');\nconst stringUtils = goog.require('Blockly.utils.string');\nconst {Msg} = goog.require('Blockly.Msg');\n\n\n/**\n * Internal implementation of the message reference and interpolation token\n * parsing used by tokenizeInterpolation() and replaceMessageReferences().\n * @param {string} message Text which might contain string table references and\n *     interpolation tokens.\n * @param {boolean} parseInterpolationTokens Option to parse numeric\n *     interpolation tokens (%1, %2, ...) when true.\n * @return {!Array<string|number>} Array of strings and numbers.\n */\nconst tokenizeInterpolationInternal = function(\n    message, parseInterpolationTokens) {\n  const tokens = [];\n  const chars = message.split('');\n  chars.push('');  // End marker.\n  // Parse the message with a finite state machine.\n  // 0 - Base case.\n  // 1 - % found.\n  // 2 - Digit found.\n  // 3 - Message ref found.\n  let state = 0;\n  const buffer = [];\n  let number = null;\n  for (let i = 0; i < chars.length; i++) {\n    const c = chars[i];\n    if (state === 0) {\n      if (c === '%') {\n        const text = buffer.join('');\n        if (text) {\n          tokens.push(text);\n        }\n        buffer.length = 0;\n        state = 1;  // Start escape.\n      } else {\n        buffer.push(c);  // Regular char.\n      }\n    } else if (state === 1) {\n      if (c === '%') {\n        buffer.push(c);  // Escaped %: %%\n        state = 0;\n      } else if (parseInterpolationTokens && '0' <= c && c <= '9') {\n        state = 2;\n        number = c;\n        const text = buffer.join('');\n        if (text) {\n          tokens.push(text);\n        }\n        buffer.length = 0;\n      } else if (c === '{') {\n        state = 3;\n      } else {\n        buffer.push('%', c);  // Not recognized. Return as literal.\n        state = 0;\n      }\n    } else if (state === 2) {\n      if ('0' <= c && c <= '9') {\n        number += c;  // Multi-digit number.\n      } else {\n        tokens.push(parseInt(number, 10));\n        i--;  // Parse this char again.\n        state = 0;\n      }\n    } else if (state === 3) {  // String table reference\n      if (c === '') {\n        // Premature end before closing '}'\n        buffer.splice(0, 0, '%{');  // Re-insert leading delimiter\n        i--;                        // Parse this char again.\n        state = 0;                  // and parse as string literal.\n      } else if (c !== '}') {\n        buffer.push(c);\n      } else {\n        const rawKey = buffer.join('');\n        if (/[A-Z]\\w*/i.test(rawKey)) {  // Strict matching\n          // Found a valid string key. Attempt case insensitive match.\n          const keyUpper = rawKey.toUpperCase();\n\n          // BKY_ is the prefix used to namespace the strings used in Blockly\n          // core files and the predefined blocks in ../blocks/.\n          // These strings are defined in ../msgs/ files.\n          const bklyKey = stringUtils.startsWith(keyUpper, 'BKY_') ?\n              keyUpper.substring(4) :\n              null;\n          if (bklyKey && bklyKey in Msg) {\n            const rawValue = Msg[bklyKey];\n            if (typeof rawValue === 'string') {\n              // Attempt to dereference substrings, too, appending to the end.\n              Array.prototype.push.apply(\n                  tokens,\n                  tokenizeInterpolationInternal(\n                      rawValue, parseInterpolationTokens));\n            } else if (parseInterpolationTokens) {\n              // When parsing interpolation tokens, numbers are special\n              // placeholders (%1, %2, etc). Make sure all other values are\n              // strings.\n              tokens.push(String(rawValue));\n            } else {\n              tokens.push(rawValue);\n            }\n          } else {\n            // No entry found in the string table. Pass reference as string.\n            tokens.push('%{' + rawKey + '}');\n          }\n          buffer.length = 0;  // Clear the array\n          state = 0;\n        } else {\n          tokens.push('%{' + rawKey + '}');\n          buffer.length = 0;\n          state = 0;  // and parse as string literal.\n        }\n      }\n    }\n  }\n  let text = buffer.join('');\n  if (text) {\n    tokens.push(text);\n  }\n\n  // Merge adjacent text tokens into a single string.\n  const mergedTokens = [];\n  buffer.length = 0;\n  for (let i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'string') {\n      buffer.push(tokens[i]);\n    } else {\n      text = buffer.join('');\n      if (text) {\n        mergedTokens.push(text);\n      }\n      buffer.length = 0;\n      mergedTokens.push(tokens[i]);\n    }\n  }\n  text = buffer.join('');\n  if (text) {\n    mergedTokens.push(text);\n  }\n  buffer.length = 0;\n\n  return mergedTokens;\n};\n\n/**\n * Parse a string with any number of interpolation tokens (%1, %2, ...).\n * It will also replace string table references (e.g., %{bky_my_msg} and\n * %{BKY_MY_MSG} will both be replaced with the value in\n * Msg['MY_MSG']). Percentage sign characters '%' may be self-escaped\n * (e.g., '%%').\n * @param {string} message Text which might contain string table references and\n *     interpolation tokens.\n * @return {!Array<string|number>} Array of strings and numbers.\n * @alias Blockly.utils.parsing.tokenizeInterpolation\n */\nconst tokenizeInterpolation = function(message) {\n  return tokenizeInterpolationInternal(message, true);\n};\nexports.tokenizeInterpolation = tokenizeInterpolation;\n\n/**\n * Replaces string table references in a message, if the message is a string.\n * For example, \"%{bky_my_msg}\" and \"%{BKY_MY_MSG}\" will both be replaced with\n * the value in Msg['MY_MSG'].\n * @param {string|?} message Message, which may be a string that contains\n *     string table references.\n * @return {string} String with message references replaced.\n * @alias Blockly.utils.parsing.replaceMessageReferences\n */\nconst replaceMessageReferences = function(message) {\n  if (typeof message !== 'string') {\n    return message;\n  }\n  const interpolatedResult = tokenizeInterpolationInternal(message, false);\n  // When parseInterpolationTokens === false, interpolatedResult should be at\n  // most length 1.\n  return interpolatedResult.length ? String(interpolatedResult[0]) : '';\n};\nexports.replaceMessageReferences = replaceMessageReferences;\n\n/**\n * Validates that any %{MSG_KEY} references in the message refer to keys of\n * the Msg string table.\n * @param {string} message Text which might contain string table references.\n * @return {boolean} True if all message references have matching values.\n *     Otherwise, false.\n * @alias Blockly.utils.parsing.checkMessageReferences\n */\nconst checkMessageReferences = function(message) {\n  let validSoFar = true;\n\n  const msgTable = Msg;\n\n  // TODO (#1169): Implement support for other string tables,\n  // prefixes other than BKY_.\n  const m = message.match(/%{BKY_[A-Z]\\w*}/ig);\n  for (let i = 0; i < m.length; i++) {\n    const msgKey = m[i].toUpperCase();\n    if (msgTable[msgKey.slice(6, -1)] === undefined) {\n      console.warn('No message string for ' + m[i] + ' in ' + message);\n      validSoFar = false;  // Continue to report other errors.\n    }\n  }\n\n  return validSoFar;\n};\nexports.checkMessageReferences = checkMessageReferences;\n\n/**\n * Parse a block colour from a number or string, as provided in a block\n * definition.\n * @param {number|string} colour HSV hue value (0 to 360), #RRGGBB string,\n *     or a message reference string pointing to one of those two values.\n * @return {{hue: ?number, hex: string}} An object containing the colour as\n *     a #RRGGBB string, and the hue if the input was an HSV hue value.\n * @throws {Error} If the colour cannot be parsed.\n * @alias Blockly.utils.parsing.parseBlockColour\n */\nconst parseBlockColour = function(colour) {\n  const dereferenced =\n      (typeof colour === 'string') ? replaceMessageReferences(colour) : colour;\n\n  const hue = Number(dereferenced);\n  if (!isNaN(hue) && 0 <= hue && hue <= 360) {\n    return {\n      hue: hue,\n      hex: colourUtils.hsvToHex(\n          hue, colourUtils.getHsvSaturation(), colourUtils.getHsvValue() * 255),\n    };\n  } else {\n    const hex = colourUtils.parse(dereferenced);\n    if (hex) {\n      // Only store hue if colour is set as a hue.\n      return {hue: null, hex: hex};\n    } else {\n      let errorMsg = 'Invalid colour: \"' + dereferenced + '\"';\n      if (colour !== dereferenced) {\n        errorMsg += ' (from \"' + colour + '\")';\n      }\n      throw Error(errorMsg);\n    }\n  }\n};\nexports.parseBlockColour = parseBlockColour;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/parsing.js?")},
"./core/utils/rect.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility methods for rectangle manipulation.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n */\n\n\n/**\n * Utility methods for rectangle manipulation.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n * @class\n */\ngoog.module('Blockly.utils.Rect');\n\n\n/**\n * Class for representing rectangular regions.\n * @alias Blockly.utils.Rect\n */\nconst Rect = class {\n  /**\n   * @param {number} top Top.\n   * @param {number} bottom Bottom.\n   * @param {number} left Left.\n   * @param {number} right Right.\n   * @struct\n   */\n  constructor(top, bottom, left, right) {\n    /** @type {number} */\n    this.top = top;\n\n    /** @type {number} */\n    this.bottom = bottom;\n\n    /** @type {number} */\n    this.left = left;\n\n    /** @type {number} */\n    this.right = right;\n  }\n\n  /**\n   * Tests whether this rectangle contains a x/y coordinate.\n   *\n   * @param {number} x The x coordinate to test for containment.\n   * @param {number} y The y coordinate to test for containment.\n   * @return {boolean} Whether this rectangle contains given coordinate.\n   */\n  contains(x, y) {\n    return x >= this.left && x <= this.right && y >= this.top &&\n        y <= this.bottom;\n  }\n\n  /**\n   * Tests whether this rectangle intersects the provided rectangle.\n   * Assumes that the coordinate system increases going down and left.\n   * @param {!Rect} other The other rectangle to check for\n   *    intersection with.\n   * @return {boolean} Whether this rectangle intersects the provided rectangle.\n   */\n  intersects(other) {\n    return !(\n        this.left > other.right || this.right < other.left ||\n        this.top > other.bottom || this.bottom < other.top);\n  }\n};\n\nexports.Rect = Rect;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/rect.js?")},
"./core/utils/sentinel.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A type used to create flag values (e.g. SKIP_SETUP).\n */\n\n\n/**\n * A type used to create flag values.\n * @class\n */\ngoog.module('Blockly.utils.Sentinel');\n\n\n/**\n * A type used to create flag values.\n * @alias Blockly.utils.Sentinel\n */\nclass Sentinel {}\n\nexports.Sentinel = Sentinel;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/sentinel.js?")},
"./core/utils/size.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility methods for size calculation.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n */\n\n\n/**\n * Utility methods for size calculation.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n * @class\n */\ngoog.module('Blockly.utils.Size');\n\n\n/**\n * Class for representing sizes consisting of a width and height.\n * @alias Blockly.utils.Size\n */\nconst Size = class {\n  /**\n   * @param {number} width Width.\n   * @param {number} height Height.\n   * @struct\n   */\n  constructor(width, height) {\n    /**\n     * Width\n     * @type {number}\n     */\n    this.width = width;\n\n    /**\n     * Height\n     * @type {number}\n     */\n    this.height = height;\n  }\n\n  /**\n   * Compares sizes for equality.\n   * @param {?Size} a A Size.\n   * @param {?Size} b A Size.\n   * @return {boolean} True iff the sizes have equal widths and equal\n   *     heights, or if both are null.\n   */\n  static equals(a, b) {\n    if (a === b) {\n      return true;\n    }\n    if (!a || !b) {\n      return false;\n    }\n    return a.width === b.width && a.height === b.height;\n  }\n};\n\nexports.Size = Size;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/size.js?")},
"./core/utils/string.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility methods for string manipulation.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n */\n\n\n/**\n * Utility methods for string manipulation.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n * @namespace Blockly.utils.string\n */\ngoog.module('Blockly.utils.string');\n\n\n/**\n * Fast prefix-checker.\n * Copied from Closure's goog.string.startsWith.\n * @param {string} str The string to check.\n * @param {string} prefix A string to look for at the start of `str`.\n * @return {boolean} True if `str` begins with `prefix`.\n * @alias Blockly.utils.string.startsWith\n */\nconst startsWith = function(str, prefix) {\n  return str.lastIndexOf(prefix, 0) === 0;\n};\nexports.startsWith = startsWith;\n\n/**\n * Given an array of strings, return the length of the shortest one.\n * @param {!Array<string>} array Array of strings.\n * @return {number} Length of shortest string.\n * @alias Blockly.utils.string.shortestStringLength\n */\nconst shortestStringLength = function(array) {\n  if (!array.length) {\n    return 0;\n  }\n  return array\n      .reduce(function(a, b) {\n        return a.length < b.length ? a : b;\n      })\n      .length;\n};\nexports.shortestStringLength = shortestStringLength;\n\n/**\n * Given an array of strings, return the length of the common prefix.\n * Words may not be split.  Any space after a word is included in the length.\n * @param {!Array<string>} array Array of strings.\n * @param {number=} opt_shortest Length of shortest string.\n * @return {number} Length of common prefix.\n * @alias Blockly.utils.string.commonWordPrefix\n */\nconst commonWordPrefix = function(array, opt_shortest) {\n  if (!array.length) {\n    return 0;\n  } else if (array.length === 1) {\n    return array[0].length;\n  }\n  let wordPrefix = 0;\n  const max = opt_shortest || shortestStringLength(array);\n  let len;\n  for (len = 0; len < max; len++) {\n    const letter = array[0][len];\n    for (let i = 1; i < array.length; i++) {\n      if (letter !== array[i][len]) {\n        return wordPrefix;\n      }\n    }\n    if (letter === ' ') {\n      wordPrefix = len + 1;\n    }\n  }\n  for (let i = 1; i < array.length; i++) {\n    const letter = array[i][len];\n    if (letter && letter !== ' ') {\n      return wordPrefix;\n    }\n  }\n  return max;\n};\nexports.commonWordPrefix = commonWordPrefix;\n\n/**\n * Given an array of strings, return the length of the common suffix.\n * Words may not be split.  Any space after a word is included in the length.\n * @param {!Array<string>} array Array of strings.\n * @param {number=} opt_shortest Length of shortest string.\n * @return {number} Length of common suffix.\n * @alias Blockly.utils.string.commonWordSuffix\n */\nconst commonWordSuffix = function(array, opt_shortest) {\n  if (!array.length) {\n    return 0;\n  } else if (array.length === 1) {\n    return array[0].length;\n  }\n  let wordPrefix = 0;\n  const max = opt_shortest || shortestStringLength(array);\n  let len;\n  for (len = 0; len < max; len++) {\n    const letter = array[0].substr(-len - 1, 1);\n    for (let i = 1; i < array.length; i++) {\n      if (letter !== array[i].substr(-len - 1, 1)) {\n        return wordPrefix;\n      }\n    }\n    if (letter === ' ') {\n      wordPrefix = len + 1;\n    }\n  }\n  for (let i = 1; i < array.length; i++) {\n    const letter = array[i].charAt(array[i].length - len - 1);\n    if (letter && letter !== ' ') {\n      return wordPrefix;\n    }\n  }\n  return max;\n};\nexports.commonWordSuffix = commonWordSuffix;\n\n/**\n * Wrap text to the specified width.\n * @param {string} text Text to wrap.\n * @param {number} limit Width to wrap each line.\n * @return {string} Wrapped text.\n * @alias Blockly.utils.string.wrap\n */\nconst wrap = function(text, limit) {\n  const lines = text.split('\\n');\n  for (let i = 0; i < lines.length; i++) {\n    lines[i] = wrapLine(lines[i], limit);\n  }\n  return lines.join('\\n');\n};\nexports.wrap = wrap;\n\n/**\n * Wrap single line of text to the specified width.\n * @param {string} text Text to wrap.\n * @param {number} limit Width to wrap each line.\n * @return {string} Wrapped text.\n */\nconst wrapLine = function(text, limit) {\n  if (text.length <= limit) {\n    // Short text, no need to wrap.\n    return text;\n  }\n  // Split the text into words.\n  const words = text.trim().split(/\\s+/);\n  // Set limit to be the length of the largest word.\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].length > limit) {\n      limit = words[i].length;\n    }\n  }\n\n  let lastScore;\n  let score = -Infinity;\n  let lastText;\n  let lineCount = 1;\n  do {\n    lastScore = score;\n    lastText = text;\n    // Create a list of booleans representing if a space (false) or\n    // a break (true) appears after each word.\n    let wordBreaks = [];\n    // Seed the list with evenly spaced linebreaks.\n    const steps = words.length / lineCount;\n    let insertedBreaks = 1;\n    for (let i = 0; i < words.length - 1; i++) {\n      if (insertedBreaks < (i + 1.5) / steps) {\n        insertedBreaks++;\n        wordBreaks[i] = true;\n      } else {\n        wordBreaks[i] = false;\n      }\n    }\n    wordBreaks = wrapMutate(words, wordBreaks, limit);\n    score = wrapScore(words, wordBreaks, limit);\n    text = wrapToText(words, wordBreaks);\n    lineCount++;\n  } while (score > lastScore);\n  return lastText;\n};\n\n/**\n * Compute a score for how good the wrapping is.\n * @param {!Array<string>} words Array of each word.\n * @param {!Array<boolean>} wordBreaks Array of line breaks.\n * @param {number} limit Width to wrap each line.\n * @return {number} Larger the better.\n */\nconst wrapScore = function(words, wordBreaks, limit) {\n  // If this function becomes a performance liability, add caching.\n  // Compute the length of each line.\n  const lineLengths = [0];\n  const linePunctuation = [];\n  for (let i = 0; i < words.length; i++) {\n    lineLengths[lineLengths.length - 1] += words[i].length;\n    if (wordBreaks[i] === true) {\n      lineLengths.push(0);\n      linePunctuation.push(words[i].charAt(words[i].length - 1));\n    } else if (wordBreaks[i] === false) {\n      lineLengths[lineLengths.length - 1]++;\n    }\n  }\n  const maxLength = Math.max.apply(Math, lineLengths);\n\n  let score = 0;\n  for (let i = 0; i < lineLengths.length; i++) {\n    // Optimize for width.\n    // -2 points per char over limit (scaled to the power of 1.5).\n    score -= Math.pow(Math.abs(limit - lineLengths[i]), 1.5) * 2;\n    // Optimize for even lines.\n    // -1 point per char smaller than max (scaled to the power of 1.5).\n    score -= Math.pow(maxLength - lineLengths[i], 1.5);\n    // Optimize for structure.\n    // Add score to line endings after punctuation.\n    if ('.?!'.indexOf(linePunctuation[i]) !== -1) {\n      score += limit / 3;\n    } else if (',;)]}'.indexOf(linePunctuation[i]) !== -1) {\n      score += limit / 4;\n    }\n  }\n  // All else being equal, the last line should not be longer than the\n  // previous line.  For example, this looks wrong:\n  // aaa bbb\n  // ccc ddd eee\n  if (lineLengths.length > 1 &&\n      lineLengths[lineLengths.length - 1] <=\n          lineLengths[lineLengths.length - 2]) {\n    score += 0.5;\n  }\n  return score;\n};\n\n/**\n * Mutate the array of line break locations until an optimal solution is found.\n * No line breaks are added or deleted, they are simply moved around.\n * @param {!Array<string>} words Array of each word.\n * @param {!Array<boolean>} wordBreaks Array of line breaks.\n * @param {number} limit Width to wrap each line.\n * @return {!Array<boolean>} New array of optimal line breaks.\n */\nconst wrapMutate = function(words, wordBreaks, limit) {\n  let bestScore = wrapScore(words, wordBreaks, limit);\n  let bestBreaks;\n  // Try shifting every line break forward or backward.\n  for (let i = 0; i < wordBreaks.length - 1; i++) {\n    if (wordBreaks[i] === wordBreaks[i + 1]) {\n      continue;\n    }\n    const mutatedWordBreaks = [].concat(wordBreaks);\n    mutatedWordBreaks[i] = !mutatedWordBreaks[i];\n    mutatedWordBreaks[i + 1] = !mutatedWordBreaks[i + 1];\n    const mutatedScore = wrapScore(words, mutatedWordBreaks, limit);\n    if (mutatedScore > bestScore) {\n      bestScore = mutatedScore;\n      bestBreaks = mutatedWordBreaks;\n    }\n  }\n  if (bestBreaks) {\n    // Found an improvement.  See if it may be improved further.\n    return wrapMutate(words, bestBreaks, limit);\n  }\n  // No improvements found.  Done.\n  return wordBreaks;\n};\n\n/**\n * Reassemble the array of words into text, with the specified line breaks.\n * @param {!Array<string>} words Array of each word.\n * @param {!Array<boolean>} wordBreaks Array of line breaks.\n * @return {string} Plain text.\n */\nconst wrapToText = function(words, wordBreaks) {\n  const text = [];\n  for (let i = 0; i < words.length; i++) {\n    text.push(words[i]);\n    if (wordBreaks[i] !== undefined) {\n      text.push(wordBreaks[i] ? '\\n' : ' ');\n    }\n  }\n  return text.join('');\n};\n\n/**\n * Is the given string a number (includes negative and decimals).\n * @param {string} str Input string.\n * @return {boolean} True if number, false otherwise.\n * @alias Blockly.utils.string.isNumber\n */\nconst isNumber = function(str) {\n  return /^\\s*-?\\d+(\\.\\d+)?\\s*$/.test(str);\n};\nexports.isNumber = isNumber;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/string.js?")},
"./core/utils/style.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/utils/size.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utilities for element styles.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n */\n\n\n/**\n * Utilities for element styles.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n * @namespace Blockly.utils.style\n */\ngoog.module('Blockly.utils.style');\n\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\nconst {Size} = goog.require('Blockly.utils.Size');\n\n\n/**\n * Gets the height and width of an element.\n * Similar to Closure's goog.style.getSize\n * @param {!Element} element Element to get size of.\n * @return {!Size} Object with width/height properties.\n * @alias Blockly.utils.style.getSize\n */\nconst getSize = function(element) {\n  if (getStyle(element, 'display') !== 'none') {\n    return getSizeWithDisplay(element);\n  }\n\n  // Evaluate size with a temporary element.\n  const style = element.style;\n  const originalDisplay = style.display;\n  const originalVisibility = style.visibility;\n  const originalPosition = style.position;\n\n  style.visibility = 'hidden';\n  style.position = 'absolute';\n  style.display = 'inline';\n\n  const offsetWidth = /** @type {!HTMLElement} */ (element).offsetWidth;\n  const offsetHeight = /** @type {!HTMLElement} */ (element).offsetHeight;\n\n  style.display = originalDisplay;\n  style.position = originalPosition;\n  style.visibility = originalVisibility;\n\n  return new Size(offsetWidth, offsetHeight);\n};\nexports.getSize = getSize;\n\n/**\n * Gets the height and width of an element when the display is not none.\n * @param {!Element} element Element to get size of.\n * @return {!Size} Object with width/height properties.\n */\nconst getSizeWithDisplay = function(element) {\n  const offsetWidth = /** @type {!HTMLElement} */ (element).offsetWidth;\n  const offsetHeight = /** @type {!HTMLElement} */ (element).offsetHeight;\n  return new Size(offsetWidth, offsetHeight);\n};\n\n/**\n * Cross-browser pseudo get computed style. It returns the computed style where\n * available. If not available it tries the cascaded style value (IE\n * currentStyle) and in worst case the inline style value.  It shouldn't be\n * called directly, see http://wiki/Main/ComputedStyleVsCascadedStyle for\n * discussion.\n *\n * Copied from Closure's goog.style.getStyle_\n *\n * @param {!Element} element Element to get style of.\n * @param {string} style Property to get (must be camelCase, not CSS-style).\n * @return {string} Style value.\n */\nconst getStyle = function(element, style) {\n  return getComputedStyle(element, style) || getCascadedStyle(element, style) ||\n      (element.style && element.style[style]);\n};\n\n/**\n * Retrieves a computed style value of a node. It returns empty string if the\n * value cannot be computed (which will be the case in Internet Explorer) or\n * \"none\" if the property requested is an SVG one and it has not been\n * explicitly set (firefox and webkit).\n *\n * Copied from Closure's goog.style.getComputedStyle\n *\n * @param {!Element} element Element to get style of.\n * @param {string} property Property to get (camel-case).\n * @return {string} Style value.\n * @alias Blockly.utils.style.getComputedStyle\n */\nconst getComputedStyle = function(element, property) {\n  if (document.defaultView && document.defaultView.getComputedStyle) {\n    const styles = document.defaultView.getComputedStyle(element, null);\n    if (styles) {\n      // element.style[..] is undefined for browser specific styles\n      // as 'filter'.\n      return styles[property] || styles.getPropertyValue(property) || '';\n    }\n  }\n\n  return '';\n};\nexports.getComputedStyle = getComputedStyle;\n\n/**\n * Gets the cascaded style value of a node, or null if the value cannot be\n * computed (only Internet Explorer can do this).\n *\n * Copied from Closure's goog.style.getCascadedStyle\n *\n * @param {!Element} element Element to get style of.\n * @param {string} style Property to get (camel-case).\n * @return {string} Style value.\n * @alias Blockly.utils.style.getCascadedStyle\n */\nconst getCascadedStyle = function(element, style) {\n  return /** @type {string} */ (\n      element.currentStyle ? element.currentStyle[style] : null);\n};\nexports.getCascadedStyle = getCascadedStyle;\n\n/**\n * Returns a Coordinate object relative to the top-left of the HTML document.\n * Similar to Closure's goog.style.getPageOffset\n * @param {!Element} el Element to get the page offset for.\n * @return {!Coordinate} The page offset.\n * @alias Blockly.utils.style.getPageOffset\n */\nconst getPageOffset = function(el) {\n  const pos = new Coordinate(0, 0);\n  const box = el.getBoundingClientRect();\n  const documentElement = document.documentElement;\n  // Must add the scroll coordinates in to get the absolute page offset\n  // of element since getBoundingClientRect returns relative coordinates to\n  // the viewport.\n  const scrollCoord = new Coordinate(\n      window.pageXOffset || documentElement.scrollLeft,\n      window.pageYOffset || documentElement.scrollTop);\n  pos.x = box.left + scrollCoord.x;\n  pos.y = box.top + scrollCoord.y;\n\n  return pos;\n};\nexports.getPageOffset = getPageOffset;\n\n/**\n * Calculates the viewport coordinates relative to the document.\n * Similar to Closure's goog.style.getViewportPageOffset\n * @return {!Coordinate} The page offset of the viewport.\n * @alias Blockly.utils.style.getViewportPageOffset\n */\nconst getViewportPageOffset = function() {\n  const body = document.body;\n  const documentElement = document.documentElement;\n  const scrollLeft = body.scrollLeft || documentElement.scrollLeft;\n  const scrollTop = body.scrollTop || documentElement.scrollTop;\n  return new Coordinate(scrollLeft, scrollTop);\n};\nexports.getViewportPageOffset = getViewportPageOffset;\n\n/**\n * Shows or hides an element from the page. Hiding the element is done by\n * setting the display property to \"none\", removing the element from the\n * rendering hierarchy so it takes up no space. To show the element, the default\n * inherited display property is restored (defined either in stylesheets or by\n * the browser's default style rules).\n * Copied from Closure's goog.style.getViewportPageOffset\n *\n * @param {!Element} el Element to show or hide.\n * @param {*} isShown True to render the element in its default style,\n *     false to disable rendering the element.\n * @alias Blockly.utils.style.setElementShown\n */\nconst setElementShown = function(el, isShown) {\n  el.style.display = isShown ? '' : 'none';\n};\nexports.setElementShown = setElementShown;\n\n/**\n * Returns true if the element is using right to left (RTL) direction.\n * Copied from Closure's goog.style.isRightToLeft\n *\n * @param {!Element} el The element to test.\n * @return {boolean} True for right to left, false for left to right.\n * @alias Blockly.utils.style.isRightToLeft\n */\nconst isRightToLeft = function(el) {\n  return 'rtl' === getStyle(el, 'direction');\n};\nexports.isRightToLeft = isRightToLeft;\n\n/**\n * Gets the computed border widths (on all sides) in pixels\n * Copied from Closure's goog.style.getBorderBox\n * @param {!Element} element  The element to get the border widths for.\n * @return {!Object} The computed border widths.\n * @alias Blockly.utils.style.getBorderBox\n */\nconst getBorderBox = function(element) {\n  const left = getComputedStyle(element, 'borderLeftWidth');\n  const right = getComputedStyle(element, 'borderRightWidth');\n  const top = getComputedStyle(element, 'borderTopWidth');\n  const bottom = getComputedStyle(element, 'borderBottomWidth');\n\n  return {\n    top: parseFloat(top),\n    right: parseFloat(right),\n    bottom: parseFloat(bottom),\n    left: parseFloat(left),\n  };\n};\nexports.getBorderBox = getBorderBox;\n\n/**\n * Changes the scroll position of `container` with the minimum amount so\n * that the content and the borders of the given `element` become visible.\n * If the element is bigger than the container, its top left corner will be\n * aligned as close to the container's top left corner as possible.\n * Copied from Closure's goog.style.scrollIntoContainerView\n *\n * @param {!Element} element The element to make visible.\n * @param {!Element} container The container to scroll. If not set, then the\n *     document scroll element will be used.\n * @param {boolean=} opt_center Whether to center the element in the container.\n *     Defaults to false.\n * @alias Blockly.utils.style.scrollIntoContainerView\n */\nconst scrollIntoContainerView = function(element, container, opt_center) {\n  const offset = getContainerOffsetToScrollInto(element, container, opt_center);\n  container.scrollLeft = offset.x;\n  container.scrollTop = offset.y;\n};\nexports.scrollIntoContainerView = scrollIntoContainerView;\n\n/**\n * Calculate the scroll position of `container` with the minimum amount so\n * that the content and the borders of the given `element` become visible.\n * If the element is bigger than the container, its top left corner will be\n * aligned as close to the container's top left corner as possible.\n * Copied from Closure's goog.style.getContainerOffsetToScrollInto\n *\n * @param {!Element} element The element to make visible.\n * @param {!Element} container The container to scroll. If not set, then the\n *     document scroll element will be used.\n * @param {boolean=} opt_center Whether to center the element in the container.\n *     Defaults to false.\n * @return {!Coordinate} The new scroll position of the container,\n *     in form of goog.math.Coordinate(scrollLeft, scrollTop).\n * @alias Blockly.utils.style.getContainerOffsetToScrollInto\n */\nconst getContainerOffsetToScrollInto = function(\n    element, container, opt_center) {\n  // Absolute position of the element's border's top left corner.\n  const elementPos = getPageOffset(element);\n  // Absolute position of the container's border's top left corner.\n  const containerPos = getPageOffset(container);\n  const containerBorder = getBorderBox(container);\n  // Relative pos. of the element's border box to the container's content box.\n  const relX = elementPos.x - containerPos.x - containerBorder.left;\n  const relY = elementPos.y - containerPos.y - containerBorder.top;\n  // How much the element can move in the container, i.e. the difference between\n  // the element's bottom-right-most and top-left-most position where it's\n  // fully visible.\n  const elementSize = getSizeWithDisplay(element);\n  const spaceX = container.clientWidth - elementSize.width;\n  const spaceY = container.clientHeight - elementSize.height;\n  let scrollLeft = container.scrollLeft;\n  let scrollTop = container.scrollTop;\n  if (opt_center) {\n    // All browsers round non-integer scroll positions down.\n    scrollLeft += relX - spaceX / 2;\n    scrollTop += relY - spaceY / 2;\n  } else {\n    // This formula was designed to give the correct scroll values in the\n    // following cases:\n    // - element is higher than container (spaceY < 0) => scroll down by relY\n    // - element is not higher that container (spaceY >= 0):\n    //   - it is above container (relY < 0) => scroll up by abs(relY)\n    //   - it is below container (relY > spaceY) => scroll down by relY - spaceY\n    //   - it is in the container => don't scroll\n    scrollLeft += Math.min(relX, Math.max(relX - spaceX, 0));\n    scrollTop += Math.min(relY, Math.max(relY - spaceY, 0));\n  }\n  return new Coordinate(scrollLeft, scrollTop);\n};\nexports.getContainerOffsetToScrollInto = getContainerOffsetToScrollInto;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/style.js?")},
"./core/utils/svg.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Defines the Svg class. Its constants enumerate\n * all SVG tag names used by Blockly.\n */\n\n\n/**\n * Defines the Svg class. Its constants enumerate\n * all SVG tag names used by Blockly.\n * @class\n */\ngoog.module('Blockly.utils.Svg');\n\n\n/**\n * A name with the type of the SVG element stored in the generic.\n * @template T\n * @alias Blockly.utils.Svg\n */\nclass Svg {\n  /**\n   * @param {string} tagName The SVG element tag name.\n   * @package\n   */\n  constructor(tagName) {\n    /**\n     * @type {string}\n     * @private\n     */\n    this.tagName_ = tagName;\n  }\n\n  /**\n   * Returns the SVG element tag name.\n   * @return {string} The name.\n   */\n  toString() {\n    return this.tagName_;\n  }\n}\n\n/**\n * @type {!Svg<!SVGAnimateElement>}\n * @package\n */\nSvg.ANIMATE = new Svg('animate');\n\n/**\n * @type {!Svg<!SVGCircleElement>}\n * @package\n */\nSvg.CIRCLE = new Svg('circle');\n\n/**\n * @type {!Svg<!SVGClipPathElement>}\n * @package\n */\nSvg.CLIPPATH = new Svg('clipPath');\n\n/**\n * @type {!Svg<!SVGDefsElement>}\n * @package\n */\nSvg.DEFS = new Svg('defs');\n\n/**\n * @type {!Svg<!SVGFECompositeElement>}\n * @package\n */\nSvg.FECOMPOSITE = new Svg('feComposite');\n\n/**\n * @type {!Svg<!SVGFEComponentTransferElement>}\n * @package\n */\nSvg.FECOMPONENTTRANSFER = new Svg('feComponentTransfer');\n\n/**\n * @type {!Svg<!SVGFEFloodElement>}\n * @package\n */\nSvg.FEFLOOD = new Svg('feFlood');\n\n/**\n * @type {!Svg<!SVGFEFuncAElement>}\n * @package\n */\nSvg.FEFUNCA = new Svg('feFuncA');\n\n/**\n * @type {!Svg<!SVGFEGaussianBlurElement>}\n * @package\n */\nSvg.FEGAUSSIANBLUR = new Svg('feGaussianBlur');\n\n/**\n * @type {!Svg<!SVGFEPointLightElement>}\n * @package\n */\nSvg.FEPOINTLIGHT = new Svg('fePointLight');\n\n/**\n * @type {!Svg<!SVGFESpecularLightingElement>}\n * @package\n */\nSvg.FESPECULARLIGHTING = new Svg('feSpecularLighting');\n\n/**\n * @type {!Svg<!SVGFilterElement>}\n * @package\n */\nSvg.FILTER = new Svg('filter');\n\n/**\n * @type {!Svg<!SVGForeignObjectElement>}\n * @package\n */\nSvg.FOREIGNOBJECT = new Svg('foreignObject');\n\n/**\n * @type {!Svg<!SVGGElement>}\n * @package\n */\nSvg.G = new Svg('g');\n\n/**\n * @type {!Svg<!SVGImageElement>}\n * @package\n */\nSvg.IMAGE = new Svg('image');\n\n/**\n * @type {!Svg<!SVGLineElement>}\n * @package\n */\nSvg.LINE = new Svg('line');\n\n/**\n * @type {!Svg<!SVGPathElement>}\n * @package\n */\nSvg.PATH = new Svg('path');\n\n/**\n * @type {!Svg<!SVGPatternElement>}\n * @package\n */\nSvg.PATTERN = new Svg('pattern');\n\n/**\n * @type {!Svg<!SVGPolygonElement>}\n * @package\n */\nSvg.POLYGON = new Svg('polygon');\n\n/**\n * @type {!Svg<!SVGRectElement>}\n * @package\n */\nSvg.RECT = new Svg('rect');\n\n/**\n * @type {!Svg<!SVGSVGElement>}\n * @package\n */\nSvg.SVG = new Svg('svg');\n\n/**\n * @type {!Svg<!SVGTextElement>}\n * @package\n */\nSvg.TEXT = new Svg('text');\n\n/**\n * @type {!Svg<!SVGTSpanElement>}\n * @package\n */\nSvg.TSPAN = new Svg('tspan');\n\nexports.Svg = Svg;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/svg.js?")},
"./core/utils/svg_math.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/deprecation.js\");\n__webpack_require__(\"./core/utils/global.js\");\n__webpack_require__(\"./core/utils/style.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/utils/rect.js\");\n__webpack_require__(\"./core/utils/size.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility methods for SVG math.\n */\n\n\n/**\n * Utility methods realted to figuring out positions of SVG elements.\n * @namespace Blockly.utils.svgMath\n */\ngoog.module('Blockly.utils.svgMath');\n\nconst deprecation = goog.require('Blockly.utils.deprecation');\nconst global = goog.require('Blockly.utils.global');\nconst style = goog.require('Blockly.utils.style');\nconst userAgent = goog.require('Blockly.utils.userAgent');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\nconst {Rect} = goog.require('Blockly.utils.Rect');\nconst {Size} = goog.require('Blockly.utils.Size');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * Static regex to pull the x,y values out of an SVG translate() directive.\n * Note that Firefox and IE (9,10) return 'translate(12)' instead of\n * 'translate(12, 0)'.\n * Note that IE (9,10) returns 'translate(16 8)' instead of 'translate(16, 8)'.\n * Note that IE has been reported to return scientific notation (0.123456e-42).\n * @type {!RegExp}\n */\nconst XY_REGEX = /translate\\(\\s*([-+\\d.e]+)([ ,]\\s*([-+\\d.e]+)\\s*)?/;\n\n/**\n * Static regex to pull the x,y values out of a translate() or translate3d()\n * style property.\n * Accounts for same exceptions as XY_REGEX.\n * @type {!RegExp}\n */\nconst XY_STYLE_REGEX =\n    /transform:\\s*translate(?:3d)?\\(\\s*([-+\\d.e]+)\\s*px([ ,]\\s*([-+\\d.e]+)\\s*px)?/;\n\n\n/**\n * Return the coordinates of the top-left corner of this element relative to\n * its parent.  Only for SVG elements and children (e.g. rect, g, path).\n * @param {!Element} element SVG element to find the coordinates of.\n * @return {!Coordinate} Object with .x and .y properties.\n * @alias Blockly.utils.svgMath.getRelativeXY\n */\nconst getRelativeXY = function(element) {\n  const xy = new Coordinate(0, 0);\n  // First, check for x and y attributes.\n  const x = element.getAttribute('x');\n  if (x) {\n    xy.x = parseInt(x, 10);\n  }\n  const y = element.getAttribute('y');\n  if (y) {\n    xy.y = parseInt(y, 10);\n  }\n  // Second, check for transform=\"translate(...)\" attribute.\n  const transform = element.getAttribute('transform');\n  const r = transform && transform.match(XY_REGEX);\n  if (r) {\n    xy.x += Number(r[1]);\n    if (r[3]) {\n      xy.y += Number(r[3]);\n    }\n  }\n\n  // Then check for style = transform: translate(...) or translate3d(...)\n  const style = element.getAttribute('style');\n  if (style && style.indexOf('translate') > -1) {\n    const styleComponents = style.match(XY_STYLE_REGEX);\n    if (styleComponents) {\n      xy.x += Number(styleComponents[1]);\n      if (styleComponents[3]) {\n        xy.y += Number(styleComponents[3]);\n      }\n    }\n  }\n  return xy;\n};\nexports.getRelativeXY = getRelativeXY;\n\n/**\n * Return the coordinates of the top-left corner of this element relative to\n * the div Blockly was injected into.\n * @param {!Element} element SVG element to find the coordinates of. If this is\n *     not a child of the div Blockly was injected into, the behaviour is\n *     undefined.\n * @return {!Coordinate} Object with .x and .y properties.\n * @alias Blockly.utils.svgMath.getInjectionDivXY\n */\nconst getInjectionDivXY = function(element) {\n  let x = 0;\n  let y = 0;\n  while (element) {\n    const xy = getRelativeXY(element);\n    x = x + xy.x;\n    y = y + xy.y;\n    const classes = element.getAttribute('class') || '';\n    if ((' ' + classes + ' ').indexOf(' injectionDiv ') !== -1) {\n      break;\n    }\n    element = /** @type {!Element} */ (element.parentNode);\n  }\n  return new Coordinate(x, y);\n};\nexports.getInjectionDivXY = getInjectionDivXY;\n\n/**\n * Check if 3D transforms are supported by adding an element\n * and attempting to set the property.\n * @return {boolean} True if 3D transforms are supported.\n * @alias Blockly.utils.svgMath.is3dSupported\n */\nconst is3dSupported = function() {\n  if (is3dSupported.cached_ !== undefined) {\n    return is3dSupported.cached_;\n  }\n  // CC-BY-SA Lorenzo Polidori\n  // stackoverflow.com/questions/5661671/detecting-transform-translate3d-support\n  if (!global.globalThis['getComputedStyle']) {\n    return false;\n  }\n\n  const el = document.createElement('p');\n  let has3d = 'none';\n  const transforms = {\n    'webkitTransform': '-webkit-transform',\n    'OTransform': '-o-transform',\n    'msTransform': '-ms-transform',\n    'MozTransform': '-moz-transform',\n    'transform': 'transform',\n  };\n\n  // Add it to the body to get the computed style.\n  document.body.insertBefore(el, null);\n\n  for (const t in transforms) {\n    if (el.style[t] !== undefined) {\n      el.style[t] = 'translate3d(1px,1px,1px)';\n      const computedStyle = global.globalThis['getComputedStyle'](el);\n      if (!computedStyle) {\n        // getComputedStyle in Firefox returns null when Blockly is loaded\n        // inside an iframe with display: none.  Returning false and not\n        // caching is3dSupported means we try again later.  This is most likely\n        // when users are interacting with blocks which should mean Blockly is\n        // visible again.\n        // See https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n        document.body.removeChild(el);\n        return false;\n      }\n      has3d = computedStyle.getPropertyValue(transforms[t]);\n    }\n  }\n  document.body.removeChild(el);\n  is3dSupported.cached_ = has3d !== 'none';\n  return is3dSupported.cached_;\n};\nexports.is3dSupported = is3dSupported;\n\n/**\n * Get the position of the current viewport in window coordinates.  This takes\n * scroll into account.\n * @return {!Rect} An object containing window width, height, and\n *     scroll position in window coordinates.\n * @alias Blockly.utils.svgMath.getViewportBBox\n * @package\n */\nconst getViewportBBox = function() {\n  // Pixels, in window coordinates.\n  const scrollOffset = style.getViewportPageOffset();\n  return new Rect(\n      scrollOffset.y, document.documentElement.clientHeight + scrollOffset.y,\n      scrollOffset.x, document.documentElement.clientWidth + scrollOffset.x);\n};\nexports.getViewportBBox = getViewportBBox;\n\n/**\n * Gets the document scroll distance as a coordinate object.\n * Copied from Closure's goog.dom.getDocumentScroll.\n * @return {!Coordinate} Object with values 'x' and 'y'.\n * @alias Blockly.utils.svgMath.getDocumentScroll\n */\nconst getDocumentScroll = function() {\n  const el = document.documentElement;\n  const win = window;\n  if (userAgent.IE && win.pageYOffset !== el.scrollTop) {\n    // The keyboard on IE10 touch devices shifts the page using the pageYOffset\n    // without modifying scrollTop. For this case, we want the body scroll\n    // offsets.\n    return new Coordinate(el.scrollLeft, el.scrollTop);\n  }\n  return new Coordinate(\n      win.pageXOffset || el.scrollLeft, win.pageYOffset || el.scrollTop);\n};\nexports.getDocumentScroll = getDocumentScroll;\n\n/**\n * Converts screen coordinates to workspace coordinates.\n * @param {!WorkspaceSvg} ws The workspace to find the coordinates on.\n * @param {!Coordinate} screenCoordinates The screen coordinates to\n * be converted to workspace coordinates\n * @return {!Coordinate} The workspace coordinates.\n * @alias Blockly.utils.svgMath.screenToWsCoordinates\n */\nconst screenToWsCoordinates = function(ws, screenCoordinates) {\n  const screenX = screenCoordinates.x;\n  const screenY = screenCoordinates.y;\n\n  const injectionDiv = ws.getInjectionDiv();\n  // Bounding rect coordinates are in client coordinates, meaning that they\n  // are in pixels relative to the upper left corner of the visible browser\n  // window.  These coordinates change when you scroll the browser window.\n  const boundingRect = injectionDiv.getBoundingClientRect();\n\n  // The client coordinates offset by the injection div's upper left corner.\n  const clientOffsetPixels =\n      new Coordinate(screenX - boundingRect.left, screenY - boundingRect.top);\n\n  // The offset in pixels between the main workspace's origin and the upper\n  // left corner of the injection div.\n  const mainOffsetPixels = ws.getOriginOffsetInPixels();\n\n  // The position of the new comment in pixels relative to the origin of the\n  // main workspace.\n  const finalOffsetPixels =\n      Coordinate.difference(clientOffsetPixels, mainOffsetPixels);\n\n  // The position in main workspace coordinates.\n  const finalOffsetMainWs = finalOffsetPixels.scale(1 / ws.scale);\n  return finalOffsetMainWs;\n};\nexports.screenToWsCoordinates = screenToWsCoordinates;\n\n/**\n * Returns the dimensions of the specified SVG image.\n * @param {!SVGElement} svg SVG image.\n * @return {!Size} Contains width and height properties.\n * @deprecated Use workspace.getCachedParentSvgSize. (2021 March 5)\n * @alias Blockly.utils.svgMath.svgSize\n */\nconst svgSize = function(svg) {\n  // When removing this function, remove svg.cachedWidth_ and svg.cachedHeight_\n  // from setCachedParentSvgSize.\n  // The deprecated name is `Blockly.svgSize` because this function used to be\n  // declared in Blockly.js.\n  deprecation.warn(\n      'Blockly.svgSize', 'March 2021', 'March 2022',\n      'workspace.getCachedParentSvgSize');\n  svg = /** @type {?} */ (svg);\n  return new Size(svg.cachedWidth_, svg.cachedHeight_);\n};\nexports.svgSize = svgSize;\n\n\nexports.TEST_ONLY = {\n  XY_REGEX,\n  XY_STYLE_REGEX,\n};\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/svg_math.js?")},
"./core/utils/svg_paths.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Methods for creating parts of SVG path strings.  See\n * developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\n */\n\n\n/**\n * Methods for creating parts of SVG path strings.  See\n * @namespace Blockly.utils.svgPaths\n */\ngoog.module('Blockly.utils.svgPaths');\n\n\n/**\n * Create a string representing the given x, y pair.  It does not matter whether\n * the coordinate is relative or absolute.  The result has leading\n * and trailing spaces, and separates the x and y coordinates with a comma but\n * no space.\n * @param {number} x The x coordinate.\n * @param {number} y The y coordinate.\n * @return {string} A string of the format ' x,y '\n * @alias Blockly.utils.svgPaths.point\n */\nconst point = function(x, y) {\n  return ' ' + x + ',' + y + ' ';\n};\nexports.point = point;\n\n/**\n * Draw a cubic or quadratic curve.  See\n * developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d#Cubic_B%C3%A9zier_Curve\n * These coordinates are unitless and hence in the user coordinate system.\n * @param {string} command The command to use.\n *     Should be one of: c, C, s, S, q, Q.\n * @param {!Array<string>} points  An array containing all of the points to pass\n *     to the curve command, in order.  The points are represented as strings of\n *     the format ' x, y '.\n * @return {string} A string defining one or more Bezier curves.  See the MDN\n *     documentation for exact format.\n * @alias Blockly.utils.svgPaths.curve\n */\nconst curve = function(command, points) {\n  return ' ' + command + points.join('');\n};\nexports.curve = curve;\n\n/**\n * Move the cursor to the given position without drawing a line.\n * The coordinates are absolute.\n * These coordinates are unitless and hence in the user coordinate system.\n * See developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#Line_commands\n * @param {number} x The absolute x coordinate.\n * @param {number} y The absolute y coordinate.\n * @return {string} A string of the format ' M x,y '\n * @alias Blockly.utils.svgPaths.moveTo\n */\nconst moveTo = function(x, y) {\n  return ' M ' + x + ',' + y + ' ';\n};\nexports.moveTo = moveTo;\n\n/**\n * Move the cursor to the given position without drawing a line.\n * Coordinates are relative.\n * These coordinates are unitless and hence in the user coordinate system.\n * See developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#Line_commands\n * @param {number} dx The relative x coordinate.\n * @param {number} dy The relative y coordinate.\n * @return {string} A string of the format ' m dx,dy '\n * @alias Blockly.utils.svgPaths.moveBy\n */\nconst moveBy = function(dx, dy) {\n  return ' m ' + dx + ',' + dy + ' ';\n};\nexports.moveBy = moveBy;\n\n/**\n * Draw a line from the current point to the end point, which is the current\n * point shifted by dx along the x-axis and dy along the y-axis.\n * These coordinates are unitless and hence in the user coordinate system.\n * See developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#Line_commands\n * @param {number} dx The relative x coordinate.\n * @param {number} dy The relative y coordinate.\n * @return {string} A string of the format ' l dx,dy '\n * @alias Blockly.utils.svgPaths.lineTo\n */\nconst lineTo = function(dx, dy) {\n  return ' l ' + dx + ',' + dy + ' ';\n};\nexports.lineTo = lineTo;\n\n/**\n * Draw multiple lines connecting all of the given points in order.  This is\n * equivalent to a series of 'l' commands.\n * These coordinates are unitless and hence in the user coordinate system.\n * See developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#Line_commands\n * @param {!Array<string>} points An array containing all of the points to\n *     draw lines to, in order.  The points are represented as strings of the\n *     format ' dx,dy '.\n * @return {string} A string of the format ' l (dx,dy)+ '\n * @alias Blockly.utils.svgPaths.line\n */\nconst line = function(points) {\n  return ' l' + points.join('');\n};\nexports.line = line;\n\n/**\n * Draw a horizontal or vertical line.\n * The first argument specifies the direction and whether the given position is\n * relative or absolute.\n * These coordinates are unitless and hence in the user coordinate system.\n * See developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d#LineTo_path_commands\n * @param {string} command The command to prepend to the coordinate.  This\n *     should be one of: V, v, H, h.\n * @param {number} val The coordinate to pass to the command.  It may be\n *     absolute or relative.\n * @return {string} A string of the format ' command val '\n * @alias Blockly.utils.svgPaths.lineOnAxis\n */\nconst lineOnAxis = function(command, val) {\n  return ' ' + command + ' ' + val + ' ';\n};\nexports.lineOnAxis = lineOnAxis;\n\n/**\n * Draw an elliptical arc curve.\n * These coordinates are unitless and hence in the user coordinate system.\n * See developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d#Elliptical_Arc_Curve\n * @param {string} command The command string.  Either 'a' or 'A'.\n * @param {string} flags The flag string.  See the MDN documentation for a\n *     description and examples.\n * @param {number} radius The radius of the arc to draw.\n * @param {string} point The point to move the cursor to after drawing the arc,\n *     specified either in absolute or relative coordinates depending on the\n *     command.\n * @return {string} A string of the format 'command radius radius flags point'\n * @alias Blockly.utils.svgPaths.arc\n */\nconst arc = function(command, flags, radius, point) {\n  return command + ' ' + radius + ' ' + radius + ' ' + flags + point;\n};\nexports.arc = arc;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/svg_paths.js?")},
"./core/utils/toolbox.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/xml.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility functions for the toolbox and flyout.\n */\n\n\n/**\n * Utility functions for the toolbox and flyout.\n * @namespace Blockly.utils.toolbox\n */\ngoog.module('Blockly.utils.toolbox');\n\nconst Xml = goog.require('Blockly.Xml');\nconst userAgent = goog.require('Blockly.utils.userAgent');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConnectionState} = goog.requireType('Blockly.serialization.blocks');\n/* eslint-disable-next-line no-unused-vars */\nconst {ToolboxCategory} = goog.requireType('Blockly.ToolboxCategory');\n/* eslint-disable-next-line no-unused-vars */\nconst {ToolboxSeparator} = goog.requireType('Blockly.ToolboxSeparator');\n\n/**\n * The information needed to create a block in the toolbox.\n * Note that disabled has a different type for backwards compatibility.\n * @typedef {{\n *            kind:string,\n *            blockxml:(string|!Node|undefined),\n *            type:(string|undefined),\n *            gap:(string|number|undefined),\n *            disabled: (string|boolean|undefined),\n *            enabled: (boolean|undefined),\n *            id: (string|undefined),\n *            x: (number|undefined),\n *            y: (number|undefined),\n *            collapsed: (boolean|undefined),\n *            inline: (boolean|undefined),\n *            data: (string|undefined),\n *            extraState: (*|undefined),\n *            icons: (!Object<string, *>|undefined),\n *            fields: (!Object<string, *>|undefined),\n *            inputs: (!Object<string, !ConnectionState>|undefined),\n *            next: (!ConnectionState|undefined)\n *          }}\n * @alias Blockly.utils.toolbox.BlockInfo\n */\nlet BlockInfo;\nexports.BlockInfo = BlockInfo;\n\n/**\n * The information needed to create a separator in the toolbox.\n * @typedef {{\n *            kind:string,\n *            id:(string|undefined),\n *            gap:(number|undefined),\n *            cssconfig:(!ToolboxSeparator.CssConfig|undefined)\n *          }}\n * @alias Blockly.utils.toolbox.SeparatorInfo\n */\nlet SeparatorInfo;\nexports.SeparatorInfo = SeparatorInfo;\n\n/**\n * The information needed to create a button in the toolbox.\n * @typedef {{\n *            kind:string,\n *            text:string,\n *            callbackkey:string\n *          }}\n * @alias Blockly.utils.toolbox.ButtonInfo\n */\nlet ButtonInfo;\nexports.ButtonInfo = ButtonInfo;\n\n/**\n * The information needed to create a label in the toolbox.\n * @typedef {{\n *            kind:string,\n *            text:string,\n *            id:(string|undefined)\n *          }}\n * @alias Blockly.utils.toolbox.LabelInfo\n */\nlet LabelInfo;\nexports.LabelInfo = LabelInfo;\n\n/**\n * The information needed to create either a button or a label in the flyout.\n * @typedef {ButtonInfo|\n *           LabelInfo}\n * @alias Blockly.utils.toolbox.ButtonOrLabelInfo\n */\nlet ButtonOrLabelInfo;\nexports.ButtonOrLabelInfo = ButtonOrLabelInfo;\n\n/**\n * The information needed to create a category in the toolbox.\n * @typedef {{\n *            kind:string,\n *            name:string,\n *            contents:!Array<!ToolboxItemInfo>,\n *            id:(string|undefined),\n *            categorystyle:(string|undefined),\n *            colour:(string|undefined),\n *            cssconfig:(!ToolboxCategory.CssConfig|undefined),\n *            hidden:(string|undefined)\n *          }}\n * @alias Blockly.utils.toolbox.StaticCategoryInfo\n */\nlet StaticCategoryInfo;\nexports.StaticCategoryInfo = StaticCategoryInfo;\n\n/**\n * The information needed to create a custom category.\n * @typedef {{\n *            kind:string,\n *            custom:string,\n *            id:(string|undefined),\n *            categorystyle:(string|undefined),\n *            colour:(string|undefined),\n *            cssconfig:(!ToolboxCategory.CssConfig|undefined),\n *            hidden:(string|undefined)\n *          }}\n * @alias Blockly.utils.toolbox.DynamicCategoryInfo\n */\nlet DynamicCategoryInfo;\nexports.DynamicCategoryInfo = DynamicCategoryInfo;\n\n/**\n * The information needed to create either a dynamic or static category.\n * @typedef {StaticCategoryInfo|\n *           DynamicCategoryInfo}\n * @alias Blockly.utils.toolbox.CategoryInfo\n */\nlet CategoryInfo;\nexports.CategoryInfo = CategoryInfo;\n\n/**\n * Any information that can be used to create an item in the toolbox.\n * @typedef {FlyoutItemInfo|\n *           StaticCategoryInfo}\n * @alias Blockly.utils.toolbox.ToolboxItemInfo\n */\nlet ToolboxItemInfo;\nexports.ToolboxItemInfo = ToolboxItemInfo;\n\n/**\n * All the different types that can be displayed in a flyout.\n * @typedef {BlockInfo|\n *           SeparatorInfo|\n *           ButtonInfo|\n *           LabelInfo|\n *           DynamicCategoryInfo}\n * @alias Blockly.utils.toolbox.FlyoutItemInfo\n */\nlet FlyoutItemInfo;\nexports.FlyoutItemInfo = FlyoutItemInfo;\n\n/**\n * The JSON definition of a toolbox.\n * @typedef {{\n *            kind:(string|undefined),\n *            contents:!Array<!ToolboxItemInfo>\n *          }}\n * @alias Blockly.utils.toolbox.ToolboxInfo\n */\nlet ToolboxInfo;\nexports.ToolboxInfo = ToolboxInfo;\n\n/**\n * An array holding flyout items.\n * @typedef {\n *            Array<!FlyoutItemInfo>\n *          }\n * @alias Blockly.utils.toolbox.FlyoutItemInfoArray\n */\nlet FlyoutItemInfoArray;\nexports.FlyoutItemInfoArray = FlyoutItemInfoArray;\n\n/**\n * All of the different types that can create a toolbox.\n * @typedef {Node|\n *           ToolboxInfo|\n *           string}\n * @alias Blockly.utils.toolbox.ToolboxDefinition\n */\nlet ToolboxDefinition;\nexports.ToolboxDefinition = ToolboxDefinition;\n\n/**\n * All of the different types that can be used to show items in a flyout.\n * @typedef {FlyoutItemInfoArray|\n *           NodeList|\n *           ToolboxInfo|\n *           Array<!Node>}\n * @alias Blockly.utils.toolbox.FlyoutDefinition\n */\nlet FlyoutDefinition;\nexports.FlyoutDefinition = FlyoutDefinition;\n\n/**\n * The name used to identify a toolbox that has category like items.\n * This only needs to be used if a toolbox wants to be treated like a category\n * toolbox but does not actually contain any toolbox items with the kind\n * 'category'.\n * @const {string}\n */\nconst CATEGORY_TOOLBOX_KIND = 'categoryToolbox';\n\n/**\n * The name used to identify a toolbox that has no categories and is displayed\n * as a simple flyout displaying blocks, buttons, or labels.\n * @const {string}\n */\nconst FLYOUT_TOOLBOX_KIND = 'flyoutToolbox';\n\n/**\n * Position of the toolbox and/or flyout relative to the workspace.\n * @enum {number}\n * @alias Blockly.utils.toolbox.Position\n */\nconst Position = {\n  TOP: 0,\n  BOTTOM: 1,\n  LEFT: 2,\n  RIGHT: 3,\n};\nexports.Position = Position;\n\n/**\n * Converts the toolbox definition into toolbox JSON.\n * @param {?ToolboxDefinition} toolboxDef The definition\n *     of the toolbox in one of its many forms.\n * @return {?ToolboxInfo} Object holding information\n *     for creating a toolbox.\n * @alias Blockly.utils.toolbox.convertToolboxDefToJson\n * @package\n */\nconst convertToolboxDefToJson = function(toolboxDef) {\n  if (!toolboxDef) {\n    return null;\n  }\n\n  if (toolboxDef instanceof Element || typeof toolboxDef === 'string') {\n    toolboxDef = parseToolboxTree(toolboxDef);\n    toolboxDef = convertToToolboxJson(toolboxDef);\n  }\n\n  const toolboxJson = /** @type {ToolboxInfo} */ (toolboxDef);\n  validateToolbox(toolboxJson);\n  return toolboxJson;\n};\nexports.convertToolboxDefToJson = convertToolboxDefToJson;\n\n/**\n * Validates the toolbox JSON fields have been set correctly.\n * @param {!ToolboxInfo} toolboxJson Object holding\n *     information for creating a toolbox.\n * @throws {Error} if the toolbox is not the correct format.\n */\nconst validateToolbox = function(toolboxJson) {\n  const toolboxKind = toolboxJson['kind'];\n  const toolboxContents = toolboxJson['contents'];\n\n  if (toolboxKind) {\n    if (toolboxKind !== FLYOUT_TOOLBOX_KIND &&\n        toolboxKind !== CATEGORY_TOOLBOX_KIND) {\n      throw Error(\n          'Invalid toolbox kind ' + toolboxKind + '.' +\n          ' Please supply either ' + FLYOUT_TOOLBOX_KIND + ' or ' +\n          CATEGORY_TOOLBOX_KIND);\n    }\n  }\n  if (!toolboxContents) {\n    throw Error('Toolbox must have a contents attribute.');\n  }\n};\n\n/**\n * Converts the flyout definition into a list of flyout items.\n * @param {?FlyoutDefinition} flyoutDef The definition of\n *    the flyout in one of its many forms.\n * @return {!FlyoutItemInfoArray} A list of flyout items.\n * @alias Blockly.utils.toolbox.convertFlyoutDefToJsonArray\n * @package\n */\nconst convertFlyoutDefToJsonArray = function(flyoutDef) {\n  if (!flyoutDef) {\n    return [];\n  }\n\n  if (flyoutDef['contents']) {\n    return flyoutDef['contents'];\n  }\n\n  // If it is already in the correct format return the flyoutDef.\n  if (Array.isArray(flyoutDef) && flyoutDef.length > 0 &&\n      !flyoutDef[0].nodeType) {\n    return flyoutDef;\n  }\n\n  return xmlToJsonArray(/** @type {!Array<Node>|!NodeList} */ (flyoutDef));\n};\nexports.convertFlyoutDefToJsonArray = convertFlyoutDefToJsonArray;\n\n/**\n * Whether or not the toolbox definition has categories.\n * @param {?ToolboxInfo} toolboxJson Object holding\n *     information for creating a toolbox.\n * @return {boolean} True if the toolbox has categories.\n * @alias Blockly.utils.toolbox.hasCategories\n * @package\n */\nconst hasCategories = function(toolboxJson) {\n  if (!toolboxJson) {\n    return false;\n  }\n\n  const toolboxKind = toolboxJson['kind'];\n  if (toolboxKind) {\n    return toolboxKind === CATEGORY_TOOLBOX_KIND;\n  }\n\n  const categories = toolboxJson['contents'].filter(function(item) {\n    return item['kind'].toUpperCase() === 'CATEGORY';\n  });\n  return !!categories.length;\n};\nexports.hasCategories = hasCategories;\n\n/**\n * Whether or not the category is collapsible.\n * @param {!CategoryInfo} categoryInfo Object holing\n *    information for creating a category.\n * @return {boolean} True if the category has subcategories.\n * @alias Blockly.utils.toolbox.isCategoryCollapsible\n * @package\n */\nconst isCategoryCollapsible = function(categoryInfo) {\n  if (!categoryInfo || !categoryInfo['contents']) {\n    return false;\n  }\n\n  const categories = categoryInfo['contents'].filter(function(item) {\n    return item['kind'].toUpperCase() === 'CATEGORY';\n  });\n  return !!categories.length;\n};\nexports.isCategoryCollapsible = isCategoryCollapsible;\n\n/**\n * Parses the provided toolbox definition into a consistent format.\n * @param {Node} toolboxDef The definition of the toolbox in one of its many\n *     forms.\n * @return {!ToolboxInfo} Object holding information\n *     for creating a toolbox.\n */\nconst convertToToolboxJson = function(toolboxDef) {\n  const contents = xmlToJsonArray(\n      /** @type {!Node|!Array<Node>} */ (toolboxDef));\n  const toolboxJson = {'contents': contents};\n  if (toolboxDef instanceof Node) {\n    addAttributes(toolboxDef, toolboxJson);\n  }\n  return toolboxJson;\n};\n\n/**\n * Converts the xml for a toolbox to JSON.\n * @param {!Node|!Array<Node>|!NodeList} toolboxDef The\n *     definition of the toolbox in one of its many forms.\n * @return {!FlyoutItemInfoArray|\n *          !Array<ToolboxItemInfo>} A list of objects in\n *          the toolbox.\n */\nconst xmlToJsonArray = function(toolboxDef) {\n  const arr = [];\n  // If it is a node it will have children.\n  let childNodes = toolboxDef.childNodes;\n  if (!childNodes) {\n    // Otherwise the toolboxDef is an array or collection.\n    childNodes = toolboxDef;\n  }\n  for (let i = 0, child; (child = childNodes[i]); i++) {\n    if (!child.tagName) {\n      continue;\n    }\n    const obj = {};\n    const tagName = child.tagName.toUpperCase();\n    obj['kind'] = tagName;\n\n    // Store the XML for a block.\n    if (tagName === 'BLOCK') {\n      obj['blockxml'] = child;\n    } else if (child.childNodes && child.childNodes.length > 0) {\n      // Get the contents of a category\n      obj['contents'] = xmlToJsonArray(child);\n    }\n\n    // Add XML attributes to object\n    addAttributes(child, obj);\n    arr.push(obj);\n  }\n  return arr;\n};\n\n/**\n * Adds the attributes on the node to the given object.\n * @param {!Node} node The node to copy the attributes from.\n * @param {!Object} obj The object to copy the attributes to.\n */\nconst addAttributes = function(node, obj) {\n  for (let j = 0; j < node.attributes.length; j++) {\n    const attr = node.attributes[j];\n    if (attr.nodeName.indexOf('css-') > -1) {\n      obj['cssconfig'] = obj['cssconfig'] || {};\n      obj['cssconfig'][attr.nodeName.replace('css-', '')] = attr.value;\n    } else {\n      obj[attr.nodeName] = attr.value;\n    }\n  }\n};\n\n/**\n * Parse the provided toolbox tree into a consistent DOM format.\n * @param {?Node|?string} toolboxDef DOM tree of blocks, or text representation\n *    of same.\n * @return {?Node} DOM tree of blocks, or null.\n * @alias Blockly.utils.toolbox.parseToolboxTree\n */\nconst parseToolboxTree = function(toolboxDef) {\n  if (toolboxDef) {\n    if (typeof toolboxDef !== 'string') {\n      if (userAgent.IE && toolboxDef.outerHTML) {\n        // In this case the tree will not have been properly built by the\n        // browser. The HTML will be contained in the element, but it will\n        // not have the proper DOM structure since the browser doesn't support\n        // XSLTProcessor (XML -> HTML).\n        toolboxDef = toolboxDef.outerHTML;\n      } else if (!(toolboxDef instanceof Element)) {\n        toolboxDef = null;\n      }\n    }\n    if (typeof toolboxDef === 'string') {\n      toolboxDef = Xml.textToDom(toolboxDef);\n      if (toolboxDef.nodeName.toLowerCase() !== 'xml') {\n        throw TypeError('Toolbox should be an <xml> document.');\n      }\n    }\n  } else {\n    toolboxDef = null;\n  }\n  return toolboxDef;\n};\nexports.parseToolboxTree = parseToolboxTree;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/toolbox.js?")},
"./core/utils/useragent.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/global.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Useragent detection.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n */\n\n\n/**\n * Useragent detection.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n * @namespace Blockly.utils.userAgent\n */\ngoog.module('Blockly.utils.userAgent');\n\nconst {globalThis} = goog.require('Blockly.utils.global');\n\n\n/**\n * The raw useragent string.\n * @type {string}\n */\nlet rawUserAgent;\n\n/** @type {boolean} */\nlet isIe;\n\n/** @type {boolean} */\nlet isEdge;\n\n/** @type {boolean} */\nlet isJavaFx;\n\n/** @type {boolean} */\nlet isChrome;\n\n/** @type {boolean} */\nlet isWebKit;\n\n/** @type {boolean} */\nlet isGecko;\n\n/** @type {boolean} */\nlet isAndroid;\n\n/** @type {boolean} */\nlet isIPad;\n\n/** @type {boolean} */\nlet isIPod;\n\n/** @type {boolean} */\nlet isIPhone;\n\n/** @type {boolean} */\nlet isMac;\n\n/** @type {boolean} */\nlet isTablet;\n\n/** @type {boolean} */\nlet isMobile;\n\n(function(raw) {\nrawUserAgent = raw;\nconst rawUpper = rawUserAgent.toUpperCase();\n/**\n * Case-insensitive test of whether name is in the useragent string.\n * @param {string} name Name to test.\n * @return {boolean} True if name is present.\n */\nfunction has(name) {\n  return rawUpper.indexOf(name.toUpperCase()) !== -1;\n}\n\n// Browsers.  Logic from:\n// https://github.com/google/closure-library/blob/master/closure/goog/labs/useragent/browser.js\nisIe = has('Trident') || has('MSIE');\nisEdge = has('Edge');\n// Useragent for JavaFX:\n// Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.44\n//     (KHTML, like Gecko) JavaFX/8.0 Safari/537.44\nisJavaFx = has('JavaFX');\nisChrome = (has('Chrome') || has('CriOS')) && !isEdge;\n\n// Engines.  Logic from:\n// https://github.com/google/closure-library/blob/master/closure/goog/labs/useragent/engine.js\nisWebKit = has('WebKit') && !isEdge;\nisGecko = has('Gecko') && !isWebKit && !isIe && !isEdge;\n\n// Platforms.  Logic from:\n// https://github.com/google/closure-library/blob/master/closure/goog/labs/useragent/platform.js\n// and\n// https://github.com/google/closure-library/blob/master/closure/goog/labs/useragent/extra.js\nisAndroid = has('Android');\nconst maxTouchPoints =\n    globalThis['navigator'] && globalThis['navigator']['maxTouchPoints'];\nisIPad = has('iPad') || has('Macintosh') && maxTouchPoints > 0;\nisIPod = has('iPod');\nisIPhone = has('iPhone') && !isIPad && !isIPod;\nisMac = has('Macintosh');\n\n// Devices.  Logic from:\n// https://github.com/google/closure-library/blob/master/closure/goog/labs/useragent/device.js\nisTablet = isIPad || (isAndroid && !has('Mobile')) || has('Silk');\nisMobile = !isTablet && (isIPod || isIPhone || isAndroid || has('IEMobile'));\n})((globalThis['navigator'] && globalThis['navigator']['userAgent']) || '');\n\n/**\n * @const {string}\n * @alias Blockly.utils.userAgent.raw\n */\nexports.raw = rawUserAgent;\n\n/**\n * @const {boolean}\n * @alias Blockly.utils.userAgent.IE\n */\nexports.IE = isIe;\n\n/**\n * @const {boolean}\n * @alias Blockly.utils.userAgent.EDGE\n */\nexports.EDGE = isEdge;\n\n/**\n * @const {boolean}\n * @alias Blockly.utils.userAgent.JavaFx\n */\nexports.JavaFx = isJavaFx;\n\n/**\n * @const {boolean}\n * @alias Blockly.utils.userAgent.CHROME\n */\nexports.CHROME = isChrome;\n\n/**\n * @const {boolean}\n * @alias Blockly.utils.userAgent.WEBKIT\n */\nexports.WEBKIT = isWebKit;\n\n/**\n * @const {boolean}\n * @alias Blockly.utils.userAgent.GECKO\n */\nexports.GECKO = isGecko;\n\n/**\n * @const {boolean}\n * @alias Blockly.utils.userAgent.ANDROID\n */\nexports.ANDROID = isAndroid;\n\n/**\n * @const {boolean}\n * @alias Blockly.utils.userAgent.IPAD\n */\nexports.IPAD = isIPad;\n\n/**\n * @const {boolean}\n * @alias Blockly.utils.userAgent.IPOD\n */\nexports.IPOD = isIPod;\n\n/**\n * @const {boolean}\n * @alias Blockly.utils.userAgent.IPHONE\n */\nexports.IPHONE = isIPhone;\n\n/**\n * @const {boolean}\n * @alias Blockly.utils.userAgent.MAC\n */\nexports.MAC = isMac;\n\n/**\n * @const {boolean}\n * @alias Blockly.utils.userAgent.TABLET\n */\nexports.TABLET = isTablet;\n\n/**\n * @const {boolean}\n * @alias Blockly.utils.userAgent.MOBILE\n */\nexports.MOBILE = isMobile;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/useragent.js?")},
"./core/utils/xml.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/global.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview XML element manipulation.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n */\n\n\n/**\n * XML element manipulation.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n * @namespace Blockly.utils.xml\n */\ngoog.module('Blockly.utils.xml');\n\nconst {globalThis} = goog.require('Blockly.utils.global');\n\n\n/**\n * Namespace for Blockly's XML.\n * @alias Blockly.utils.xml.NAME_SPACE\n */\nconst NAME_SPACE = 'https://developers.google.com/blockly/xml';\nexports.NAME_SPACE = NAME_SPACE;\n\n/**\n * The Document object to use.  By default this is just document, but\n * the Node.js build of Blockly (see scripts/package/node/core.js)\n * calls setDocument to supply a Document implementation from the\n * jsdom package instead.\n * @type {!Document}\n */\nlet xmlDocument = globalThis['document'];\n\n/**\n * Get the document object to use for XML serialization.\n * @return {!Document} The document object.\n * @alias Blockly.utils.xml.getDocument\n */\nconst getDocument = function() {\n  return xmlDocument;\n};\nexports.getDocument = getDocument;\n\n/**\n * Get the document object to use for XML serialization.\n * @param {!Document} document The document object to use.\n * @alias Blockly.utils.xml.setDocument\n */\nconst setDocument = function(document) {\n  xmlDocument = document;\n};\nexports.setDocument = setDocument;\n\n/**\n * Create DOM element for XML.\n * @param {string} tagName Name of DOM element.\n * @return {!Element} New DOM element.\n * @alias Blockly.utils.xml.createElement\n */\nconst createElement = function(tagName) {\n  return xmlDocument.createElementNS(NAME_SPACE, tagName);\n};\nexports.createElement = createElement;\n\n/**\n * Create text element for XML.\n * @param {string} text Text content.\n * @return {!Text} New DOM text node.\n * @alias Blockly.utils.xml.createTextNode\n */\nconst createTextNode = function(text) {\n  return xmlDocument.createTextNode(text);\n};\nexports.createTextNode = createTextNode;\n\n/**\n * Converts an XML string into a DOM tree.\n * @param {string} text XML string.\n * @return {Document} The DOM document.\n * @throws if XML doesn't parse.\n * @alias Blockly.utils.xml.textToDomDocument\n */\nconst textToDomDocument = function(text) {\n  const oParser = new DOMParser();\n  return oParser.parseFromString(text, 'text/xml');\n};\nexports.textToDomDocument = textToDomDocument;\n\n/**\n * Converts a DOM structure into plain text.\n * Currently the text format is fairly ugly: all one line with no whitespace.\n * @param {!Node} dom A tree of XML nodes.\n * @return {string} Text representation.\n * @alias Blockly.utils.xml.domToText\n */\nconst domToText = function(dom) {\n  const oSerializer = new XMLSerializer();\n  return oSerializer.serializeToString(dom);\n};\nexports.domToText = domToText;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/utils/xml.js?")},
"./core/variable_map.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/array.js\");\n__webpack_require__(\"./core/dialog.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/utils/idgenerator.js\");\n__webpack_require__(\"./core/utils/object.js\");\n__webpack_require__(\"./core/msg.js\");\n__webpack_require__(\"./core/names.js\");\n__webpack_require__(\"./core/variable_model.js\");\n__webpack_require__(\"./core/events/events_var_delete.js\");\n__webpack_require__(\"./core/events/events_var_rename.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing a map of variables and their types.\n */\n\n\n/**\n * Object representing a map of variables and their types.\n * @class\n */\ngoog.module('Blockly.VariableMap');\n\nconst arrayUtils = goog.require('Blockly.utils.array');\nconst dialog = goog.require('Blockly.dialog');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst idGenerator = goog.require('Blockly.utils.idGenerator');\nconst object = goog.require('Blockly.utils.object');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\nconst {Msg} = goog.require('Blockly.Msg');\nconst {Names} = goog.require('Blockly.Names');\nconst {VariableModel} = goog.require('Blockly.VariableModel');\n/* eslint-disable-next-line no-unused-vars */\nconst {Workspace} = goog.requireType('Blockly.Workspace');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.VarDelete');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.VarRename');\n\n\n/**\n * Class for a variable map.  This contains a dictionary data structure with\n * variable types as keys and lists of variables as values.  The list of\n * variables are the type indicated by the key.\n * @alias Blockly.VariableMap\n */\nclass VariableMap {\n  /**\n   * @param {!Workspace} workspace The workspace this map belongs to.\n   */\n  constructor(workspace) {\n    /**\n     * A map from variable type to list of variable names.  The lists contain\n     * all of the named variables in the workspace, including variables that are\n     * not currently in use.\n     * @type {!Object<string, !Array<VariableModel>>}\n     * @private\n     */\n    this.variableMap_ = Object.create(null);\n\n    /**\n     * The workspace this map belongs to.\n     * @type {!Workspace}\n     */\n    this.workspace = workspace;\n  }\n  /**\n   * Clear the variable map.\n   */\n  clear() {\n    this.variableMap_ = Object.create(null);\n  }\n  /* Begin functions for renaming variables. */\n  /**\n   * Rename the given variable by updating its name in the variable map.\n   * @param {!VariableModel} variable Variable to rename.\n   * @param {string} newName New variable name.\n   * @package\n   */\n  renameVariable(variable, newName) {\n    const type = variable.type;\n    const conflictVar = this.getVariable(newName, type);\n    const blocks = this.workspace.getAllBlocks(false);\n    eventUtils.setGroup(true);\n    try {\n      // The IDs may match if the rename is a simple case change (name1 ->\n      // Name1).\n      if (!conflictVar || conflictVar.getId() === variable.getId()) {\n        this.renameVariableAndUses_(variable, newName, blocks);\n      } else {\n        this.renameVariableWithConflict_(\n            variable, newName, conflictVar, blocks);\n      }\n    } finally {\n      eventUtils.setGroup(false);\n    }\n  }\n  /**\n   * Rename a variable by updating its name in the variable map. Identify the\n   * variable to rename with the given ID.\n   * @param {string} id ID of the variable to rename.\n   * @param {string} newName New variable name.\n   */\n  renameVariableById(id, newName) {\n    const variable = this.getVariableById(id);\n    if (!variable) {\n      throw Error('Tried to rename a variable that didn\\'t exist. ID: ' + id);\n    }\n\n    this.renameVariable(variable, newName);\n  }\n  /**\n   * Update the name of the given variable and refresh all references to it.\n   * The new name must not conflict with any existing variable names.\n   * @param {!VariableModel} variable Variable to rename.\n   * @param {string} newName New variable name.\n   * @param {!Array<!Block>} blocks The list of all blocks in the\n   *     workspace.\n   * @private\n   */\n  renameVariableAndUses_(variable, newName, blocks) {\n    eventUtils.fire(\n        new (eventUtils.get(eventUtils.VAR_RENAME))(variable, newName));\n    variable.name = newName;\n    for (let i = 0; i < blocks.length; i++) {\n      blocks[i].updateVarName(variable);\n    }\n  }\n  /**\n   * Update the name of the given variable to the same name as an existing\n   * variable.  The two variables are coalesced into a single variable with the\n   * ID of the existing variable that was already using newName. Refresh all\n   * references to the variable.\n   * @param {!VariableModel} variable Variable to rename.\n   * @param {string} newName New variable name.\n   * @param {!VariableModel} conflictVar The variable that was already\n   *     using newName.\n   * @param {!Array<!Block>} blocks The list of all blocks in the\n   *     workspace.\n   * @private\n   */\n  renameVariableWithConflict_(variable, newName, conflictVar, blocks) {\n    const type = variable.type;\n    const oldCase = conflictVar.name;\n\n    if (newName !== oldCase) {\n      // Simple rename to change the case and update references.\n      this.renameVariableAndUses_(conflictVar, newName, blocks);\n    }\n\n    // These blocks now refer to a different variable.\n    // These will fire change events.\n    for (let i = 0; i < blocks.length; i++) {\n      blocks[i].renameVarById(variable.getId(), conflictVar.getId());\n    }\n\n    // Finally delete the original variable, which is now unreferenced.\n    eventUtils.fire(new (eventUtils.get(eventUtils.VAR_DELETE))(variable));\n    // And remove it from the list.\n    arrayUtils.removeElem(this.variableMap_[type], variable);\n  }\n  /* End functions for renaming variables. */\n  /**\n   * Create a variable with a given name, optional type, and optional ID.\n   * @param {string} name The name of the variable. This must be unique across\n   *     variables and procedures.\n   * @param {?string=} opt_type The type of the variable like 'int' or 'string'.\n   *     Does not need to be unique. Field_variable can filter variables based\n   * on their type. This will default to '' which is a specific type.\n   * @param {?string=} opt_id The unique ID of the variable. This will default\n   *     to a UUID.\n   * @return {!VariableModel} The newly created variable.\n   */\n  createVariable(name, opt_type, opt_id) {\n    let variable = this.getVariable(name, opt_type);\n    if (variable) {\n      if (opt_id && variable.getId() !== opt_id) {\n        throw Error(\n            'Variable \"' + name + '\" is already in use and its id is \"' +\n            variable.getId() + '\" which conflicts with the passed in ' +\n            'id, \"' + opt_id + '\".');\n      }\n      // The variable already exists and has the same ID.\n      return variable;\n    }\n    if (opt_id && this.getVariableById(opt_id)) {\n      throw Error('Variable id, \"' + opt_id + '\", is already in use.');\n    }\n    const id = opt_id || idGenerator.genUid();\n    const type = opt_type || '';\n    variable = new VariableModel(this.workspace, name, type, id);\n\n    const variables = this.variableMap_[type] || [];\n    variables.push(variable);\n    // Delete the list of variables of this type, and re-add it so that\n    // the most recent addition is at the end.\n    // This is used so the toolbox's set block is set to the most recent\n    // variable.\n    delete this.variableMap_[type];\n    this.variableMap_[type] = variables;\n\n    return variable;\n  }\n  /* Begin functions for variable deletion. */\n  /**\n   * Delete a variable.\n   * @param {!VariableModel} variable Variable to delete.\n   */\n  deleteVariable(variable) {\n    const variableId = variable.getId();\n    const variableList = this.variableMap_[variable.type];\n    for (let i = 0; i < variableList.length; i++) {\n      const tempVar = variableList[i];\n      if (tempVar.getId() === variableId) {\n        variableList.splice(i, 1);\n        eventUtils.fire(new (eventUtils.get(eventUtils.VAR_DELETE))(variable));\n        return;\n      }\n    }\n  }\n  /**\n   * Delete a variables by the passed in ID and all of its uses from this\n   * workspace. May prompt the user for confirmation.\n   * @param {string} id ID of variable to delete.\n   */\n  deleteVariableById(id) {\n    const variable = this.getVariableById(id);\n    if (variable) {\n      // Check whether this variable is a function parameter before deleting.\n      const variableName = variable.name;\n      const uses = this.getVariableUsesById(id);\n      for (let i = 0, block; (block = uses[i]); i++) {\n        if (block.type === 'procedures_defnoreturn' ||\n            block.type === 'procedures_defreturn') {\n          const procedureName = String(block.getFieldValue('NAME'));\n          const deleteText = Msg['CANNOT_DELETE_VARIABLE_PROCEDURE']\n                                 .replace('%1', variableName)\n                                 .replace('%2', procedureName);\n          dialog.alert(deleteText);\n          return;\n        }\n      }\n\n      const map = this;\n      if (uses.length > 1) {\n        // Confirm before deleting multiple blocks.\n        const confirmText = Msg['DELETE_VARIABLE_CONFIRMATION']\n                                .replace('%1', String(uses.length))\n                                .replace('%2', variableName);\n        dialog.confirm(confirmText, function(ok) {\n          if (ok && variable) {\n            map.deleteVariableInternal(variable, uses);\n          }\n        });\n      } else {\n        // No confirmation necessary for a single block.\n        map.deleteVariableInternal(variable, uses);\n      }\n    } else {\n      console.warn('Can\\'t delete non-existent variable: ' + id);\n    }\n  }\n  /**\n   * Deletes a variable and all of its uses from this workspace without asking\n   * the user for confirmation.\n   * @param {!VariableModel} variable Variable to delete.\n   * @param {!Array<!Block>} uses An array of uses of the variable.\n   * @package\n   */\n  deleteVariableInternal(variable, uses) {\n    const existingGroup = eventUtils.getGroup();\n    if (!existingGroup) {\n      eventUtils.setGroup(true);\n    }\n    try {\n      for (let i = 0; i < uses.length; i++) {\n        uses[i].dispose(true);\n      }\n      this.deleteVariable(variable);\n    } finally {\n      if (!existingGroup) {\n        eventUtils.setGroup(false);\n      }\n    }\n  }\n  /* End functions for variable deletion. */\n  /**\n   * Find the variable by the given name and type and return it.  Return null if\n   *     it is not found.\n   * @param {string} name The name to check for.\n   * @param {?string=} opt_type The type of the variable.  If not provided it\n   *     defaults to the empty string, which is a specific type.\n   * @return {?VariableModel} The variable with the given name, or null if\n   *     it was not found.\n   */\n  getVariable(name, opt_type) {\n    const type = opt_type || '';\n    const list = this.variableMap_[type];\n    if (list) {\n      for (let j = 0, variable; (variable = list[j]); j++) {\n        if (Names.equals(variable.name, name)) {\n          return variable;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Find the variable by the given ID and return it.  Return null if not found.\n   * @param {string} id The ID to check for.\n   * @return {?VariableModel} The variable with the given ID.\n   */\n  getVariableById(id) {\n    const keys = Object.keys(this.variableMap_);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      for (let j = 0, variable; (variable = this.variableMap_[key][j]); j++) {\n        if (variable.getId() === id) {\n          return variable;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Get a list containing all of the variables of a specified type. If type is\n   *     null, return list of variables with empty string type.\n   * @param {?string} type Type of the variables to find.\n   * @return {!Array<!VariableModel>} The sought after variables of the\n   *     passed in type. An empty array if none are found.\n   */\n  getVariablesOfType(type) {\n    type = type || '';\n    const variableList = this.variableMap_[type];\n    if (variableList) {\n      return variableList.slice();\n    }\n    return [];\n  }\n  /**\n   * Return all variable and potential variable types.  This list always\n   * contains the empty string.\n   * @param {?Workspace} ws The workspace used to look for potential\n   * variables. This can be different than the workspace stored on this object\n   * if the passed in ws is a flyout workspace.\n   * @return {!Array<string>} List of variable types.\n   * @package\n   */\n  getVariableTypes(ws) {\n    const variableMap = {};\n    object.mixin(variableMap, this.variableMap_);\n    if (ws && ws.getPotentialVariableMap()) {\n      object.mixin(variableMap, ws.getPotentialVariableMap().variableMap_);\n    }\n    const types = Object.keys(variableMap);\n    let hasEmpty = false;\n    for (let i = 0; i < types.length; i++) {\n      if (types[i] === '') {\n        hasEmpty = true;\n      }\n    }\n    if (!hasEmpty) {\n      types.push('');\n    }\n    return types;\n  }\n  /**\n   * Return all variables of all types.\n   * @return {!Array<!VariableModel>} List of variable models.\n   */\n  getAllVariables() {\n    let allVariables = [];\n    for (const key in this.variableMap_) {\n      allVariables = allVariables.concat(this.variableMap_[key]);\n    }\n    return allVariables;\n  }\n  /**\n   * Returns all of the variable names of all types.\n   * @return {!Array<string>} All of the variable names of all types.\n   */\n  getAllVariableNames() {\n    const allNames = [];\n    for (const key in this.variableMap_) {\n      const variables = this.variableMap_[key];\n      for (let i = 0, variable; (variable = variables[i]); i++) {\n        allNames.push(variable.name);\n      }\n    }\n    return allNames;\n  }\n  /**\n   * Find all the uses of a named variable.\n   * @param {string} id ID of the variable to find.\n   * @return {!Array<!Block>} Array of block usages.\n   */\n  getVariableUsesById(id) {\n    const uses = [];\n    const blocks = this.workspace.getAllBlocks(false);\n    // Iterate through every block and check the name.\n    for (let i = 0; i < blocks.length; i++) {\n      const blockVariables = blocks[i].getVarModels();\n      if (blockVariables) {\n        for (let j = 0; j < blockVariables.length; j++) {\n          if (blockVariables[j].getId() === id) {\n            uses.push(blocks[i]);\n          }\n        }\n      }\n    }\n    return uses;\n  }\n}\n\nexports.VariableMap = VariableMap;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/variable_map.js?")},
"./core/variable_model.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/utils/idgenerator.js\");\n__webpack_require__(\"./core/events/events_var_create.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Components for the variable model.\n */\n\n\n/**\n * Components for the variable model.\n * @class\n */\ngoog.module('Blockly.VariableModel');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst idGenerator = goog.require('Blockly.utils.idGenerator');\n/* eslint-disable-next-line no-unused-vars */\nconst {Workspace} = goog.requireType('Blockly.Workspace');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.VarCreate');\n\n\n/**\n * Class for a variable model.\n * Holds information for the variable including name, ID, and type.\n * @see {Blockly.FieldVariable}\n * @alias Blockly.VariableModel\n */\nclass VariableModel {\n  /**\n   * @param {!Workspace} workspace The variable's workspace.\n   * @param {string} name The name of the variable.  This is the user-visible\n   *     name (e.g. 'my var' or '\u79c1\u306e\u5909\u6570'), not the generated name.\n   * @param {string=} opt_type The type of the variable like 'int' or 'string'.\n   *     Does not need to be unique. Field_variable can filter variables based\n   * on their type. This will default to '' which is a specific type.\n   * @param {string=} opt_id The unique ID of the variable. This will default to\n   *     a UUID.\n   */\n  constructor(workspace, name, opt_type, opt_id) {\n    /**\n     * The workspace the variable is in.\n     * @type {!Workspace}\n     */\n    this.workspace = workspace;\n\n    /**\n     * The name of the variable, typically defined by the user.  It may be\n     * changed by the user.\n     * @type {string}\n     */\n    this.name = name;\n\n    /**\n     * The type of the variable, such as 'int' or 'sound_effect'. This may be\n     * used to build a list of variables of a specific type. By default this is\n     * the empty string '', which is a specific type.\n     * @see {Blockly.FieldVariable}\n     * @type {string}\n     */\n    this.type = opt_type || '';\n\n    /**\n     * A unique ID for the variable. This should be defined at creation and\n     * not change, even if the name changes. In most cases this should be a\n     * UUID.\n     * @type {string}\n     * @private\n     */\n    this.id_ = opt_id || idGenerator.genUid();\n\n    eventUtils.fire(new (eventUtils.get(eventUtils.VAR_CREATE))(this));\n  }\n  /**\n   * @return {string} The ID for the variable.\n   */\n  getId() {\n    return this.id_;\n  }\n  /**\n   * A custom compare function for the VariableModel objects.\n   * @param {VariableModel} var1 First variable to compare.\n   * @param {VariableModel} var2 Second variable to compare.\n   * @return {number} -1 if name of var1 is less than name of var2, 0 if equal,\n   *     and 1 if greater.\n   * @package\n   */\n  static compareByName(var1, var2) {\n    return var1.name.localeCompare(var2.name, undefined, {sensitivity: 'base'});\n  }\n}\n\nexports.VariableModel = VariableModel;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/variable_model.js?")},
"./core/variables.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/xml.js\");\n__webpack_require__(\"./core/dialog.js\");\n__webpack_require__(\"./core/utils/xml.js\");\n__webpack_require__(\"./core/blocks.js\");\n__webpack_require__(\"./core/msg.js\");\n__webpack_require__(\"./core/variable_model.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility functions for handling variables.\n */\n\n\n/**\n * Utility functions for handling variables.\n * @namespace Blockly.Variables\n */\ngoog.module('Blockly.Variables');\n\nconst Xml = goog.require('Blockly.Xml');\nconst dialog = goog.require('Blockly.dialog');\nconst utilsXml = goog.require('Blockly.utils.xml');\nconst {Blocks} = goog.require('Blockly.blocks');\nconst {Msg} = goog.require('Blockly.Msg');\nconst {VariableModel} = goog.require('Blockly.VariableModel');\n/* eslint-disable-next-line no-unused-vars */\nconst {Workspace} = goog.requireType('Blockly.Workspace');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n/**\n * String for use in the \"custom\" attribute of a category in toolbox XML.\n * This string indicates that the category should be dynamically populated with\n * variable blocks.\n * See also Blockly.Procedures.CATEGORY_NAME and\n * Blockly.VariablesDynamic.CATEGORY_NAME.\n * @const {string}\n * @alias Blockly.Variables.CATEGORY_NAME\n */\nconst CATEGORY_NAME = 'VARIABLE';\nexports.CATEGORY_NAME = CATEGORY_NAME;\n\n/**\n * Find all user-created variables that are in use in the workspace.\n * For use by generators.\n * To get a list of all variables on a workspace, including unused variables,\n * call Workspace.getAllVariables.\n * @param {!Workspace} ws The workspace to search for variables.\n * @return {!Array<!VariableModel>} Array of variable models.\n * @alias Blockly.Variables.allUsedVarModels\n */\nconst allUsedVarModels = function(ws) {\n  const blocks = ws.getAllBlocks(false);\n  const variableHash = Object.create(null);\n  // Iterate through every block and add each variable to the hash.\n  for (let i = 0; i < blocks.length; i++) {\n    const blockVariables = blocks[i].getVarModels();\n    if (blockVariables) {\n      for (let j = 0; j < blockVariables.length; j++) {\n        const variable = blockVariables[j];\n        const id = variable.getId();\n        if (id) {\n          variableHash[id] = variable;\n        }\n      }\n    }\n  }\n  // Flatten the hash into a list.\n  const variableList = [];\n  for (const id in variableHash) {\n    variableList.push(variableHash[id]);\n  }\n  return variableList;\n};\nexports.allUsedVarModels = allUsedVarModels;\n\n/**\n * @type {Object<string,boolean>}\n */\nconst ALL_DEVELOPER_VARS_WARNINGS_BY_BLOCK_TYPE = {};\n\n/**\n * Find all developer variables used by blocks in the workspace.\n * Developer variables are never shown to the user, but are declared as global\n * variables in the generated code.\n * To declare developer variables, define the getDeveloperVariables function on\n * your block and return a list of variable names.\n * For use by generators.\n * @param {!Workspace} workspace The workspace to search.\n * @return {!Array<string>} A list of non-duplicated variable names.\n * @alias Blockly.Variables.allDeveloperVariables\n */\nconst allDeveloperVariables = function(workspace) {\n  const blocks = workspace.getAllBlocks(false);\n  const variableHash = Object.create(null);\n  for (let i = 0, block; (block = blocks[i]); i++) {\n    let getDeveloperVariables = block.getDeveloperVariables;\n    if (!getDeveloperVariables && block.getDeveloperVars) {\n      // August 2018: getDeveloperVars() was deprecated and renamed\n      // getDeveloperVariables().\n      getDeveloperVariables = block.getDeveloperVars;\n      if (!ALL_DEVELOPER_VARS_WARNINGS_BY_BLOCK_TYPE[block.type]) {\n        console.warn(\n            'Function getDeveloperVars() deprecated. Use ' +\n            'getDeveloperVariables() (block type \\'' + block.type + '\\')');\n        ALL_DEVELOPER_VARS_WARNINGS_BY_BLOCK_TYPE[block.type] = true;\n      }\n    }\n    if (getDeveloperVariables) {\n      const devVars = getDeveloperVariables();\n      for (let j = 0; j < devVars.length; j++) {\n        variableHash[devVars[j]] = true;\n      }\n    }\n  }\n\n  // Flatten the hash into a list.\n  return Object.keys(variableHash);\n};\nexports.allDeveloperVariables = allDeveloperVariables;\n\n/**\n * Construct the elements (blocks and button) required by the flyout for the\n * variable category.\n * @param {!WorkspaceSvg} workspace The workspace containing variables.\n * @return {!Array<!Element>} Array of XML elements.\n * @alias Blockly.Variables.flyoutCategory\n */\nconst flyoutCategory = function(workspace) {\n  let xmlList = [];\n  const button = document.createElement('button');\n  button.setAttribute('text', '%{BKY_NEW_VARIABLE}');\n  button.setAttribute('callbackKey', 'CREATE_VARIABLE');\n\n  workspace.registerButtonCallback('CREATE_VARIABLE', function(button) {\n    createVariableButtonHandler(button.getTargetWorkspace());\n  });\n\n  xmlList.push(button);\n\n  const blockList = flyoutCategoryBlocks(workspace);\n  xmlList = xmlList.concat(blockList);\n  return xmlList;\n};\nexports.flyoutCategory = flyoutCategory;\n\n/**\n * Construct the blocks required by the flyout for the variable category.\n * @param {!Workspace} workspace The workspace containing variables.\n * @return {!Array<!Element>} Array of XML block elements.\n * @alias Blockly.Variables.flyoutCategoryBlocks\n */\nconst flyoutCategoryBlocks = function(workspace) {\n  const variableModelList = workspace.getVariablesOfType('');\n\n  const xmlList = [];\n  if (variableModelList.length > 0) {\n    // New variables are added to the end of the variableModelList.\n    const mostRecentVariable = variableModelList[variableModelList.length - 1];\n    if (Blocks['variables_set']) {\n      const block = utilsXml.createElement('block');\n      block.setAttribute('type', 'variables_set');\n      block.setAttribute('gap', Blocks['math_change'] ? 8 : 24);\n      block.appendChild(generateVariableFieldDom(mostRecentVariable));\n      xmlList.push(block);\n    }\n    if (Blocks['math_change']) {\n      const block = utilsXml.createElement('block');\n      block.setAttribute('type', 'math_change');\n      block.setAttribute('gap', Blocks['variables_get'] ? 20 : 8);\n      block.appendChild(generateVariableFieldDom(mostRecentVariable));\n      const value = Xml.textToDom(\n          '<value name=\"DELTA\">' +\n          '<shadow type=\"math_number\">' +\n          '<field name=\"NUM\">1</field>' +\n          '</shadow>' +\n          '</value>');\n      block.appendChild(value);\n      xmlList.push(block);\n    }\n\n    if (Blocks['variables_get']) {\n      variableModelList.sort(VariableModel.compareByName);\n      for (let i = 0, variable; (variable = variableModelList[i]); i++) {\n        const block = utilsXml.createElement('block');\n        block.setAttribute('type', 'variables_get');\n        block.setAttribute('gap', 8);\n        block.appendChild(generateVariableFieldDom(variable));\n        xmlList.push(block);\n      }\n    }\n  }\n  return xmlList;\n};\nexports.flyoutCategoryBlocks = flyoutCategoryBlocks;\n\n/**\n * @alias Blockly.Variables.VAR_LETTER_OPTIONS\n */\nconst VAR_LETTER_OPTIONS = 'ijkmnopqrstuvwxyzabcdefgh';  // No 'l'.\nexports.VAR_LETTER_OPTIONS = VAR_LETTER_OPTIONS;\n\n/**\n * Return a new variable name that is not yet being used. This will try to\n * generate single letter variable names in the range 'i' to 'z' to start with.\n * If no unique name is located it will try 'i' to 'z', 'a' to 'h',\n * then 'i2' to 'z2' etc.  Skip 'l'.\n * @param {!Workspace} workspace The workspace to be unique in.\n * @return {string} New variable name.\n * @alias Blockly.Variables.generateUniqueName\n */\nconst generateUniqueName = function(workspace) {\n  return generateUniqueNameFromOptions(\n      VAR_LETTER_OPTIONS.charAt(0), workspace.getAllVariableNames());\n};\nexports.generateUniqueName = generateUniqueName;\n\n/**\n * Returns a unique name that is not present in the usedNames array. This\n * will try to generate single letter names in the range a -> z (skip l). It\n * will start with the character passed to startChar.\n * @param {string} startChar The character to start the search at.\n * @param {!Array<string>} usedNames A list of all of the used names.\n * @return {string} A unique name that is not present in the usedNames array.\n * @alias Blockly.Variables.generateUniqueNameFromOptions\n */\nconst generateUniqueNameFromOptions = function(startChar, usedNames) {\n  if (!usedNames.length) {\n    return startChar;\n  }\n\n  const letters = VAR_LETTER_OPTIONS;\n  let suffix = '';\n  let letterIndex = letters.indexOf(startChar);\n  let potName = startChar;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let inUse = false;\n    for (let i = 0; i < usedNames.length; i++) {\n      if (usedNames[i].toLowerCase() === potName) {\n        inUse = true;\n        break;\n      }\n    }\n    if (!inUse) {\n      return potName;\n    }\n\n    letterIndex++;\n    if (letterIndex === letters.length) {\n      // Reached the end of the character sequence so back to 'i'.\n      letterIndex = 0;\n      suffix = Number(suffix) + 1;\n    }\n    potName = letters.charAt(letterIndex) + suffix;\n  }\n};\nexports.generateUniqueNameFromOptions = generateUniqueNameFromOptions;\n\n/**\n * Handles \"Create Variable\" button in the default variables toolbox category.\n * It will prompt the user for a variable name, including re-prompts if a name\n * is already in use among the workspace's variables.\n *\n * Custom button handlers can delegate to this function, allowing variables\n * types and after-creation processing. More complex customization (e.g.,\n * prompting for variable type) is beyond the scope of this function.\n *\n * @param {!Workspace} workspace The workspace on which to create the\n *     variable.\n * @param {function(?string=)=} opt_callback A callback. It will be passed an\n *     acceptable new variable name, or null if change is to be aborted (cancel\n *     button), or undefined if an existing variable was chosen.\n * @param {string=} opt_type The type of the variable like 'int', 'string', or\n *     ''. This will default to '', which is a specific type.\n * @alias Blockly.Variables.createVariableButtonHandler\n */\nconst createVariableButtonHandler = function(\n    workspace, opt_callback, opt_type) {\n  const type = opt_type || '';\n  // This function needs to be named so it can be called recursively.\n  const promptAndCheckWithAlert = function(defaultName) {\n    promptName(Msg['NEW_VARIABLE_TITLE'], defaultName, function(text) {\n      if (text) {\n        const existing = nameUsedWithAnyType(text, workspace);\n        if (existing) {\n          let msg;\n          if (existing.type === type) {\n            msg = Msg['VARIABLE_ALREADY_EXISTS'].replace('%1', existing.name);\n          } else {\n            msg = Msg['VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE'];\n            msg = msg.replace('%1', existing.name).replace('%2', existing.type);\n          }\n          dialog.alert(msg, function() {\n            promptAndCheckWithAlert(text);  // Recurse\n          });\n        } else {\n          // No conflict\n          workspace.createVariable(text, type);\n          if (opt_callback) {\n            opt_callback(text);\n          }\n        }\n      } else {\n        // User canceled prompt.\n        if (opt_callback) {\n          opt_callback(null);\n        }\n      }\n    });\n  };\n  promptAndCheckWithAlert('');\n};\nexports.createVariableButtonHandler = createVariableButtonHandler;\n\n/**\n * Opens a prompt that allows the user to enter a new name for a variable.\n * Triggers a rename if the new name is valid. Or re-prompts if there is a\n * collision.\n * @param {!Workspace} workspace The workspace on which to rename the\n *     variable.\n * @param {!VariableModel} variable Variable to rename.\n * @param {function(?string=)=} opt_callback A callback. It will\n *     be passed an acceptable new variable name, or null if change is to be\n *     aborted (cancel button), or undefined if an existing variable was chosen.\n * @alias Blockly.Variables.renameVariable\n */\nconst renameVariable = function(workspace, variable, opt_callback) {\n  // This function needs to be named so it can be called recursively.\n  const promptAndCheckWithAlert = function(defaultName) {\n    const promptText =\n        Msg['RENAME_VARIABLE_TITLE'].replace('%1', variable.name);\n    promptName(promptText, defaultName, function(newName) {\n      if (newName) {\n        const existing =\n            nameUsedWithOtherType(newName, variable.type, workspace);\n        if (existing) {\n          const msg = Msg['VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE']\n                          .replace('%1', existing.name)\n                          .replace('%2', existing.type);\n          dialog.alert(msg, function() {\n            promptAndCheckWithAlert(newName);  // Recurse\n          });\n        } else {\n          workspace.renameVariableById(variable.getId(), newName);\n          if (opt_callback) {\n            opt_callback(newName);\n          }\n        }\n      } else {\n        // User canceled prompt.\n        if (opt_callback) {\n          opt_callback(null);\n        }\n      }\n    });\n  };\n  promptAndCheckWithAlert('');\n};\nexports.renameVariable = renameVariable;\n\n/**\n * Prompt the user for a new variable name.\n * @param {string} promptText The string of the prompt.\n * @param {string} defaultText The default value to show in the prompt's field.\n * @param {function(?string)} callback A callback. It will return the new\n *     variable name, or null if the user picked something illegal.\n * @alias Blockly.Variables.promptName\n */\nconst promptName = function(promptText, defaultText, callback) {\n  dialog.prompt(promptText, defaultText, function(newVar) {\n    // Merge runs of whitespace.  Strip leading and trailing whitespace.\n    // Beyond this, all names are legal.\n    if (newVar) {\n      newVar = newVar.replace(/[\\s\\xa0]+/g, ' ').trim();\n      if (newVar === Msg['RENAME_VARIABLE'] || newVar === Msg['NEW_VARIABLE']) {\n        // Ok, not ALL names are legal...\n        newVar = null;\n      }\n    }\n    callback(newVar);\n  });\n};\nexports.promptName = promptName;\n\n/**\n * Check whether there exists a variable with the given name but a different\n * type.\n * @param {string} name The name to search for.\n * @param {string} type The type to exclude from the search.\n * @param {!Workspace} workspace The workspace to search for the\n *     variable.\n * @return {?VariableModel} The variable with the given name and a\n *     different type, or null if none was found.\n */\nconst nameUsedWithOtherType = function(name, type, workspace) {\n  const allVariables = workspace.getVariableMap().getAllVariables();\n\n  name = name.toLowerCase();\n  for (let i = 0, variable; (variable = allVariables[i]); i++) {\n    if (variable.name.toLowerCase() === name && variable.type !== type) {\n      return variable;\n    }\n  }\n  return null;\n};\n\n/**\n * Check whether there exists a variable with the given name of any type.\n * @param {string} name The name to search for.\n * @param {!Workspace} workspace The workspace to search for the\n *     variable.\n * @return {?VariableModel} The variable with the given name,\n *     or null if none was found.\n * @alias Blockly.Variables.nameUsedWithAnyType\n */\nconst nameUsedWithAnyType = function(name, workspace) {\n  const allVariables = workspace.getVariableMap().getAllVariables();\n\n  name = name.toLowerCase();\n  for (let i = 0, variable; (variable = allVariables[i]); i++) {\n    if (variable.name.toLowerCase() === name) {\n      return variable;\n    }\n  }\n  return null;\n};\nexports.nameUsedWithAnyType = nameUsedWithAnyType;\n\n/**\n * Generate DOM objects representing a variable field.\n * @param {!VariableModel} variableModel The variable model to\n *     represent.\n * @return {?Element} The generated DOM.\n * @alias Blockly.Variables.generateVariableFieldDom\n */\nconst generateVariableFieldDom = function(variableModel) {\n  /* Generates the following XML:\n   * <field name=\"VAR\" id=\"goKTKmYJ8DhVHpruv\" variabletype=\"int\">foo</field>\n   */\n  const field = utilsXml.createElement('field');\n  field.setAttribute('name', 'VAR');\n  field.setAttribute('id', variableModel.getId());\n  field.setAttribute('variabletype', variableModel.type);\n  const name = utilsXml.createTextNode(variableModel.name);\n  field.appendChild(name);\n  return field;\n};\nexports.generateVariableFieldDom = generateVariableFieldDom;\n\n/**\n * Helper function to look up or create a variable on the given workspace.\n * If no variable exists, creates and returns it.\n * @param {!Workspace} workspace The workspace to search for the\n *     variable.  It may be a flyout workspace or main workspace.\n * @param {?string} id The ID to use to look up or create the variable, or null.\n * @param {string=} opt_name The string to use to look up or create the\n *     variable.\n * @param {string=} opt_type The type to use to look up or create the variable.\n * @return {!VariableModel} The variable corresponding to the given ID\n *     or name + type combination.\n * @alias Blockly.Variables.getOrCreateVariablePackage\n */\nconst getOrCreateVariablePackage = function(workspace, id, opt_name, opt_type) {\n  let variable = getVariable(workspace, id, opt_name, opt_type);\n  if (!variable) {\n    variable = createVariable(workspace, id, opt_name, opt_type);\n  }\n  return variable;\n};\nexports.getOrCreateVariablePackage = getOrCreateVariablePackage;\n\n/**\n * Look up  a variable on the given workspace.\n * Always looks in the main workspace before looking in the flyout workspace.\n * Always prefers lookup by ID to lookup by name + type.\n * @param {!Workspace} workspace The workspace to search for the\n *     variable.  It may be a flyout workspace or main workspace.\n * @param {?string} id The ID to use to look up the variable, or null.\n * @param {string=} opt_name The string to use to look up the variable.\n *     Only used if lookup by ID fails.\n * @param {string=} opt_type The type to use to look up the variable.\n *     Only used if lookup by ID fails.\n * @return {?VariableModel} The variable corresponding to the given ID\n *     or name + type combination, or null if not found.\n * @alias Blockly.Variables.getVariable\n */\nconst getVariable = function(workspace, id, opt_name, opt_type) {\n  const potentialVariableMap = workspace.getPotentialVariableMap();\n  let variable = null;\n  // Try to just get the variable, by ID if possible.\n  if (id) {\n    // Look in the real variable map before checking the potential variable map.\n    variable = workspace.getVariableById(id);\n    if (!variable && potentialVariableMap) {\n      variable = potentialVariableMap.getVariableById(id);\n    }\n    if (variable) {\n      return variable;\n    }\n  }\n  // If there was no ID, or there was an ID but it didn't match any variables,\n  // look up by name and type.\n  if (opt_name) {\n    if (opt_type === undefined) {\n      throw Error('Tried to look up a variable by name without a type');\n    }\n    // Otherwise look up by name and type.\n    variable = workspace.getVariable(opt_name, opt_type);\n    if (!variable && potentialVariableMap) {\n      variable = potentialVariableMap.getVariable(opt_name, opt_type);\n    }\n  }\n  return variable;\n};\nexports.getVariable = getVariable;\n\n/**\n * Helper function to create a variable on the given workspace.\n * @param {!Workspace} workspace The workspace in which to create the\n * variable.  It may be a flyout workspace or main workspace.\n * @param {?string} id The ID to use to create the variable, or null.\n * @param {string=} opt_name The string to use to create the variable.\n * @param {string=} opt_type The type to use to create the variable.\n * @return {!VariableModel} The variable corresponding to the given ID\n *     or name + type combination.\n */\nconst createVariable = function(workspace, id, opt_name, opt_type) {\n  const potentialVariableMap = workspace.getPotentialVariableMap();\n  // Variables without names get uniquely named for this workspace.\n  if (!opt_name) {\n    const ws =\n        /** @type {!Workspace} */ (\n            workspace.isFlyout ?\n                /** @type {!WorkspaceSvg} */ (workspace).targetWorkspace :\n                workspace);\n    // Must call version on exports to allow for mocking in tests. See #5321\n    opt_name = exports.generateUniqueName(ws);\n  }\n\n  // Create a potential variable if in the flyout.\n  let variable = null;\n  if (potentialVariableMap) {\n    variable = potentialVariableMap.createVariable(opt_name, opt_type, id);\n  } else {  // In the main workspace, create a real variable.\n    variable = workspace.createVariable(opt_name, opt_type, id);\n  }\n  return variable;\n};\n\n/**\n * Helper function to get the list of variables that have been added to the\n * workspace after adding a new block, using the given list of variables that\n * were in the workspace before the new block was added.\n * @param {!Workspace} workspace The workspace to inspect.\n * @param {!Array<!VariableModel>} originalVariables The array of\n *     variables that existed in the workspace before adding the new block.\n * @return {!Array<!VariableModel>} The new array of variables that\n *     were freshly added to the workspace after creating the new block,\n *     or [] if no new variables were added to the workspace.\n * @alias Blockly.Variables.getAddedVariables\n * @package\n */\nconst getAddedVariables = function(workspace, originalVariables) {\n  const allCurrentVariables = workspace.getAllVariables();\n  const addedVariables = [];\n  if (originalVariables.length !== allCurrentVariables.length) {\n    for (let i = 0; i < allCurrentVariables.length; i++) {\n      const variable = allCurrentVariables[i];\n      // For any variable that is present in allCurrentVariables but not\n      // present in originalVariables, add the variable to addedVariables.\n      if (originalVariables.indexOf(variable) === -1) {\n        addedVariables.push(variable);\n      }\n    }\n  }\n  return addedVariables;\n};\nexports.getAddedVariables = getAddedVariables;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/variables.js?")},
"./core/variables_dynamic.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/variables.js\");\n__webpack_require__(\"./core/utils/xml.js\");\n__webpack_require__(\"./core/blocks.js\");\n__webpack_require__(\"./core/msg.js\");\n__webpack_require__(\"./core/variable_model.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility functions for handling typed variables.\n *\n */\n\n\n/**\n * Utility functions for handling typed variables.\n *\n * @namespace Blockly.VariablesDynamic\n */\ngoog.module('Blockly.VariablesDynamic');\n\nconst Variables = goog.require('Blockly.Variables');\nconst xml = goog.require('Blockly.utils.xml');\nconst {Blocks} = goog.require('Blockly.blocks');\nconst {Msg} = goog.require('Blockly.Msg');\nconst {VariableModel} = goog.require('Blockly.VariableModel');\n/* eslint-disable-next-line no-unused-vars */\nconst {Workspace} = goog.requireType('Blockly.Workspace');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * String for use in the \"custom\" attribute of a category in toolbox XML.\n * This string indicates that the category should be dynamically populated with\n * variable blocks.\n * See also Blockly.Variables.CATEGORY_NAME and\n * Blockly.Procedures.CATEGORY_NAME.\n * @const {string}\n * @alias Blockly.VariablesDynamic.CATEGORY_NAME\n */\nconst CATEGORY_NAME = 'VARIABLE_DYNAMIC';\nexports.CATEGORY_NAME = CATEGORY_NAME;\n\nconst stringButtonClickHandler = function(button) {\n  Variables.createVariableButtonHandler(\n      button.getTargetWorkspace(), undefined, 'String');\n};\nexports.onCreateVariableButtonClick_String = stringButtonClickHandler;\n\nconst numberButtonClickHandler = function(button) {\n  Variables.createVariableButtonHandler(\n      button.getTargetWorkspace(), undefined, 'Number');\n};\nexports.onCreateVariableButtonClick_Number = numberButtonClickHandler;\n\nconst colourButtonClickHandler = function(button) {\n  Variables.createVariableButtonHandler(\n      button.getTargetWorkspace(), undefined, 'Colour');\n};\nexports.onCreateVariableButtonClick_Colour = colourButtonClickHandler;\n\n/**\n * Construct the elements (blocks and button) required by the flyout for the\n * variable category.\n * @param {!WorkspaceSvg} workspace The workspace containing variables.\n * @return {!Array<!Element>} Array of XML elements.\n * @alias Blockly.VariablesDynamic.flyoutCategory\n */\nconst flyoutCategory = function(workspace) {\n  let xmlList = [];\n  let button = document.createElement('button');\n  button.setAttribute('text', Msg['NEW_STRING_VARIABLE']);\n  button.setAttribute('callbackKey', 'CREATE_VARIABLE_STRING');\n  xmlList.push(button);\n  button = document.createElement('button');\n  button.setAttribute('text', Msg['NEW_NUMBER_VARIABLE']);\n  button.setAttribute('callbackKey', 'CREATE_VARIABLE_NUMBER');\n  xmlList.push(button);\n  button = document.createElement('button');\n  button.setAttribute('text', Msg['NEW_COLOUR_VARIABLE']);\n  button.setAttribute('callbackKey', 'CREATE_VARIABLE_COLOUR');\n  xmlList.push(button);\n\n  workspace.registerButtonCallback(\n      'CREATE_VARIABLE_STRING', stringButtonClickHandler);\n  workspace.registerButtonCallback(\n      'CREATE_VARIABLE_NUMBER', numberButtonClickHandler);\n  workspace.registerButtonCallback(\n      'CREATE_VARIABLE_COLOUR', colourButtonClickHandler);\n\n\n  const blockList = flyoutCategoryBlocks(workspace);\n  xmlList = xmlList.concat(blockList);\n  return xmlList;\n};\nexports.flyoutCategory = flyoutCategory;\n\n/**\n * Construct the blocks required by the flyout for the variable category.\n * @param {!Workspace} workspace The workspace containing variables.\n * @return {!Array<!Element>} Array of XML block elements.\n * @alias Blockly.VariablesDynamic.flyoutCategoryBlocks\n */\nconst flyoutCategoryBlocks = function(workspace) {\n  const variableModelList = workspace.getAllVariables();\n\n  const xmlList = [];\n  if (variableModelList.length > 0) {\n    if (Blocks['variables_set_dynamic']) {\n      const firstVariable = variableModelList[variableModelList.length - 1];\n      const block = xml.createElement('block');\n      block.setAttribute('type', 'variables_set_dynamic');\n      block.setAttribute('gap', 24);\n      block.appendChild(Variables.generateVariableFieldDom(firstVariable));\n      xmlList.push(block);\n    }\n    if (Blocks['variables_get_dynamic']) {\n      variableModelList.sort(VariableModel.compareByName);\n      for (let i = 0, variable; (variable = variableModelList[i]); i++) {\n        const block = xml.createElement('block');\n        block.setAttribute('type', 'variables_get_dynamic');\n        block.setAttribute('gap', 8);\n        block.appendChild(Variables.generateVariableFieldDom(variable));\n        xmlList.push(block);\n      }\n    }\n  }\n  return xmlList;\n};\nexports.flyoutCategoryBlocks = flyoutCategoryBlocks;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/variables_dynamic.js?")},
"./core/warning.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/bubble.js\");\n__webpack_require__(\"./core/icon.js\");\n__webpack_require__(\"./core/utils/svg.js\");\n__webpack_require__(\"./core/events/events_bubble_open.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing a warning.\n */\n\n\n/**\n * Object representing a warning.\n * @class\n */\ngoog.module('Blockly.Warning');\n\nconst dom = goog.require('Blockly.utils.dom');\nconst eventUtils = goog.require('Blockly.Events.utils');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\nconst {Bubble} = goog.require('Blockly.Bubble');\n/* eslint-disable-next-line no-unused-vars */\nconst {Coordinate} = goog.requireType('Blockly.utils.Coordinate');\nconst {Icon} = goog.require('Blockly.Icon');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BubbleOpen');\n\n\n/**\n * Class for a warning.\n * @extends {Icon}\n * @alias Blockly.Warning\n */\nclass Warning extends Icon {\n  /**\n   * @param {!BlockSvg} block The block associated with this warning.\n   */\n  constructor(block) {\n    super(block);\n    this.createIcon();\n    // The text_ object can contain multiple warnings.\n    this.text_ = Object.create(null);\n\n    /**\n     * The top-level node of the warning text, or null if not created.\n     * @type {?SVGTextElement}\n     * @private\n     */\n    this.paragraphElement_ = null;\n\n    /**\n     * Does this icon get hidden when the block is collapsed?\n     * @type {boolean}\n     */\n    this.collapseHidden = false;\n  }\n\n  /**\n   * Draw the warning icon.\n   * @param {!Element} group The icon group.\n   * @protected\n   */\n  drawIcon_(group) {\n    // Triangle with rounded corners.\n    dom.createSvgElement(\n        Svg.PATH, {\n          'class': 'blocklyIconShape',\n          'd': 'M2,15Q-1,15 0.5,12L6.5,1.7Q8,-1 9.5,1.7L15.5,12Q17,15 14,15z',\n        },\n        group);\n    // Can't use a real '!' text character since different browsers and\n    // operating systems render it differently. Body of exclamation point.\n    dom.createSvgElement(\n        Svg.PATH, {\n          'class': 'blocklyIconSymbol',\n          'd': 'm7,4.8v3.16l0.27,2.27h1.46l0.27,-2.27v-3.16z',\n        },\n        group);\n    // Dot of exclamation point.\n    dom.createSvgElement(\n        Svg.RECT, {\n          'class': 'blocklyIconSymbol',\n          'x': '7',\n          'y': '11',\n          'height': '2',\n          'width': '2',\n        },\n        group);\n  }\n\n  /**\n   * Show or hide the warning bubble.\n   * @param {boolean} visible True if the bubble should be visible.\n   */\n  setVisible(visible) {\n    if (visible === this.isVisible()) {\n      return;\n    }\n    eventUtils.fire(new (eventUtils.get(eventUtils.BUBBLE_OPEN))(\n        this.block_, visible, 'warning'));\n    if (visible) {\n      this.createBubble_();\n    } else {\n      this.disposeBubble_();\n    }\n  }\n\n  /**\n   * Show the bubble.\n   * @private\n   */\n  createBubble_() {\n    this.paragraphElement_ = Bubble.textToDom(this.getText());\n    this.bubble_ = Bubble.createNonEditableBubble(\n        this.paragraphElement_, /** @type {!BlockSvg} */ (this.block_),\n        /** @type {!Coordinate} */ (this.iconXY_));\n    this.applyColour();\n  }\n\n  /**\n   * Dispose of the bubble and references to it.\n   * @private\n   */\n  disposeBubble_() {\n    this.bubble_.dispose();\n    this.bubble_ = null;\n    this.paragraphElement_ = null;\n  }\n\n  /**\n   * Set this warning's text.\n   * @param {string} text Warning text (or '' to delete). This supports\n   *    linebreaks.\n   * @param {string} id An ID for this text entry to be able to maintain\n   *     multiple warnings.\n   */\n  setText(text, id) {\n    if (this.text_[id] === text) {\n      return;\n    }\n    if (text) {\n      this.text_[id] = text;\n    } else {\n      delete this.text_[id];\n    }\n    if (this.isVisible()) {\n      this.setVisible(false);\n      this.setVisible(true);\n    }\n  }\n\n  /**\n   * Get this warning's texts.\n   * @return {string} All texts concatenated into one string.\n   */\n  getText() {\n    const allWarnings = [];\n    for (const id in this.text_) {\n      allWarnings.push(this.text_[id]);\n    }\n    return allWarnings.join('\\n');\n  }\n\n  /**\n   * Dispose of this warning.\n   */\n  dispose() {\n    this.block_.warning = null;\n    Icon.prototype.dispose.call(this);\n  }\n}\n\nexports.Warning = Warning;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/warning.js?")},
"./core/widgetdiv.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/utils/deprecation.js\");\n__webpack_require__(\"./core/utils/dom.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2013 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A div that floats on top of Blockly.  This singleton contains\n *     temporary HTML UI widgets that the user is currently interacting with.\n *     E.g. text input areas, colour pickers, context menus.\n */\n\n\n/**\n * A div that floats on top of Blockly.  This singleton contains\n *     temporary HTML UI widgets that the user is currently interacting with.\n *     E.g. text input areas, colour pickers, context menus.\n * @namespace Blockly.WidgetDiv\n */\ngoog.module('Blockly.WidgetDiv');\n\nconst common = goog.require('Blockly.common');\nconst deprecation = goog.require('Blockly.utils.deprecation');\nconst dom = goog.require('Blockly.utils.dom');\n/* eslint-disable-next-line no-unused-vars */\nconst {Rect} = goog.requireType('Blockly.utils.Rect');\n/* eslint-disable-next-line no-unused-vars */\nconst {Size} = goog.requireType('Blockly.utils.Size');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * The object currently using this container.\n * @type {Object}\n */\nlet owner = null;\n\n/**\n * Optional cleanup function set by whichever object uses the widget.\n * @type {Function}\n */\nlet dispose = null;\n\n/**\n * A class name representing the current owner's workspace renderer.\n * @type {string}\n */\nlet rendererClassName = '';\n\n/**\n * A class name representing the current owner's workspace theme.\n * @type {string}\n */\nlet themeClassName = '';\n\n/**\n * The HTML container for popup overlays (e.g. editor widgets).\n * @type {?HTMLDivElement}\n */\nlet DIV;\n\n/**\n * Returns the HTML container for editor widgets.\n * @return {?HTMLDivElement} The editor widget container.\n * @alias Blockly.WidgetDiv.getDiv\n */\nconst getDiv = function() {\n  return DIV;\n};\nexports.getDiv = getDiv;\n\n/**\n * Allows unit tests to reset the div.\n * @param {?HTMLDivElement} newDiv The new value for the DIV field.\n * @alias Blockly.WidgetDiv.testOnly_setDiv\n * @ignore\n */\nconst testOnly_setDiv = function(newDiv) {\n  DIV = newDiv;\n};\nexports.testOnly_setDiv = testOnly_setDiv;\n\nObject.defineProperties(exports, {\n  /**\n   * The HTML container for popup overlays (e.g. editor widgets).\n   * @name Blockly.WidgetDiv.DIV\n   * @type {?Element}\n   * @deprecated Use Blockly.WidgetDiv.getDiv() and .setDiv().\n   *     (September 2021)\n   * @suppress {checkTypes}\n   */\n  DIV: {\n    get: function() {\n      deprecation.warn(\n          'Blockly.WidgetDiv.DIV', 'September 2021', 'September 2022',\n          'Blockly.WidgetDiv.getDiv()');\n      return getDiv();\n    },\n  },\n});\n\n/**\n * Create the widget div and inject it onto the page.\n * @alias Blockly.WidgetDiv.createDom\n */\nconst createDom = function() {\n  if (DIV) {\n    return;  // Already created.\n  }\n\n  DIV = /** @type {!HTMLDivElement} */ (document.createElement('div'));\n  DIV.className = 'blocklyWidgetDiv';\n  const container = common.getParentContainer() || document.body;\n  container.appendChild(DIV);\n};\nexports.createDom = createDom;\n\n/**\n * Initialize and display the widget div.  Close the old one if needed.\n * @param {!Object} newOwner The object that will be using this container.\n * @param {boolean} rtl Right-to-left (true) or left-to-right (false).\n * @param {Function} newDispose Optional cleanup function to be run when the\n *     widget is closed.\n * @alias Blockly.WidgetDiv.show\n */\nconst show = function(newOwner, rtl, newDispose) {\n  hide();\n  owner = newOwner;\n  dispose = newDispose;\n  const div = DIV;\n  div.style.direction = rtl ? 'rtl' : 'ltr';\n  div.style.display = 'block';\n  const mainWorkspace =\n      /** @type {!WorkspaceSvg} */ (common.getMainWorkspace());\n  rendererClassName = mainWorkspace.getRenderer().getClassName();\n  themeClassName = mainWorkspace.getTheme().getClassName();\n  dom.addClass(div, rendererClassName);\n  dom.addClass(div, themeClassName);\n};\nexports.show = show;\n\n/**\n * Destroy the widget and hide the div.\n * @alias Blockly.WidgetDiv.hide\n */\nconst hide = function() {\n  if (!isVisible()) {\n    return;\n  }\n  owner = null;\n\n  const div = DIV;\n  div.style.display = 'none';\n  div.style.left = '';\n  div.style.top = '';\n  dispose && dispose();\n  dispose = null;\n  div.textContent = '';\n\n  if (rendererClassName) {\n    dom.removeClass(div, rendererClassName);\n    rendererClassName = '';\n  }\n  if (themeClassName) {\n    dom.removeClass(div, themeClassName);\n    themeClassName = '';\n  }\n  (/** @type {!WorkspaceSvg} */ (common.getMainWorkspace())).markFocused();\n};\nexports.hide = hide;\n\n/**\n * Is the container visible?\n * @return {boolean} True if visible.\n * @alias Blockly.WidgetDiv.isVisible\n */\nconst isVisible = function() {\n  return !!owner;\n};\nexports.isVisible = isVisible;\n\n/**\n * Destroy the widget and hide the div if it is being used by the specified\n * object.\n * @param {!Object} oldOwner The object that was using this container.\n * @alias Blockly.WidgetDiv.hideIfOwner\n */\nconst hideIfOwner = function(oldOwner) {\n  if (owner === oldOwner) {\n    hide();\n  }\n};\nexports.hideIfOwner = hideIfOwner;\n\n/**\n * Set the widget div's position and height.  This function does nothing clever:\n * it will not ensure that your widget div ends up in the visible window.\n * @param {number} x Horizontal location (window coordinates, not body).\n * @param {number} y Vertical location (window coordinates, not body).\n * @param {number} height The height of the widget div (pixels).\n */\nconst positionInternal = function(x, y, height) {\n  DIV.style.left = x + 'px';\n  DIV.style.top = y + 'px';\n  DIV.style.height = height + 'px';\n};\n\n/**\n * Position the widget div based on an anchor rectangle.\n * The widget should be placed adjacent to but not overlapping the anchor\n * rectangle.  The preferred position is directly below and aligned to the left\n * (LTR) or right (RTL) side of the anchor.\n * @param {!Rect} viewportBBox The bounding rectangle of the\n *     current viewport, in window coordinates.\n * @param {!Rect} anchorBBox The bounding rectangle of the anchor,\n *     in window coordinates.\n * @param {!Size} widgetSize The size of the widget that is inside\n *     the widget div, in window coordinates.\n * @param {boolean} rtl Whether the workspace is in RTL mode.  This determines\n *     horizontal alignment.\n * @alias Blockly.WidgetDiv.positionWithAnchor\n * @package\n */\nconst positionWithAnchor = function(viewportBBox, anchorBBox, widgetSize, rtl) {\n  const y = calculateY(viewportBBox, anchorBBox, widgetSize);\n  const x = calculateX(viewportBBox, anchorBBox, widgetSize, rtl);\n\n  if (y < 0) {\n    positionInternal(x, 0, widgetSize.height + y);\n  } else {\n    positionInternal(x, y, widgetSize.height);\n  }\n};\nexports.positionWithAnchor = positionWithAnchor;\n\n/**\n * Calculate an x position (in window coordinates) such that the widget will not\n * be offscreen on the right or left.\n * @param {!Rect} viewportBBox The bounding rectangle of the\n *     current viewport, in window coordinates.\n * @param {!Rect} anchorBBox The bounding rectangle of the anchor,\n *     in window coordinates.\n * @param {!Size} widgetSize The dimensions of the widget inside\n *     the widget div.\n * @param {boolean} rtl Whether the Blockly workspace is in RTL mode.\n * @return {number} A valid x-coordinate for the top left corner of the widget\n *     div, in window coordinates.\n */\nconst calculateX = function(viewportBBox, anchorBBox, widgetSize, rtl) {\n  if (rtl) {\n    // Try to align the right side of the field and the right side of widget.\n    const widgetLeft = anchorBBox.right - widgetSize.width;\n    // Don't go offscreen left.\n    const x = Math.max(widgetLeft, viewportBBox.left);\n    // But really don't go offscreen right:\n    return Math.min(x, viewportBBox.right - widgetSize.width);\n  } else {\n    // Try to align the left side of the field and the left side of widget.\n    // Don't go offscreen right.\n    const x = Math.min(anchorBBox.left, viewportBBox.right - widgetSize.width);\n    // But left is more important, because that's where the text is.\n    return Math.max(x, viewportBBox.left);\n  }\n};\n\n/**\n * Calculate a y position (in window coordinates) such that the widget will not\n * be offscreen on the top or bottom.\n * @param {!Rect} viewportBBox The bounding rectangle of the\n *     current viewport, in window coordinates.\n * @param {!Rect} anchorBBox The bounding rectangle of the anchor,\n *     in window coordinates.\n * @param {!Size} widgetSize The dimensions of the widget inside\n *     the widget div.\n * @return {number} A valid y-coordinate for the top left corner of the widget\n *     div, in window coordinates.\n */\nconst calculateY = function(viewportBBox, anchorBBox, widgetSize) {\n  // Flip the widget vertically if off the bottom.\n  if (anchorBBox.bottom + widgetSize.height >= viewportBBox.bottom) {\n    // The bottom of the widget is at the top of the field.\n    return anchorBBox.top - widgetSize.height;\n    // The widget could go off the top of the window, but it would also go off\n    // the bottom.  The window is just too small.\n  } else {\n    // The top of the widget is at the bottom of the field.\n    return anchorBBox.bottom;\n  }\n};\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/widgetdiv.js?")},
"./core/workspace.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/array.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/utils/idgenerator.js\");\n__webpack_require__(\"./core/utils/math.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/interfaces/i_ast_node_location.js\");\n__webpack_require__(\"./core/options.js\");\n__webpack_require__(\"./core/variable_map.js\");\n__webpack_require__(\"./core/connection_checker.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing a workspace.\n */\n\n\n/**\n * Object representing a workspace.\n * @class\n */\ngoog.module('Blockly.Workspace');\n\nconst arrayUtils = goog.require('Blockly.utils.array');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst idGenerator = goog.require('Blockly.utils.idGenerator');\nconst math = goog.require('Blockly.utils.math');\nconst registry = goog.require('Blockly.registry');\n/* eslint-disable-next-line no-unused-vars */\nconst toolbox = goog.requireType('Blockly.utils.toolbox');\n/* eslint-disable-next-line no-unused-vars */\nconst {Abstract} = goog.requireType('Blockly.Events.Abstract');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlocklyOptions} = goog.requireType('Blockly.BlocklyOptions');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\n/* eslint-disable-next-line no-unused-vars */\nconst {ConnectionDB} = goog.requireType('Blockly.ConnectionDB');\n/* eslint-disable-next-line no-unused-vars */\nconst {IASTNodeLocation} = goog.require('Blockly.IASTNodeLocation');\n/* eslint-disable-next-line no-unused-vars */\nconst {IConnectionChecker} = goog.requireType('Blockly.IConnectionChecker');\nconst {Options} = goog.require('Blockly.Options');\nconst {VariableMap} = goog.require('Blockly.VariableMap');\n/* eslint-disable-next-line no-unused-vars */\nconst {VariableModel} = goog.requireType('Blockly.VariableModel');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceComment} = goog.requireType('Blockly.WorkspaceComment');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.ConnectionChecker');\n\n\n/**\n * Database of all workspaces.\n * @private\n */\nconst WorkspaceDB_ = Object.create(null);\n\n/**\n * Class for a workspace.  This is a data structure that contains blocks.\n * There is no UI, and can be created headlessly.\n * @implements {IASTNodeLocation}\n * @alias Blockly.Workspace\n */\nclass Workspace {\n  /**\n   * @param {!Options=} opt_options Dictionary of options.\n   */\n  constructor(opt_options) {\n    /** @type {string} */\n    this.id = idGenerator.genUid();\n    WorkspaceDB_[this.id] = this;\n    /** @type {!Options} */\n    this.options =\n        opt_options || new Options(/** @type {!BlocklyOptions} */ ({}));\n    /** @type {boolean} */\n    this.RTL = !!this.options.RTL;\n    /** @type {boolean} */\n    this.horizontalLayout = !!this.options.horizontalLayout;\n    /** @type {toolbox.Position} */\n    this.toolboxPosition = this.options.toolboxPosition;\n\n    /**\n     * Returns `true` if the workspace is visible and `false` if it's headless.\n     * @type {boolean}\n     */\n    this.rendered = false;\n\n    /**\n     * Is this workspace the surface for a flyout?\n     * @type {boolean}\n     */\n    this.isFlyout = false;\n\n    /**\n     * Is this workspace the surface for a mutator?\n     * @type {boolean}\n     * @package\n     */\n    this.isMutator = false;\n\n    /**\n     * Returns `true` if the workspace is currently in the process of a bulk\n     * clear.\n     * @type {boolean}\n     * @package\n     */\n    this.isClearing = false;\n\n    /**\n     * Maximum number of undo events in stack. `0` turns off undo, `Infinity`\n     * sets it to unlimited.\n     * @type {number}\n     */\n    this.MAX_UNDO = 1024;\n\n    /**\n     * Set of databases for rapid lookup of connection locations.\n     * @type {Array<!ConnectionDB>}\n     */\n    this.connectionDBList = null;\n\n    const connectionCheckerClass = registry.getClassFromOptions(\n        registry.Type.CONNECTION_CHECKER, this.options, true);\n    /**\n     * An object that encapsulates logic for safety, type, and dragging checks.\n     * @type {!IConnectionChecker}\n     */\n    this.connectionChecker = new connectionCheckerClass(this);\n\n    /**\n     * @type {!Array<!Block>}\n     * @private\n     */\n    this.topBlocks_ = [];\n    /**\n     * @type {!Array<!WorkspaceComment>}\n     * @private\n     */\n    this.topComments_ = [];\n    /**\n     * @type {!Object}\n     * @private\n     */\n    this.commentDB_ = Object.create(null);\n    /**\n     * @type {!Array<!Function>}\n     * @private\n     */\n    this.listeners_ = [];\n    /**\n     * @type {!Array<!Abstract>}\n     * @protected\n     */\n    this.undoStack_ = [];\n    /**\n     * @type {!Array<!Abstract>}\n     * @protected\n     */\n    this.redoStack_ = [];\n    /**\n     * @type {!Object}\n     * @private\n     */\n    this.blockDB_ = Object.create(null);\n    /**\n     * @type {!Object}\n     * @private\n     */\n    this.typedBlocksDB_ = Object.create(null);\n\n    /**\n     * A map from variable type to list of variable names.  The lists contain\n     * all of the named variables in the workspace, including variables that are\n     * not currently in use.\n     * @type {!VariableMap}\n     * @private\n     */\n    this.variableMap_ = new VariableMap(this);\n\n    /**\n     * Blocks in the flyout can refer to variables that don't exist in the main\n     * workspace.  For instance, the \"get item in list\" block refers to an\n     * \"item\" variable regardless of whether the variable has been created yet.\n     * A FieldVariable must always refer to a VariableModel.  We reconcile\n     * these by tracking \"potential\" variables in the flyout.  These variables\n     * become real when references to them are dragged into the main workspace.\n     * @type {?VariableMap}\n     * @private\n     */\n    this.potentialVariableMap_ = null;\n  }\n\n  /**\n   * Dispose of this workspace.\n   * Unlink from all DOM elements to prevent memory leaks.\n   * @suppress {checkTypes}\n   */\n  dispose() {\n    this.listeners_.length = 0;\n    this.clear();\n    // Remove from workspace database.\n    delete WorkspaceDB_[this.id];\n  }\n\n  /**\n   * Compare function for sorting objects (blocks, comments, etc) by position;\n   *    top to bottom (with slight LTR or RTL bias).\n   * @param {!Block | !WorkspaceComment} a The first object to\n   *    compare.\n   * @param {!Block | !WorkspaceComment} b The second object to\n   *    compare.\n   * @return {number} The comparison value. This tells Array.sort() how to\n   *    change object a's index.\n   * @private\n   */\n  sortObjects_(a, b) {\n    const aXY = a.getRelativeToSurfaceXY();\n    const bXY = b.getRelativeToSurfaceXY();\n    return (aXY.y + Workspace.prototype.sortObjects_.offset * aXY.x) -\n        (bXY.y + Workspace.prototype.sortObjects_.offset * bXY.x);\n  }\n\n  /**\n   * Adds a block to the list of top blocks.\n   * @param {!Block} block Block to add.\n   */\n  addTopBlock(block) {\n    this.topBlocks_.push(block);\n  }\n\n  /**\n   * Removes a block from the list of top blocks.\n   * @param {!Block} block Block to remove.\n   */\n  removeTopBlock(block) {\n    if (!arrayUtils.removeElem(this.topBlocks_, block)) {\n      throw Error('Block not present in workspace\\'s list of top-most blocks.');\n    }\n  }\n\n  /**\n   * Finds the top-level blocks and returns them.  Blocks are optionally sorted\n   * by position; top to bottom (with slight LTR or RTL bias).\n   * @param {boolean} ordered Sort the list if true.\n   * @return {!Array<!Block>} The top-level block objects.\n   */\n  getTopBlocks(ordered) {\n    // Copy the topBlocks_ list.\n    const blocks = [].concat(this.topBlocks_);\n    if (ordered && blocks.length > 1) {\n      this.sortObjects_.offset = Math.sin(math.toRadians(Workspace.SCAN_ANGLE));\n      if (this.RTL) {\n        this.sortObjects_.offset *= -1;\n      }\n      blocks.sort(this.sortObjects_);\n    }\n    return blocks;\n  }\n\n  /**\n   * Add a block to the list of blocks keyed by type.\n   * @param {!Block} block Block to add.\n   */\n  addTypedBlock(block) {\n    if (!this.typedBlocksDB_[block.type]) {\n      this.typedBlocksDB_[block.type] = [];\n    }\n    this.typedBlocksDB_[block.type].push(block);\n  }\n\n  /**\n   * Remove a block from the list of blocks keyed by type.\n   * @param {!Block} block Block to remove.\n   */\n  removeTypedBlock(block) {\n    arrayUtils.removeElem(this.typedBlocksDB_[block.type], block);\n    if (!this.typedBlocksDB_[block.type].length) {\n      delete this.typedBlocksDB_[block.type];\n    }\n  }\n\n  /**\n   * Finds the blocks with the associated type and returns them. Blocks are\n   * optionally sorted by position; top to bottom (with slight LTR or RTL bias).\n   * @param {string} type The type of block to search for.\n   * @param {boolean} ordered Sort the list if true.\n   * @return {!Array<!Block>} The blocks of the given type.\n   */\n  getBlocksByType(type, ordered) {\n    if (!this.typedBlocksDB_[type]) {\n      return [];\n    }\n    const blocks = this.typedBlocksDB_[type].slice(0);\n    if (ordered && blocks.length > 1) {\n      this.sortObjects_.offset = Math.sin(math.toRadians(Workspace.SCAN_ANGLE));\n      if (this.RTL) {\n        this.sortObjects_.offset *= -1;\n      }\n      blocks.sort(this.sortObjects_);\n    }\n\n    return blocks.filter(function(block) {\n      return !block.isInsertionMarker();\n    });\n  }\n\n  /**\n   * Adds a comment to the list of top comments.\n   * @param {!WorkspaceComment} comment comment to add.\n   * @package\n   */\n  addTopComment(comment) {\n    this.topComments_.push(comment);\n\n    // Note: If the comment database starts to hold block comments, this may\n    // need to move to a separate function.\n    if (this.commentDB_[comment.id]) {\n      console.warn(\n          'Overriding an existing comment on this workspace, with id \"' +\n          comment.id + '\"');\n    }\n    this.commentDB_[comment.id] = comment;\n  }\n\n  /**\n   * Removes a comment from the list of top comments.\n   * @param {!WorkspaceComment} comment comment to remove.\n   * @package\n   */\n  removeTopComment(comment) {\n    if (!arrayUtils.removeElem(this.topComments_, comment)) {\n      throw Error(\n          'Comment not present in workspace\\'s list of top-most ' +\n          'comments.');\n    }\n    // Note: If the comment database starts to hold block comments, this may\n    // need to move to a separate function.\n    delete this.commentDB_[comment.id];\n  }\n\n  /**\n   * Finds the top-level comments and returns them.  Comments are optionally\n   * sorted by position; top to bottom (with slight LTR or RTL bias).\n   * @param {boolean} ordered Sort the list if true.\n   * @return {!Array<!WorkspaceComment>} The top-level comment objects.\n   * @package\n   */\n  getTopComments(ordered) {\n    // Copy the topComments_ list.\n    const comments = [].concat(this.topComments_);\n    if (ordered && comments.length > 1) {\n      this.sortObjects_.offset = Math.sin(math.toRadians(Workspace.SCAN_ANGLE));\n      if (this.RTL) {\n        this.sortObjects_.offset *= -1;\n      }\n      comments.sort(this.sortObjects_);\n    }\n    return comments;\n  }\n\n  /**\n   * Find all blocks in workspace.  Blocks are optionally sorted\n   * by position; top to bottom (with slight LTR or RTL bias).\n   * @param {boolean} ordered Sort the list if true.\n   * @return {!Array<!Block>} Array of blocks.\n   */\n  getAllBlocks(ordered) {\n    let blocks;\n    if (ordered) {\n      // Slow, but ordered.\n      const topBlocks = this.getTopBlocks(true);\n      blocks = [];\n      for (let i = 0; i < topBlocks.length; i++) {\n        blocks.push.apply(blocks, topBlocks[i].getDescendants(true));\n      }\n    } else {\n      // Fast, but in no particular order.\n      blocks = this.getTopBlocks(false);\n      for (let i = 0; i < blocks.length; i++) {\n        blocks.push.apply(blocks, blocks[i].getChildren(false));\n      }\n    }\n\n    // Insertion markers exist on the workspace for rendering reasons, but\n    // aren't \"real\" blocks from a developer perspective.\n    const filtered = blocks.filter(function(block) {\n      return !block.isInsertionMarker();\n    });\n\n    return filtered;\n  }\n\n  /**\n   * Dispose of all blocks and comments in workspace.\n   */\n  clear() {\n    this.isClearing = true;\n    try {\n      const existingGroup = eventUtils.getGroup();\n      if (!existingGroup) {\n        eventUtils.setGroup(true);\n      }\n      while (this.topBlocks_.length) {\n        this.topBlocks_[0].dispose(false);\n      }\n      while (this.topComments_.length) {\n        this.topComments_[this.topComments_.length - 1].dispose();\n      }\n      if (!existingGroup) {\n        eventUtils.setGroup(false);\n      }\n      this.variableMap_.clear();\n      if (this.potentialVariableMap_) {\n        this.potentialVariableMap_.clear();\n      }\n    } finally {\n      this.isClearing = false;\n    }\n  }\n\n  /* Begin functions that are just pass-throughs to the variable map. */\n\n  /**\n   * Rename a variable by updating its name in the variable map. Identify the\n   * variable to rename with the given ID.\n   * @param {string} id ID of the variable to rename.\n   * @param {string} newName New variable name.\n   */\n  renameVariableById(id, newName) {\n    this.variableMap_.renameVariableById(id, newName);\n  }\n\n  /**\n   * Create a variable with a given name, optional type, and optional ID.\n   * @param {string} name The name of the variable. This must be unique across\n   *     variables and procedures.\n   * @param {?string=} opt_type The type of the variable like 'int' or 'string'.\n   *     Does not need to be unique. Field_variable can filter variables based\n   * on their type. This will default to '' which is a specific type.\n   * @param {?string=} opt_id The unique ID of the variable. This will default\n   *     to a UUID.\n   * @return {!VariableModel} The newly created variable.\n   */\n  createVariable(name, opt_type, opt_id) {\n    return this.variableMap_.createVariable(name, opt_type, opt_id);\n  }\n\n  /**\n   * Find all the uses of the given variable, which is identified by ID.\n   * @param {string} id ID of the variable to find.\n   * @return {!Array<!Block>} Array of block usages.\n   */\n  getVariableUsesById(id) {\n    return this.variableMap_.getVariableUsesById(id);\n  }\n\n  /**\n   * Delete a variables by the passed in ID and all of its uses from this\n   * workspace. May prompt the user for confirmation.\n   * @param {string} id ID of variable to delete.\n   */\n  deleteVariableById(id) {\n    this.variableMap_.deleteVariableById(id);\n  }\n\n  /**\n   * Find the variable by the given name and return it. Return null if not\n   * found.\n   * @param {string} name The name to check for.\n   * @param {string=} opt_type The type of the variable.  If not provided it\n   *     defaults to the empty string, which is a specific type.\n   * @return {?VariableModel} The variable with the given name.\n   */\n  getVariable(name, opt_type) {\n    // TODO (#1559): Possibly delete this function after resolving #1559.\n    return this.variableMap_.getVariable(name, opt_type);\n  }\n\n  /**\n   * Find the variable by the given ID and return it. Return null if not found.\n   * @param {string} id The ID to check for.\n   * @return {?VariableModel} The variable with the given ID.\n   */\n  getVariableById(id) {\n    return this.variableMap_.getVariableById(id);\n  }\n\n  /**\n   * Find the variable with the specified type. If type is null, return list of\n   *     variables with empty string type.\n   * @param {?string} type Type of the variables to find.\n   * @return {!Array<!VariableModel>} The sought after variables of the\n   *     passed in type. An empty array if none are found.\n   */\n  getVariablesOfType(type) {\n    return this.variableMap_.getVariablesOfType(type);\n  }\n\n  /**\n   * Return all variable types.\n   * @return {!Array<string>} List of variable types.\n   * @package\n   */\n  getVariableTypes() {\n    return this.variableMap_.getVariableTypes(this);\n  }\n\n  /**\n   * Return all variables of all types.\n   * @return {!Array<!VariableModel>} List of variable models.\n   */\n  getAllVariables() {\n    return this.variableMap_.getAllVariables();\n  }\n\n  /**\n   * Returns all variable names of all types.\n   * @return {!Array<string>} List of all variable names of all types.\n   */\n  getAllVariableNames() {\n    return this.variableMap_.getAllVariableNames();\n  }\n\n  /* End functions that are just pass-throughs to the variable map. */\n\n  /**\n   * Returns the horizontal offset of the workspace.\n   * Intended for LTR/RTL compatibility in XML.\n   * Not relevant for a headless workspace.\n   * @return {number} Width.\n   */\n  getWidth() {\n    return 0;\n  }\n\n  /**\n   * Obtain a newly created block.\n   * @param {!string} prototypeName Name of the language object containing\n   *     type-specific functions for this block.\n   * @param {string=} opt_id Optional ID.  Use this ID if provided, otherwise\n   *     create a new ID.\n   * @return {!Block} The created block.\n   */\n  newBlock(prototypeName, opt_id) {\n    const {Block} = goog.module.get('Blockly.Block');\n    return new Block(this, prototypeName, opt_id);\n  }\n\n  /**\n   * The number of blocks that may be added to the workspace before reaching\n   *     the maxBlocks.\n   * @return {number} Number of blocks left.\n   */\n  remainingCapacity() {\n    if (isNaN(this.options.maxBlocks)) {\n      return Infinity;\n    }\n\n    return this.options.maxBlocks - this.getAllBlocks(false).length;\n  }\n\n  /**\n   * The number of blocks of the given type that may be added to the workspace\n   *    before reaching the maxInstances allowed for that type.\n   * @param {string} type Type of block to return capacity for.\n   * @return {number} Number of blocks of type left.\n   */\n  remainingCapacityOfType(type) {\n    if (!this.options.maxInstances) {\n      return Infinity;\n    }\n\n    const maxInstanceOfType = (this.options.maxInstances[type] !== undefined) ?\n        this.options.maxInstances[type] :\n        Infinity;\n\n    return maxInstanceOfType - this.getBlocksByType(type, false).length;\n  }\n\n  /**\n   * Check if there is remaining capacity for blocks of the given counts to be\n   *    created. If the total number of blocks represented by the map is more\n   * than the total remaining capacity, it returns false. If a type count is\n   * more than the remaining capacity for that type, it returns false.\n   * @param {!Object} typeCountsMap A map of types to counts (usually\n   *     representing\n   *    blocks to be created).\n   * @return {boolean} True if there is capacity for the given map,\n   *    false otherwise.\n   */\n  isCapacityAvailable(typeCountsMap) {\n    if (!this.hasBlockLimits()) {\n      return true;\n    }\n    let copyableBlocksCount = 0;\n    for (const type in typeCountsMap) {\n      if (typeCountsMap[type] > this.remainingCapacityOfType(type)) {\n        return false;\n      }\n      copyableBlocksCount += typeCountsMap[type];\n    }\n    if (copyableBlocksCount > this.remainingCapacity()) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Checks if the workspace has any limits on the maximum number of blocks,\n   *    or the maximum number of blocks of specific types.\n   * @return {boolean} True if it has block limits, false otherwise.\n   */\n  hasBlockLimits() {\n    return this.options.maxBlocks !== Infinity || !!this.options.maxInstances;\n  }\n\n  /**\n   * Gets the undo stack for workplace.\n   * @return {!Array<!Abstract>} undo stack\n   * @package\n   */\n  getUndoStack() {\n    return this.undoStack_;\n  }\n\n  /**\n   * Gets the redo stack for workplace.\n   * @return {!Array<!Abstract>} redo stack\n   * @package\n   */\n  getRedoStack() {\n    return this.redoStack_;\n  }\n\n  /**\n   * Undo or redo the previous action.\n   * @param {boolean} redo False if undo, true if redo.\n   */\n  undo(redo) {\n    const inputStack = redo ? this.redoStack_ : this.undoStack_;\n    const outputStack = redo ? this.undoStack_ : this.redoStack_;\n    const inputEvent = inputStack.pop();\n    if (!inputEvent) {\n      return;\n    }\n    let events = [inputEvent];\n    // Do another undo/redo if the next one is of the same group.\n    while (inputStack.length && inputEvent.group &&\n           inputEvent.group === inputStack[inputStack.length - 1].group) {\n      events.push(inputStack.pop());\n    }\n    // Push these popped events on the opposite stack.\n    for (let i = 0; i < events.length; i++) {\n      const event = events[i];\n      outputStack.push(event);\n    }\n    events = eventUtils.filter(events, redo);\n    eventUtils.setRecordUndo(false);\n    try {\n      for (let i = 0; i < events.length; i++) {\n        const event = events[i];\n        event.run(redo);\n      }\n    } finally {\n      eventUtils.setRecordUndo(true);\n    }\n  }\n\n  /**\n   * Clear the undo/redo stacks.\n   */\n  clearUndo() {\n    this.undoStack_.length = 0;\n    this.redoStack_.length = 0;\n    // Stop any events already in the firing queue from being undoable.\n    eventUtils.clearPendingUndo();\n  }\n\n  /**\n   * When something in this workspace changes, call a function.\n   * Note that there may be a few recent events already on the stack.  Thus the\n   * new change listener might be called with events that occurred a few\n   * milliseconds before the change listener was added.\n   * @param {!Function} func Function to call.\n   * @return {!Function} Obsolete return value, ignore.\n   */\n  addChangeListener(func) {\n    this.listeners_.push(func);\n    return func;\n  }\n\n  /**\n   * Stop listening for this workspace's changes.\n   * @param {!Function} func Function to stop calling.\n   */\n  removeChangeListener(func) {\n    arrayUtils.removeElem(this.listeners_, func);\n  }\n\n  /**\n   * Fire a change event.\n   * @param {!Abstract} event Event to fire.\n   */\n  fireChangeListener(event) {\n    if (event.recordUndo) {\n      this.undoStack_.push(event);\n      this.redoStack_.length = 0;\n      while (this.undoStack_.length > this.MAX_UNDO && this.MAX_UNDO >= 0) {\n        this.undoStack_.shift();\n      }\n    }\n    for (let i = 0; i < this.listeners_.length; i++) {\n      const func = this.listeners_[i];\n      func(event);\n    }\n  }\n\n  /**\n   * Find the block on this workspace with the specified ID.\n   * @param {string} id ID of block to find.\n   * @return {?Block} The sought after block, or null if not found.\n   */\n  getBlockById(id) {\n    return this.blockDB_[id] || null;\n  }\n\n  /**\n   * Set a block on this workspace with the specified ID.\n   * @param {string} id ID of block to set.\n   * @param {Block} block The block to set.\n   * @package\n   */\n  setBlockById(id, block) {\n    this.blockDB_[id] = block;\n  }\n\n  /**\n   * Delete a block off this workspace with the specified ID.\n   * @param {string} id ID of block to delete.\n   * @package\n   */\n  removeBlockById(id) {\n    delete this.blockDB_[id];\n  }\n\n  /**\n   * Find the comment on this workspace with the specified ID.\n   * @param {string} id ID of comment to find.\n   * @return {?WorkspaceComment} The sought after comment, or null if not\n   *     found.\n   * @package\n   */\n  getCommentById(id) {\n    return this.commentDB_[id] || null;\n  }\n\n  /**\n   * Checks whether all value and statement inputs in the workspace are filled\n   * with blocks.\n   * @param {boolean=} opt_shadowBlocksAreFilled An optional argument\n   *     controlling whether shadow blocks are counted as filled. Defaults to\n   *     true.\n   * @return {boolean} True if all inputs are filled, false otherwise.\n   */\n  allInputsFilled(opt_shadowBlocksAreFilled) {\n    const blocks = this.getTopBlocks(false);\n    for (let i = 0; i < blocks.length; i++) {\n      const block = blocks[i];\n      if (!block.allInputsFilled(opt_shadowBlocksAreFilled)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return the variable map that contains \"potential\" variables.\n   * These exist in the flyout but not in the workspace.\n   * @return {?VariableMap} The potential variable map.\n   * @package\n   */\n  getPotentialVariableMap() {\n    return this.potentialVariableMap_;\n  }\n\n  /**\n   * Create and store the potential variable map for this workspace.\n   * @package\n   */\n  createPotentialVariableMap() {\n    this.potentialVariableMap_ = new VariableMap(this);\n  }\n\n  /**\n   * Return the map of all variables on the workspace.\n   * @return {!VariableMap} The variable map.\n   */\n  getVariableMap() {\n    return this.variableMap_;\n  }\n\n  /**\n   * Set the map of all variables on the workspace.\n   * @param {!VariableMap} variableMap The variable map.\n   * @package\n   */\n  setVariableMap(variableMap) {\n    this.variableMap_ = variableMap;\n  }\n\n  /**\n   * Find the workspace with the specified ID.\n   * @param {string} id ID of workspace to find.\n   * @return {?Workspace} The sought after workspace or null if not found.\n   */\n  static getById(id) {\n    return WorkspaceDB_[id] || null;\n  }\n\n  /**\n   * Find all workspaces.\n   * @return {!Array<!Workspace>} Array of workspaces.\n   */\n  static getAll() {\n    const workspaces = [];\n    for (const workspaceId in WorkspaceDB_) {\n      workspaces.push(WorkspaceDB_[workspaceId]);\n    }\n    return workspaces;\n  }\n}\n\n/**\n * Angle away from the horizontal to sweep for blocks.  Order of execution is\n * generally top to bottom, but a small angle changes the scan to give a bit of\n * a left to right bias (reversed in RTL).  Units are in degrees.\n * See: https://tvtropes.org/pmwiki/pmwiki.php/Main/DiagonalBilling\n */\nWorkspace.SCAN_ANGLE = 3;\n\nexports.Workspace = Workspace;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/workspace.js?")},
"./core/workspace_audio.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\n__webpack_require__(\"./core/utils/global.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object in charge of loading, storing, and playing audio for a\n *     workspace.\n */\n\n\n/**\n * Object in charge of loading, storing, and playing audio for a\n *     workspace.\n * @class\n */\ngoog.module('Blockly.WorkspaceAudio');\n\nconst userAgent = goog.require('Blockly.utils.userAgent');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\nconst {globalThis} = goog.require('Blockly.utils.global');\n\n\n/**\n * Prevent a sound from playing if another sound preceded it within this many\n * milliseconds.\n * @const\n */\nconst SOUND_LIMIT = 100;\n\n/**\n * Class for loading, storing, and playing audio for a workspace.\n * @alias Blockly.WorkspaceAudio\n */\nclass WorkspaceAudio {\n  /**\n   * @param {WorkspaceSvg} parentWorkspace The parent of the workspace\n   *     this audio object belongs to, or null.\n   */\n  constructor(parentWorkspace) {\n    /**\n     * The parent of the workspace this object belongs to, or null.  May be\n     * checked for sounds that this object can't find.\n     * @type {WorkspaceSvg}\n     * @private\n     */\n    this.parentWorkspace_ = parentWorkspace;\n\n    /**\n     * Database of pre-loaded sounds.\n     * @private\n     */\n    this.SOUNDS_ = Object.create(null);\n\n    /**\n     * Time that the last sound was played.\n     * @type {Date}\n     * @private\n     */\n    this.lastSound_ = null;\n  }\n\n  /**\n   * Dispose of this audio manager.\n   * @package\n   */\n  dispose() {\n    this.parentWorkspace_ = null;\n    this.SOUNDS_ = null;\n  }\n  /**\n   * Load an audio file.  Cache it, ready for instantaneous playing.\n   * @param {!Array<string>} filenames List of file types in decreasing order of\n   *   preference (i.e. increasing size).  E.g. ['media/go.mp3', 'media/go.wav']\n   *   Filenames include path from Blockly's root.  File extensions matter.\n   * @param {string} name Name of sound.\n   */\n  load(filenames, name) {\n    if (!filenames.length) {\n      return;\n    }\n    let audioTest;\n    try {\n      audioTest = new globalThis['Audio']();\n    } catch (e) {\n      // No browser support for Audio.\n      // IE can throw an error even if the Audio object exists.\n      return;\n    }\n    let sound;\n    for (let i = 0; i < filenames.length; i++) {\n      const filename = filenames[i];\n      const ext = filename.match(/\\.(\\w+)$/);\n      if (ext && audioTest.canPlayType('audio/' + ext[1])) {\n        // Found an audio format we can play.\n        sound = new globalThis['Audio'](filename);\n        break;\n      }\n    }\n    if (sound && sound.play) {\n      this.SOUNDS_[name] = sound;\n    }\n  }\n  /**\n   * Preload all the audio files so that they play quickly when asked for.\n   * @package\n   */\n  preload() {\n    for (const name in this.SOUNDS_) {\n      const sound = this.SOUNDS_[name];\n      sound.volume = 0.01;\n      const playPromise = sound.play();\n      // Edge does not return a promise, so we need to check.\n      if (playPromise !== undefined) {\n        // If we don't wait for the play request to complete before calling\n        // pause() we will get an exception: (DOMException: The play() request\n        // was interrupted) See more:\n        // https://developers.google.com/web/updates/2017/06/play-request-was-interrupted\n        playPromise.then(sound.pause).catch(function() {\n          // Play without user interaction was prevented.\n        });\n      } else {\n        sound.pause();\n      }\n\n      // iOS can only process one sound at a time.  Trying to load more than one\n      // corrupts the earlier ones.  Just load one and leave the others\n      // uncached.\n      if (userAgent.IPAD || userAgent.IPHONE) {\n        break;\n      }\n    }\n  }\n  /**\n   * Play a named sound at specified volume.  If volume is not specified,\n   * use full volume (1).\n   * @param {string} name Name of sound.\n   * @param {number=} opt_volume Volume of sound (0-1).\n   */\n  play(name, opt_volume) {\n    const sound = this.SOUNDS_[name];\n    if (sound) {\n      // Don't play one sound on top of another.\n      const now = new Date;\n      if (this.lastSound_ !== null && now - this.lastSound_ < SOUND_LIMIT) {\n        return;\n      }\n      this.lastSound_ = now;\n      let mySound;\n      if (userAgent.IPAD || userAgent.ANDROID) {\n        // Creating a new audio node causes lag in Android and iPad.  Android\n        // refetches the file from the server, iPad uses a singleton audio\n        // node which must be deleted and recreated for each new audio tag.\n        mySound = sound;\n      } else {\n        mySound = sound.cloneNode();\n      }\n      mySound.volume = (opt_volume === undefined ? 1 : opt_volume);\n      mySound.play();\n    } else if (this.parentWorkspace_) {\n      // Maybe a workspace on a lower level knows about this sound.\n      this.parentWorkspace_.getAudioManager().play(name, opt_volume);\n    }\n  }\n}\n\nexports.WorkspaceAudio = WorkspaceAudio;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/workspace_audio.js?")},
"./core/workspace_comment.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/utils/idgenerator.js\");\n__webpack_require__(\"./core/utils/xml.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/events/events_comment_move.js\");\n__webpack_require__(\"./core/events/events_comment_change.js\");\n__webpack_require__(\"./core/events/events_comment_create.js\");\n__webpack_require__(\"./core/events/events_comment_delete.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing a code comment on the workspace.\n */\n\n\n/**\n * Object representing a code comment on the workspace.\n * @class\n */\ngoog.module('Blockly.WorkspaceComment');\n\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst idGenerator = goog.require('Blockly.utils.idGenerator');\nconst xml = goog.require('Blockly.utils.xml');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\n/* eslint-disable-next-line no-unused-vars */\nconst {CommentMove} = goog.require('Blockly.Events.CommentMove');\n/* eslint-disable-next-line no-unused-vars */\nconst {Workspace} = goog.requireType('Blockly.Workspace');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.CommentChange');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.CommentCreate');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.CommentDelete');\n\n\n/**\n * Class for a workspace comment.\n * @alias Blockly.WorkspaceComment\n */\nclass WorkspaceComment {\n  /**\n   * @param {!Workspace} workspace The block's workspace.\n   * @param {string} content The content of this workspace comment.\n   * @param {number} height Height of the comment.\n   * @param {number} width Width of the comment.\n   * @param {string=} opt_id Optional ID.  Use this ID if provided, otherwise\n   *     create a new ID.\n   */\n  constructor(workspace, content, height, width, opt_id) {\n    /** @type {string} */\n    this.id = (opt_id && !workspace.getCommentById(opt_id)) ?\n        opt_id :\n        idGenerator.genUid();\n\n    workspace.addTopComment(this);\n\n    /**\n     * The comment's position in workspace units.  (0, 0) is at the workspace's\n     * origin; scale does not change this value.\n     * @type {!Coordinate}\n     * @protected\n     */\n    this.xy_ = new Coordinate(0, 0);\n\n    /**\n     * The comment's height in workspace units.  Scale does not change this\n     * value.\n     * @type {number}\n     * @protected\n     */\n    this.height_ = height;\n\n    /**\n     * The comment's width in workspace units.  Scale does not change this\n     * value.\n     * @type {number}\n     * @protected\n     */\n    this.width_ = width;\n\n    /**\n     * @type {!Workspace}\n     */\n    this.workspace = workspace;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.RTL = workspace.RTL;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.deletable_ = true;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.movable_ = true;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.editable_ = true;\n\n    /**\n     * @protected\n     * @type {string}\n     */\n    this.content_ = content;\n\n    /**\n     * Whether this comment has been disposed.\n     * @protected\n     * @type {boolean}\n     */\n    this.disposed_ = false;\n\n    /**\n     * @package\n     * @type {boolean}\n     */\n    this.isComment = true;\n\n    WorkspaceComment.fireCreateEvent(this);\n  }\n\n  /**\n   * Dispose of this comment.\n   * @package\n   */\n  dispose() {\n    if (this.disposed_) {\n      return;\n    }\n\n    if (eventUtils.isEnabled()) {\n      eventUtils.fire(new (eventUtils.get(eventUtils.COMMENT_DELETE))(this));\n    }\n\n    // Remove from the list of top comments and the comment database.\n    this.workspace.removeTopComment(this);\n    this.disposed_ = true;\n  }\n\n  // Height, width, x, and y are all stored on even non-rendered comments, to\n  // preserve state if you pass the contents through a headless workspace.\n\n  /**\n   * Get comment height.\n   * @return {number} Comment height.\n   * @package\n   */\n  getHeight() {\n    return this.height_;\n  }\n\n  /**\n   * Set comment height.\n   * @param {number} height Comment height.\n   * @package\n   */\n  setHeight(height) {\n    this.height_ = height;\n  }\n\n  /**\n   * Get comment width.\n   * @return {number} Comment width.\n   * @package\n   */\n  getWidth() {\n    return this.width_;\n  }\n\n  /**\n   * Set comment width.\n   * @param {number} width comment width.\n   * @package\n   */\n  setWidth(width) {\n    this.width_ = width;\n  }\n\n  /**\n   * Get stored location.\n   * @return {!Coordinate} The comment's stored location.\n   *   This is not valid if the comment is currently being dragged.\n   * @package\n   */\n  getXY() {\n    return new Coordinate(this.xy_.x, this.xy_.y);\n  }\n\n  /**\n   * Move a comment by a relative offset.\n   * @param {number} dx Horizontal offset, in workspace units.\n   * @param {number} dy Vertical offset, in workspace units.\n   * @package\n   */\n  moveBy(dx, dy) {\n    const event = /** @type {!CommentMove} */ (\n        new (eventUtils.get(eventUtils.COMMENT_MOVE))(this));\n    this.xy_.translate(dx, dy);\n    event.recordNew();\n    eventUtils.fire(event);\n  }\n\n  /**\n   * Get whether this comment is deletable or not.\n   * @return {boolean} True if deletable.\n   * @package\n   */\n  isDeletable() {\n    return this.deletable_ &&\n        !(this.workspace && this.workspace.options.readOnly);\n  }\n\n  /**\n   * Set whether this comment is deletable or not.\n   * @param {boolean} deletable True if deletable.\n   * @package\n   */\n  setDeletable(deletable) {\n    this.deletable_ = deletable;\n  }\n\n  /**\n   * Get whether this comment is movable or not.\n   * @return {boolean} True if movable.\n   * @package\n   */\n  isMovable() {\n    return this.movable_ &&\n        !(this.workspace && this.workspace.options.readOnly);\n  }\n\n  /**\n   * Set whether this comment is movable or not.\n   * @param {boolean} movable True if movable.\n   * @package\n   */\n  setMovable(movable) {\n    this.movable_ = movable;\n  }\n\n  /**\n   * Get whether this comment is editable or not.\n   * @return {boolean} True if editable.\n   */\n  isEditable() {\n    return this.editable_ &&\n        !(this.workspace && this.workspace.options.readOnly);\n  }\n\n  /**\n   * Set whether this comment is editable or not.\n   * @param {boolean} editable True if editable.\n   */\n  setEditable(editable) {\n    this.editable_ = editable;\n  }\n\n  /**\n   * Returns this comment's text.\n   * @return {string} Comment text.\n   * @package\n   */\n  getContent() {\n    return this.content_;\n  }\n\n  /**\n   * Set this comment's content.\n   * @param {string} content Comment content.\n   * @package\n   */\n  setContent(content) {\n    if (this.content_ !== content) {\n      eventUtils.fire(new (eventUtils.get(eventUtils.COMMENT_CHANGE))(\n          this, this.content_, content));\n      this.content_ = content;\n    }\n  }\n\n  /**\n   * Encode a comment subtree as XML with XY coordinates.\n   * @param {boolean=} opt_noId True if the encoder should skip the comment ID.\n   * @return {!Element} Tree of XML elements.\n   * @package\n   */\n  toXmlWithXY(opt_noId) {\n    const element = this.toXml(opt_noId);\n    element.setAttribute('x', Math.round(this.xy_.x));\n    element.setAttribute('y', Math.round(this.xy_.y));\n    element.setAttribute('h', this.height_);\n    element.setAttribute('w', this.width_);\n    return element;\n  }\n\n  /**\n   * Encode a comment subtree as XML, but don't serialize the XY coordinates.\n   * This method avoids some expensive metrics-related calls that are made in\n   * toXmlWithXY().\n   * @param {boolean=} opt_noId True if the encoder should skip the comment ID.\n   * @return {!Element} Tree of XML elements.\n   * @package\n   */\n  toXml(opt_noId) {\n    const commentElement = xml.createElement('comment');\n    if (!opt_noId) {\n      commentElement.id = this.id;\n    }\n    commentElement.textContent = this.getContent();\n    return commentElement;\n  }\n\n  /**\n   * Fire a create event for the given workspace comment, if comments are\n   * enabled.\n   * @param {!WorkspaceComment} comment The comment that was just created.\n   * @package\n   */\n  static fireCreateEvent(comment) {\n    if (eventUtils.isEnabled()) {\n      const existingGroup = eventUtils.getGroup();\n      if (!existingGroup) {\n        eventUtils.setGroup(true);\n      }\n      try {\n        eventUtils.fire(\n            new (eventUtils.get(eventUtils.COMMENT_CREATE))(comment));\n      } finally {\n        if (!existingGroup) {\n          eventUtils.setGroup(false);\n        }\n      }\n    }\n  }\n\n  /**\n   * Decode an XML comment tag and create a comment on the workspace.\n   * @param {!Element} xmlComment XML comment element.\n   * @param {!Workspace} workspace The workspace.\n   * @return {!WorkspaceComment} The created workspace comment.\n   * @package\n   */\n  static fromXml(xmlComment, workspace) {\n    const info = WorkspaceComment.parseAttributes(xmlComment);\n\n    const comment =\n        new WorkspaceComment(workspace, info.content, info.h, info.w, info.id);\n\n    const commentX = parseInt(xmlComment.getAttribute('x'), 10);\n    const commentY = parseInt(xmlComment.getAttribute('y'), 10);\n    if (!isNaN(commentX) && !isNaN(commentY)) {\n      comment.moveBy(commentX, commentY);\n    }\n\n    WorkspaceComment.fireCreateEvent(comment);\n    return comment;\n  }\n\n  /**\n   * Decode an XML comment tag and return the results in an object.\n   * @param {!Element} xml XML comment element.\n   * @return {{w: number, h: number, x: number, y: number, content: string}} An\n   *     object containing the id, size, position, and comment string.\n   * @package\n   */\n  static parseAttributes(xml) {\n    const xmlH = xml.getAttribute('h');\n    const xmlW = xml.getAttribute('w');\n\n    return {\n      // @type {string}\n      id: xml.getAttribute('id'),\n      // The height of the comment in workspace units, or 100 if not specified.\n      // @type {number}\n      h: xmlH ? parseInt(xmlH, 10) : 100,\n      // The width of the comment in workspace units, or 100 if not specified.\n      // @type {number}\n      w: xmlW ? parseInt(xmlW, 10) : 100,\n      // The x position of the comment in workspace coordinates, or NaN if not\n      // specified in the XML.\n      // @type {number}\n      x: parseInt(xml.getAttribute('x'), 10),\n      // The y position of the comment in workspace coordinates, or NaN if not\n      // specified in the XML.\n      // @type {number}\n      y: parseInt(xml.getAttribute('y'), 10),\n      // @type {string}\n      content: xml.textContent,\n    };\n  }\n}\n\nexports.WorkspaceComment = WorkspaceComment;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/workspace_comment.js?")},
"./core/workspace_comment_svg.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/contextmenu.js\");\n__webpack_require__(\"./core/css.js\");\n__webpack_require__(\"./core/touch.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/utils/svg_math.js\");\n__webpack_require__(\"./core/events/events_comment_move.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/interfaces/i_bounded_element.js\");\n__webpack_require__(\"./core/interfaces/i_bubble.js\");\n__webpack_require__(\"./core/interfaces/i_copyable.js\");\n__webpack_require__(\"./core/utils/rect.js\");\n__webpack_require__(\"./core/utils/svg.js\");\n__webpack_require__(\"./core/workspace_comment.js\");\n__webpack_require__(\"./core/events/events_comment_create.js\");\n__webpack_require__(\"./core/events/events_comment_delete.js\");\n__webpack_require__(\"./core/events/events_selected.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing a code comment on a rendered workspace.\n */\n\n\n/**\n * Object representing a code comment on a rendered workspace.\n * @class\n */\ngoog.module('Blockly.WorkspaceCommentSvg');\n\nconst ContextMenu = goog.require('Blockly.ContextMenu');\nconst Css = goog.require('Blockly.Css');\nconst Touch = goog.require('Blockly.Touch');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst common = goog.require('Blockly.common');\nconst dom = goog.require('Blockly.utils.dom');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst svgMath = goog.require('Blockly.utils.svgMath');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockDragSurfaceSvg} = goog.requireType('Blockly.BlockDragSurfaceSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {CommentMove} = goog.require('Blockly.Events.CommentMove');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\n/* eslint-disable-next-line no-unused-vars */\nconst {IBoundedElement} = goog.require('Blockly.IBoundedElement');\n/* eslint-disable-next-line no-unused-vars */\nconst {IBubble} = goog.require('Blockly.IBubble');\n/* eslint-disable-next-line no-unused-vars */\nconst {ICopyable} = goog.require('Blockly.ICopyable');\nconst {Rect} = goog.require('Blockly.utils.Rect');\nconst {Svg} = goog.require('Blockly.utils.Svg');\nconst {WorkspaceComment} = goog.require('Blockly.WorkspaceComment');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.CommentCreate');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.CommentDelete');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.Selected');\n\n\n/**\n * Size of the resize icon.\n * @type {number}\n * @const\n */\nconst RESIZE_SIZE = 8;\n\n/**\n * Radius of the border around the comment.\n * @type {number}\n * @const\n */\nconst BORDER_RADIUS = 3;\n\n/**\n * Offset from the foreignobject edge to the textarea edge.\n * @type {number}\n * @const\n */\nconst TEXTAREA_OFFSET = 2;\n\n/**\n * Class for a workspace comment's SVG representation.\n * @extends {WorkspaceComment}\n * @implements {IBoundedElement}\n * @implements {IBubble}\n * @implements {ICopyable}\n * @alias Blockly.WorkspaceCommentSvg\n */\nclass WorkspaceCommentSvg extends WorkspaceComment {\n  /**\n   * @param {!WorkspaceSvg} workspace The block's workspace.\n   * @param {string} content The content of this workspace comment.\n   * @param {number} height Height of the comment.\n   * @param {number} width Width of the comment.\n   * @param {string=} opt_id Optional ID.  Use this ID if provided, otherwise\n   *     create a new ID.\n   */\n  constructor(workspace, content, height, width, opt_id) {\n    super(workspace, content, height, width, opt_id);\n    /**\n     * @type {!WorkspaceSvg}\n     */\n    this.workspace;\n\n    /**\n     * Mouse up event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onMouseUpWrapper_ = null;\n\n    /**\n     * Mouse move event data.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onMouseMoveWrapper_ = null;\n\n    /**\n     * Whether event handlers have been initialized.\n     * @type {boolean}\n     * @private\n     */\n    this.eventsInit_ = false;\n\n    /**\n     * @type {?Element}\n     * @private\n     */\n    this.textarea_ = null;\n\n    /**\n     * @type {?SVGRectElement}\n     * @private\n     */\n    this.svgRectTarget_ = null;\n\n    /**\n     * @type {?SVGRectElement}\n     * @private\n     */\n    this.svgHandleTarget_ = null;\n\n    /**\n     * @type {?SVGForeignObjectElement}\n     * @private\n     */\n    this.foreignObject_ = null;\n\n    /**\n     * @type {?SVGGElement}\n     * @private\n     */\n    this.resizeGroup_ = null;\n\n    /**\n     * @type {?SVGGElement}\n     * @private\n     */\n    this.deleteGroup_ = null;\n\n    /**\n     * @type {?SVGCircleElement}\n     * @private\n     */\n    this.deleteIconBorder_ = null;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.focused_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.autoLayout_ = false;\n\n    // Create core elements for the block.\n    /**\n     * @type {!SVGElement}\n     * @private\n     */\n    this.svgGroup_ =\n        dom.createSvgElement(Svg.G, {'class': 'blocklyComment'}, null);\n    this.svgGroup_.translate_ = '';\n\n    this.svgRect_ = dom.createSvgElement(Svg.RECT, {\n      'class': 'blocklyCommentRect',\n      'x': 0,\n      'y': 0,\n      'rx': BORDER_RADIUS,\n      'ry': BORDER_RADIUS,\n    });\n    this.svgGroup_.appendChild(this.svgRect_);\n\n    /**\n     * Whether the comment is rendered onscreen and is a part of the DOM.\n     * @type {boolean}\n     * @private\n     */\n    this.rendered_ = false;\n\n    /**\n     * Whether to move the comment to the drag surface when it is dragged.\n     * True if it should move, false if it should be translated directly.\n     * @type {boolean}\n     * @private\n     */\n    this.useDragSurface_ =\n        svgMath.is3dSupported() && !!workspace.getBlockDragSurface();\n\n    this.render();\n  }\n\n  /**\n   * Dispose of this comment.\n   * @package\n   */\n  dispose() {\n    if (this.disposed_) {\n      return;\n    }\n    // If this comment is being dragged, unlink the mouse events.\n    if (common.getSelected() === this) {\n      this.unselect();\n      this.workspace.cancelCurrentGesture();\n    }\n\n    if (eventUtils.isEnabled()) {\n      eventUtils.fire(new (eventUtils.get(eventUtils.COMMENT_DELETE))(this));\n    }\n\n    dom.removeNode(this.svgGroup_);\n    // Dispose of any rendered components\n    this.disposeInternal_();\n\n    eventUtils.disable();\n    super.dispose();\n    eventUtils.enable();\n  }\n\n  /**\n   * Create and initialize the SVG representation of a workspace comment.\n   * May be called more than once.\n   *\n   * @param {boolean=} opt_noSelect Text inside text area will be selected if\n   *     false\n   *\n   * @package\n   */\n  initSvg(opt_noSelect) {\n    if (!this.workspace.rendered) {\n      throw TypeError('Workspace is headless.');\n    }\n    if (!this.workspace.options.readOnly && !this.eventsInit_) {\n      browserEvents.conditionalBind(\n          /** @type {!SVGRectElement} */ (this.svgRectTarget_), 'mousedown',\n          this, this.pathMouseDown_);\n      browserEvents.conditionalBind(\n          /** @type {!SVGRectElement} */ (this.svgHandleTarget_), 'mousedown',\n          this, this.pathMouseDown_);\n    }\n    this.eventsInit_ = true;\n\n    this.updateMovable();\n    if (!this.getSvgRoot().parentNode) {\n      this.workspace.getBubbleCanvas().appendChild(this.getSvgRoot());\n    }\n\n    if (!opt_noSelect && this.textarea_) {\n      this.textarea_.select();\n    }\n  }\n\n  /**\n   * Handle a mouse-down on an SVG comment.\n   * @param {!Event} e Mouse down event or touch start event.\n   * @private\n   */\n  pathMouseDown_(e) {\n    const gesture = this.workspace.getGesture(e);\n    if (gesture) {\n      gesture.handleBubbleStart(e, this);\n    }\n  }\n\n  /**\n   * Show the context menu for this workspace comment.\n   * @param {!Event} e Mouse event.\n   * @package\n   */\n  showContextMenu(e) {\n    if (this.workspace.options.readOnly) {\n      return;\n    }\n    // Save the current workspace comment in a variable for use in closures.\n    const comment = this;\n    const menuOptions = [];\n\n    if (this.isDeletable() && this.isMovable()) {\n      menuOptions.push(ContextMenu.commentDuplicateOption(comment));\n      menuOptions.push(ContextMenu.commentDeleteOption(comment));\n    }\n\n    ContextMenu.show(e, menuOptions, this.RTL);\n  }\n\n  /**\n   * Select this comment.  Highlight it visually.\n   * @package\n   */\n  select() {\n    if (common.getSelected() === this) {\n      return;\n    }\n    let oldId = null;\n    if (common.getSelected()) {\n      oldId = common.getSelected().id;\n      // Unselect any previously selected block.\n      eventUtils.disable();\n      try {\n        common.getSelected().unselect();\n      } finally {\n        eventUtils.enable();\n      }\n    }\n    const event = new (eventUtils.get(eventUtils.SELECTED))(\n        oldId, this.id, this.workspace.id);\n    eventUtils.fire(event);\n    common.setSelected(this);\n    this.addSelect();\n  }\n\n  /**\n   * Unselect this comment.  Remove its highlighting.\n   * @package\n   */\n  unselect() {\n    if (common.getSelected() !== this) {\n      return;\n    }\n    const event = new (eventUtils.get(eventUtils.SELECTED))(\n        this.id, null, this.workspace.id);\n    eventUtils.fire(event);\n    common.setSelected(null);\n    this.removeSelect();\n    this.blurFocus();\n  }\n\n  /**\n   * Select this comment.  Highlight it visually.\n   * @package\n   */\n  addSelect() {\n    dom.addClass(\n        /** @type {!Element} */ (this.svgGroup_), 'blocklySelected');\n    this.setFocus();\n  }\n\n  /**\n   * Unselect this comment.  Remove its highlighting.\n   * @package\n   */\n  removeSelect() {\n    dom.removeClass(\n        /** @type {!Element} */ (this.svgGroup_), 'blocklySelected');\n    this.blurFocus();\n  }\n\n  /**\n   * Focus this comment.  Highlight it visually.\n   * @package\n   */\n  addFocus() {\n    dom.addClass(\n        /** @type {!Element} */ (this.svgGroup_), 'blocklyFocused');\n  }\n\n  /**\n   * Unfocus this comment.  Remove its highlighting.\n   * @package\n   */\n  removeFocus() {\n    dom.removeClass(\n        /** @type {!Element} */ (this.svgGroup_), 'blocklyFocused');\n  }\n\n  /**\n   * Return the coordinates of the top-left corner of this comment relative to\n   * the drawing surface's origin (0,0), in workspace units.\n   * If the comment is on the workspace, (0, 0) is the origin of the workspace\n   * coordinate system.\n   * This does not change with workspace scale.\n   * @return {!Coordinate} Object with .x and .y properties in\n   *     workspace coordinates.\n   * @package\n   */\n  getRelativeToSurfaceXY() {\n    let x = 0;\n    let y = 0;\n\n    const dragSurfaceGroup = this.useDragSurface_ ?\n        this.workspace.getBlockDragSurface().getGroup() :\n        null;\n\n    let element = this.getSvgRoot();\n    if (element) {\n      do {\n        // Loop through this comment and every parent.\n        const xy = svgMath.getRelativeXY(/** @type {!Element} */ (element));\n        x += xy.x;\n        y += xy.y;\n        // If this element is the current element on the drag surface, include\n        // the translation of the drag surface itself.\n        if (this.useDragSurface_ &&\n            this.workspace.getBlockDragSurface().getCurrentBlock() ===\n                element) {\n          const surfaceTranslation =\n              this.workspace.getBlockDragSurface().getSurfaceTranslation();\n          x += surfaceTranslation.x;\n          y += surfaceTranslation.y;\n        }\n        element = element.parentNode;\n      } while (element && element !== this.workspace.getBubbleCanvas() &&\n               element !== dragSurfaceGroup);\n    }\n    this.xy_ = new Coordinate(x, y);\n    return this.xy_;\n  }\n\n  /**\n   * Move a comment by a relative offset.\n   * @param {number} dx Horizontal offset, in workspace units.\n   * @param {number} dy Vertical offset, in workspace units.\n   * @package\n   */\n  moveBy(dx, dy) {\n    const event = /** @type {!CommentMove} */ (\n        new (eventUtils.get(eventUtils.COMMENT_MOVE))(this));\n    // TODO: Do I need to look up the relative to surface XY position here?\n    const xy = this.getRelativeToSurfaceXY();\n    this.translate(xy.x + dx, xy.y + dy);\n    this.xy_ = new Coordinate(xy.x + dx, xy.y + dy);\n    event.recordNew();\n    eventUtils.fire(event);\n    this.workspace.resizeContents();\n  }\n\n  /**\n   * Transforms a comment by setting the translation on the transform attribute\n   * of the block's SVG.\n   * @param {number} x The x coordinate of the translation in workspace units.\n   * @param {number} y The y coordinate of the translation in workspace units.\n   * @package\n   */\n  translate(x, y) {\n    this.xy_ = new Coordinate(x, y);\n    this.getSvgRoot().setAttribute(\n        'transform', 'translate(' + x + ',' + y + ')');\n  }\n\n  /**\n   * Move this comment to its workspace's drag surface, accounting for\n   * positioning.  Generally should be called at the same time as\n   * setDragging(true).  Does nothing if useDragSurface_ is false.\n   * @package\n   */\n  moveToDragSurface() {\n    if (!this.useDragSurface_) {\n      return;\n    }\n    // The translation for drag surface blocks,\n    // is equal to the current relative-to-surface position,\n    // to keep the position in sync as it move on/off the surface.\n    // This is in workspace coordinates.\n    const xy = this.getRelativeToSurfaceXY();\n    this.clearTransformAttributes_();\n    this.workspace.getBlockDragSurface().translateSurface(xy.x, xy.y);\n    // Execute the move on the top-level SVG component\n    this.workspace.getBlockDragSurface().setBlocksAndShow(this.getSvgRoot());\n  }\n\n  /**\n   * Move this comment during a drag, taking into account whether we are using a\n   * drag surface to translate blocks.\n   * @param {BlockDragSurfaceSvg} dragSurface The surface that carries\n   *     rendered items during a drag, or null if no drag surface is in use.\n   * @param {!Coordinate} newLoc The location to translate to, in\n   *     workspace coordinates.\n   * @package\n   */\n  moveDuringDrag(dragSurface, newLoc) {\n    if (dragSurface) {\n      dragSurface.translateSurface(newLoc.x, newLoc.y);\n    } else {\n      this.svgGroup_.translate_ =\n          'translate(' + newLoc.x + ',' + newLoc.y + ')';\n      this.svgGroup_.setAttribute(\n          'transform', this.svgGroup_.translate_ + this.svgGroup_.skew_);\n    }\n  }\n\n  /**\n   * Move the bubble group to the specified location in workspace coordinates.\n   * @param {number} x The x position to move to.\n   * @param {number} y The y position to move to.\n   * @package\n   */\n  moveTo(x, y) {\n    this.translate(x, y);\n  }\n\n  /**\n   * Clear the comment of transform=\"...\" attributes.\n   * Used when the comment is switching from 3d to 2d transform or vice versa.\n   * @private\n   */\n  clearTransformAttributes_() {\n    this.getSvgRoot().removeAttribute('transform');\n  }\n\n  /**\n   * Returns the coordinates of a bounding box describing the dimensions of this\n   * comment.\n   * Coordinate system: workspace coordinates.\n   * @return {!Rect} Object with coordinates of the bounding box.\n   * @package\n   */\n  getBoundingRectangle() {\n    const blockXY = this.getRelativeToSurfaceXY();\n    const commentBounds = this.getHeightWidth();\n    const top = blockXY.y;\n    const bottom = blockXY.y + commentBounds.height;\n    let left;\n    let right;\n    if (this.RTL) {\n      left = blockXY.x - commentBounds.width;\n      // Add the width of the tab/puzzle piece knob to the x coordinate\n      // since X is the corner of the rectangle, not the whole puzzle piece.\n      right = blockXY.x;\n    } else {\n      // Subtract the width of the tab/puzzle piece knob to the x coordinate\n      // since X is the corner of the rectangle, not the whole puzzle piece.\n      left = blockXY.x;\n      right = blockXY.x + commentBounds.width;\n    }\n    return new Rect(top, bottom, left, right);\n  }\n\n  /**\n   * Add or remove the UI indicating if this comment is movable or not.\n   * @package\n   */\n  updateMovable() {\n    if (this.isMovable()) {\n      dom.addClass(\n          /** @type {!Element} */ (this.svgGroup_), 'blocklyDraggable');\n    } else {\n      dom.removeClass(\n          /** @type {!Element} */ (this.svgGroup_), 'blocklyDraggable');\n    }\n  }\n\n  /**\n   * Set whether this comment is movable or not.\n   * @param {boolean} movable True if movable.\n   * @package\n   */\n  setMovable(movable) {\n    super.setMovable(movable);\n    this.updateMovable();\n  }\n\n  /**\n   * Set whether this comment is editable or not.\n   * @param {boolean} editable True if editable.\n   */\n  setEditable(editable) {\n    super.setEditable(editable);\n    if (this.textarea_) {\n      this.textarea_.readOnly = !editable;\n    }\n  }\n\n  /**\n   * Recursively adds or removes the dragging class to this node and its\n   * children.\n   * @param {boolean} adding True if adding, false if removing.\n   * @package\n   */\n  setDragging(adding) {\n    if (adding) {\n      const group = this.getSvgRoot();\n      group.translate_ = '';\n      group.skew_ = '';\n      dom.addClass(\n          /** @type {!Element} */ (this.svgGroup_), 'blocklyDragging');\n    } else {\n      dom.removeClass(\n          /** @type {!Element} */ (this.svgGroup_), 'blocklyDragging');\n    }\n  }\n\n  /**\n   * Return the root node of the SVG or null if none exists.\n   * @return {!SVGElement} The root SVG node (probably a group).\n   * @package\n   */\n  getSvgRoot() {\n    return this.svgGroup_;\n  }\n\n  /**\n   * Returns this comment's text.\n   * @return {string} Comment text.\n   * @package\n   */\n  getContent() {\n    return this.textarea_ ? this.textarea_.value : this.content_;\n  }\n\n  /**\n   * Set this comment's content.\n   * @param {string} content Comment content.\n   * @package\n   */\n  setContent(content) {\n    super.setContent(content);\n    if (this.textarea_) {\n      this.textarea_.value = content;\n    }\n  }\n\n  /**\n   * Update the cursor over this comment by adding or removing a class.\n   * @param {boolean} enable True if the delete cursor should be shown, false\n   *     otherwise.\n   * @package\n   */\n  setDeleteStyle(enable) {\n    if (enable) {\n      dom.addClass(\n          /** @type {!Element} */ (this.svgGroup_), 'blocklyDraggingDelete');\n    } else {\n      dom.removeClass(\n          /** @type {!Element} */ (this.svgGroup_), 'blocklyDraggingDelete');\n    }\n  }\n\n  /**\n   * Set whether auto-layout of this bubble is enabled.  The first time a bubble\n   * is shown it positions itself to not cover any blocks.  Once a user has\n   * dragged it to reposition, it renders where the user put it.\n   * @param {boolean} _enable True if auto-layout should be enabled, false\n   *     otherwise.\n   * @package\n   */\n  setAutoLayout(_enable) {\n    // NOP for compatibility with the bubble dragger.\n  }\n\n  /**\n   * Encode a comment subtree as XML with XY coordinates.\n   * @param {boolean=} opt_noId True if the encoder should skip the comment ID.\n   * @return {!Element} Tree of XML elements.\n   * @package\n   */\n  toXmlWithXY(opt_noId) {\n    let width;  // Not used in LTR.\n    if (this.workspace.RTL) {\n      // Here be performance dragons: This calls getMetrics().\n      width = this.workspace.getWidth();\n    }\n    const element = this.toXml(opt_noId);\n    const xy = this.getRelativeToSurfaceXY();\n    element.setAttribute(\n        'x', Math.round(this.workspace.RTL ? width - xy.x : xy.x));\n    element.setAttribute('y', Math.round(xy.y));\n    element.setAttribute('h', this.getHeight());\n    element.setAttribute('w', this.getWidth());\n    return element;\n  }\n\n  /**\n   * Encode a comment for copying.\n   * @return {!ICopyable.CopyData} Copy metadata.\n   * @package\n   */\n  toCopyData() {\n    return {\n      saveInfo: this.toXmlWithXY(),\n      source: this.workspace,\n      typeCounts: null,\n    };\n  }\n\n  /**\n   * Returns a bounding box describing the dimensions of this comment.\n   * @return {!{height: number, width: number}} Object with height and width\n   *     properties in workspace units.\n   * @package\n   */\n  getHeightWidth() {\n    return {width: this.getWidth(), height: this.getHeight()};\n  }\n\n  /**\n   * Renders the workspace comment.\n   * @package\n   */\n  render() {\n    if (this.rendered_) {\n      return;\n    }\n\n    const size = this.getHeightWidth();\n\n    // Add text area\n    this.createEditor_();\n    this.svgGroup_.appendChild(this.foreignObject_);\n\n    this.svgHandleTarget_ = dom.createSvgElement(\n        Svg.RECT, {'class': 'blocklyCommentHandleTarget', 'x': 0, 'y': 0});\n    this.svgGroup_.appendChild(this.svgHandleTarget_);\n    this.svgRectTarget_ = dom.createSvgElement(Svg.RECT, {\n      'class': 'blocklyCommentTarget',\n      'x': 0,\n      'y': 0,\n      'rx': BORDER_RADIUS,\n      'ry': BORDER_RADIUS,\n    });\n    this.svgGroup_.appendChild(this.svgRectTarget_);\n\n    // Add the resize icon\n    this.addResizeDom_();\n    if (this.isDeletable()) {\n      // Add the delete icon\n      this.addDeleteDom_();\n    }\n\n    this.setSize_(size.width, size.height);\n\n    // Set the content\n    this.textarea_.value = this.content_;\n\n    this.rendered_ = true;\n\n    if (this.resizeGroup_) {\n      browserEvents.conditionalBind(\n          /** @type {!SVGGElement} */ (this.resizeGroup_), 'mousedown', this,\n          this.resizeMouseDown_);\n    }\n\n    if (this.isDeletable()) {\n      browserEvents.conditionalBind(\n          /** @type {!SVGGElement} */ (this.deleteGroup_), 'mousedown', this,\n          this.deleteMouseDown_);\n      browserEvents.conditionalBind(\n          /** @type {!SVGGElement} */ (this.deleteGroup_), 'mouseout', this,\n          this.deleteMouseOut_);\n      browserEvents.conditionalBind(\n          /** @type {!SVGGElement} */ (this.deleteGroup_), 'mouseup', this,\n          this.deleteMouseUp_);\n    }\n  }\n\n  /**\n   * Create the text area for the comment.\n   * @return {!Element} The top-level node of the editor.\n   * @private\n   */\n  createEditor_() {\n    /* Create the editor.  Here's the markup that will be generated:\n      <foreignObject class=\"blocklyCommentForeignObject\" x=\"0\" y=\"10\"\n      width=\"164\" height=\"164\"> <body xmlns=\"http://www.w3.org/1999/xhtml\"\n      class=\"blocklyMinimalBody\"> <textarea xmlns=\"http://www.w3.org/1999/xhtml\"\n              class=\"blocklyCommentTextarea\"\n              style=\"height: 164px; width: 164px;\"></textarea>\n        </body>\n      </foreignObject>\n    */\n    this.foreignObject_ = dom.createSvgElement(\n        Svg.FOREIGNOBJECT, {\n          'x': 0,\n          'y': WorkspaceCommentSvg.TOP_OFFSET,\n          'class': 'blocklyCommentForeignObject',\n        },\n        null);\n    const body = document.createElementNS(dom.HTML_NS, 'body');\n    body.setAttribute('xmlns', dom.HTML_NS);\n    body.className = 'blocklyMinimalBody';\n    const textarea = document.createElementNS(dom.HTML_NS, 'textarea');\n    textarea.className = 'blocklyCommentTextarea';\n    textarea.setAttribute('dir', this.RTL ? 'RTL' : 'LTR');\n    textarea.readOnly = !this.isEditable();\n    body.appendChild(textarea);\n    this.textarea_ = textarea;\n    this.foreignObject_.appendChild(body);\n    // Don't zoom with mousewheel.\n    browserEvents.conditionalBind(textarea, 'wheel', this, function(e) {\n      e.stopPropagation();\n    });\n    browserEvents.conditionalBind(\n        textarea, 'change', this,\n        /**\n         * @this {WorkspaceCommentSvg}\n         * @param {Event} e Unused event parameter\n         */\n        function(\n            /* eslint-disable no-unused-vars */ e\n            /* eslint-enable no-unused-vars */) {\n          this.setContent(textarea.value);\n        });\n    return this.foreignObject_;\n  }\n\n  /**\n   * Add the resize icon to the DOM\n   * @private\n   */\n  addResizeDom_() {\n    this.resizeGroup_ = dom.createSvgElement(\n        Svg.G, {'class': this.RTL ? 'blocklyResizeSW' : 'blocklyResizeSE'},\n        this.svgGroup_);\n    dom.createSvgElement(\n        Svg.POLYGON,\n        {'points': '0,x x,x x,0'.replace(/x/g, RESIZE_SIZE.toString())},\n        this.resizeGroup_);\n    dom.createSvgElement(\n        Svg.LINE, {\n          'class': 'blocklyResizeLine',\n          'x1': RESIZE_SIZE / 3,\n          'y1': RESIZE_SIZE - 1,\n          'x2': RESIZE_SIZE - 1,\n          'y2': RESIZE_SIZE / 3,\n        },\n        this.resizeGroup_);\n    dom.createSvgElement(\n        Svg.LINE, {\n          'class': 'blocklyResizeLine',\n          'x1': RESIZE_SIZE * 2 / 3,\n          'y1': RESIZE_SIZE - 1,\n          'x2': RESIZE_SIZE - 1,\n          'y2': RESIZE_SIZE * 2 / 3,\n        },\n        this.resizeGroup_);\n  }\n\n  /**\n   * Add the delete icon to the DOM\n   * @private\n   */\n  addDeleteDom_() {\n    this.deleteGroup_ = dom.createSvgElement(\n        Svg.G, {'class': 'blocklyCommentDeleteIcon'}, this.svgGroup_);\n    this.deleteIconBorder_ = dom.createSvgElement(\n        Svg.CIRCLE,\n        {'class': 'blocklyDeleteIconShape', 'r': '7', 'cx': '7.5', 'cy': '7.5'},\n        this.deleteGroup_);\n    // x icon.\n    dom.createSvgElement(\n        Svg.LINE, {\n          'x1': '5',\n          'y1': '10',\n          'x2': '10',\n          'y2': '5',\n          'stroke': '#fff',\n          'stroke-width': '2',\n        },\n        this.deleteGroup_);\n    dom.createSvgElement(\n        Svg.LINE, {\n          'x1': '5',\n          'y1': '5',\n          'x2': '10',\n          'y2': '10',\n          'stroke': '#fff',\n          'stroke-width': '2',\n        },\n        this.deleteGroup_);\n  }\n\n  /**\n   * Handle a mouse-down on comment's resize corner.\n   * @param {!Event} e Mouse down event.\n   * @private\n   */\n  resizeMouseDown_(e) {\n    this.unbindDragEvents_();\n    if (browserEvents.isRightButton(e)) {\n      // No right-click.\n      e.stopPropagation();\n      return;\n    }\n    // Left-click (or middle click)\n    this.workspace.startDrag(\n        e,\n        new Coordinate(\n            this.workspace.RTL ? -this.width_ : this.width_, this.height_));\n\n    this.onMouseUpWrapper_ = browserEvents.conditionalBind(\n        document, 'mouseup', this, this.resizeMouseUp_);\n    this.onMouseMoveWrapper_ = browserEvents.conditionalBind(\n        document, 'mousemove', this, this.resizeMouseMove_);\n    this.workspace.hideChaff();\n    // This event has been handled.  No need to bubble up to the document.\n    e.stopPropagation();\n  }\n\n  /**\n   * Handle a mouse-down on comment's delete icon.\n   * @param {!Event} e Mouse down event.\n   * @private\n   */\n  deleteMouseDown_(e) {\n    // Highlight the delete icon.\n    dom.addClass(\n        /** @type {!Element} */ (this.deleteIconBorder_),\n        'blocklyDeleteIconHighlighted');\n    // This event has been handled.  No need to bubble up to the document.\n    e.stopPropagation();\n  }\n\n  /**\n   * Handle a mouse-out on comment's delete icon.\n   * @param {!Event} _e Mouse out event.\n   * @private\n   */\n  deleteMouseOut_(_e) {\n    // Restore highlight on the delete icon.\n    dom.removeClass(\n        /** @type {!Element} */ (this.deleteIconBorder_),\n        'blocklyDeleteIconHighlighted');\n  }\n\n  /**\n   * Handle a mouse-up on comment's delete icon.\n   * @param {!Event} e Mouse up event.\n   * @private\n   */\n  deleteMouseUp_(e) {\n    // Delete this comment.\n    this.dispose();\n    // This event has been handled.  No need to bubble up to the document.\n    e.stopPropagation();\n  }\n\n  /**\n   * Stop binding to the global mouseup and mousemove events.\n   * @private\n   */\n  unbindDragEvents_() {\n    if (this.onMouseUpWrapper_) {\n      browserEvents.unbind(this.onMouseUpWrapper_);\n      this.onMouseUpWrapper_ = null;\n    }\n    if (this.onMouseMoveWrapper_) {\n      browserEvents.unbind(this.onMouseMoveWrapper_);\n      this.onMouseMoveWrapper_ = null;\n    }\n  }\n\n  /**\n   * Handle a mouse-up event while dragging a comment's border or resize handle.\n   * @param {!Event} _e Mouse up event.\n   * @private\n   */\n  resizeMouseUp_(_e) {\n    Touch.clearTouchIdentifier();\n    this.unbindDragEvents_();\n  }\n\n  /**\n   * Resize this comment to follow the mouse.\n   * @param {!Event} e Mouse move event.\n   * @private\n   */\n  resizeMouseMove_(e) {\n    this.autoLayout_ = false;\n    const newXY = this.workspace.moveDrag(e);\n    this.setSize_(this.RTL ? -newXY.x : newXY.x, newXY.y);\n  }\n\n  /**\n   * Callback function triggered when the comment has resized.\n   * Resize the text area accordingly.\n   * @private\n   */\n  resizeComment_() {\n    const size = this.getHeightWidth();\n    const topOffset = WorkspaceCommentSvg.TOP_OFFSET;\n    const textOffset = TEXTAREA_OFFSET * 2;\n\n    this.foreignObject_.setAttribute('width', size.width);\n    this.foreignObject_.setAttribute('height', size.height - topOffset);\n    if (this.RTL) {\n      this.foreignObject_.setAttribute('x', -size.width);\n    }\n    this.textarea_.style.width = (size.width - textOffset) + 'px';\n    this.textarea_.style.height = (size.height - textOffset - topOffset) + 'px';\n  }\n\n  /**\n   * Set size\n   * @param {number} width width of the container\n   * @param {number} height height of the container\n   * @private\n   */\n  setSize_(width, height) {\n    // Minimum size of a comment.\n    width = Math.max(width, 45);\n    height = Math.max(height, 20 + WorkspaceCommentSvg.TOP_OFFSET);\n    this.width_ = width;\n    this.height_ = height;\n    this.svgRect_.setAttribute('width', width);\n    this.svgRect_.setAttribute('height', height);\n    this.svgRectTarget_.setAttribute('width', width);\n    this.svgRectTarget_.setAttribute('height', height);\n    this.svgHandleTarget_.setAttribute('width', width);\n    this.svgHandleTarget_.setAttribute(\n        'height', WorkspaceCommentSvg.TOP_OFFSET);\n    if (this.RTL) {\n      this.svgRect_.setAttribute('transform', 'scale(-1 1)');\n      this.svgRectTarget_.setAttribute('transform', 'scale(-1 1)');\n    }\n\n    if (this.resizeGroup_) {\n      if (this.RTL) {\n        // Mirror the resize group.\n        this.resizeGroup_.setAttribute(\n            'transform',\n            'translate(' + (-width + RESIZE_SIZE) + ',' +\n                (height - RESIZE_SIZE) + ') scale(-1 1)');\n        this.deleteGroup_.setAttribute(\n            'transform',\n            'translate(' + (-width + RESIZE_SIZE) + ',' + (-RESIZE_SIZE) +\n                ') scale(-1 1)');\n      } else {\n        this.resizeGroup_.setAttribute(\n            'transform',\n            'translate(' + (width - RESIZE_SIZE) + ',' +\n                (height - RESIZE_SIZE) + ')');\n        this.deleteGroup_.setAttribute(\n            'transform',\n            'translate(' + (width - RESIZE_SIZE) + ',' + (-RESIZE_SIZE) + ')');\n      }\n    }\n\n    // Allow the contents to resize.\n    this.resizeComment_();\n  }\n\n  /**\n   * Dispose of any rendered comment components.\n   * @private\n   */\n  disposeInternal_() {\n    this.textarea_ = null;\n    this.foreignObject_ = null;\n    this.svgRectTarget_ = null;\n    this.svgHandleTarget_ = null;\n    this.disposed_ = true;\n  }\n\n  /**\n   * Set the focus on the text area.\n   * @package\n   */\n  setFocus() {\n    const comment = this;\n    this.focused_ = true;\n    // Defer CSS changes.\n    setTimeout(function() {\n      if (comment.disposed_) {\n        return;\n      }\n      comment.textarea_.focus();\n      comment.addFocus();\n      dom.addClass(\n          /** @type {!SVGRectElement} */ (comment.svgRectTarget_),\n          'blocklyCommentTargetFocused');\n      dom.addClass(\n          /** @type {!SVGRectElement} */ (comment.svgHandleTarget_),\n          'blocklyCommentHandleTargetFocused');\n    }, 0);\n  }\n\n  /**\n   * Remove focus from the text area.\n   * @package\n   */\n  blurFocus() {\n    const comment = this;\n    this.focused_ = false;\n    // Defer CSS changes.\n    setTimeout(function() {\n      if (comment.disposed_) {\n        return;\n      }\n\n      comment.textarea_.blur();\n      comment.removeFocus();\n      dom.removeClass(\n          /** @type {!SVGRectElement} */ (comment.svgRectTarget_),\n          'blocklyCommentTargetFocused');\n      dom.removeClass(\n          /** @type {!SVGRectElement} */ (comment.svgHandleTarget_),\n          'blocklyCommentHandleTargetFocused');\n    }, 0);\n  }\n\n  /**\n   * Decode an XML comment tag and create a rendered comment on the workspace.\n   * @param {!Element} xmlComment XML comment element.\n   * @param {!WorkspaceSvg} workspace The workspace.\n   * @param {number=} opt_wsWidth The width of the workspace, which is used to\n   *     position comments correctly in RTL.\n   * @return {!WorkspaceCommentSvg} The created workspace comment.\n   * @package\n   */\n  static fromXmlRendered(xmlComment, workspace, opt_wsWidth) {\n    eventUtils.disable();\n    let comment;\n    try {\n      const info = WorkspaceComment.parseAttributes(xmlComment);\n\n      comment = new WorkspaceCommentSvg(\n          workspace, info.content, info.h, info.w, info.id);\n      if (workspace.rendered) {\n        comment.initSvg(true);\n        comment.render();\n      }\n      // Position the comment correctly, taking into account the width of a\n      // rendered RTL workspace.\n      if (!isNaN(info.x) && !isNaN(info.y)) {\n        if (workspace.RTL) {\n          const wsWidth = opt_wsWidth || workspace.getWidth();\n          comment.moveBy(wsWidth - info.x, info.y);\n        } else {\n          comment.moveBy(info.x, info.y);\n        }\n      }\n    } finally {\n      eventUtils.enable();\n    }\n\n    WorkspaceComment.fireCreateEvent(\n        /** @type {!WorkspaceCommentSvg} */ (comment));\n    return (/** @type {!WorkspaceCommentSvg} */ (comment));\n  }\n}\n\n/**\n * The width and height to use to size a workspace comment when it is first\n * added, before it has been edited by the user.\n * @type {number}\n * @package\n */\nWorkspaceCommentSvg.DEFAULT_SIZE = 100;\n\n/**\n * Offset from the top to make room for a top bar.\n * @type {number}\n * @const\n * @private\n */\nWorkspaceCommentSvg.TOP_OFFSET = 10;\n\n/**\n * CSS for workspace comment.  See css.js for use.\n */\nCss.register(`\n.blocklyCommentForeignObject {\n  position: relative;\n  z-index: 0;\n}\n\n.blocklyCommentRect {\n  fill: #E7DE8E;\n  stroke: #bcA903;\n  stroke-width: 1px;\n}\n\n.blocklyCommentTarget {\n  fill: transparent;\n  stroke: #bcA903;\n}\n\n.blocklyCommentTargetFocused {\n  fill: none;\n}\n\n.blocklyCommentHandleTarget {\n  fill: none;\n}\n\n.blocklyCommentHandleTargetFocused {\n  fill: transparent;\n}\n\n.blocklyFocused>.blocklyCommentRect {\n  fill: #B9B272;\n  stroke: #B9B272;\n}\n\n.blocklySelected>.blocklyCommentTarget {\n  stroke: #fc3;\n  stroke-width: 3px;\n}\n\n.blocklyCommentDeleteIcon {\n  cursor: pointer;\n  fill: #000;\n  display: none;\n}\n\n.blocklySelected > .blocklyCommentDeleteIcon {\n  display: block;\n}\n\n.blocklyDeleteIconShape {\n  fill: #000;\n  stroke: #000;\n  stroke-width: 1px;\n}\n\n.blocklyDeleteIconShape.blocklyDeleteIconHighlighted {\n  stroke: #fc3;\n}\n`);\n\nexports.WorkspaceCommentSvg = WorkspaceCommentSvg;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/workspace_comment_svg.js?")},
"./core/workspace_drag_surface_svg.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/utils/svg_math.js\");\n__webpack_require__(\"./core/utils/svg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview An SVG that floats on top of the workspace.\n * Blocks are moved into this SVG during a drag, improving performance.\n * The entire SVG is translated using CSS translation instead of SVG so the\n * blocks are never repainted during drag improving performance.\n */\n\n\n\n/**\n * An SVG that floats on top of the workspace.\n * Blocks are moved into this SVG during a drag, improving performance.\n * The entire SVG is translated using CSS translation instead of SVG so the\n * blocks are never repainted during drag improving performance.\n * @class\n */\ngoog.module('Blockly.WorkspaceDragSurfaceSvg');\n\nconst dom = goog.require('Blockly.utils.dom');\nconst svgMath = goog.require('Blockly.utils.svgMath');\n/* eslint-disable-next-line no-unused-vars */\nconst {Coordinate} = goog.requireType('Blockly.utils.Coordinate');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n\n\n/**\n * Blocks are moved into this SVG during a drag, improving performance.\n * The entire SVG is translated using CSS transforms instead of SVG so the\n * blocks are never repainted during drag improving performance.\n * @alias Blockly.WorkspaceDragSurfaceSvg\n */\nclass WorkspaceDragSurfaceSvg {\n  /**\n   * @param {!Element} container Containing element.\n   */\n  constructor(container) {\n    /**\n     * The SVG drag surface. Set once by WorkspaceDragSurfaceSvg.createDom.\n     * @type {SVGElement}\n     * @private\n     */\n    this.SVG_ = null;\n\n    /**\n     * Containing HTML element; parent of the workspace and the drag surface.\n     * @type {Element}\n     * @private\n     */\n    this.container_ = container;\n\n    /**\n     * The element to insert the block canvas and bubble canvas after when it\n     * goes back in the DOM at the end of a drag.\n     * @type {Element}\n     * @private\n     */\n    this.previousSibling_ = null;\n\n    this.createDom();\n  }\n  /**\n   * Create the drag surface and inject it into the container.\n   */\n  createDom() {\n    if (this.SVG_) {\n      return;  // Already created.\n    }\n\n    /**\n     * Dom structure when the workspace is being dragged. If there is no drag in\n     * progress, the SVG is empty and display: none.\n     * <svg class=\"blocklyWsDragSurface\" style=transform:translate3d(...)>\n     *   <g class=\"blocklyBlockCanvas\"></g>\n     *   <g class=\"blocklyBubbleCanvas\">/g>\n     * </svg>\n     */\n    this.SVG_ = dom.createSvgElement(\n        Svg.SVG, {\n          'xmlns': dom.SVG_NS,\n          'xmlns:html': dom.HTML_NS,\n          'xmlns:xlink': dom.XLINK_NS,\n          'version': '1.1',\n          'class': 'blocklyWsDragSurface blocklyOverflowVisible',\n        },\n        null);\n    this.container_.appendChild(this.SVG_);\n  }\n  /**\n   * Translate the entire drag surface during a drag.\n   * We translate the drag surface instead of the blocks inside the surface\n   * so that the browser avoids repainting the SVG.\n   * Because of this, the drag coordinates must be adjusted by scale.\n   * @param {number} x X translation for the entire surface\n   * @param {number} y Y translation for the entire surface\n   * @package\n   */\n  translateSurface(x, y) {\n    // This is a work-around to prevent a the blocks from rendering\n    // fuzzy while they are being moved on the drag surface.\n    const fixedX = x.toFixed(0);\n    const fixedY = y.toFixed(0);\n\n    this.SVG_.style.display = 'block';\n    dom.setCssTransform(\n        this.SVG_, 'translate3d(' + fixedX + 'px, ' + fixedY + 'px, 0)');\n  }\n  /**\n   * Reports the surface translation in scaled workspace coordinates.\n   * Use this when finishing a drag to return blocks to the correct position.\n   * @return {!Coordinate} Current translation of the surface\n   * @package\n   */\n  getSurfaceTranslation() {\n    return svgMath.getRelativeXY(/** @type {!SVGElement} */ (this.SVG_));\n  }\n  /**\n   * Move the blockCanvas and bubbleCanvas out of the surface SVG and on to\n   * newSurface.\n   * @param {SVGElement} newSurface The element to put the drag surface contents\n   *     into.\n   * @package\n   */\n  clearAndHide(newSurface) {\n    if (!newSurface) {\n      throw Error(\n          'Couldn\\'t clear and hide the drag surface: missing new surface.');\n    }\n    const blockCanvas = /** @type {!Element} */ (this.SVG_.childNodes[0]);\n    const bubbleCanvas = /** @type {!Element} */ (this.SVG_.childNodes[1]);\n    if (!blockCanvas || !bubbleCanvas ||\n        !dom.hasClass(blockCanvas, 'blocklyBlockCanvas') ||\n        !dom.hasClass(bubbleCanvas, 'blocklyBubbleCanvas')) {\n      throw Error(\n          'Couldn\\'t clear and hide the drag surface. A node was missing.');\n    }\n\n    // If there is a previous sibling, put the blockCanvas back right\n    // afterwards, otherwise insert it as the first child node in newSurface.\n    if (this.previousSibling_ !== null) {\n      dom.insertAfter(blockCanvas, this.previousSibling_);\n    } else {\n      newSurface.insertBefore(blockCanvas, newSurface.firstChild);\n    }\n\n    // Reattach the bubble canvas after the blockCanvas.\n    dom.insertAfter(bubbleCanvas, blockCanvas);\n    // Hide the drag surface.\n    this.SVG_.style.display = 'none';\n    if (this.SVG_.childNodes.length) {\n      throw Error('Drag surface was not cleared.');\n    }\n    dom.setCssTransform(this.SVG_, '');\n    this.previousSibling_ = null;\n  }\n  /**\n   * Set the SVG to have the block canvas and bubble canvas in it and then\n   * show the surface.\n   * @param {!SVGElement} blockCanvas The block canvas <g> element from the\n   *     workspace.\n   * @param {!SVGElement} bubbleCanvas The <g> element that contains the\n   bubbles.\n   * @param {Element} previousSibling The element to insert the block canvas and\n         bubble canvas after when it goes back in the DOM at the end of a drag.\n   * @param {number} width The width of the workspace SVG element.\n   * @param {number} height The height of the workspace SVG element.\n   * @param {number} scale The scale of the workspace being dragged.\n   * @package\n   */\n  setContentsAndShow(\n      blockCanvas, bubbleCanvas, previousSibling, width, height, scale) {\n    if (this.SVG_.childNodes.length) {\n      throw Error('Already dragging a block.');\n    }\n    this.previousSibling_ = previousSibling;\n    // Make sure the blocks and bubble canvas are scaled appropriately.\n    blockCanvas.setAttribute(\n        'transform', 'translate(0, 0) scale(' + scale + ')');\n    bubbleCanvas.setAttribute(\n        'transform', 'translate(0, 0) scale(' + scale + ')');\n    this.SVG_.setAttribute('width', width);\n    this.SVG_.setAttribute('height', height);\n    this.SVG_.appendChild(blockCanvas);\n    this.SVG_.appendChild(bubbleCanvas);\n    this.SVG_.style.display = 'block';\n  }\n}\n\nexports.WorkspaceDragSurfaceSvg = WorkspaceDragSurfaceSvg;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/workspace_drag_surface_svg.js?")},
"./core/workspace_dragger.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Methods for dragging a workspace visually.\n */\n\n\n/**\n * Methods for dragging a workspace visually.\n * @class\n */\ngoog.module('Blockly.WorkspaceDragger');\n\nconst common = goog.require('Blockly.common');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n\n\n/**\n * Class for a workspace dragger.  It moves the workspace around when it is\n * being dragged by a mouse or touch.\n * Note that the workspace itself manages whether or not it has a drag surface\n * and how to do translations based on that.  This simply passes the right\n * commands based on events.\n * @alias Blockly.WorkspaceDragger\n */\nclass WorkspaceDragger {\n  /**\n   * @param {!WorkspaceSvg} workspace The workspace to drag.\n   */\n  constructor(workspace) {\n    /**\n     * @type {!WorkspaceSvg}\n     * @private\n     */\n    this.workspace_ = workspace;\n\n    /**\n     * Whether horizontal scroll is enabled.\n     * @type {boolean}\n     * @private\n     */\n    this.horizontalScrollEnabled_ = this.workspace_.isMovableHorizontally();\n\n    /**\n     * Whether vertical scroll is enabled.\n     * @type {boolean}\n     * @private\n     */\n    this.verticalScrollEnabled_ = this.workspace_.isMovableVertically();\n\n    /**\n     * The scroll position of the workspace at the beginning of the drag.\n     * Coordinate system: pixel coordinates.\n     * @type {!Coordinate}\n     * @protected\n     */\n    this.startScrollXY_ = new Coordinate(workspace.scrollX, workspace.scrollY);\n  }\n  /**\n   * Sever all links from this object.\n   * @package\n   * @suppress {checkTypes}\n   */\n  dispose() {\n    this.workspace_ = null;\n  }\n  /**\n   * Start dragging the workspace.\n   * @package\n   */\n  startDrag() {\n    if (common.getSelected()) {\n      common.getSelected().unselect();\n    }\n    this.workspace_.setupDragSurface();\n  }\n  /**\n   * Finish dragging the workspace and put everything back where it belongs.\n   * @param {!Coordinate} currentDragDeltaXY How far the pointer has\n   *     moved from the position at the start of the drag, in pixel coordinates.\n   * @package\n   */\n  endDrag(currentDragDeltaXY) {\n    // Make sure everything is up to date.\n    this.drag(currentDragDeltaXY);\n    this.workspace_.resetDragSurface();\n  }\n  /**\n   * Move the workspace based on the most recent mouse movements.\n   * @param {!Coordinate} currentDragDeltaXY How far the pointer has\n   *     moved from the position at the start of the drag, in pixel coordinates.\n   * @package\n   */\n  drag(currentDragDeltaXY) {\n    const newXY = Coordinate.sum(this.startScrollXY_, currentDragDeltaXY);\n\n    if (this.horizontalScrollEnabled_ && this.verticalScrollEnabled_) {\n      this.workspace_.scroll(newXY.x, newXY.y);\n    } else if (this.horizontalScrollEnabled_) {\n      this.workspace_.scroll(newXY.x, this.workspace_.scrollY);\n    } else if (this.verticalScrollEnabled_) {\n      this.workspace_.scroll(this.workspace_.scrollX, newXY.y);\n    } else {\n      throw new TypeError('Invalid state.');\n    }\n  }\n}\n\nexports.WorkspaceDragger = WorkspaceDragger;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/workspace_dragger.js?")},
"./core/workspace_svg.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/contextmenu.js\");\n__webpack_require__(\"./core/tooltip.js\");\n__webpack_require__(\"./core/widgetdiv.js\");\n__webpack_require__(\"./core/xml.js\");\n__webpack_require__(\"./core/utils/array.js\");\n__webpack_require__(\"./core/renderers/common/block_rendering.js\");\n__webpack_require__(\"./core/serialization/blocks.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/common.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/dropdowndiv.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/registry.js\");\n__webpack_require__(\"./core/utils/svg_math.js\");\n__webpack_require__(\"./core/utils/toolbox.js\");\n__webpack_require__(\"./core/utils/useragent.js\");\n__webpack_require__(\"./core/utils.js\");\n__webpack_require__(\"./core/block_svg.js\");\n__webpack_require__(\"./core/theme/classic.js\");\n__webpack_require__(\"./core/component_manager.js\");\n__webpack_require__(\"./core/config.js\");\n__webpack_require__(\"./core/connection_db.js\");\n__webpack_require__(\"./core/contextmenu_registry.js\");\n__webpack_require__(\"./core/utils/coordinate.js\");\n__webpack_require__(\"./core/gesture.js\");\n__webpack_require__(\"./core/grid.js\");\n__webpack_require__(\"./core/interfaces/i_ast_node_location_svg.js\");\n__webpack_require__(\"./core/marker_manager.js\");\n__webpack_require__(\"./core/options.js\");\n__webpack_require__(\"./core/utils/rect.js\");\n__webpack_require__(\"./core/utils/size.js\");\n__webpack_require__(\"./core/utils/svg.js\");\n__webpack_require__(\"./core/theme_manager.js\");\n__webpack_require__(\"./core/touch_gesture.js\");\n__webpack_require__(\"./core/workspace_audio.js\");\n__webpack_require__(\"./core/workspace.js\");\n__webpack_require__(\"./core/events/events_block_create.js\");\n__webpack_require__(\"./core/events/events_theme_change.js\");\n__webpack_require__(\"./core/events/events_viewport.js\");\n__webpack_require__(\"./core/metrics_manager.js\");\n__webpack_require__(\"./core/msg.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2014 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing a workspace rendered as SVG.\n */\n\n\n/**\n * Object representing a workspace rendered as SVG.\n * @class\n */\ngoog.module('Blockly.WorkspaceSvg');\n\nconst ContextMenu = goog.require('Blockly.ContextMenu');\n/* eslint-disable-next-line no-unused-vars */\nconst Procedures = goog.requireType('Blockly.Procedures');\nconst Tooltip = goog.require('Blockly.Tooltip');\n/* eslint-disable-next-line no-unused-vars */\nconst Variables = goog.requireType('Blockly.Variables');\n/* eslint-disable-next-line no-unused-vars */\nconst VariablesDynamic = goog.requireType('Blockly.VariablesDynamic');\nconst WidgetDiv = goog.require('Blockly.WidgetDiv');\nconst Xml = goog.require('Blockly.Xml');\nconst arrayUtils = goog.require('Blockly.utils.array');\nconst blockRendering = goog.require('Blockly.blockRendering');\nconst blocks = goog.require('Blockly.serialization.blocks');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst common = goog.require('Blockly.common');\nconst dom = goog.require('Blockly.utils.dom');\nconst dropDownDiv = goog.require('Blockly.dropDownDiv');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst registry = goog.require('Blockly.registry');\nconst svgMath = goog.require('Blockly.utils.svgMath');\nconst toolbox = goog.require('Blockly.utils.toolbox');\nconst userAgent = goog.require('Blockly.utils.userAgent');\nconst utils = goog.require('Blockly.utils');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockDragSurfaceSvg} = goog.requireType('Blockly.BlockDragSurfaceSvg');\nconst {BlockSvg} = goog.require('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlocklyOptions} = goog.requireType('Blockly.BlocklyOptions');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\nconst {Classic} = goog.require('Blockly.Themes.Classic');\nconst {ComponentManager} = goog.require('Blockly.ComponentManager');\nconst {config} = goog.require('Blockly.config');\nconst {ConnectionDB} = goog.require('Blockly.ConnectionDB');\nconst {ContextMenuRegistry} = goog.require('Blockly.ContextMenuRegistry');\nconst {Coordinate} = goog.require('Blockly.utils.Coordinate');\n/* eslint-disable-next-line no-unused-vars */\nconst {Cursor} = goog.requireType('Blockly.Cursor');\n/* eslint-disable-next-line no-unused-vars */\nconst {FlyoutButton} = goog.requireType('Blockly.FlyoutButton');\nconst {Gesture} = goog.require('Blockly.Gesture');\nconst {Grid} = goog.require('Blockly.Grid');\n/* eslint-disable-next-line no-unused-vars */\nconst {IASTNodeLocationSvg} = goog.require('Blockly.IASTNodeLocationSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {IBoundedElement} = goog.requireType('Blockly.IBoundedElement');\n/* eslint-disable-next-line no-unused-vars */\nconst {ICopyable} = goog.requireType('Blockly.ICopyable');\n/* eslint-disable-next-line no-unused-vars */\nconst {IDragTarget} = goog.requireType('Blockly.IDragTarget');\n/* eslint-disable-next-line no-unused-vars */\nconst {IFlyout} = goog.requireType('Blockly.IFlyout');\n/* eslint-disable-next-line no-unused-vars */\nconst {IMetricsManager} = goog.requireType('Blockly.IMetricsManager');\n/* eslint-disable-next-line no-unused-vars */\nconst {IToolbox} = goog.requireType('Blockly.IToolbox');\nconst {MarkerManager} = goog.require('Blockly.MarkerManager');\n/* eslint-disable-next-line no-unused-vars */\nconst {Marker} = goog.requireType('Blockly.Marker');\n/* eslint-disable-next-line no-unused-vars */\nconst {Metrics} = goog.requireType('Blockly.utils.Metrics');\nconst {Options} = goog.require('Blockly.Options');\nconst {Rect} = goog.require('Blockly.utils.Rect');\n/* eslint-disable-next-line no-unused-vars */\nconst {RenderedConnection} = goog.requireType('Blockly.RenderedConnection');\n/* eslint-disable-next-line no-unused-vars */\nconst {Renderer} = goog.requireType('Blockly.blockRendering.Renderer');\n/* eslint-disable-next-line no-unused-vars */\nconst {ScrollbarPair} = goog.requireType('Blockly.ScrollbarPair');\nconst {Size} = goog.require('Blockly.utils.Size');\nconst {Svg} = goog.require('Blockly.utils.Svg');\nconst {ThemeManager} = goog.require('Blockly.ThemeManager');\n/* eslint-disable-next-line no-unused-vars */\nconst {Theme} = goog.requireType('Blockly.Theme');\nconst {TouchGesture} = goog.require('Blockly.TouchGesture');\n/* eslint-disable-next-line no-unused-vars */\nconst {Trashcan} = goog.requireType('Blockly.Trashcan');\n/* eslint-disable-next-line no-unused-vars */\nconst {VariableModel} = goog.requireType('Blockly.VariableModel');\nconst {WorkspaceAudio} = goog.require('Blockly.WorkspaceAudio');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceCommentSvg} = goog.requireType('Blockly.WorkspaceCommentSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceComment} = goog.requireType('Blockly.WorkspaceComment');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceDragSurfaceSvg} = goog.requireType('Blockly.WorkspaceDragSurfaceSvg');\nconst {Workspace} = goog.require('Blockly.Workspace');\n/* eslint-disable-next-line no-unused-vars */\nconst {ZoomControls} = goog.requireType('Blockly.ZoomControls');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.BlockCreate');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.ThemeChange');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.ViewportChange');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.MetricsManager');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Msg');\n\n\n/**\n * Margin around the top/bottom/left/right after a zoomToFit call.\n * @const\n */\nconst ZOOM_TO_FIT_MARGIN = 20;\n\n/**\n * Class for a workspace.  This is an onscreen area with optional trashcan,\n * scrollbars, bubbles, and dragging.\n * @extends {Workspace}\n * @implements {IASTNodeLocationSvg}\n * @alias Blockly.WorkspaceSvg\n */\nclass WorkspaceSvg extends Workspace {\n  /**\n   * @param {!Options} options Dictionary of options.\n   * @param {BlockDragSurfaceSvg=} opt_blockDragSurface Drag surface for\n   *     blocks.\n   * @param {WorkspaceDragSurfaceSvg=} opt_wsDragSurface Drag surface for\n   *     the workspace.\n   */\n  constructor(options, opt_blockDragSurface, opt_wsDragSurface) {\n    super(options);\n\n    /**\n     * A wrapper function called when a resize event occurs.\n     * You can pass the result to `eventHandling.unbind`.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.resizeHandlerWrapper_ = null;\n\n    /**\n     * The render status of an SVG workspace.\n     * Returns `false` for headless workspaces and true for instances of\n     * `WorkspaceSvg`.\n     * @type {boolean}\n     */\n    this.rendered = true;\n\n    /**\n     * Whether the workspace is visible.  False if the workspace has been hidden\n     * by calling `setVisible(false)`.\n     * @type {boolean}\n     * @private\n     */\n    this.isVisible_ = true;\n\n    /**\n     * Whether this workspace has resizes enabled.\n     * Disable during batch operations for a performance improvement.\n     * @type {boolean}\n     * @private\n     */\n    this.resizesEnabled_ = true;\n\n    /**\n     * Current horizontal scrolling offset in pixel units, relative to the\n     * workspace origin.\n     *\n     * It is useful to think about a view, and a canvas moving beneath that\n     * view. As the canvas moves right, this value becomes more positive, and\n     * the view is now \"seeing\" the left side of the canvas. As the canvas moves\n     * left, this value becomes more negative, and the view is now \"seeing\" the\n     * right side of the canvas.\n     *\n     * The confusing thing about this value is that it does not, and must not\n     * include the absoluteLeft offset. This is because it is used to calculate\n     * the viewLeft value.\n     *\n     * The viewLeft is relative to the workspace origin (although in pixel\n     * units). The workspace origin is the top-left corner of the workspace (at\n     * least when it is enabled). It is shifted from the top-left of the\n     * blocklyDiv so as not to be beneath the toolbox.\n     *\n     * When the workspace is enabled the viewLeft and workspace origin are at\n     * the same X location. As the canvas slides towards the right beneath the\n     * view this value (scrollX) becomes more positive, and the viewLeft becomes\n     * more negative relative to the workspace origin (imagine the workspace\n     * origin as a dot on the canvas sliding to the right as the canvas moves).\n     *\n     * So if the scrollX were to include the absoluteLeft this would in a way\n     * \"unshift\" the workspace origin. This means that the viewLeft would be\n     * representing the left edge of the blocklyDiv, rather than the left edge\n     * of the workspace.\n     *\n     * @type {number}\n     */\n    this.scrollX = 0;\n\n    /**\n     * Current vertical scrolling offset in pixel units, relative to the\n     * workspace origin.\n     *\n     * It is useful to think about a view, and a canvas moving beneath that\n     * view. As the canvas moves down, this value becomes more positive, and the\n     * view is now \"seeing\" the upper part of the canvas. As the canvas moves\n     * up, this value becomes more negative, and the view is \"seeing\" the lower\n     * part of the canvas.\n     *\n     * This confusing thing about this value is that it does not, and must not\n     * include the absoluteTop offset. This is because it is used to calculate\n     * the viewTop value.\n     *\n     * The viewTop is relative to the workspace origin (although in pixel\n     * units). The workspace origin is the top-left corner of the workspace (at\n     * least when it is enabled). It is shifted from the top-left of the\n     * blocklyDiv so as not to be beneath the toolbox.\n     *\n     * When the workspace is enabled the viewTop and workspace origin are at the\n     * same Y location. As the canvas slides towards the bottom this value\n     * (scrollY) becomes more positive, and the viewTop becomes more negative\n     * relative to the workspace origin (image in the workspace origin as a dot\n     * on the canvas sliding downwards as the canvas moves).\n     *\n     * So if the scrollY were to include the absoluteTop this would in a way\n     * \"unshift\" the workspace origin. This means that the viewTop would be\n     * representing the top edge of the blocklyDiv, rather than the top edge of\n     * the workspace.\n     *\n     * @type {number}\n     */\n    this.scrollY = 0;\n\n    /**\n     * Horizontal scroll value when scrolling started in pixel units.\n     * @type {number}\n     */\n    this.startScrollX = 0;\n\n    /**\n     * Vertical scroll value when scrolling started in pixel units.\n     * @type {number}\n     */\n    this.startScrollY = 0;\n\n    /**\n     * Distance from mouse to object being dragged.\n     * @type {Coordinate}\n     * @private\n     */\n    this.dragDeltaXY_ = null;\n\n    /**\n     * Current scale.\n     * @type {number}\n     */\n    this.scale = 1;\n\n    /**\n     * Cached scale value. Used to detect changes in viewport.\n     * @type {number}\n     * @private\n     */\n    this.oldScale_ = 1;\n\n    /**\n     * Cached viewport top value. Used to detect changes in viewport.\n     * @type {number}\n     * @private\n     */\n    this.oldTop_ = 0;\n\n    /**\n     * Cached viewport left value. Used to detect changes in viewport.\n     * @type {number}\n     * @private\n     */\n    this.oldLeft_ = 0;\n\n    /**\n     * The workspace's trashcan (if any).\n     * @type {Trashcan}\n     */\n    this.trashcan = null;\n\n    /**\n     * This workspace's scrollbars, if they exist.\n     * @type {ScrollbarPair}\n     */\n    this.scrollbar = null;\n\n    /**\n     * Fixed flyout providing blocks which may be dragged into this workspace.\n     * @type {IFlyout}\n     * @private\n     */\n    this.flyout_ = null;\n\n    /**\n     * Category-based toolbox providing blocks which may be dragged into this\n     * workspace.\n     * @type {IToolbox}\n     * @private\n     */\n    this.toolbox_ = null;\n\n    /**\n     * The current gesture in progress on this workspace, if any.\n     * @type {TouchGesture}\n     * @package\n     */\n    this.currentGesture_ = null;\n\n    /**\n     * This workspace's surface for dragging blocks, if it exists.\n     * @type {BlockDragSurfaceSvg}\n     * @private\n     */\n    this.blockDragSurface_ = null;\n\n    /**\n     * This workspace's drag surface, if it exists.\n     * @type {WorkspaceDragSurfaceSvg}\n     * @private\n     */\n    this.workspaceDragSurface_ = null;\n\n    /**\n     * Whether to move workspace to the drag surface when it is dragged.\n     * True if it should move, false if it should be translated directly.\n     * @type {boolean}\n     * @private\n     */\n    this.useWorkspaceDragSurface_ = false;\n\n    /**\n     * Whether the drag surface is actively in use. When true, calls to\n     * translate will translate the drag surface instead of the translating the\n     * workspace directly.\n     * This is set to true in setupDragSurface and to false in resetDragSurface.\n     * @type {boolean}\n     * @private\n     */\n    this.isDragSurfaceActive_ = false;\n\n    /**\n     * The first parent div with 'injectionDiv' in the name, or null if not set.\n     * Access this with getInjectionDiv.\n     * @type {Element}\n     * @private\n     */\n    this.injectionDiv_ = null;\n\n    /**\n     * Last known position of the page scroll.\n     * This is used to determine whether we have recalculated screen coordinate\n     * stuff since the page scrolled.\n     * @type {Coordinate}\n     * @private\n     */\n    this.lastRecordedPageScroll_ = null;\n\n    /**\n     * Developers may define this function to add custom menu options to the\n     * workspace's context menu or edit the workspace-created set of menu\n     * options.\n     * @param {!Array<!Object>} options List of menu options to add to.\n     * @param {!Event} e The right-click event that triggered the context menu.\n     */\n    this.configureContextMenu;\n\n    /**\n     * In a flyout, the target workspace where blocks should be placed after a\n     * drag. Otherwise null.\n     * @type {WorkspaceSvg}\n     * @package\n     */\n    this.targetWorkspace = null;\n\n    /**\n     * Inverted screen CTM, for use in mouseToSvg.\n     * @type {?SVGMatrix}\n     * @private\n     */\n    this.inverseScreenCTM_ = null;\n\n    /**\n     * Inverted screen CTM is dirty, recalculate it.\n     * @type {boolean}\n     * @private\n     */\n    this.inverseScreenCTMDirty_ = true;\n\n    const MetricsManagerClass = registry.getClassFromOptions(\n        registry.Type.METRICS_MANAGER, options, true);\n    /**\n     * Object in charge of calculating metrics for the workspace.\n     * @type {!IMetricsManager}\n     * @private\n     */\n    this.metricsManager_ = new MetricsManagerClass(this);\n\n    /**\n     * Method to get all the metrics that have to do with a workspace.\n     * @type {function():!Metrics}\n     * @package\n     */\n    this.getMetrics = options.getMetrics ||\n        this.metricsManager_.getMetrics.bind(this.metricsManager_);\n\n    /**\n     * Translates the workspace.\n     * @type {function(!{x:number, y:number}):void}\n     * @package\n     */\n    this.setMetrics =\n        options.setMetrics || WorkspaceSvg.setTopLevelWorkspaceMetrics_;\n\n    /**\n     * @type {!ComponentManager}\n     * @private\n     */\n    this.componentManager_ = new ComponentManager();\n\n    this.connectionDBList = ConnectionDB.init(this.connectionChecker);\n\n    if (opt_blockDragSurface) {\n      this.blockDragSurface_ = opt_blockDragSurface;\n    }\n\n    if (opt_wsDragSurface) {\n      this.workspaceDragSurface_ = opt_wsDragSurface;\n    }\n\n    this.useWorkspaceDragSurface_ =\n        !!this.workspaceDragSurface_ && svgMath.is3dSupported();\n\n    /**\n     * List of currently highlighted blocks.  Block highlighting is often used\n     * to visually mark blocks currently being executed.\n     * @type {!Array<!BlockSvg>}\n     * @private\n     */\n    this.highlightedBlocks_ = [];\n\n    /**\n     * Object in charge of loading, storing, and playing audio for a workspace.\n     * @type {!WorkspaceAudio}\n     * @private\n     */\n    this.audioManager_ = new WorkspaceAudio(\n        /** @type {WorkspaceSvg} */ (options.parentWorkspace));\n\n    /**\n     * This workspace's grid object or null.\n     * @type {Grid}\n     * @private\n     */\n    this.grid_ = this.options.gridPattern ?\n        new Grid(this.options.gridPattern, options.gridOptions) :\n        null;\n\n    /**\n     * Manager in charge of markers and cursors.\n     * @type {!MarkerManager}\n     * @private\n     */\n    this.markerManager_ = new MarkerManager(this);\n\n    /**\n     * Map from function names to callbacks, for deciding what to do when a\n     * custom toolbox category is opened.\n     * @type {!Object<string, ?function(!WorkspaceSvg):\n     *     !toolbox.FlyoutDefinition>}\n     * @private\n     */\n    this.toolboxCategoryCallbacks_ = Object.create(null);\n\n    /**\n     * Map from function names to callbacks, for deciding what to do when a\n     * button is clicked.\n     * @type {!Object<string, ?function(!FlyoutButton)>}\n     * @private\n     */\n    this.flyoutButtonCallbacks_ = Object.create(null);\n\n    const Variables = goog.module.get('Blockly.Variables');\n    if (Variables && Variables.flyoutCategory) {\n      this.registerToolboxCategoryCallback(\n          Variables.CATEGORY_NAME, Variables.flyoutCategory);\n    }\n\n    const VariablesDynamic = goog.module.get('Blockly.VariablesDynamic');\n    if (VariablesDynamic && VariablesDynamic.flyoutCategory) {\n      this.registerToolboxCategoryCallback(\n          VariablesDynamic.CATEGORY_NAME, VariablesDynamic.flyoutCategory);\n    }\n\n    const Procedures = goog.module.get('Blockly.Procedures');\n    if (Procedures && Procedures.flyoutCategory) {\n      this.registerToolboxCategoryCallback(\n          Procedures.CATEGORY_NAME, Procedures.flyoutCategory);\n      this.addChangeListener(Procedures.mutatorOpenListener);\n    }\n\n    /**\n     * Object in charge of storing and updating the workspace theme.\n     * @type {!ThemeManager}\n     * @protected\n     */\n    this.themeManager_ = this.options.parentWorkspace ?\n        this.options.parentWorkspace.getThemeManager() :\n        new ThemeManager(this, this.options.theme || Classic);\n    this.themeManager_.subscribeWorkspace(this);\n\n    /**\n     * The block renderer used for rendering blocks on this workspace.\n     * @type {!Renderer}\n     * @private\n     */\n    this.renderer_ = blockRendering.init(\n        this.options.renderer || 'geras', this.getTheme(),\n        this.options.rendererOverrides);\n\n    /**\n     * Cached parent SVG.\n     * @type {SVGElement}\n     * @private\n     */\n    this.cachedParentSvg_ = null;\n\n    /**\n     * True if keyboard accessibility mode is on, false otherwise.\n     * @type {boolean}\n     */\n    this.keyboardAccessibilityMode = false;\n\n    /**\n     * The list of top-level bounded elements on the workspace.\n     * @type {!Array<!IBoundedElement>}\n     * @private\n     */\n    this.topBoundedElements_ = [];\n\n    /**\n     * The recorded drag targets.\n     * @type {!Array<\n     * {\n     *   component: !IDragTarget,\n     *   clientRect: !Rect\n     * }>}\n     * @private\n     */\n    this.dragTargetAreas_ = [];\n\n    /**\n     * The cached size of the parent svg element.\n     * Used to compute svg metrics.\n     * @type {!Size}\n     * @private\n     */\n    this.cachedParentSvgSize_ = new Size(0, 0);\n  }\n\n  /**\n   * Get the marker manager for this workspace.\n   * @return {!MarkerManager} The marker manager.\n   */\n  getMarkerManager() {\n    return this.markerManager_;\n  }\n\n  /**\n   * Gets the metrics manager for this workspace.\n   * @return {!IMetricsManager} The metrics manager.\n   * @public\n   */\n  getMetricsManager() {\n    return this.metricsManager_;\n  }\n\n  /**\n   * Sets the metrics manager for the workspace.\n   * @param {!IMetricsManager} metricsManager The metrics manager.\n   * @package\n   */\n  setMetricsManager(metricsManager) {\n    this.metricsManager_ = metricsManager;\n    this.getMetrics =\n        this.metricsManager_.getMetrics.bind(this.metricsManager_);\n  }\n\n  /**\n   * Gets the component manager for this workspace.\n   * @return {!ComponentManager} The component manager.\n   * @public\n   */\n  getComponentManager() {\n    return this.componentManager_;\n  }\n\n  /**\n   * Add the cursor SVG to this workspaces SVG group.\n   * @param {SVGElement} cursorSvg The SVG root of the cursor to be added to the\n   *     workspace SVG group.\n   * @package\n   */\n  setCursorSvg(cursorSvg) {\n    this.markerManager_.setCursorSvg(cursorSvg);\n  }\n\n  /**\n   * Add the marker SVG to this workspaces SVG group.\n   * @param {SVGElement} markerSvg The SVG root of the marker to be added to the\n   *     workspace SVG group.\n   * @package\n   */\n  setMarkerSvg(markerSvg) {\n    this.markerManager_.setMarkerSvg(markerSvg);\n  }\n\n  /**\n   * Get the marker with the given ID.\n   * @param {string} id The ID of the marker.\n   * @return {?Marker} The marker with the given ID or null if no marker\n   *     with the given ID exists.\n   * @package\n   */\n  getMarker(id) {\n    if (this.markerManager_) {\n      return this.markerManager_.getMarker(id);\n    }\n    return null;\n  }\n\n  /**\n   * The cursor for this workspace.\n   * @return {?Cursor} The cursor for the workspace.\n   */\n  getCursor() {\n    if (this.markerManager_) {\n      return this.markerManager_.getCursor();\n    }\n    return null;\n  }\n\n  /**\n   * Get the block renderer attached to this workspace.\n   * @return {!Renderer} The renderer attached to this\n   *     workspace.\n   */\n  getRenderer() {\n    return this.renderer_;\n  }\n\n  /**\n   * Get the theme manager for this workspace.\n   * @return {!ThemeManager} The theme manager for this workspace.\n   * @package\n   */\n  getThemeManager() {\n    return this.themeManager_;\n  }\n\n  /**\n   * Get the workspace theme object.\n   * @return {!Theme} The workspace theme object.\n   */\n  getTheme() {\n    return this.themeManager_.getTheme();\n  }\n\n  /**\n   * Set the workspace theme object.\n   * If no theme is passed, default to the `Classic` theme.\n   * @param {Theme} theme The workspace theme object.\n   */\n  setTheme(theme) {\n    if (!theme) {\n      theme = /** @type {!Theme} */ (Classic);\n    }\n    this.themeManager_.setTheme(theme);\n  }\n\n  /**\n   * Refresh all blocks on the workspace after a theme update.\n   * @package\n   */\n  refreshTheme() {\n    if (this.svgGroup_) {\n      this.renderer_.refreshDom(this.svgGroup_, this.getTheme());\n    }\n\n    // Update all blocks in workspace that have a style name.\n    this.updateBlockStyles_(this.getAllBlocks(false).filter(function(block) {\n      return !!block.getStyleName();\n    }));\n\n    // Update current toolbox selection.\n    this.refreshToolboxSelection();\n    if (this.toolbox_) {\n      this.toolbox_.refreshTheme();\n    }\n\n    // Re-render if workspace is visible\n    if (this.isVisible()) {\n      this.setVisible(true);\n    }\n\n    const event = new (eventUtils.get(eventUtils.THEME_CHANGE))(\n        this.getTheme().name, this.id);\n    eventUtils.fire(event);\n  }\n\n  /**\n   * Updates all the blocks with new style.\n   * @param {!Array<!Block>} blocks List of blocks to update the style\n   *     on.\n   * @private\n   */\n  updateBlockStyles_(blocks) {\n    for (let i = 0, block; (block = blocks[i]); i++) {\n      const blockStyleName = block.getStyleName();\n      if (blockStyleName) {\n        block.setStyle(blockStyleName);\n        if (block.mutator) {\n          block.mutator.updateBlockStyle();\n        }\n      }\n    }\n  }\n\n  /**\n   * Getter for the inverted screen CTM.\n   * @return {?SVGMatrix} The matrix to use in mouseToSvg\n   */\n  getInverseScreenCTM() {\n    // Defer getting the screen CTM until we actually need it, this should\n    // avoid forced reflows from any calls to updateInverseScreenCTM.\n    if (this.inverseScreenCTMDirty_) {\n      const ctm = this.getParentSvg().getScreenCTM();\n      if (ctm) {\n        this.inverseScreenCTM_ = ctm.inverse();\n        this.inverseScreenCTMDirty_ = false;\n      }\n    }\n\n    return this.inverseScreenCTM_;\n  }\n\n  /**\n   * Mark the inverse screen CTM as dirty.\n   */\n  updateInverseScreenCTM() {\n    this.inverseScreenCTMDirty_ = true;\n  }\n\n  /**\n   * Getter for isVisible\n   * @return {boolean} Whether the workspace is visible.\n   *     False if the workspace has been hidden by calling `setVisible(false)`.\n   */\n  isVisible() {\n    return this.isVisible_;\n  }\n\n  /**\n   * Return the absolute coordinates of the top-left corner of this element,\n   * scales that after canvas SVG element, if it's a descendant.\n   * The origin (0,0) is the top-left corner of the Blockly SVG.\n   * @param {!SVGElement} element SVG element to find the coordinates of.\n   * @return {!Coordinate} Object with .x and .y properties.\n   * @package\n   */\n  getSvgXY(element) {\n    let x = 0;\n    let y = 0;\n    let scale = 1;\n    if (dom.containsNode(this.getCanvas(), element) ||\n        dom.containsNode(this.getBubbleCanvas(), element)) {\n      // Before the SVG canvas, scale the coordinates.\n      scale = this.scale;\n    }\n    do {\n      // Loop through this block and every parent.\n      const xy = svgMath.getRelativeXY(element);\n      if (element === this.getCanvas() || element === this.getBubbleCanvas()) {\n        // After the SVG canvas, don't scale the coordinates.\n        scale = 1;\n      }\n      x += xy.x * scale;\n      y += xy.y * scale;\n      element = /** @type {!SVGElement} */ (element.parentNode);\n    } while (element && element !== this.getParentSvg());\n    return new Coordinate(x, y);\n  }\n\n  /**\n   * Gets the size of the workspace's parent SVG element.\n   * @return {!Size} The cached width and height of the workspace's\n   *     parent SVG element.\n   * @package\n   */\n  getCachedParentSvgSize() {\n    const size = this.cachedParentSvgSize_;\n    return new Size(size.width, size.height);\n  }\n\n  /**\n   * Return the position of the workspace origin relative to the injection div\n   * origin in pixels.\n   * The workspace origin is where a block would render at position (0, 0).\n   * It is not the upper left corner of the workspace SVG.\n   * @return {!Coordinate} Offset in pixels.\n   * @package\n   */\n  getOriginOffsetInPixels() {\n    return svgMath.getInjectionDivXY(this.getCanvas());\n  }\n\n  /**\n   * Return the injection div that is a parent of this workspace.\n   * Walks the DOM the first time it's called, then returns a cached value.\n   * Note: We assume this is only called after the workspace has been injected\n   * into the DOM.\n   * @return {!Element} The first parent div with 'injectionDiv' in the name.\n   * @package\n   */\n  getInjectionDiv() {\n    // NB: it would be better to pass this in at createDom, but is more likely\n    // to break existing uses of Blockly.\n    if (!this.injectionDiv_) {\n      let element = this.svgGroup_;\n      while (element) {\n        const classes = element.getAttribute('class') || '';\n        if ((' ' + classes + ' ').indexOf(' injectionDiv ') !== -1) {\n          this.injectionDiv_ = element;\n          break;\n        }\n        element = /** @type {!Element} */ (element.parentNode);\n      }\n    }\n    return /** @type {!Element} */ (this.injectionDiv_);\n  }\n\n  /**\n   * Get the SVG block canvas for the workspace.\n   * @return {?SVGElement} The SVG group for the workspace.\n   * @package\n   */\n  getBlockCanvas() {\n    return this.svgBlockCanvas_;\n  }\n\n  /**\n   * Save resize handler data so we can delete it later in dispose.\n   * @param {!browserEvents.Data} handler Data that can be passed to\n   *     eventHandling.unbind.\n   */\n  setResizeHandlerWrapper(handler) {\n    this.resizeHandlerWrapper_ = handler;\n  }\n\n  /**\n   * Create the workspace DOM elements.\n   * @param {string=} opt_backgroundClass Either 'blocklyMainBackground' or\n   *     'blocklyMutatorBackground'.\n   * @return {!Element} The workspace's SVG group.\n   */\n  createDom(opt_backgroundClass) {\n    /**\n     * <g class=\"blocklyWorkspace\">\n     *   <rect class=\"blocklyMainBackground\" height=\"100%\" width=\"100%\"></rect>\n     *   [Trashcan and/or flyout may go here]\n     *   <g class=\"blocklyBlockCanvas\"></g>\n     *   <g class=\"blocklyBubbleCanvas\"></g>\n     * </g>\n     * @type {SVGElement}\n     */\n    this.svgGroup_ =\n        dom.createSvgElement(Svg.G, {'class': 'blocklyWorkspace'}, null);\n\n    // Note that a <g> alone does not receive mouse events--it must have a\n    // valid target inside it.  If no background class is specified, as in the\n    // flyout, the workspace will not receive mouse events.\n    if (opt_backgroundClass) {\n      /** @type {SVGElement} */\n      this.svgBackground_ = dom.createSvgElement(\n          Svg.RECT,\n          {'height': '100%', 'width': '100%', 'class': opt_backgroundClass},\n          this.svgGroup_);\n\n      if (opt_backgroundClass === 'blocklyMainBackground' && this.grid_) {\n        this.svgBackground_.style.fill =\n            'url(#' + this.grid_.getPatternId() + ')';\n      } else {\n        this.themeManager_.subscribe(\n            this.svgBackground_, 'workspaceBackgroundColour', 'fill');\n      }\n    }\n    /** @type {SVGElement} */\n    this.svgBlockCanvas_ = dom.createSvgElement(\n        Svg.G, {'class': 'blocklyBlockCanvas'}, this.svgGroup_);\n    /** @type {SVGElement} */\n    this.svgBubbleCanvas_ = dom.createSvgElement(\n        Svg.G, {'class': 'blocklyBubbleCanvas'}, this.svgGroup_);\n\n    if (!this.isFlyout) {\n      browserEvents.conditionalBind(\n          this.svgGroup_, 'mousedown', this, this.onMouseDown_, false, true);\n      // This no-op works around https://bugs.webkit.org/show_bug.cgi?id=226683,\n      // which otherwise prevents zoom/scroll events from being observed in\n      // Safari. Once that bug is fixed it should be removed.\n      document.body.addEventListener('wheel', function() {});\n      browserEvents.conditionalBind(\n          this.svgGroup_, 'wheel', this, this.onMouseWheel_);\n    }\n\n    // Determine if there needs to be a category tree, or a simple list of\n    // blocks.  This cannot be changed later, since the UI is very different.\n    if (this.options.hasCategories) {\n      const ToolboxClass = registry.getClassFromOptions(\n          registry.Type.TOOLBOX, this.options, true);\n      this.toolbox_ = new ToolboxClass(this);\n    }\n    if (this.grid_) {\n      this.grid_.update(this.scale);\n    }\n    this.recordDragTargets();\n    const CursorClass =\n        registry.getClassFromOptions(registry.Type.CURSOR, this.options);\n\n    CursorClass && this.markerManager_.setCursor(new CursorClass());\n\n    this.renderer_.createDom(this.svgGroup_, this.getTheme());\n    return this.svgGroup_;\n  }\n\n  /**\n   * Dispose of this workspace.\n   * Unlink from all DOM elements to prevent memory leaks.\n   * @suppress {checkTypes}\n   */\n  dispose() {\n    // Stop rerendering.\n    this.rendered = false;\n    if (this.currentGesture_) {\n      this.currentGesture_.cancel();\n    }\n    if (this.svgGroup_) {\n      dom.removeNode(this.svgGroup_);\n      this.svgGroup_ = null;\n    }\n    this.svgBlockCanvas_ = null;\n    this.svgBubbleCanvas_ = null;\n    if (this.toolbox_) {\n      this.toolbox_.dispose();\n      this.toolbox_ = null;\n    }\n    if (this.flyout_) {\n      this.flyout_.dispose();\n      this.flyout_ = null;\n    }\n    if (this.trashcan) {\n      this.trashcan.dispose();\n      this.trashcan = null;\n    }\n    if (this.scrollbar) {\n      this.scrollbar.dispose();\n      this.scrollbar = null;\n    }\n    if (this.zoomControls_) {\n      this.zoomControls_.dispose();\n      this.zoomControls_ = null;\n    }\n\n    if (this.audioManager_) {\n      this.audioManager_.dispose();\n      this.audioManager_ = null;\n    }\n\n    if (this.grid_) {\n      this.grid_.dispose();\n      this.grid_ = null;\n    }\n\n    this.renderer_.dispose();\n\n    if (this.markerManager_) {\n      this.markerManager_.dispose();\n      this.markerManager_ = null;\n    }\n\n    super.dispose();\n\n    // Dispose of theme manager after all blocks and mutators are disposed of.\n    if (this.themeManager_) {\n      this.themeManager_.unsubscribeWorkspace(this);\n      this.themeManager_.unsubscribe(this.svgBackground_);\n      if (!this.options.parentWorkspace) {\n        this.themeManager_.dispose();\n        this.themeManager_ = null;\n      }\n    }\n\n    this.connectionDBList = null;\n\n    this.toolboxCategoryCallbacks_ = null;\n    this.flyoutButtonCallbacks_ = null;\n\n    if (!this.options.parentWorkspace) {\n      // Top-most workspace.  Dispose of the div that the\n      // SVG is injected into (i.e. injectionDiv).\n      const parentSvg = this.getParentSvg();\n      if (parentSvg && parentSvg.parentNode) {\n        dom.removeNode(parentSvg.parentNode);\n      }\n    }\n    if (this.resizeHandlerWrapper_) {\n      browserEvents.unbind(this.resizeHandlerWrapper_);\n      this.resizeHandlerWrapper_ = null;\n    }\n  }\n\n  /**\n   * Obtain a newly created block.\n   *\n   * This block's SVG must still be initialized\n   * ([initSvg]{@link BlockSvg#initSvg}) and it must be rendered\n   * ([render]{@link BlockSvg#render}) before the block will be visible.\n   * @param {!string} prototypeName Name of the language object containing\n   *     type-specific functions for this block.\n   * @param {string=} opt_id Optional ID.  Use this ID if provided, otherwise\n   *     create a new ID.\n   * @return {!BlockSvg} The created block.\n   * @override\n   */\n  newBlock(prototypeName, opt_id) {\n    return new BlockSvg(this, prototypeName, opt_id);\n  }\n\n  /**\n   * Add a trashcan.\n   * @package\n   */\n  addTrashcan() {\n    const {Trashcan} = goog.module.get('Blockly.Trashcan');\n    if (!Trashcan) {\n      throw Error('Missing require for Blockly.Trashcan');\n    }\n    /** @type {Trashcan} */\n    this.trashcan = new Trashcan(this);\n    const svgTrashcan = this.trashcan.createDom();\n    this.svgGroup_.insertBefore(svgTrashcan, this.svgBlockCanvas_);\n  }\n\n  /**\n   * Add zoom controls.\n   * @package\n   */\n  addZoomControls() {\n    const {ZoomControls} = goog.module.get('Blockly.ZoomControls');\n    if (!ZoomControls) {\n      throw Error('Missing require for Blockly.ZoomControls');\n    }\n    /** @type {ZoomControls} */\n    this.zoomControls_ = new ZoomControls(this);\n    const svgZoomControls = this.zoomControls_.createDom();\n    this.svgGroup_.appendChild(svgZoomControls);\n  }\n\n  /**\n   * Add a flyout element in an element with the given tag name.\n   * @param {string|\n   * !Svg<!SVGSVGElement>|\n   * !Svg<!SVGGElement>} tagName What type of tag the\n   *     flyout belongs in.\n   * @return {!Element} The element containing the flyout DOM.\n   * @package\n   */\n  addFlyout(tagName) {\n    const workspaceOptions = new Options(\n        /** @type {!BlocklyOptions} */\n        ({\n          'parentWorkspace': this,\n          'rtl': this.RTL,\n          'oneBasedIndex': this.options.oneBasedIndex,\n          'horizontalLayout': this.horizontalLayout,\n          'renderer': this.options.renderer,\n          'rendererOverrides': this.options.rendererOverrides,\n          'move': {\n            'scrollbars': true,\n          },\n        }));\n    workspaceOptions.toolboxPosition = this.options.toolboxPosition;\n    if (this.horizontalLayout) {\n      const HorizontalFlyout = registry.getClassFromOptions(\n          registry.Type.FLYOUTS_HORIZONTAL_TOOLBOX, this.options, true);\n      this.flyout_ = new HorizontalFlyout(workspaceOptions);\n    } else {\n      const VerticalFlyout = registry.getClassFromOptions(\n          registry.Type.FLYOUTS_VERTICAL_TOOLBOX, this.options, true);\n      this.flyout_ = new VerticalFlyout(workspaceOptions);\n    }\n    this.flyout_.autoClose = false;\n    this.flyout_.getWorkspace().setVisible(true);\n\n    // Return the element so that callers can place it in their desired\n    // spot in the DOM.  For example, mutator flyouts do not go in the same\n    // place as main workspace flyouts.\n    return this.flyout_.createDom(tagName);\n  }\n\n  /**\n   * Getter for the flyout associated with this workspace.  This flyout may be\n   * owned by either the toolbox or the workspace, depending on toolbox\n   * configuration.  It will be null if there is no flyout.\n   * @param {boolean=} opt_own Whether to only return the workspace's own\n   *     flyout.\n   * @return {?IFlyout} The flyout on this workspace.\n   * @package\n   */\n  getFlyout(opt_own) {\n    if (this.flyout_ || opt_own) {\n      return this.flyout_;\n    }\n    if (this.toolbox_) {\n      return this.toolbox_.getFlyout();\n    }\n    return null;\n  }\n\n  /**\n   * Getter for the toolbox associated with this workspace, if one exists.\n   * @return {?IToolbox} The toolbox on this workspace.\n   * @package\n   */\n  getToolbox() {\n    return this.toolbox_;\n  }\n\n  /**\n   * Update items that use screen coordinate calculations\n   * because something has changed (e.g. scroll position, window size).\n   * @private\n   */\n  updateScreenCalculations_() {\n    this.updateInverseScreenCTM();\n    this.recordDragTargets();\n  }\n\n  /**\n   * If enabled, resize the parts of the workspace that change when the\n   * workspace contents (e.g. block positions) change.  This will also scroll\n   * the workspace contents if needed.\n   * @package\n   */\n  resizeContents() {\n    if (!this.resizesEnabled_ || !this.rendered) {\n      return;\n    }\n    if (this.scrollbar) {\n      this.scrollbar.resize();\n    }\n    this.updateInverseScreenCTM();\n  }\n\n  /**\n   * Resize and reposition all of the workspace chrome (toolbox,\n   * trash, scrollbars etc.)\n   * This should be called when something changes that\n   * requires recalculating dimensions and positions of the\n   * trash, zoom, toolbox, etc. (e.g. window resize).\n   */\n  resize() {\n    if (this.toolbox_) {\n      this.toolbox_.position();\n    }\n    if (this.flyout_) {\n      this.flyout_.position();\n    }\n\n    const positionables = this.componentManager_.getComponents(\n        ComponentManager.Capability.POSITIONABLE, true);\n    const metrics = this.getMetricsManager().getUiMetrics();\n    const savedPositions = [];\n    for (let i = 0, positionable; (positionable = positionables[i]); i++) {\n      positionable.position(metrics, savedPositions);\n      const boundingRect = positionable.getBoundingRectangle();\n      if (boundingRect) {\n        savedPositions.push(boundingRect);\n      }\n    }\n\n    if (this.scrollbar) {\n      this.scrollbar.resize();\n    }\n    this.updateScreenCalculations_();\n  }\n\n  /**\n   * Resizes and repositions workspace chrome if the page has a new\n   * scroll position.\n   * @package\n   */\n  updateScreenCalculationsIfScrolled() {\n    /* eslint-disable indent */\n    const currScroll = svgMath.getDocumentScroll();\n    if (!Coordinate.equals(this.lastRecordedPageScroll_, currScroll)) {\n      this.lastRecordedPageScroll_ = currScroll;\n      this.updateScreenCalculations_();\n    }\n  }\n  /* eslint-enable indent */\n\n  /**\n   * Get the SVG element that forms the drawing surface.\n   * @return {!SVGGElement} SVG group element.\n   */\n  getCanvas() {\n    return /** @type {!SVGGElement} */ (this.svgBlockCanvas_);\n  }\n\n  /**\n   * Caches the width and height of the workspace's parent SVG element for use\n   * with getSvgMetrics.\n   * @param {?number} width The width of the parent SVG element.\n   * @param {?number} height The height of the parent SVG element\n   * @package\n   */\n  setCachedParentSvgSize(width, height) {\n    const svg = this.getParentSvg();\n    if (width != null) {\n      this.cachedParentSvgSize_.width = width;\n      // This is set to support the public (but deprecated) Blockly.svgSize\n      // method.\n      svg.cachedWidth_ = width;\n    }\n    if (height != null) {\n      this.cachedParentSvgSize_.height = height;\n      // This is set to support the public (but deprecated) Blockly.svgSize\n      // method.\n      svg.cachedHeight_ = height;\n    }\n  }\n\n  /**\n   * Get the SVG element that forms the bubble surface.\n   * @return {!SVGGElement} SVG group element.\n   */\n  getBubbleCanvas() {\n    return /** @type {!SVGGElement} */ (this.svgBubbleCanvas_);\n  }\n\n  /**\n   * Get the SVG element that contains this workspace.\n   * Note: We assume this is only called after the workspace has been injected\n   * into the DOM.\n   * @return {!SVGElement} SVG element.\n   */\n  getParentSvg() {\n    if (!this.cachedParentSvg_) {\n      let element = this.svgGroup_;\n      while (element) {\n        if (element.tagName === 'svg') {\n          this.cachedParentSvg_ = element;\n          break;\n        }\n        element = /** @type {!SVGElement} */ (element.parentNode);\n      }\n    }\n    return /** @type {!SVGElement} */ (this.cachedParentSvg_);\n  }\n\n  /**\n   * Fires a viewport event if events are enabled and there is a change in\n   * viewport values.\n   * @package\n   */\n  maybeFireViewportChangeEvent() {\n    if (!eventUtils.isEnabled()) {\n      return;\n    }\n    const scale = this.scale;\n    const top = -this.scrollY;\n    const left = -this.scrollX;\n    if (scale === this.oldScale_ && Math.abs(top - this.oldTop_) < 1 &&\n        Math.abs(left - this.oldLeft_) < 1) {\n      // Ignore sub-pixel changes in top and left. Due to #4192 there are a lot\n      // of negligible changes in viewport top/left.\n      return;\n    }\n    const event = new (eventUtils.get(eventUtils.VIEWPORT_CHANGE))(\n        top, left, scale, this.id, this.oldScale_);\n    this.oldScale_ = scale;\n    this.oldTop_ = top;\n    this.oldLeft_ = left;\n    eventUtils.fire(event);\n  }\n\n  /**\n   * Translate this workspace to new coordinates.\n   * @param {number} x Horizontal translation, in pixel units relative to the\n   *    top left of the Blockly div.\n   * @param {number} y Vertical translation, in pixel units relative to the\n   *    top left of the Blockly div.\n   */\n  translate(x, y) {\n    if (this.useWorkspaceDragSurface_ && this.isDragSurfaceActive_) {\n      this.workspaceDragSurface_.translateSurface(x, y);\n    } else {\n      const translation = 'translate(' + x + ',' + y + ') ' +\n          'scale(' + this.scale + ')';\n      this.svgBlockCanvas_.setAttribute('transform', translation);\n      this.svgBubbleCanvas_.setAttribute('transform', translation);\n    }\n    // Now update the block drag surface if we're using one.\n    if (this.blockDragSurface_) {\n      this.blockDragSurface_.translateAndScaleGroup(x, y, this.scale);\n    }\n    // And update the grid if we're using one.\n    if (this.grid_) {\n      this.grid_.moveTo(x, y);\n    }\n\n    this.maybeFireViewportChangeEvent();\n  }\n\n  /**\n   * Called at the end of a workspace drag to take the contents\n   * out of the drag surface and put them back into the workspace SVG.\n   * Does nothing if the workspace drag surface is not enabled.\n   * @package\n   */\n  resetDragSurface() {\n    // Don't do anything if we aren't using a drag surface.\n    if (!this.useWorkspaceDragSurface_) {\n      return;\n    }\n\n    this.isDragSurfaceActive_ = false;\n\n    const trans = this.workspaceDragSurface_.getSurfaceTranslation();\n    this.workspaceDragSurface_.clearAndHide(this.svgGroup_);\n    const translation = 'translate(' + trans.x + ',' + trans.y + ') ' +\n        'scale(' + this.scale + ')';\n    this.svgBlockCanvas_.setAttribute('transform', translation);\n    this.svgBubbleCanvas_.setAttribute('transform', translation);\n  }\n\n  /**\n   * Called at the beginning of a workspace drag to move contents of\n   * the workspace to the drag surface.\n   * Does nothing if the drag surface is not enabled.\n   * @package\n   */\n  setupDragSurface() {\n    // Don't do anything if we aren't using a drag surface.\n    if (!this.useWorkspaceDragSurface_) {\n      return;\n    }\n\n    // This can happen if the user starts a drag, mouses up outside of the\n    // document where the mouseup listener is registered (e.g. outside of an\n    // iframe) and then moves the mouse back in the workspace.  On mobile and\n    // ff, we get the mouseup outside the frame. On chrome and safari desktop we\n    // do not.\n    if (this.isDragSurfaceActive_) {\n      return;\n    }\n\n    this.isDragSurfaceActive_ = true;\n\n    // Figure out where we want to put the canvas back.  The order\n    // in the is important because things are layered.\n    const previousElement =\n        /** @type {Element} */ (this.svgBlockCanvas_.previousSibling);\n    const width = parseInt(this.getParentSvg().getAttribute('width'), 10);\n    const height = parseInt(this.getParentSvg().getAttribute('height'), 10);\n    const coord = svgMath.getRelativeXY(this.getCanvas());\n    this.workspaceDragSurface_.setContentsAndShow(\n        this.getCanvas(), this.getBubbleCanvas(), previousElement, width,\n        height, this.scale);\n    this.workspaceDragSurface_.translateSurface(coord.x, coord.y);\n  }\n\n  /**\n   * Gets the drag surface blocks are moved to when a drag is started.\n   * @return {?BlockDragSurfaceSvg} This workspace's block drag surface,\n   *     if one is in use.\n   * @package\n   */\n  getBlockDragSurface() {\n    return this.blockDragSurface_;\n  }\n\n  /**\n   * Returns the horizontal offset of the workspace.\n   * Intended for LTR/RTL compatibility in XML.\n   * @return {number} Width.\n   */\n  getWidth() {\n    const metrics = this.getMetrics();\n    return metrics ? metrics.viewWidth / this.scale : 0;\n  }\n\n  /**\n   * Toggles the visibility of the workspace.\n   * Currently only intended for main workspace.\n   * @param {boolean} isVisible True if workspace should be visible.\n   */\n  setVisible(isVisible) {\n    this.isVisible_ = isVisible;\n    if (!this.svgGroup_) {\n      return;\n    }\n\n    // Tell the scrollbar whether its container is visible so it can\n    // tell when to hide itself.\n    if (this.scrollbar) {\n      this.scrollbar.setContainerVisible(isVisible);\n    }\n\n    // Tell the flyout whether its container is visible so it can\n    // tell when to hide itself.\n    if (this.getFlyout()) {\n      this.getFlyout().setContainerVisible(isVisible);\n    }\n\n    this.getParentSvg().style.display = isVisible ? 'block' : 'none';\n    if (this.toolbox_) {\n      // Currently does not support toolboxes in mutators.\n      this.toolbox_.setVisible(isVisible);\n    }\n    if (isVisible) {\n      const blocks = this.getAllBlocks(false);\n      // Tell each block on the workspace to mark its fields as dirty.\n      for (let i = blocks.length - 1; i >= 0; i--) {\n        blocks[i].markDirty();\n      }\n\n      this.render();\n      if (this.toolbox_) {\n        this.toolbox_.position();\n      }\n    } else {\n      this.hideChaff(true);\n    }\n  }\n\n  /**\n   * Render all blocks in workspace.\n   */\n  render() {\n    // Generate list of all blocks.\n    const blocks = this.getAllBlocks(false);\n    // Render each block.\n    for (let i = blocks.length - 1; i >= 0; i--) {\n      blocks[i].render(false);\n    }\n\n    if (this.currentGesture_) {\n      const imList = this.currentGesture_.getInsertionMarkers();\n      for (let i = 0; i < imList.length; i++) {\n        imList[i].render(false);\n      }\n    }\n\n    this.markerManager_.updateMarkers();\n  }\n\n  /**\n   * Highlight or unhighlight a block in the workspace.  Block highlighting is\n   * often used to visually mark blocks currently being executed.\n   * @param {?string} id ID of block to highlight/unhighlight,\n   *   or null for no block (used to unhighlight all blocks).\n   * @param {boolean=} opt_state If undefined, highlight specified block and\n   * automatically unhighlight all others.  If true or false, manually\n   * highlight/unhighlight the specified block.\n   */\n  highlightBlock(id, opt_state) {\n    if (opt_state === undefined) {\n      // Unhighlight all blocks.\n      for (let i = 0, block; (block = this.highlightedBlocks_[i]); i++) {\n        block.setHighlighted(false);\n      }\n      this.highlightedBlocks_.length = 0;\n    }\n    // Highlight/unhighlight the specified block.\n    const block = id ? this.getBlockById(id) : null;\n    if (block) {\n      const state = (opt_state === undefined) || opt_state;\n      // Using Set here would be great, but at the cost of IE10 support.\n      if (!state) {\n        arrayUtils.removeElem(this.highlightedBlocks_, block);\n      } else if (this.highlightedBlocks_.indexOf(block) === -1) {\n        this.highlightedBlocks_.push(block);\n      }\n      block.setHighlighted(state);\n    }\n  }\n\n  /**\n   * Pastes the provided block or workspace comment onto the workspace.\n   * Does not check whether there is remaining capacity for the object, that\n   * should be done before calling this method.\n   * @param {!Object|!Element|!DocumentFragment} state The representation of the\n   *     thing to paste.\n   * @return {!ICopyable|null} The pasted thing, or null if\n   *     the paste was not successful.\n   */\n  paste(state) {\n    if (!this.rendered || !state['type'] && !state.tagName) {\n      return null;\n    }\n    if (this.currentGesture_) {\n      this.currentGesture_.cancel();  // Dragging while pasting?  No.\n    }\n\n    const existingGroup = eventUtils.getGroup();\n    if (!existingGroup) {\n      eventUtils.setGroup(true);\n    }\n\n    let pastedThing;\n    // Checks if this is JSON. JSON has a type property, while elements don't.\n    if (state['type']) {\n      pastedThing =\n          this.pasteBlock_(null, /** @type {!blocks.State} */ (state));\n    } else {\n      const xmlBlock = /** @type {!Element} */ (state);\n      if (xmlBlock.tagName.toLowerCase() === 'comment') {\n        pastedThing = this.pasteWorkspaceComment_(xmlBlock);\n      } else {\n        pastedThing = this.pasteBlock_(xmlBlock, null);\n      }\n    }\n\n    eventUtils.setGroup(existingGroup);\n    return pastedThing;\n  }\n\n  /**\n   * Paste the provided block onto the workspace.\n   * @param {?Element} xmlBlock XML block element.\n   * @param {?blocks.State} jsonBlock JSON block\n   *     representation.\n   * @return {!BlockSvg} The pasted block.\n   * @private\n   */\n  pasteBlock_(xmlBlock, jsonBlock) {\n    eventUtils.disable();\n    let block;\n    try {\n      let blockX = 0;\n      let blockY = 0;\n      if (xmlBlock) {\n        block = /** @type {!BlockSvg} */ (Xml.domToBlock(xmlBlock, this));\n        blockX = parseInt(xmlBlock.getAttribute('x'), 10);\n        if (this.RTL) {\n          blockX = -blockX;\n        }\n        blockY = parseInt(xmlBlock.getAttribute('y'), 10);\n      } else if (jsonBlock) {\n        block = /** @type {!BlockSvg} */ (blocks.append(jsonBlock, this));\n        blockX = jsonBlock['x'] || 10;\n        if (this.RTL) {\n          blockX = this.getWidth() - blockX;\n        }\n        blockY = jsonBlock['y'] || 10;\n      }\n\n      // Move the duplicate to original position.\n      if (!isNaN(blockX) && !isNaN(blockY)) {\n        // Offset block until not clobbering another block and not in connection\n        // distance with neighbouring blocks.\n        let collide;\n        do {\n          collide = false;\n          const allBlocks = this.getAllBlocks(false);\n          for (let i = 0, otherBlock; (otherBlock = allBlocks[i]); i++) {\n            const otherXY = otherBlock.getRelativeToSurfaceXY();\n            if (Math.abs(blockX - otherXY.x) <= 1 &&\n                Math.abs(blockY - otherXY.y) <= 1) {\n              collide = true;\n              break;\n            }\n          }\n          if (!collide) {\n            // Check for blocks in snap range to any of its connections.\n            const connections = block.getConnections_(false);\n            for (let i = 0, connection; (connection = connections[i]); i++) {\n              const neighbour =\n                  /** @type {!RenderedConnection} */ (connection)\n                      .closest(\n                          config.snapRadius, new Coordinate(blockX, blockY));\n              if (neighbour.connection) {\n                collide = true;\n                break;\n              }\n            }\n          }\n          if (collide) {\n            if (this.RTL) {\n              blockX -= config.snapRadius;\n            } else {\n              blockX += config.snapRadius;\n            }\n            blockY += config.snapRadius * 2;\n          }\n        } while (collide);\n        block.moveTo(new Coordinate(blockX, blockY));\n      }\n    } finally {\n      eventUtils.enable();\n    }\n    if (eventUtils.isEnabled() && !block.isShadow()) {\n      eventUtils.fire(new (eventUtils.get(eventUtils.BLOCK_CREATE))(block));\n    }\n    block.select();\n    return block;\n  }\n\n  /**\n   * Paste the provided comment onto the workspace.\n   * @param {!Element} xmlComment XML workspace comment element.\n   * @return {!WorkspaceCommentSvg} The pasted workspace comment.\n   * @private\n   * @suppress {checkTypes} Suppress checks while workspace comments are not\n   *     bundled in.\n   */\n  pasteWorkspaceComment_(xmlComment) {\n    eventUtils.disable();\n    let comment;\n    try {\n      comment = goog.module.get('Blockly.WorkspaceCommentSvg')\n                    .fromXml(xmlComment, this);\n      // Move the duplicate to original position.\n      let commentX = parseInt(xmlComment.getAttribute('x'), 10);\n      let commentY = parseInt(xmlComment.getAttribute('y'), 10);\n      if (!isNaN(commentX) && !isNaN(commentY)) {\n        if (this.RTL) {\n          commentX = -commentX;\n        }\n        // Offset workspace comment.\n        // TODO (#1719): Properly offset comment such that it's not interfering\n        // with any blocks.\n        commentX += 50;\n        commentY += 50;\n        comment.moveBy(commentX, commentY);\n      }\n    } finally {\n      eventUtils.enable();\n    }\n    if (eventUtils.isEnabled()) {\n      goog.module.get('Blockly.WorkspaceComment').fireCreateEvent(comment);\n    }\n    comment.select();\n    return comment;\n  }\n\n  /**\n   * Refresh the toolbox unless there's a drag in progress.\n   * @package\n   */\n  refreshToolboxSelection() {\n    const ws = this.isFlyout ? this.targetWorkspace : this;\n    if (ws && !ws.currentGesture_ && ws.toolbox_ && ws.toolbox_.getFlyout()) {\n      ws.toolbox_.refreshSelection();\n    }\n  }\n\n  /**\n   * Rename a variable by updating its name in the variable map.  Update the\n   *     flyout to show the renamed variable immediately.\n   * @param {string} id ID of the variable to rename.\n   * @param {string} newName New variable name.\n   */\n  renameVariableById(id, newName) {\n    super.renameVariableById(id, newName);\n    this.refreshToolboxSelection();\n  }\n\n  /**\n   * Delete a variable by the passed in ID.   Update the flyout to show\n   *     immediately that the variable is deleted.\n   * @param {string} id ID of variable to delete.\n   */\n  deleteVariableById(id) {\n    super.deleteVariableById(id);\n    this.refreshToolboxSelection();\n  }\n\n  /**\n   * Create a new variable with the given name.  Update the flyout to show the\n   *     new variable immediately.\n   * @param {string} name The new variable's name.\n   * @param {?string=} opt_type The type of the variable like 'int' or 'string'.\n   *     Does not need to be unique. Field_variable can filter variables based\n   * on their type. This will default to '' which is a specific type.\n   * @param {?string=} opt_id The unique ID of the variable. This will default\n   *     to a UUID.\n   * @return {!VariableModel} The newly created variable.\n   */\n  createVariable(name, opt_type, opt_id) {\n    const newVar = super.createVariable(name, opt_type, opt_id);\n    this.refreshToolboxSelection();\n    return newVar;\n  }\n\n  /**\n   * Make a list of all the delete areas for this workspace.\n   * @deprecated Use workspace.recordDragTargets. (2021 June)\n   */\n  recordDeleteAreas() {\n    utils.deprecation.warn(\n        'WorkspaceSvg.prototype.recordDeleteAreas', 'June 2021', 'June 2022',\n        'WorkspaceSvg.prototype.recordDragTargets');\n    this.recordDragTargets();\n  }\n\n  /**\n   * Make a list of all the delete areas for this workspace.\n   */\n  recordDragTargets() {\n    const dragTargets = this.componentManager_.getComponents(\n        ComponentManager.Capability.DRAG_TARGET, true);\n\n    this.dragTargetAreas_ = [];\n    for (let i = 0, targetArea; (targetArea = dragTargets[i]); i++) {\n      const rect = targetArea.getClientRect();\n      if (rect) {\n        this.dragTargetAreas_.push({\n          component: targetArea,\n          clientRect: rect,\n        });\n      }\n    }\n  }\n\n  /**\n   * Returns the drag target the mouse event is over.\n   * @param {!Event} e Mouse move event.\n   * @return {?IDragTarget} Null if not over a drag target, or the drag\n   *     target the event is over.\n   */\n  getDragTarget(e) {\n    for (let i = 0, targetArea; (targetArea = this.dragTargetAreas_[i]); i++) {\n      if (targetArea.clientRect.contains(e.clientX, e.clientY)) {\n        return targetArea.component;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Handle a mouse-down on SVG drawing surface.\n   * @param {!Event} e Mouse down event.\n   * @private\n   */\n  onMouseDown_(e) {\n    const gesture = this.getGesture(e);\n    if (gesture) {\n      gesture.handleWsStart(e, this);\n    }\n  }\n\n  /**\n   * Start tracking a drag of an object on this workspace.\n   * @param {!Event} e Mouse down event.\n   * @param {!Coordinate} xy Starting location of object.\n   */\n  startDrag(e, xy) {\n    // Record the starting offset between the bubble's location and the mouse.\n    const point = browserEvents.mouseToSvg(\n        e, this.getParentSvg(), this.getInverseScreenCTM());\n    // Fix scale of mouse event.\n    point.x /= this.scale;\n    point.y /= this.scale;\n    this.dragDeltaXY_ = Coordinate.difference(xy, point);\n  }\n\n  /**\n   * Track a drag of an object on this workspace.\n   * @param {!Event} e Mouse move event.\n   * @return {!Coordinate} New location of object.\n   */\n  moveDrag(e) {\n    const point = browserEvents.mouseToSvg(\n        e, this.getParentSvg(), this.getInverseScreenCTM());\n    // Fix scale of mouse event.\n    point.x /= this.scale;\n    point.y /= this.scale;\n    return Coordinate.sum(\n        /** @type {!Coordinate} */ (this.dragDeltaXY_), point);\n  }\n\n  /**\n   * Is the user currently dragging a block or scrolling the flyout/workspace?\n   * @return {boolean} True if currently dragging or scrolling.\n   */\n  isDragging() {\n    return this.currentGesture_ !== null && this.currentGesture_.isDragging();\n  }\n\n  /**\n   * Is this workspace draggable?\n   * @return {boolean} True if this workspace may be dragged.\n   */\n  isDraggable() {\n    return this.options.moveOptions && this.options.moveOptions.drag;\n  }\n\n  /**\n   * Is this workspace movable?\n   *\n   * This means the user can reposition the X Y coordinates of the workspace\n   * through input. This can be through scrollbars, scroll wheel, dragging, or\n   * through zooming with the scroll wheel or pinch (since the zoom is centered\n   * on the mouse position). This does not include zooming with the zoom\n   * controls since the X Y coordinates are decided programmatically.\n   * @return {boolean} True if the workspace is movable, false otherwise.\n   */\n  isMovable() {\n    return (this.options.moveOptions &&\n            !!this.options.moveOptions.scrollbars) ||\n        (this.options.moveOptions && this.options.moveOptions.wheel) ||\n        (this.options.moveOptions && this.options.moveOptions.drag) ||\n        (this.options.zoomOptions && this.options.zoomOptions.wheel) ||\n        (this.options.zoomOptions && this.options.zoomOptions.pinch);\n  }\n\n  /**\n   * Is this workspace movable horizontally?\n   * @return {boolean} True if the workspace is movable horizontally, false\n   *    otherwise.\n   */\n  isMovableHorizontally() {\n    const hasScrollbars = !!this.scrollbar;\n    return this.isMovable() &&\n        (!hasScrollbars ||\n         (hasScrollbars && this.scrollbar.canScrollHorizontally()));\n  }\n\n  /**\n   * Is this workspace movable vertically?\n   * @return {boolean} True if the workspace is movable vertically, false\n   *    otherwise.\n   */\n  isMovableVertically() {\n    const hasScrollbars = !!this.scrollbar;\n    return this.isMovable() &&\n        (!hasScrollbars ||\n         (hasScrollbars && this.scrollbar.canScrollVertically()));\n  }\n\n  /**\n   * Handle a mouse-wheel on SVG drawing surface.\n   * @param {!Event} e Mouse wheel event.\n   * @private\n   */\n  onMouseWheel_(e) {\n    // Don't scroll or zoom anything if drag is in progress.\n    if (Gesture.inProgress()) {\n      e.preventDefault();\n      e.stopPropagation();\n      return;\n    }\n    const canWheelZoom =\n        this.options.zoomOptions && this.options.zoomOptions.wheel;\n    const canWheelMove =\n        this.options.moveOptions && this.options.moveOptions.wheel;\n    if (!canWheelZoom && !canWheelMove) {\n      return;\n    }\n\n    const scrollDelta = browserEvents.getScrollDeltaPixels(e);\n\n    // Zoom should also be enabled by the command key on Mac devices,\n    // but not super on Unix.\n    let commandKey;\n    if (userAgent.MAC) {\n      commandKey = e.metaKey;\n    }\n\n    if (canWheelZoom && (e.ctrlKey || commandKey || !canWheelMove)) {\n      // Zoom.\n      // The vertical scroll distance that corresponds to a click of a zoom\n      // button.\n      const PIXELS_PER_ZOOM_STEP = 50;\n      const delta = -scrollDelta.y / PIXELS_PER_ZOOM_STEP;\n      const position = browserEvents.mouseToSvg(\n          e, this.getParentSvg(), this.getInverseScreenCTM());\n      this.zoom(position.x, position.y, delta);\n    } else {\n      // Scroll.\n      let x = this.scrollX - scrollDelta.x;\n      let y = this.scrollY - scrollDelta.y;\n\n      if (e.shiftKey && !scrollDelta.x) {\n        // Scroll horizontally (based on vertical scroll delta).\n        // This is needed as for some browser/system combinations which do not\n        // set deltaX.\n        x = this.scrollX - scrollDelta.y;\n        y = this.scrollY;  // Don't scroll vertically.\n      }\n      this.scroll(x, y);\n    }\n    e.preventDefault();\n  }\n\n  /**\n   * Calculate the bounding box for the blocks on the workspace.\n   * Coordinate system: workspace coordinates.\n   *\n   * @return {!Rect} Contains the position and size of the\n   *   bounding box containing the blocks on the workspace.\n   */\n  getBlocksBoundingBox() {\n    const topElements = this.getTopBoundedElements();\n    // There are no blocks, return empty rectangle.\n    if (!topElements.length) {\n      return new Rect(0, 0, 0, 0);\n    }\n\n    // Initialize boundary using the first block.\n    const boundary = topElements[0].getBoundingRectangle();\n\n    // Start at 1 since the 0th block was used for initialization.\n    for (let i = 1; i < topElements.length; i++) {\n      const topElement = topElements[i];\n      if (topElement.isInsertionMarker && topElement.isInsertionMarker()) {\n        continue;\n      }\n      const blockBoundary = topElement.getBoundingRectangle();\n      if (blockBoundary.top < boundary.top) {\n        boundary.top = blockBoundary.top;\n      }\n      if (blockBoundary.bottom > boundary.bottom) {\n        boundary.bottom = blockBoundary.bottom;\n      }\n      if (blockBoundary.left < boundary.left) {\n        boundary.left = blockBoundary.left;\n      }\n      if (blockBoundary.right > boundary.right) {\n        boundary.right = blockBoundary.right;\n      }\n    }\n    return boundary;\n  }\n\n  /**\n   * Clean up the workspace by ordering all the blocks in a column.\n   */\n  cleanUp() {\n    this.setResizesEnabled(false);\n    eventUtils.setGroup(true);\n    const topBlocks = this.getTopBlocks(true);\n    let cursorY = 0;\n    for (let i = 0, block; (block = topBlocks[i]); i++) {\n      if (!block.isMovable()) {\n        continue;\n      }\n      const xy = block.getRelativeToSurfaceXY();\n      block.moveBy(-xy.x, cursorY - xy.y);\n      block.snapToGrid();\n      cursorY = block.getRelativeToSurfaceXY().y +\n          block.getHeightWidth().height +\n          this.renderer_.getConstants().MIN_BLOCK_HEIGHT;\n    }\n    eventUtils.setGroup(false);\n    this.setResizesEnabled(true);\n  }\n\n  /**\n   * Show the context menu for the workspace.\n   * @param {!Event} e Mouse event.\n   * @package\n   */\n  showContextMenu(e) {\n    if (this.options.readOnly || this.isFlyout) {\n      return;\n    }\n    const menuOptions = ContextMenuRegistry.registry.getContextMenuOptions(\n        ContextMenuRegistry.ScopeType.WORKSPACE, {workspace: this});\n\n    // Allow the developer to add or modify menuOptions.\n    if (this.configureContextMenu) {\n      this.configureContextMenu(menuOptions, e);\n    }\n\n    ContextMenu.show(e, menuOptions, this.RTL);\n  }\n\n  /**\n   * Modify the block tree on the existing toolbox.\n   * @param {?toolbox.ToolboxDefinition} toolboxDef\n   *    DOM tree of toolbox contents, string of toolbox contents, or JSON\n   *    representing toolbox definition.\n   */\n  updateToolbox(toolboxDef) {\n    const parsedToolboxDef = toolbox.convertToolboxDefToJson(toolboxDef);\n\n    if (!parsedToolboxDef) {\n      if (this.options.languageTree) {\n        throw Error('Can\\'t nullify an existing toolbox.');\n      }\n      return;  // No change (null to null).\n    }\n    if (!this.options.languageTree) {\n      throw Error('Existing toolbox is null.  Can\\'t create new toolbox.');\n    }\n\n    if (toolbox.hasCategories(parsedToolboxDef)) {\n      if (!this.toolbox_) {\n        throw Error('Existing toolbox has no categories.  Can\\'t change mode.');\n      }\n      this.options.languageTree = parsedToolboxDef;\n      this.toolbox_.render(parsedToolboxDef);\n    } else {\n      if (!this.flyout_) {\n        throw Error('Existing toolbox has categories.  Can\\'t change mode.');\n      }\n      this.options.languageTree = parsedToolboxDef;\n      this.flyout_.show(parsedToolboxDef);\n    }\n  }\n\n  /**\n   * Mark this workspace as the currently focused main workspace.\n   */\n  markFocused() {\n    if (this.options.parentWorkspace) {\n      this.options.parentWorkspace.markFocused();\n    } else {\n      common.setMainWorkspace(this);\n      // We call e.preventDefault in many event handlers which means we\n      // need to explicitly grab focus (e.g from a textarea) because\n      // the browser will not do it for us.  How to do this is browser\n      // dependent.\n      this.setBrowserFocus();\n    }\n  }\n\n  /**\n   * Set the workspace to have focus in the browser.\n   * @private\n   */\n  setBrowserFocus() {\n    // Blur whatever was focused since explicitly grabbing focus below does not\n    // work in Edge.\n    // In IE, SVGs can't be blurred or focused. Check to make sure the current\n    // focus can be blurred before doing so.\n    // See https://github.com/google/blockly/issues/4440\n    if (document.activeElement && document.activeElement.blur) {\n      document.activeElement.blur();\n    }\n    try {\n      // Focus the workspace SVG - this is for Chrome and Firefox.\n      this.getParentSvg().focus({preventScroll: true});\n    } catch (e) {\n      // IE and Edge do not support focus on SVG elements. When that fails\n      // above, get the injectionDiv (the workspace's parent) and focus that\n      // instead.  This doesn't work in Chrome.\n      try {\n        // In IE11, use setActive (which is IE only) so the page doesn't scroll\n        // to the workspace gaining focus.\n        this.getParentSvg().parentNode.setActive();\n      } catch (e) {\n        // setActive support was discontinued in Edge so when that fails, call\n        // focus instead.\n        this.getParentSvg().parentNode.focus({preventScroll: true});\n      }\n    }\n  }\n\n  /**\n   * Zooms the workspace in or out relative to/centered on the given (x, y)\n   * coordinate.\n   * @param {number} x X coordinate of center, in pixel units relative to the\n   *     top-left corner of the parentSVG.\n   * @param {number} y Y coordinate of center, in pixel units relative to the\n   *     top-left corner of the parentSVG.\n   * @param {number} amount Amount of zooming. The formula for the new scale\n   *     is newScale = currentScale * (scaleSpeed^amount). scaleSpeed is set in\n   *     the workspace options. Negative amount values zoom out, and positive\n   *     amount values zoom in.\n   */\n  zoom(x, y, amount) {\n    // Scale factor.\n    const speed = this.options.zoomOptions.scaleSpeed;\n    let scaleChange = Math.pow(speed, amount);\n    const newScale = this.scale * scaleChange;\n    if (this.scale === newScale) {\n      return;  // No change in zoom.\n    }\n\n    // Clamp scale within valid range.\n    if (newScale > this.options.zoomOptions.maxScale) {\n      scaleChange = this.options.zoomOptions.maxScale / this.scale;\n    } else if (newScale < this.options.zoomOptions.minScale) {\n      scaleChange = this.options.zoomOptions.minScale / this.scale;\n    }\n\n    // Transform the x/y coordinates from the parentSVG's space into the\n    // canvas' space, so that they are in workspace units relative to the top\n    // left of the visible portion of the workspace.\n    let matrix = this.getCanvas().getCTM();\n    let center = this.getParentSvg().createSVGPoint();\n    center.x = x;\n    center.y = y;\n    center = center.matrixTransform(matrix.inverse());\n    x = center.x;\n    y = center.y;\n\n    // Find the new scrollX/scrollY so that the center remains in the same\n    // position (relative to the center) after we zoom.\n    // newScale and matrix.a should be identical (within a rounding error).\n    matrix = matrix.translate(x * (1 - scaleChange), y * (1 - scaleChange))\n                 .scale(scaleChange);\n    // scrollX and scrollY are in pixels.\n    // The scrollX and scrollY still need to have absoluteLeft and absoluteTop\n    // subtracted from them, but we'll leave that for setScale so that they're\n    // correctly updated for the new flyout size if we have a simple toolbox.\n    this.scrollX = matrix.e;\n    this.scrollY = matrix.f;\n    this.setScale(newScale);\n  }\n\n  /**\n   * Zooming the blocks centered in the center of view with zooming in or out.\n   * @param {number} type Type of zooming (-1 zooming out and 1 zooming in).\n   */\n  zoomCenter(type) {\n    const metrics = this.getMetrics();\n    let x;\n    let y;\n    if (this.flyout_) {\n      // If you want blocks in the center of the view (visible portion of the\n      // workspace) to stay centered when the size of the view decreases (i.e.\n      // when the size of the flyout increases) you need the center of the\n      // *blockly div* to stay in the same pixel-position.\n      // Note: This only works because of how scrollCenter positions blocks.\n      x = metrics.svgWidth ? metrics.svgWidth / 2 : 0;\n      y = metrics.svgHeight ? metrics.svgHeight / 2 : 0;\n    } else {\n      x = (metrics.viewWidth / 2) + metrics.absoluteLeft;\n      y = (metrics.viewHeight / 2) + metrics.absoluteTop;\n    }\n    this.zoom(x, y, type);\n  }\n\n  /**\n   * Zoom the blocks to fit in the workspace if possible.\n   */\n  zoomToFit() {\n    if (!this.isMovable()) {\n      console.warn(\n          'Tried to move a non-movable workspace. This could result' +\n          ' in blocks becoming inaccessible.');\n      return;\n    }\n\n    const metrics = this.getMetrics();\n    let workspaceWidth = metrics.viewWidth;\n    let workspaceHeight = metrics.viewHeight;\n    const blocksBox = this.getBlocksBoundingBox();\n    const doubleMargin = ZOOM_TO_FIT_MARGIN * 2;\n    let blocksWidth = blocksBox.right - blocksBox.left + doubleMargin;\n    let blocksHeight = blocksBox.bottom - blocksBox.top + doubleMargin;\n    if (!blocksWidth) {\n      return;  // Prevents zooming to infinity.\n    }\n    if (this.flyout_) {\n      // We have to add the flyout size to both the workspace size and the\n      // block size because the blocks we want to resize include the blocks in\n      // the flyout, and the area we want to fit them includes the portion of\n      // the workspace that is behind the flyout.\n      if (this.horizontalLayout) {\n        workspaceHeight += this.flyout_.getHeight();\n        // Convert from pixels to workspace coordinates.\n        blocksHeight += this.flyout_.getHeight() / this.scale;\n      } else {\n        workspaceWidth += this.flyout_.getWidth();\n        // Convert from pixels to workspace coordinates.\n        blocksWidth += this.flyout_.getWidth() / this.scale;\n      }\n    }\n\n    // Scale Units: (pixels / workspaceUnit)\n    const ratioX = workspaceWidth / blocksWidth;\n    const ratioY = workspaceHeight / blocksHeight;\n    eventUtils.disable();\n    try {\n      this.setScale(Math.min(ratioX, ratioY));\n      this.scrollCenter();\n    } finally {\n      eventUtils.enable();\n    }\n    this.maybeFireViewportChangeEvent();\n  }\n\n  /**\n   * Add a transition class to the block and bubble canvas, to animate any\n   * transform changes.\n   * @package\n   */\n  beginCanvasTransition() {\n    dom.addClass(\n        /** @type {!SVGElement} */ (this.svgBlockCanvas_),\n        'blocklyCanvasTransitioning');\n    dom.addClass(\n        /** @type {!SVGElement} */ (this.svgBubbleCanvas_),\n        'blocklyCanvasTransitioning');\n  }\n\n  /**\n   * Remove transition class from the block and bubble canvas.\n   * @package\n   */\n  endCanvasTransition() {\n    dom.removeClass(\n        /** @type {!SVGElement} */ (this.svgBlockCanvas_),\n        'blocklyCanvasTransitioning');\n    dom.removeClass(\n        /** @type {!SVGElement} */ (this.svgBubbleCanvas_),\n        'blocklyCanvasTransitioning');\n  }\n\n  /**\n   * Center the workspace.\n   */\n  scrollCenter() {\n    if (!this.isMovable()) {\n      console.warn(\n          'Tried to move a non-movable workspace. This could result' +\n          ' in blocks becoming inaccessible.');\n      return;\n    }\n\n    const metrics = this.getMetrics();\n    let x = (metrics.scrollWidth - metrics.viewWidth) / 2;\n    let y = (metrics.scrollHeight - metrics.viewHeight) / 2;\n\n    // Convert from workspace directions to canvas directions.\n    x = -x - metrics.scrollLeft;\n    y = -y - metrics.scrollTop;\n    this.scroll(x, y);\n  }\n\n  /**\n   * Scroll the workspace to center on the given block. If the block has other\n   * blocks stacked below it, the workspace will be centered on the stack.\n   * @param {?string} id ID of block center on.\n   * @public\n   */\n  centerOnBlock(id) {\n    if (!this.isMovable()) {\n      console.warn(\n          'Tried to move a non-movable workspace. This could result' +\n          ' in blocks becoming inaccessible.');\n      return;\n    }\n\n    const block = id ? this.getBlockById(id) : null;\n    if (!block) {\n      return;\n    }\n\n    // XY is in workspace coordinates.\n    const xy = block.getRelativeToSurfaceXY();\n    // Height/width is in workspace units.\n    const heightWidth = block.getHeightWidth();\n\n    // Find the enter of the block in workspace units.\n    const blockCenterY = xy.y + heightWidth.height / 2;\n\n    // In RTL the block's position is the top right of the block, not top left.\n    const multiplier = this.RTL ? -1 : 1;\n    const blockCenterX = xy.x + (multiplier * heightWidth.width / 2);\n\n    // Workspace scale, used to convert from workspace coordinates to pixels.\n    const scale = this.scale;\n\n    // Center of block in pixels, relative to workspace origin (center 0,0).\n    // Scrolling to here would put the block in the top-left corner of the\n    // visible workspace.\n    const pixelX = blockCenterX * scale;\n    const pixelY = blockCenterY * scale;\n\n    const metrics = this.getMetrics();\n\n    // viewHeight and viewWidth are in pixels.\n    const halfViewWidth = metrics.viewWidth / 2;\n    const halfViewHeight = metrics.viewHeight / 2;\n\n    // Put the block in the center of the visible workspace instead.\n    const scrollToCenterX = pixelX - halfViewWidth;\n    const scrollToCenterY = pixelY - halfViewHeight;\n\n    // Convert from workspace directions to canvas directions.\n    const x = -scrollToCenterX;\n    const y = -scrollToCenterY;\n\n    this.scroll(x, y);\n  }\n\n  /**\n   * Set the workspace's zoom factor.\n   * @param {number} newScale Zoom factor. Units: (pixels / workspaceUnit).\n   */\n  setScale(newScale) {\n    if (this.options.zoomOptions.maxScale &&\n        newScale > this.options.zoomOptions.maxScale) {\n      newScale = this.options.zoomOptions.maxScale;\n    } else if (\n        this.options.zoomOptions.minScale &&\n        newScale < this.options.zoomOptions.minScale) {\n      newScale = this.options.zoomOptions.minScale;\n    }\n    this.scale = newScale;\n\n    this.hideChaff(false);\n    // Get the flyout, if any, whether our own or owned by the toolbox.\n    const flyout = this.getFlyout(false);\n    if (flyout && flyout.isVisible()) {\n      flyout.reflow();\n      this.recordDragTargets();\n    }\n    if (this.grid_) {\n      this.grid_.update(this.scale);\n    }\n\n    // We call scroll instead of scrollbar.resize() so that we can center the\n    // zoom correctly without scrollbars, but scroll does not resize the\n    // scrollbars so we have to call resizeView/resizeContent as well.\n    const metrics = this.getMetrics();\n\n    this.scrollX -= metrics.absoluteLeft;\n    this.scrollY -= metrics.absoluteTop;\n    // The scroll values and the view values are additive inverses of\n    // each other, so when we subtract from one we have to add to the other.\n    metrics.viewLeft += metrics.absoluteLeft;\n    metrics.viewTop += metrics.absoluteTop;\n\n    this.scroll(this.scrollX, this.scrollY);\n    if (this.scrollbar) {\n      if (this.flyout_) {\n        this.scrollbar.resizeView(metrics);\n      } else {\n        this.scrollbar.resizeContent(metrics);\n      }\n    }\n  }\n\n  /**\n   * Get the workspace's zoom factor.  If the workspace has a parent, we call\n   * into the parent to get the workspace scale.\n   * @return {number} The workspace zoom factor. Units: (pixels /\n   *     workspaceUnit).\n   */\n  getScale() {\n    if (this.options.parentWorkspace) {\n      return this.options.parentWorkspace.getScale();\n    }\n    return this.scale;\n  }\n\n  /**\n   * Scroll the workspace to a specified offset (in pixels), keeping in the\n   * workspace bounds. See comment on workspaceSvg.scrollX for more detail on\n   * the meaning of these values.\n   * @param {number} x Target X to scroll to.\n   * @param {number} y Target Y to scroll to.\n   * @package\n   */\n  scroll(x, y) {\n    this.hideChaff(/* opt_onlyClosePopups= */ true);\n\n    // Keep scrolling within the bounds of the content.\n    const metrics = this.getMetrics();\n    // Canvas coordinates (aka scroll coordinates) have inverse directionality\n    // to workspace coordinates so we have to inverse them.\n    x = Math.min(x, -metrics.scrollLeft);\n    y = Math.min(y, -metrics.scrollTop);\n    const maxXDisplacement =\n        Math.max(0, metrics.scrollWidth - metrics.viewWidth);\n    const maxXScroll = metrics.scrollLeft + maxXDisplacement;\n    const maxYDisplacement =\n        Math.max(0, metrics.scrollHeight - metrics.viewHeight);\n    const maxYScroll = metrics.scrollTop + maxYDisplacement;\n    x = Math.max(x, -maxXScroll);\n    y = Math.max(y, -maxYScroll);\n    this.scrollX = x;\n    this.scrollY = y;\n\n    if (this.scrollbar) {\n      // The content position (displacement from the content's top-left to the\n      // origin) plus the scroll position (displacement from the view's top-left\n      // to the origin) gives us the distance from the view's top-left to the\n      // content's top-left. Then we negate this so we get the displacement from\n      // the content's top-left to the view's top-left, matching the\n      // directionality of the scrollbars.\n      this.scrollbar.set(\n          -(x + metrics.scrollLeft), -(y + metrics.scrollTop), false);\n    }\n    // We have to shift the translation so that when the canvas is at 0, 0 the\n    // workspace origin is not underneath the toolbox.\n    x += metrics.absoluteLeft;\n    y += metrics.absoluteTop;\n    this.translate(x, y);\n  }\n\n  /**\n   * Find the block on this workspace with the specified ID.\n   * @param {string} id ID of block to find.\n   * @return {?BlockSvg} The sought after block, or null if not found.\n   * @override\n   */\n  getBlockById(id) {\n    return /** @type {BlockSvg} */ (super.getBlockById(id));\n  }\n\n  /**\n   * Find all blocks in workspace.  Blocks are optionally sorted\n   * by position; top to bottom (with slight LTR or RTL bias).\n   * @param {boolean} ordered Sort the list if true.\n   * @return {!Array<!BlockSvg>} Array of blocks.\n   */\n  getAllBlocks(ordered) {\n    return /** @type {!Array<!BlockSvg>} */ (super.getAllBlocks(ordered));\n  }\n\n  /**\n   * Finds the top-level blocks and returns them.  Blocks are optionally sorted\n   * by position; top to bottom (with slight LTR or RTL bias).\n   * @param {boolean} ordered Sort the list if true.\n   * @return {!Array<!BlockSvg>} The top-level block objects.\n   * @override\n   */\n  getTopBlocks(ordered) {\n    return super.getTopBlocks(ordered);\n  }\n\n  /**\n   * Adds a block to the list of top blocks.\n   * @param {!Block} block Block to add.\n   */\n  addTopBlock(block) {\n    this.addTopBoundedElement(/** @type {!BlockSvg} */ (block));\n    super.addTopBlock(block);\n  }\n\n  /**\n   * Removes a block from the list of top blocks.\n   * @param {!Block} block Block to remove.\n   */\n  removeTopBlock(block) {\n    this.removeTopBoundedElement(/** @type {!BlockSvg} */ (block));\n    super.removeTopBlock(block);\n  }\n\n  /**\n   * Adds a comment to the list of top comments.\n   * @param {!WorkspaceComment} comment comment to add.\n   */\n  addTopComment(comment) {\n    this.addTopBoundedElement(\n        /** @type {!WorkspaceCommentSvg} */ (comment));\n    super.addTopComment(comment);\n  }\n\n  /**\n   * Removes a comment from the list of top comments.\n   * @param {!WorkspaceComment} comment comment to remove.\n   */\n  removeTopComment(comment) {\n    this.removeTopBoundedElement(\n        /** @type {!WorkspaceCommentSvg} */ (comment));\n    super.removeTopComment(comment);\n  }\n\n  /**\n   * Adds a bounded element to the list of top bounded elements.\n   * @param {!IBoundedElement} element Bounded element to add.\n   */\n  addTopBoundedElement(element) {\n    this.topBoundedElements_.push(element);\n  }\n\n  /**\n   * Removes a bounded element from the list of top bounded elements.\n   * @param {!IBoundedElement} element Bounded element to remove.\n   */\n  removeTopBoundedElement(element) {\n    arrayUtils.removeElem(this.topBoundedElements_, element);\n  }\n\n  /**\n   * Finds the top-level bounded elements and returns them.\n   * @return {!Array<!IBoundedElement>} The top-level bounded elements.\n   */\n  getTopBoundedElements() {\n    return [].concat(this.topBoundedElements_);\n  }\n\n  /**\n   * Update whether this workspace has resizes enabled.\n   * If enabled, workspace will resize when appropriate.\n   * If disabled, workspace will not resize until re-enabled.\n   * Use to avoid resizing during a batch operation, for performance.\n   * @param {boolean} enabled Whether resizes should be enabled.\n   */\n  setResizesEnabled(enabled) {\n    const reenabled = (!this.resizesEnabled_ && enabled);\n    this.resizesEnabled_ = enabled;\n    if (reenabled) {\n      // Newly enabled.  Trigger a resize.\n      this.resizeContents();\n    }\n  }\n\n  /**\n   * Dispose of all blocks in workspace, with an optimization to prevent\n   * resizes.\n   */\n  clear() {\n    this.setResizesEnabled(false);\n    super.clear();\n    this.topBoundedElements_ = [];\n    this.setResizesEnabled(true);\n  }\n\n  /**\n   * Register a callback function associated with a given key, for clicks on\n   * buttons and labels in the flyout.\n   * For instance, a button specified by the XML\n   * <button text=\"create variable\" callbackKey=\"CREATE_VARIABLE\"></button>\n   * should be matched by a call to\n   * registerButtonCallback(\"CREATE_VARIABLE\", yourCallbackFunction).\n   * @param {string} key The name to use to look up this function.\n   * @param {function(!FlyoutButton)} func The function to call when the\n   *     given button is clicked.\n   */\n  registerButtonCallback(key, func) {\n    if (typeof func !== 'function') {\n      throw TypeError('Button callbacks must be functions.');\n    }\n    this.flyoutButtonCallbacks_[key] = func;\n  }\n\n  /**\n   * Get the callback function associated with a given key, for clicks on\n   * buttons and labels in the flyout.\n   * @param {string} key The name to use to look up the function.\n   * @return {?function(!FlyoutButton)} The function corresponding to the\n   *     given key for this workspace; null if no callback is registered.\n   */\n  getButtonCallback(key) {\n    const result = this.flyoutButtonCallbacks_[key];\n    return result ? result : null;\n  }\n\n  /**\n   * Remove a callback for a click on a button in the flyout.\n   * @param {string} key The name associated with the callback function.\n   */\n  removeButtonCallback(key) {\n    this.flyoutButtonCallbacks_[key] = null;\n  }\n\n  /**\n   * Register a callback function associated with a given key, for populating\n   * custom toolbox categories in this workspace.  See the variable and\n   * procedure categories as an example.\n   * @param {string} key The name to use to look up this function.\n   * @param {function(!WorkspaceSvg): !toolbox.FlyoutDefinition} func The\n   *     function to call when the given toolbox category is opened.\n   */\n  registerToolboxCategoryCallback(key, func) {\n    if (typeof func !== 'function') {\n      throw TypeError('Toolbox category callbacks must be functions.');\n    }\n    this.toolboxCategoryCallbacks_[key] = func;\n  }\n\n  /**\n   * Get the callback function associated with a given key, for populating\n   * custom toolbox categories in this workspace.\n   * @param {string} key The name to use to look up the function.\n   * @return {?function(!WorkspaceSvg): !toolbox.FlyoutDefinition} The function\n   *     corresponding to the given key for this workspace, or null if no\n   * function is registered.\n   */\n  getToolboxCategoryCallback(key) {\n    return this.toolboxCategoryCallbacks_[key] || null;\n  }\n\n  /**\n   * Remove a callback for a click on a custom category's name in the toolbox.\n   * @param {string} key The name associated with the callback function.\n   */\n  removeToolboxCategoryCallback(key) {\n    this.toolboxCategoryCallbacks_[key] = null;\n  }\n\n  /**\n   * Look up the gesture that is tracking this touch stream on this workspace.\n   * May create a new gesture.\n   * @param {!Event} e Mouse event or touch event.\n   * @return {?TouchGesture} The gesture that is tracking this touch\n   *     stream, or null if no valid gesture exists.\n   * @package\n   */\n  getGesture(e) {\n    const isStart =\n        (e.type === 'mousedown' || e.type === 'touchstart' ||\n         e.type === 'pointerdown');\n\n    const gesture = this.currentGesture_;\n    if (gesture) {\n      if (isStart && gesture.hasStarted()) {\n        console.warn('Tried to start the same gesture twice.');\n        // That's funny.  We must have missed a mouse up.\n        // Cancel it, rather than try to retrieve all of the state we need.\n        gesture.cancel();\n        return null;\n      }\n      return gesture;\n    }\n\n    // No gesture existed on this workspace, but this looks like the start of a\n    // new gesture.\n    if (isStart) {\n      this.currentGesture_ = new TouchGesture(e, this);\n      return this.currentGesture_;\n    }\n    // No gesture existed and this event couldn't be the start of a new gesture.\n    return null;\n  }\n\n  /**\n   * Clear the reference to the current gesture.\n   * @package\n   */\n  clearGesture() {\n    this.currentGesture_ = null;\n  }\n\n  /**\n   * Cancel the current gesture, if one exists.\n   * @package\n   */\n  cancelCurrentGesture() {\n    if (this.currentGesture_) {\n      this.currentGesture_.cancel();\n    }\n  }\n\n  /**\n   * Get the audio manager for this workspace.\n   * @return {!WorkspaceAudio} The audio manager for this workspace.\n   */\n  getAudioManager() {\n    return this.audioManager_;\n  }\n\n  /**\n   * Get the grid object for this workspace, or null if there is none.\n   * @return {?Grid} The grid object for this workspace.\n   * @package\n   */\n  getGrid() {\n    return this.grid_;\n  }\n\n  /**\n   * Close tooltips, context menus, dropdown selections, etc.\n   * @param {boolean=} opt_onlyClosePopups Whether only popups should be closed.\n   */\n  hideChaff(opt_onlyClosePopups) {\n    Tooltip.hide();\n    WidgetDiv.hide();\n    dropDownDiv.hideWithoutAnimation();\n\n    const onlyClosePopups = !!opt_onlyClosePopups;\n    const autoHideables = this.getComponentManager().getComponents(\n        ComponentManager.Capability.AUTOHIDEABLE, true);\n    autoHideables.forEach(\n        (autoHideable) => autoHideable.autoHide(onlyClosePopups));\n  }\n\n  /**\n   * Sets the X/Y translations of a top level workspace.\n   * @param {!Object} xyRatio Contains an x and/or y property which is a float\n   *     between 0 and 1 specifying the degree of scrolling.\n   * @private\n   * @this {WorkspaceSvg}\n   */\n  static setTopLevelWorkspaceMetrics_(xyRatio) {\n    const metrics = this.getMetrics();\n\n    if (typeof xyRatio.x === 'number') {\n      this.scrollX =\n          -(metrics.scrollLeft +\n            (metrics.scrollWidth - metrics.viewWidth) * xyRatio.x);\n    }\n    if (typeof xyRatio.y === 'number') {\n      this.scrollY =\n          -(metrics.scrollTop +\n            (metrics.scrollHeight - metrics.viewHeight) * xyRatio.y);\n    }\n    // We have to shift the translation so that when the canvas is at 0, 0 the\n    // workspace origin is not underneath the toolbox.\n    const x = this.scrollX + metrics.absoluteLeft;\n    const y = this.scrollY + metrics.absoluteTop;\n    // We could call scroll here, but that has extra checks we don't need to do.\n    this.translate(x, y);\n  }\n}\n\n/**\n * Size the workspace when the contents change.  This also updates\n * scrollbars accordingly.\n * @param {!WorkspaceSvg} workspace The workspace to resize.\n * @alias Blockly.WorkspaceSvg.resizeSvgContents\n */\nconst resizeSvgContents = function(workspace) {\n  workspace.resizeContents();\n};\nexports.resizeSvgContents = resizeSvgContents;\n\nexports.WorkspaceSvg = WorkspaceSvg;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/workspace_svg.js?")},
"./core/xml.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/utils/xml.js\");\n__webpack_require__(\"./core/utils/size.js\");\n__webpack_require__(\"./core/input_types.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview XML reader and writer.\n */\n\n\n/**\n * XML reader and writer.\n * @namespace Blockly.Xml\n */\ngoog.module('Blockly.Xml');\n\nconst dom = goog.require('Blockly.utils.dom');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst utilsXml = goog.require('Blockly.utils.xml');\n/* eslint-disable-next-line no-unused-vars */\nconst {Block} = goog.requireType('Blockly.Block');\n/* eslint-disable-next-line no-unused-vars */\nconst {BlockSvg} = goog.requireType('Blockly.BlockSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Connection} = goog.requireType('Blockly.Connection');\n/* eslint-disable-next-line no-unused-vars */\nconst {Field} = goog.requireType('Blockly.Field');\nconst {Size} = goog.require('Blockly.utils.Size');\n/* eslint-disable-next-line no-unused-vars */\nconst {VariableModel} = goog.requireType('Blockly.VariableModel');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n/* eslint-disable-next-line no-unused-vars */\nconst {Workspace} = goog.requireType('Blockly.Workspace');\nconst {inputTypes} = goog.require('Blockly.inputTypes');\ngoog.requireType('Blockly.Comment');\ngoog.requireType('Blockly.Variables');\ngoog.requireType('Blockly.WorkspaceComment');\ngoog.requireType('Blockly.WorkspaceCommentSvg');\n\n\n/**\n * Encode a block tree as XML.\n * @param {!Workspace} workspace The workspace containing blocks.\n * @param {boolean=} opt_noId True if the encoder should skip the block IDs.\n * @return {!Element} XML DOM element.\n * @alias Blockly.Xml.workspaceToDom\n */\nconst workspaceToDom = function(workspace, opt_noId) {\n  const treeXml = utilsXml.createElement('xml');\n  const variablesElement = variablesToDom(\n      goog.module.get('Blockly.Variables').allUsedVarModels(workspace));\n  if (variablesElement.hasChildNodes()) {\n    treeXml.appendChild(variablesElement);\n  }\n  const comments = workspace.getTopComments(true);\n  for (let i = 0; i < comments.length; i++) {\n    const comment = comments[i];\n    treeXml.appendChild(comment.toXmlWithXY(opt_noId));\n  }\n  const blocks = workspace.getTopBlocks(true);\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    treeXml.appendChild(blockToDomWithXY(block, opt_noId));\n  }\n  return treeXml;\n};\nexports.workspaceToDom = workspaceToDom;\n\n/**\n * Encode a list of variables as XML.\n * @param {!Array<!VariableModel>} variableList List of all variable\n *     models.\n * @return {!Element} Tree of XML elements.\n * @alias Blockly.Xml.variablesToDom\n */\nconst variablesToDom = function(variableList) {\n  const variables = utilsXml.createElement('variables');\n  for (let i = 0; i < variableList.length; i++) {\n    const variable = variableList[i];\n    const element = utilsXml.createElement('variable');\n    element.appendChild(utilsXml.createTextNode(variable.name));\n    if (variable.type) {\n      element.setAttribute('type', variable.type);\n    }\n    element.id = variable.getId();\n    variables.appendChild(element);\n  }\n  return variables;\n};\nexports.variablesToDom = variablesToDom;\n\n/**\n * Encode a block subtree as XML with XY coordinates.\n * @param {!Block} block The root block to encode.\n * @param {boolean=} opt_noId True if the encoder should skip the block ID.\n * @return {!Element|!DocumentFragment} Tree of XML elements or an empty\n *     document fragment if the block was an insertion marker.\n * @alias Blockly.Xml.blockToDomWithXY\n */\nconst blockToDomWithXY = function(block, opt_noId) {\n  if (block.isInsertionMarker()) {  // Skip over insertion markers.\n    block = block.getChildren(false)[0];\n    if (!block) {\n      // Disappears when appended.\n      return new DocumentFragment();\n    }\n  }\n\n  let width;  // Not used in LTR.\n  if (block.workspace.RTL) {\n    width = block.workspace.getWidth();\n  }\n\n  const element = blockToDom(block, opt_noId);\n  const xy = block.getRelativeToSurfaceXY();\n  element.setAttribute(\n      'x', Math.round(block.workspace.RTL ? width - xy.x : xy.x));\n  element.setAttribute('y', Math.round(xy.y));\n  return element;\n};\nexports.blockToDomWithXY = blockToDomWithXY;\n\n/**\n * Encode a field as XML.\n * @param {!Field} field The field to encode.\n * @return {?Element} XML element, or null if the field did not need to be\n *     serialized.\n */\nconst fieldToDom = function(field) {\n  if (field.isSerializable()) {\n    const container = utilsXml.createElement('field');\n    container.setAttribute('name', field.name || '');\n    return field.toXml(container);\n  }\n  return null;\n};\n\n/**\n * Encode all of a block's fields as XML and attach them to the given tree of\n * XML elements.\n * @param {!Block} block A block with fields to be encoded.\n * @param {!Element} element The XML element to which the field DOM should be\n *     attached.\n */\nconst allFieldsToDom = function(block, element) {\n  for (let i = 0; i < block.inputList.length; i++) {\n    const input = block.inputList[i];\n    for (let j = 0; j < input.fieldRow.length; j++) {\n      const field = input.fieldRow[j];\n      const fieldDom = fieldToDom(field);\n      if (fieldDom) {\n        element.appendChild(fieldDom);\n      }\n    }\n  }\n};\n\n/**\n * Encode a block subtree as XML.\n * @param {!Block} block The root block to encode.\n * @param {boolean=} opt_noId True if the encoder should skip the block ID.\n * @return {!Element|!DocumentFragment} Tree of XML elements or an empty\n *     document fragment if the block was an insertion marker.\n * @alias Blockly.Xml.blockToDom\n */\nconst blockToDom = function(block, opt_noId) {\n  // Skip over insertion markers.\n  if (block.isInsertionMarker()) {\n    const child = block.getChildren(false)[0];\n    if (child) {\n      return blockToDom(child);\n    } else {\n      // Disappears when appended.\n      return new DocumentFragment();\n    }\n  }\n\n  const element = utilsXml.createElement(block.isShadow() ? 'shadow' : 'block');\n  element.setAttribute('type', block.type);\n  if (!opt_noId) {\n    // It's important to use setAttribute here otherwise IE11 won't serialize\n    // the block's ID when domToText is called.\n    element.setAttribute('id', block.id);\n  }\n  if (block.mutationToDom) {\n    // Custom data for an advanced block.\n    const mutation = block.mutationToDom();\n    if (mutation && (mutation.hasChildNodes() || mutation.hasAttributes())) {\n      element.appendChild(mutation);\n    }\n  }\n\n  allFieldsToDom(block, element);\n\n  const commentText = block.getCommentText();\n  if (commentText) {\n    const size = block.commentModel.size;\n    const pinned = block.commentModel.pinned;\n\n    const commentElement = utilsXml.createElement('comment');\n    commentElement.appendChild(utilsXml.createTextNode(commentText));\n    commentElement.setAttribute('pinned', pinned);\n    commentElement.setAttribute('h', size.height);\n    commentElement.setAttribute('w', size.width);\n\n    element.appendChild(commentElement);\n  }\n\n  if (block.data) {\n    const dataElement = utilsXml.createElement('data');\n    dataElement.appendChild(utilsXml.createTextNode(block.data));\n    element.appendChild(dataElement);\n  }\n\n  for (let i = 0; i < block.inputList.length; i++) {\n    const input = block.inputList[i];\n    let container;\n    let empty = true;\n    if (input.type === inputTypes.DUMMY) {\n      continue;\n    } else {\n      const childBlock = input.connection.targetBlock();\n      if (input.type === inputTypes.VALUE) {\n        container = utilsXml.createElement('value');\n      } else if (input.type === inputTypes.STATEMENT) {\n        container = utilsXml.createElement('statement');\n      }\n      const childShadow = input.connection.getShadowDom();\n      if (childShadow && (!childBlock || !childBlock.isShadow())) {\n        container.appendChild(cloneShadow(childShadow, opt_noId));\n      }\n      if (childBlock) {\n        const childElem = blockToDom(childBlock, opt_noId);\n        if (childElem.nodeType === dom.NodeType.ELEMENT_NODE) {\n          container.appendChild(childElem);\n          empty = false;\n        }\n      }\n    }\n    container.setAttribute('name', input.name);\n    if (!empty) {\n      element.appendChild(container);\n    }\n  }\n  if (block.inputsInline !== undefined &&\n      block.inputsInline !== block.inputsInlineDefault) {\n    element.setAttribute('inline', block.inputsInline);\n  }\n  if (block.isCollapsed()) {\n    element.setAttribute('collapsed', true);\n  }\n  if (!block.isEnabled()) {\n    element.setAttribute('disabled', true);\n  }\n  if (!block.isDeletable() && !block.isShadow()) {\n    element.setAttribute('deletable', false);\n  }\n  if (!block.isMovable() && !block.isShadow()) {\n    element.setAttribute('movable', false);\n  }\n  if (!block.isEditable()) {\n    element.setAttribute('editable', false);\n  }\n\n  const nextBlock = block.getNextBlock();\n  let container;\n  if (nextBlock) {\n    const nextElem = blockToDom(nextBlock, opt_noId);\n    if (nextElem.nodeType === dom.NodeType.ELEMENT_NODE) {\n      container = utilsXml.createElement('next');\n      container.appendChild(nextElem);\n      element.appendChild(container);\n    }\n  }\n  const nextShadow =\n      block.nextConnection && block.nextConnection.getShadowDom();\n  if (nextShadow && (!nextBlock || !nextBlock.isShadow())) {\n    container.appendChild(cloneShadow(nextShadow, opt_noId));\n  }\n\n  return element;\n};\nexports.blockToDom = blockToDom;\n\n/**\n * Deeply clone the shadow's DOM so that changes don't back-wash to the block.\n * @param {!Element} shadow A tree of XML elements.\n * @param {boolean=} opt_noId True if the encoder should skip the block ID.\n * @return {!Element} A tree of XML elements.\n */\nconst cloneShadow = function(shadow, opt_noId) {\n  shadow = shadow.cloneNode(true);\n  // Walk the tree looking for whitespace.  Don't prune whitespace in a tag.\n  let node = shadow;\n  let textNode;\n  while (node) {\n    if (opt_noId && node.nodeName === 'shadow') {\n      // Strip off IDs from shadow blocks.  There should never be a 'block' as\n      // a child of a 'shadow', so no need to check that.\n      node.removeAttribute('id');\n    }\n    if (node.firstChild) {\n      node = node.firstChild;\n    } else {\n      while (node && !node.nextSibling) {\n        textNode = node;\n        node = node.parentNode;\n        if (textNode.nodeType === dom.NodeType.TEXT_NODE &&\n            textNode.data.trim() === '' && node.firstChild !== textNode) {\n          // Prune whitespace after a tag.\n          dom.removeNode(textNode);\n        }\n      }\n      if (node) {\n        textNode = node;\n        node = node.nextSibling;\n        if (textNode.nodeType === dom.NodeType.TEXT_NODE &&\n            textNode.data.trim() === '') {\n          // Prune whitespace before a tag.\n          dom.removeNode(textNode);\n        }\n      }\n    }\n  }\n  return shadow;\n};\n\n/**\n * Converts a DOM structure into plain text.\n * Currently the text format is fairly ugly: all one line with no whitespace,\n * unless the DOM itself has whitespace built-in.\n * @param {!Node} dom A tree of XML nodes.\n * @return {string} Text representation.\n * @alias Blockly.Xml.domToText\n */\nconst domToText = function(dom) {\n  const text = utilsXml.domToText(dom);\n  // Unpack self-closing tags.  These tags fail when embedded in HTML.\n  // <block name=\"foo\"/> -> <block name=\"foo\"></block>\n  return text.replace(/<(\\w+)([^<]*)\\/>/g, '<$1$2></$1>');\n};\nexports.domToText = domToText;\n\n/**\n * Converts a DOM structure into properly indented text.\n * @param {!Node} dom A tree of XML elements.\n * @return {string} Text representation.\n * @alias Blockly.Xml.domToPrettyText\n */\nconst domToPrettyText = function(dom) {\n  // This function is not guaranteed to be correct for all XML.\n  // But it handles the XML that Blockly generates.\n  const blob = domToText(dom);\n  // Place every open and close tag on its own line.\n  const lines = blob.split('<');\n  // Indent every line.\n  let indent = '';\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i];\n    if (line[0] === '/') {\n      indent = indent.substring(2);\n    }\n    lines[i] = indent + '<' + line;\n    if (line[0] !== '/' && line.slice(-2) !== '/>') {\n      indent += '  ';\n    }\n  }\n  // Pull simple tags back together.\n  // E.g. <foo></foo>\n  let text = lines.join('\\n');\n  text = text.replace(/(<(\\w+)\\b[^>]*>[^\\n]*)\\n *<\\/\\2>/g, '$1</$2>');\n  // Trim leading blank line.\n  return text.replace(/^\\n/, '');\n};\nexports.domToPrettyText = domToPrettyText;\n\n/**\n * Converts an XML string into a DOM structure.\n * @param {string} text An XML string.\n * @return {!Element} A DOM object representing the singular child of the\n *     document element.\n * @throws if the text doesn't parse.\n * @alias Blockly.Xml.textToDom\n */\nconst textToDom = function(text) {\n  const doc = utilsXml.textToDomDocument(text);\n  if (!doc || !doc.documentElement ||\n      doc.getElementsByTagName('parsererror').length) {\n    throw Error('textToDom was unable to parse: ' + text);\n  }\n  return doc.documentElement;\n};\nexports.textToDom = textToDom;\n\n/**\n * Clear the given workspace then decode an XML DOM and\n * create blocks on the workspace.\n * @param {!Element} xml XML DOM.\n * @param {!WorkspaceSvg} workspace The workspace.\n * @return {!Array<string>} An array containing new block IDs.\n * @alias Blockly.Xml.clearWorkspaceAndLoadFromXml\n */\nconst clearWorkspaceAndLoadFromXml = function(xml, workspace) {\n  workspace.setResizesEnabled(false);\n  workspace.clear();\n  const blockIds = domToWorkspace(xml, workspace);\n  workspace.setResizesEnabled(true);\n  return blockIds;\n};\nexports.clearWorkspaceAndLoadFromXml = clearWorkspaceAndLoadFromXml;\n\n/**\n * Decode an XML DOM and create blocks on the workspace.\n * @param {!Element} xml XML DOM.\n * @param {!Workspace} workspace The workspace.\n * @return {!Array<string>} An array containing new block IDs.\n * @suppress {strictModuleDepCheck} Suppress module check while workspace\n *     comments are not bundled in.\n * @alias Blockly.Xml.domToWorkspace\n */\nconst domToWorkspace = function(xml, workspace) {\n  const {Workspace} = goog.module.get('Blockly.Workspace');\n  if (xml instanceof Workspace) {\n    const swap = xml;\n    // Closure Compiler complains here because the arguments are reversed.\n    /** @suppress {checkTypes} */\n    xml = workspace;\n    workspace = swap;\n    console.warn(\n        'Deprecated call to domToWorkspace, ' +\n        'swap the arguments.');\n  }\n\n  let width;  // Not used in LTR.\n  if (workspace.RTL) {\n    width = workspace.getWidth();\n  }\n  const newBlockIds = [];  // A list of block IDs added by this call.\n  dom.startTextWidthCache();\n  const existingGroup = eventUtils.getGroup();\n  if (!existingGroup) {\n    eventUtils.setGroup(true);\n  }\n\n  // Disable workspace resizes as an optimization.\n  // Assume it is rendered so we can check.\n  if (/** @type {!WorkspaceSvg} */ (workspace).setResizesEnabled) {\n    /** @type {!WorkspaceSvg} */ (workspace).setResizesEnabled(false);\n  }\n  let variablesFirst = true;\n  try {\n    for (let i = 0, xmlChild; (xmlChild = xml.childNodes[i]); i++) {\n      const name = xmlChild.nodeName.toLowerCase();\n      const xmlChildElement = /** @type {!Element} */ (xmlChild);\n      if (name === 'block' ||\n          (name === 'shadow' && !eventUtils.getRecordUndo())) {\n        // Allow top-level shadow blocks if recordUndo is disabled since\n        // that means an undo is in progress.  Such a block is expected\n        // to be moved to a nested destination in the next operation.\n        const block = domToBlock(xmlChildElement, workspace);\n        newBlockIds.push(block.id);\n        const blockX = xmlChildElement.hasAttribute('x') ?\n            parseInt(xmlChildElement.getAttribute('x'), 10) :\n            10;\n        const blockY = xmlChildElement.hasAttribute('y') ?\n            parseInt(xmlChildElement.getAttribute('y'), 10) :\n            10;\n        if (!isNaN(blockX) && !isNaN(blockY)) {\n          block.moveBy(workspace.RTL ? width - blockX : blockX, blockY);\n        }\n        variablesFirst = false;\n      } else if (name === 'shadow') {\n        throw TypeError('Shadow block cannot be a top-level block.');\n      } else if (name === 'comment') {\n        if (workspace.rendered) {\n          const {WorkspaceCommentSvg} =\n              goog.module.get('Blockly.WorkspaceCommentSvg');\n          if (!WorkspaceCommentSvg) {\n            console.warn(\n                'Missing require for Blockly.WorkspaceCommentSvg, ' +\n                'ignoring workspace comment.');\n          } else {\n            WorkspaceCommentSvg.fromXmlRendered(\n                xmlChildElement,\n                /** @type {!WorkspaceSvg} */ (workspace), width);\n          }\n        } else {\n          const {WorkspaceComment} =\n              goog.module.get('Blockly.WorkspaceComment');\n          if (!WorkspaceComment) {\n            console.warn(\n                'Missing require for Blockly.WorkspaceComment, ' +\n                'ignoring workspace comment.');\n          } else {\n            WorkspaceComment.fromXml(xmlChildElement, workspace);\n          }\n        }\n      } else if (name === 'variables') {\n        if (variablesFirst) {\n          domToVariables(xmlChildElement, workspace);\n        } else {\n          throw Error(\n              '\\'variables\\' tag must exist once before block and ' +\n              'shadow tag elements in the workspace XML, but it was found in ' +\n              'another location.');\n        }\n        variablesFirst = false;\n      }\n    }\n  } finally {\n    if (!existingGroup) {\n      eventUtils.setGroup(false);\n    }\n    dom.stopTextWidthCache();\n  }\n  // Re-enable workspace resizing.\n  if (/** @type {!WorkspaceSvg} */ (workspace).setResizesEnabled) {\n    /** @type {!WorkspaceSvg} */ (workspace).setResizesEnabled(true);\n  }\n  eventUtils.fire(new (eventUtils.get(eventUtils.FINISHED_LOADING))(workspace));\n  return newBlockIds;\n};\nexports.domToWorkspace = domToWorkspace;\n\n/**\n * Decode an XML DOM and create blocks on the workspace. Position the new\n * blocks immediately below prior blocks, aligned by their starting edge.\n * @param {!Element} xml The XML DOM.\n * @param {!Workspace} workspace The workspace to add to.\n * @return {!Array<string>} An array containing new block IDs.\n * @alias Blockly.Xml.appendDomToWorkspace\n */\nconst appendDomToWorkspace = function(xml, workspace) {\n  // First check if we have a WorkspaceSvg, otherwise the blocks have no shape\n  // and the position does not matter.\n  // Assume it is rendered so we can check.\n  if (!/** @type {!WorkspaceSvg} */ (workspace).getBlocksBoundingBox) {\n    return domToWorkspace(xml, workspace);\n  }\n\n  const bbox = /** @type {!WorkspaceSvg} */ (workspace).getBlocksBoundingBox();\n  // Load the new blocks into the workspace and get the IDs of the new blocks.\n  const newBlockIds = domToWorkspace(xml, workspace);\n  if (bbox && bbox.top !== bbox.bottom) {  // check if any previous block\n    let offsetY = 0;  // offset to add to y of the new block\n    let offsetX = 0;\n    const farY = bbox.bottom;                             // bottom position\n    const topX = workspace.RTL ? bbox.right : bbox.left;  // x of bounding box\n    // Check position of the new blocks.\n    let newLeftX = Infinity;    // x of top left corner\n    let newRightX = -Infinity;  // x of top right corner\n    let newY = Infinity;        // y of top corner\n    const ySeparation = 10;\n    for (let i = 0; i < newBlockIds.length; i++) {\n      const blockXY =\n          workspace.getBlockById(newBlockIds[i]).getRelativeToSurfaceXY();\n      if (blockXY.y < newY) {\n        newY = blockXY.y;\n      }\n      if (blockXY.x < newLeftX) {  // if we left align also on x\n        newLeftX = blockXY.x;\n      }\n      if (blockXY.x > newRightX) {  // if we right align also on x\n        newRightX = blockXY.x;\n      }\n    }\n    offsetY = farY - newY + ySeparation;\n    offsetX = workspace.RTL ? topX - newRightX : topX - newLeftX;\n    for (let i = 0; i < newBlockIds.length; i++) {\n      const block = workspace.getBlockById(newBlockIds[i]);\n      block.moveBy(offsetX, offsetY);\n    }\n  }\n  return newBlockIds;\n};\nexports.appendDomToWorkspace = appendDomToWorkspace;\n\n/**\n * Decode an XML block tag and create a block (and possibly sub blocks) on the\n * workspace.\n * @param {!Element} xmlBlock XML block element.\n * @param {!Workspace} workspace The workspace.\n * @return {!Block} The root block created.\n * @alias Blockly.Xml.domToBlock\n */\nconst domToBlock = function(xmlBlock, workspace) {\n  const {Workspace} = goog.module.get('Blockly.Workspace');\n  if (xmlBlock instanceof Workspace) {\n    const swap = xmlBlock;\n    // Closure Compiler complains here because the arguments are reversed.\n    /** @suppress {checkTypes} */\n    xmlBlock = /** @type {!Element} */ (workspace);\n    workspace = swap;\n    console.warn(\n        'Deprecated call to domToBlock, ' +\n        'swap the arguments.');\n  }\n  // Create top-level block.\n  eventUtils.disable();\n  const variablesBeforeCreation = workspace.getAllVariables();\n  let topBlock;\n  try {\n    topBlock = domToBlockHeadless(xmlBlock, workspace);\n    // Generate list of all blocks.\n    if (workspace.rendered) {\n      const topBlockSvg = /** @type {!BlockSvg} */ (topBlock);\n      const blocks = topBlock.getDescendants(false);\n      topBlockSvg.setConnectionTracking(false);\n      // Render each block.\n      for (let i = blocks.length - 1; i >= 0; i--) {\n        blocks[i].initSvg();\n      }\n      for (let i = blocks.length - 1; i >= 0; i--) {\n        blocks[i].render(false);\n      }\n      // Populating the connection database may be deferred until after the\n      // blocks have rendered.\n      setTimeout(function() {\n        if (!topBlockSvg.disposed) {\n          topBlockSvg.setConnectionTracking(true);\n        }\n      }, 1);\n      topBlockSvg.updateDisabled();\n      // Allow the scrollbars to resize and move based on the new contents.\n      // TODO(@picklesrus): #387. Remove when domToBlock avoids resizing.\n      /** @type {!WorkspaceSvg} */ (workspace).resizeContents();\n    } else {\n      const blocks = topBlock.getDescendants(false);\n      for (let i = blocks.length - 1; i >= 0; i--) {\n        blocks[i].initModel();\n      }\n    }\n  } finally {\n    eventUtils.enable();\n  }\n  if (eventUtils.isEnabled()) {\n    const newVariables =\n        goog.module.get('Blockly.Variables')\n            .getAddedVariables(workspace, variablesBeforeCreation);\n    // Fire a VarCreate event for each (if any) new variable created.\n    for (let i = 0; i < newVariables.length; i++) {\n      const thisVariable = newVariables[i];\n      eventUtils.fire(\n          new (eventUtils.get(eventUtils.VAR_CREATE))(thisVariable));\n    }\n    // Block events come after var events, in case they refer to newly created\n    // variables.\n    eventUtils.fire(new (eventUtils.get(eventUtils.CREATE))(topBlock));\n  }\n  return topBlock;\n};\nexports.domToBlock = domToBlock;\n\n/**\n * Decode an XML list of variables and add the variables to the workspace.\n * @param {!Element} xmlVariables List of XML variable elements.\n * @param {!Workspace} workspace The workspace to which the variable\n *     should be added.\n * @alias Blockly.Xml.domToVariables\n */\nconst domToVariables = function(xmlVariables, workspace) {\n  for (let i = 0; i < xmlVariables.childNodes.length; i++) {\n    const xmlChild = xmlVariables.childNodes[i];\n    if (xmlChild.nodeType !== dom.NodeType.ELEMENT_NODE) {\n      continue;  // Skip text nodes.\n    }\n    const type = xmlChild.getAttribute('type');\n    const id = xmlChild.getAttribute('id');\n    const name = xmlChild.textContent;\n\n    workspace.createVariable(name, type, id);\n  }\n};\nexports.domToVariables = domToVariables;\n\n/**\n * A mapping of nodeName to node for child nodes of xmlBlock.\n * @typedef {{\n *      mutation: !Array<!Element>,\n *      comment: !Array<!Element>,\n *      data: !Array<!Element>,\n *      field: !Array<!Element>,\n *      input: !Array<!Element>,\n *      next: !Array<!Element>\n *    }}\n */\nlet childNodeTagMap;  // eslint-disable-line no-unused-vars\n\n/**\n * Creates a mapping of childNodes for each supported XML tag for the provided\n * xmlBlock. Logs a warning for any encountered unsupported tags.\n * @param {!Element} xmlBlock XML block element.\n * @return {!childNodeTagMap} The childNode map from nodeName to\n *    node.\n */\nconst mapSupportedXmlTags = function(xmlBlock) {\n  const childNodeMap =\n      {mutation: [], comment: [], data: [], field: [], input: [], next: []};\n  for (let i = 0; i < xmlBlock.childNodes.length; i++) {\n    const xmlChild = xmlBlock.childNodes[i];\n    if (xmlChild.nodeType === dom.NodeType.TEXT_NODE) {\n      // Ignore any text at the <block> level.  It's all whitespace anyway.\n      continue;\n    }\n    switch (xmlChild.nodeName.toLowerCase()) {\n      case 'mutation':\n        childNodeMap.mutation.push(xmlChild);\n        break;\n      case 'comment':\n        if (!goog.module.get('Blockly.Comment')) {\n          console.warn(\n              'Missing require for Comment, ' +\n              'ignoring block comment.');\n          break;\n        }\n        childNodeMap.comment.push(xmlChild);\n        break;\n      case 'data':\n        childNodeMap.data.push(xmlChild);\n        break;\n      case 'title':\n        // Titles were renamed to field in December 2013.\n        // Fall through.\n      case 'field':\n        childNodeMap.field.push(xmlChild);\n        break;\n      case 'value':\n      case 'statement':\n        childNodeMap.input.push(xmlChild);\n        break;\n      case 'next':\n        childNodeMap.next.push(xmlChild);\n        break;\n      default:\n        // Unknown tag; ignore.  Same principle as HTML parsers.\n        console.warn('Ignoring unknown tag: ' + xmlChild.nodeName);\n    }\n  }\n  return childNodeMap;\n};\n\n/**\n * Applies mutation tag child nodes to the given block.\n * @param {!Array<!Element>} xmlChildren Child nodes.\n * @param {!Block} block The block to apply the child nodes on.\n * @return {boolean} True if mutation may have added some elements that need\n *    initialization (requiring initSvg call).\n */\nconst applyMutationTagNodes = function(xmlChildren, block) {\n  let shouldCallInitSvg = false;\n  for (let i = 0; i < xmlChildren.length; i++) {\n    const xmlChild = xmlChildren[i];\n    // Custom data for an advanced block.\n    if (block.domToMutation) {\n      block.domToMutation(xmlChild);\n      if (block.initSvg) {\n        // Mutation may have added some elements that need initializing.\n        shouldCallInitSvg = true;\n      }\n    }\n  }\n  return shouldCallInitSvg;\n};\n\n/**\n * Applies comment tag child nodes to the given block.\n * @param {!Array<!Element>} xmlChildren Child nodes.\n * @param {!Block} block The block to apply the child nodes on.\n */\nconst applyCommentTagNodes = function(xmlChildren, block) {\n  for (let i = 0; i < xmlChildren.length; i++) {\n    const xmlChild = xmlChildren[i];\n    const text = xmlChild.textContent;\n    const pinned = xmlChild.getAttribute('pinned') === 'true';\n    const width = parseInt(xmlChild.getAttribute('w'), 10);\n    const height = parseInt(xmlChild.getAttribute('h'), 10);\n\n    block.setCommentText(text);\n    block.commentModel.pinned = pinned;\n    if (!isNaN(width) && !isNaN(height)) {\n      block.commentModel.size = new Size(width, height);\n    }\n\n    if (pinned && block.getCommentIcon && !block.isInFlyout) {\n      const blockSvg = /** @type {BlockSvg} */ (block);\n      setTimeout(function() {\n        blockSvg.getCommentIcon().setVisible(true);\n      }, 1);\n    }\n  }\n};\n\n/**\n * Applies data tag child nodes to the given block.\n * @param {!Array<!Element>} xmlChildren Child nodes.\n * @param {!Block} block The block to apply the child nodes on.\n */\nconst applyDataTagNodes = function(xmlChildren, block) {\n  for (let i = 0; i < xmlChildren.length; i++) {\n    const xmlChild = xmlChildren[i];\n    block.data = xmlChild.textContent;\n  }\n};\n\n/**\n * Applies field tag child nodes to the given block.\n * @param {!Array<!Element>} xmlChildren Child nodes.\n * @param {!Block} block The block to apply the child nodes on.\n */\nconst applyFieldTagNodes = function(xmlChildren, block) {\n  for (let i = 0; i < xmlChildren.length; i++) {\n    const xmlChild = xmlChildren[i];\n    const nodeName = xmlChild.getAttribute('name');\n    domToField(block, nodeName, xmlChild);\n  }\n};\n\n/**\n * Finds any enclosed blocks or shadows within this XML node.\n * @param {!Element} xmlNode The XML node to extract child block info from.\n * @return {{childBlockElement: ?Element, childShadowElement: ?Element}} Any\n *    found child block.\n */\nconst findChildBlocks = function(xmlNode) {\n  const childBlockInfo = {childBlockElement: null, childShadowElement: null};\n  for (let i = 0; i < xmlNode.childNodes.length; i++) {\n    const xmlChild = xmlNode.childNodes[i];\n    if (xmlChild.nodeType === dom.NodeType.ELEMENT_NODE) {\n      if (xmlChild.nodeName.toLowerCase() === 'block') {\n        childBlockInfo.childBlockElement = /** @type {!Element} */ (xmlChild);\n      } else if (xmlChild.nodeName.toLowerCase() === 'shadow') {\n        childBlockInfo.childShadowElement = /** @type {!Element} */ (xmlChild);\n      }\n    }\n  }\n  return childBlockInfo;\n};\n\n/**\n * Applies input child nodes (value or statement) to the given block.\n * @param {!Array<!Element>} xmlChildren Child nodes.\n * @param {!Workspace} workspace The workspace containing the given\n *    block.\n * @param {!Block} block The block to apply the child nodes on.\n * @param {string} prototypeName The prototype name of the block.\n */\nconst applyInputTagNodes = function(\n    xmlChildren, workspace, block, prototypeName) {\n  for (let i = 0; i < xmlChildren.length; i++) {\n    const xmlChild = xmlChildren[i];\n    const nodeName = xmlChild.getAttribute('name');\n    const input = block.getInput(nodeName);\n    if (!input) {\n      console.warn(\n          'Ignoring non-existent input ' + nodeName + ' in block ' +\n          prototypeName);\n      break;\n    }\n    const childBlockInfo = findChildBlocks(xmlChild);\n    if (childBlockInfo.childBlockElement) {\n      if (!input.connection) {\n        throw TypeError('Input connection does not exist.');\n      }\n      domToBlockHeadless(\n          childBlockInfo.childBlockElement, workspace, input.connection, false);\n    }\n    // Set shadow after so we don't create a shadow we delete immediately.\n    if (childBlockInfo.childShadowElement) {\n      input.connection.setShadowDom(childBlockInfo.childShadowElement);\n    }\n  }\n};\n\n/**\n * Applies next child nodes to the given block.\n * @param {!Array<!Element>} xmlChildren Child nodes.\n * @param {!Workspace} workspace The workspace containing the given\n *    block.\n * @param {!Block} block The block to apply the child nodes on.\n */\nconst applyNextTagNodes = function(xmlChildren, workspace, block) {\n  for (let i = 0; i < xmlChildren.length; i++) {\n    const xmlChild = xmlChildren[i];\n    const childBlockInfo = findChildBlocks(xmlChild);\n    if (childBlockInfo.childBlockElement) {\n      if (!block.nextConnection) {\n        throw TypeError('Next statement does not exist.');\n      }\n      // If there is more than one XML 'next' tag.\n      if (block.nextConnection.isConnected()) {\n        throw TypeError('Next statement is already connected.');\n      }\n      // Create child block.\n      domToBlockHeadless(\n          childBlockInfo.childBlockElement, workspace, block.nextConnection,\n          true);\n    }\n    // Set shadow after so we don't create a shadow we delete immediately.\n    if (childBlockInfo.childShadowElement && block.nextConnection) {\n      block.nextConnection.setShadowDom(childBlockInfo.childShadowElement);\n    }\n  }\n};\n\n\n/**\n * Decode an XML block tag and create a block (and possibly sub blocks) on the\n * workspace.\n * @param {!Element} xmlBlock XML block element.\n * @param {!Workspace} workspace The workspace.\n * @param {!Connection=} parentConnection The parent connection to\n *    to connect this block to after instantiating.\n * @param {boolean=} connectedToParentNext Whether the provided parent\n *     connection\n *    is a next connection, rather than output or statement.\n * @return {!Block} The root block created.\n */\nconst domToBlockHeadless = function(\n    xmlBlock, workspace, parentConnection, connectedToParentNext) {\n  let block = null;\n  const prototypeName = xmlBlock.getAttribute('type');\n  if (!prototypeName) {\n    throw TypeError('Block type unspecified: ' + xmlBlock.outerHTML);\n  }\n  const id = xmlBlock.getAttribute('id');\n  block = workspace.newBlock(prototypeName, id);\n\n  // Preprocess childNodes so tags can be processed in a consistent order.\n  const xmlChildNameMap = mapSupportedXmlTags(xmlBlock);\n\n  const shouldCallInitSvg =\n      applyMutationTagNodes(xmlChildNameMap.mutation, block);\n  applyCommentTagNodes(xmlChildNameMap.comment, block);\n  applyDataTagNodes(xmlChildNameMap.data, block);\n\n  // Connect parent after processing mutation and before setting fields.\n  if (parentConnection) {\n    if (connectedToParentNext) {\n      if (block.previousConnection) {\n        parentConnection.connect(block.previousConnection);\n      } else {\n        throw TypeError('Next block does not have previous statement.');\n      }\n    } else {\n      if (block.outputConnection) {\n        parentConnection.connect(block.outputConnection);\n      } else if (block.previousConnection) {\n        parentConnection.connect(block.previousConnection);\n      } else {\n        throw TypeError(\n            'Child block does not have output or previous statement.');\n      }\n    }\n  }\n\n  applyFieldTagNodes(xmlChildNameMap.field, block);\n  applyInputTagNodes(xmlChildNameMap.input, workspace, block, prototypeName);\n  applyNextTagNodes(xmlChildNameMap.next, workspace, block);\n\n  if (shouldCallInitSvg) {\n    // This shouldn't even be called here\n    // (ref: https://github.com/google/blockly/pull/4296#issuecomment-884226021\n    // But the XML serializer/deserializer is iceboxed so I'm not going to fix\n    // it.\n    (/** @type {!BlockSvg} */ (block)).initSvg();\n  }\n\n  const inline = xmlBlock.getAttribute('inline');\n  if (inline) {\n    block.setInputsInline(inline === 'true');\n  }\n  const disabled = xmlBlock.getAttribute('disabled');\n  if (disabled) {\n    block.setEnabled(disabled !== 'true' && disabled !== 'disabled');\n  }\n  const deletable = xmlBlock.getAttribute('deletable');\n  if (deletable) {\n    block.setDeletable(deletable === 'true');\n  }\n  const movable = xmlBlock.getAttribute('movable');\n  if (movable) {\n    block.setMovable(movable === 'true');\n  }\n  const editable = xmlBlock.getAttribute('editable');\n  if (editable) {\n    block.setEditable(editable === 'true');\n  }\n  const collapsed = xmlBlock.getAttribute('collapsed');\n  if (collapsed) {\n    block.setCollapsed(collapsed === 'true');\n  }\n  if (xmlBlock.nodeName.toLowerCase() === 'shadow') {\n    // Ensure all children are also shadows.\n    const children = block.getChildren(false);\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (!child.isShadow()) {\n        throw TypeError('Shadow block not allowed non-shadow child.');\n      }\n    }\n    // Ensure this block doesn't have any variable inputs.\n    if (block.getVarModels().length) {\n      throw TypeError('Shadow blocks cannot have variable references.');\n    }\n    block.setShadow(true);\n  }\n  return block;\n};\n\n/**\n * Decode an XML field tag and set the value of that field on the given block.\n * @param {!Block} block The block that is currently being deserialized.\n * @param {string} fieldName The name of the field on the block.\n * @param {!Element} xml The field tag to decode.\n */\nconst domToField = function(block, fieldName, xml) {\n  const field = block.getField(fieldName);\n  if (!field) {\n    console.warn(\n        'Ignoring non-existent field ' + fieldName + ' in block ' + block.type);\n    return;\n  }\n  field.fromXml(xml);\n};\n\n/**\n * Remove any 'next' block (statements in a stack).\n * @param {!Element|!DocumentFragment} xmlBlock XML block element or an empty\n *     DocumentFragment if the block was an insertion marker.\n * @alias Blockly.Xml.deleteNext\n */\nconst deleteNext = function(xmlBlock) {\n  for (let i = 0; i < xmlBlock.childNodes.length; i++) {\n    const child = xmlBlock.childNodes[i];\n    if (child.nodeName.toLowerCase() === 'next') {\n      xmlBlock.removeChild(child);\n      break;\n    }\n  }\n};\nexports.deleteNext = deleteNext;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/xml.js?")},
"./core/zoom_controls.js":function(c,a,b){eval("__webpack_require__(\"./closure/goog/base.js\");\n__webpack_require__(\"./core/css.js\");\n__webpack_require__(\"./core/touch.js\");\n__webpack_require__(\"./core/browser_events.js\");\n__webpack_require__(\"./core/utils/dom.js\");\n__webpack_require__(\"./core/events/utils.js\");\n__webpack_require__(\"./core/sprites.js\");\n__webpack_require__(\"./core/positionable_helpers.js\");\n__webpack_require__(\"./core/component_manager.js\");\n__webpack_require__(\"./core/interfaces/i_positionable.js\");\n__webpack_require__(\"./core/utils/rect.js\");\n__webpack_require__(\"./core/utils/size.js\");\n__webpack_require__(\"./core/utils/svg.js\");\n__webpack_require__(\"./core/events/events_click.js\");\nvar googPreviousLoaderState__ = goog.moduleLoaderState_;\ngoog.moduleLoaderState_ = {moduleName: '', declareLegacyNamespace: false};\ngoog.loadModule(function() {\n/**\n * @license\n * Copyright 2015 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Object representing a zoom icons.\n */\n\n\n/**\n * Object representing a zoom icons.\n * @class\n */\ngoog.module('Blockly.ZoomControls');\n\nconst Css = goog.require('Blockly.Css');\nconst Touch = goog.require('Blockly.Touch');\nconst browserEvents = goog.require('Blockly.browserEvents');\nconst dom = goog.require('Blockly.utils.dom');\nconst eventUtils = goog.require('Blockly.Events.utils');\nconst {SPRITE} = goog.require('Blockly.sprite');\nconst uiPosition = goog.require('Blockly.uiPosition');\nconst {ComponentManager} = goog.require('Blockly.ComponentManager');\n/* eslint-disable-next-line no-unused-vars */\nconst {IPositionable} = goog.require('Blockly.IPositionable');\n/* eslint-disable-next-line no-unused-vars */\nconst {MetricsManager} = goog.requireType('Blockly.MetricsManager');\nconst {Rect} = goog.require('Blockly.utils.Rect');\nconst {Size} = goog.require('Blockly.utils.Size');\nconst {Svg} = goog.require('Blockly.utils.Svg');\n/* eslint-disable-next-line no-unused-vars */\nconst {WorkspaceSvg} = goog.requireType('Blockly.WorkspaceSvg');\n/** @suppress {extraRequire} */\ngoog.require('Blockly.Events.Click');\n\n\n/**\n * Class for a zoom controls.\n * @implements {IPositionable}\n * @alias Blockly.ZoomControls\n */\nclass ZoomControls {\n  /**\n   * @param {!WorkspaceSvg} workspace The workspace to sit in.\n   */\n  constructor(workspace) {\n    /**\n     * @type {!WorkspaceSvg}\n     * @private\n     */\n    this.workspace_ = workspace;\n\n    /**\n     * The unique id for this component that is used to register with the\n     * ComponentManager.\n     * @type {string}\n     */\n    this.id = 'zoomControls';\n\n    /**\n     * A handle to use to unbind the mouse down event handler for zoom reset\n     *    button. Opaque data returned from browserEvents.conditionalBind.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onZoomResetWrapper_ = null;\n\n    /**\n     * A handle to use to unbind the mouse down event handler for zoom in\n     * button. Opaque data returned from browserEvents.conditionalBind.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onZoomInWrapper_ = null;\n\n    /**\n     * A handle to use to unbind the mouse down event handler for zoom out\n     * button. Opaque data returned from browserEvents.conditionalBind.\n     * @type {?browserEvents.Data}\n     * @private\n     */\n    this.onZoomOutWrapper_ = null;\n\n    /**\n     * The zoom in svg <g> element.\n     * @type {SVGGElement}\n     * @private\n     */\n    this.zoomInGroup_ = null;\n\n    /**\n     * The zoom out svg <g> element.\n     * @type {SVGGElement}\n     * @private\n     */\n    this.zoomOutGroup_ = null;\n\n    /**\n     * The zoom reset svg <g> element.\n     * @type {SVGGElement}\n     * @private\n     */\n    this.zoomResetGroup_ = null;\n\n    /**\n     * Width of the zoom controls.\n     * @type {number}\n     * @const\n     * @private\n     */\n    this.WIDTH_ = 32;\n\n    /**\n     * Height of each zoom control.\n     * @type {number}\n     * @const\n     * @private\n     */\n    this.HEIGHT_ = 32;\n\n    /**\n     * Small spacing used between the zoom in and out control, in pixels.\n     * @type {number}\n     * @const\n     * @private\n     */\n    this.SMALL_SPACING_ = 2;\n\n    /**\n     * Large spacing used between the zoom in and reset control, in pixels.\n     * @type {number}\n     * @const\n     * @private\n     */\n    this.LARGE_SPACING_ = 11;\n\n    /**\n     * Distance between zoom controls and bottom or top edge of workspace.\n     * @type {number}\n     * @const\n     * @private\n     */\n    this.MARGIN_VERTICAL_ = 20;\n\n    /**\n     * Distance between zoom controls and right or left edge of workspace.\n     * @type {number}\n     * @private\n     */\n    this.MARGIN_HORIZONTAL_ = 20;\n\n    /**\n     * The SVG group containing the zoom controls.\n     * @type {SVGElement}\n     * @private\n     */\n    this.svgGroup_ = null;\n\n    /**\n     * Left coordinate of the zoom controls.\n     * @type {number}\n     * @private\n     */\n    this.left_ = 0;\n\n    /**\n     * Top coordinate of the zoom controls.\n     * @type {number}\n     * @private\n     */\n    this.top_ = 0;\n\n    /**\n     * Whether this has been initialized.\n     * @type {boolean}\n     * @private\n     */\n    this.initialized_ = false;\n  }\n  /**\n   * Create the zoom controls.\n   * @return {!SVGElement} The zoom controls SVG group.\n   */\n  createDom() {\n    this.svgGroup_ = dom.createSvgElement(Svg.G, {}, null);\n\n    // Each filter/pattern needs a unique ID for the case of multiple Blockly\n    // instances on a page.  Browser behaviour becomes undefined otherwise.\n    // https://neil.fraser.name/news/2015/11/01/\n    const rnd = String(Math.random()).substring(2);\n    this.createZoomOutSvg_(rnd);\n    this.createZoomInSvg_(rnd);\n    if (this.workspace_.isMovable()) {\n      // If we zoom to the center and the workspace isn't movable we could\n      // loose blocks at the edges of the workspace.\n      this.createZoomResetSvg_(rnd);\n    }\n    return this.svgGroup_;\n  }\n  /**\n   * Initializes the zoom controls.\n   */\n  init() {\n    this.workspace_.getComponentManager().addComponent({\n      component: this,\n      weight: 2,\n      capabilities: [ComponentManager.Capability.POSITIONABLE],\n    });\n    this.initialized_ = true;\n  }\n  /**\n   * Disposes of this zoom controls.\n   * Unlink from all DOM elements to prevent memory leaks.\n   */\n  dispose() {\n    this.workspace_.getComponentManager().removeComponent('zoomControls');\n    if (this.svgGroup_) {\n      dom.removeNode(this.svgGroup_);\n    }\n    if (this.onZoomResetWrapper_) {\n      browserEvents.unbind(this.onZoomResetWrapper_);\n    }\n    if (this.onZoomInWrapper_) {\n      browserEvents.unbind(this.onZoomInWrapper_);\n    }\n    if (this.onZoomOutWrapper_) {\n      browserEvents.unbind(this.onZoomOutWrapper_);\n    }\n  }\n  /**\n   * Returns the bounding rectangle of the UI element in pixel units relative to\n   * the Blockly injection div.\n   * @return {?Rect} The UI elements's bounding box. Null if\n   *   bounding box should be ignored by other UI elements.\n   */\n  getBoundingRectangle() {\n    let height = this.SMALL_SPACING_ + 2 * this.HEIGHT_;\n    if (this.zoomResetGroup_) {\n      height += this.LARGE_SPACING_ + this.HEIGHT_;\n    }\n    const bottom = this.top_ + height;\n    const right = this.left_ + this.WIDTH_;\n    return new Rect(this.top_, bottom, this.left_, right);\n  }\n  /**\n   * Positions the zoom controls.\n   * It is positioned in the opposite corner to the corner the\n   * categories/toolbox starts at.\n   * @param {!MetricsManager.UiMetrics} metrics The workspace metrics.\n   * @param {!Array<!Rect>} savedPositions List of rectangles that\n   *     are already on the workspace.\n   */\n  position(metrics, savedPositions) {\n    // Not yet initialized.\n    if (!this.initialized_) {\n      return;\n    }\n\n    const cornerPosition =\n        uiPosition.getCornerOppositeToolbox(this.workspace_, metrics);\n    let height = this.SMALL_SPACING_ + 2 * this.HEIGHT_;\n    if (this.zoomResetGroup_) {\n      height += this.LARGE_SPACING_ + this.HEIGHT_;\n    }\n    const startRect = uiPosition.getStartPositionRect(\n        cornerPosition, new Size(this.WIDTH_, height), this.MARGIN_HORIZONTAL_,\n        this.MARGIN_VERTICAL_, metrics, this.workspace_);\n\n    const verticalPosition = cornerPosition.vertical;\n    const bumpDirection = verticalPosition === uiPosition.verticalPosition.TOP ?\n        uiPosition.bumpDirection.DOWN :\n        uiPosition.bumpDirection.UP;\n    const positionRect = uiPosition.bumpPositionRect(\n        startRect, this.MARGIN_VERTICAL_, bumpDirection, savedPositions);\n\n    if (verticalPosition === uiPosition.verticalPosition.TOP) {\n      const zoomInTranslateY = this.SMALL_SPACING_ + this.HEIGHT_;\n      this.zoomInGroup_.setAttribute(\n          'transform', 'translate(0, ' + zoomInTranslateY + ')');\n      if (this.zoomResetGroup_) {\n        const zoomResetTranslateY =\n            zoomInTranslateY + this.LARGE_SPACING_ + this.HEIGHT_;\n        this.zoomResetGroup_.setAttribute(\n            'transform', 'translate(0, ' + zoomResetTranslateY + ')');\n      }\n    } else {\n      const zoomInTranslateY =\n          this.zoomResetGroup_ ? this.LARGE_SPACING_ + this.HEIGHT_ : 0;\n      this.zoomInGroup_.setAttribute(\n          'transform', 'translate(0, ' + zoomInTranslateY + ')');\n      const zoomOutTranslateY =\n          zoomInTranslateY + this.SMALL_SPACING_ + this.HEIGHT_;\n      this.zoomOutGroup_.setAttribute(\n          'transform', 'translate(0, ' + zoomOutTranslateY + ')');\n    }\n\n    this.top_ = positionRect.top;\n    this.left_ = positionRect.left;\n    this.svgGroup_.setAttribute(\n        'transform', 'translate(' + this.left_ + ',' + this.top_ + ')');\n  }\n  /**\n   * Create the zoom in icon and its event handler.\n   * @param {string} rnd The random string to use as a suffix in the clip path's\n   *     ID.  These IDs must be unique in case there are multiple Blockly\n   *     instances on the same page.\n   * @private\n   */\n  createZoomOutSvg_(rnd) {\n    /* This markup will be generated and added to the .svgGroup_:\n    <g class=\"blocklyZoom\">\n      <clipPath id=\"blocklyZoomoutClipPath837493\">\n        <rect width=\"32\" height=\"32></rect>\n      </clipPath>\n      <image width=\"96\" height=\"124\" x=\"-64\" y=\"-92\"\n    xlink:href=\"media/sprites.png\"\n          clip-path=\"url(#blocklyZoomoutClipPath837493)\"></image>\n    </g>\n    */\n    this.zoomOutGroup_ =\n        dom.createSvgElement(Svg.G, {'class': 'blocklyZoom'}, this.svgGroup_);\n    const clip = dom.createSvgElement(\n        Svg.CLIPPATH, {'id': 'blocklyZoomoutClipPath' + rnd},\n        this.zoomOutGroup_);\n    dom.createSvgElement(\n        Svg.RECT, {\n          'width': 32,\n          'height': 32,\n        },\n        clip);\n    const zoomoutSvg = dom.createSvgElement(\n        Svg.IMAGE, {\n          'width': SPRITE.width,\n          'height': SPRITE.height,\n          'x': -64,\n          'y': -92,\n          'clip-path': 'url(#blocklyZoomoutClipPath' + rnd + ')',\n        },\n        this.zoomOutGroup_);\n    zoomoutSvg.setAttributeNS(\n        dom.XLINK_NS, 'xlink:href',\n        this.workspace_.options.pathToMedia + SPRITE.url);\n\n    // Attach listener.\n    this.onZoomOutWrapper_ = browserEvents.conditionalBind(\n        this.zoomOutGroup_, 'mousedown', null, this.zoom_.bind(this, -1));\n  }\n  /**\n   * Create the zoom out icon and its event handler.\n   * @param {string} rnd The random string to use as a suffix in the clip path's\n   *     ID.  These IDs must be unique in case there are multiple Blockly\n   *     instances on the same page.\n   * @private\n   */\n  createZoomInSvg_(rnd) {\n    /* This markup will be generated and added to the .svgGroup_:\n    <g class=\"blocklyZoom\">\n      <clipPath id=\"blocklyZoominClipPath837493\">\n        <rect width=\"32\" height=\"32\"></rect>\n      </clipPath>\n      <image width=\"96\" height=\"124\" x=\"-32\" y=\"-92\"\n    xlink:href=\"media/sprites.png\"\n          clip-path=\"url(#blocklyZoominClipPath837493)\"></image>\n    </g>\n    */\n    this.zoomInGroup_ =\n        dom.createSvgElement(Svg.G, {'class': 'blocklyZoom'}, this.svgGroup_);\n    const clip = dom.createSvgElement(\n        Svg.CLIPPATH, {'id': 'blocklyZoominClipPath' + rnd}, this.zoomInGroup_);\n    dom.createSvgElement(\n        Svg.RECT, {\n          'width': 32,\n          'height': 32,\n        },\n        clip);\n    const zoominSvg = dom.createSvgElement(\n        Svg.IMAGE, {\n          'width': SPRITE.width,\n          'height': SPRITE.height,\n          'x': -32,\n          'y': -92,\n          'clip-path': 'url(#blocklyZoominClipPath' + rnd + ')',\n        },\n        this.zoomInGroup_);\n    zoominSvg.setAttributeNS(\n        dom.XLINK_NS, 'xlink:href',\n        this.workspace_.options.pathToMedia + SPRITE.url);\n\n    // Attach listener.\n    this.onZoomInWrapper_ = browserEvents.conditionalBind(\n        this.zoomInGroup_, 'mousedown', null, this.zoom_.bind(this, 1));\n  }\n  /**\n   * Handles a mouse down event on the zoom in or zoom out buttons on the\n   *    workspace.\n   * @param {number} amount Amount of zooming. Negative amount values zoom out,\n   *    and positive amount values zoom in.\n   * @param {!Event} e A mouse down event.\n   * @private\n   */\n  zoom_(amount, e) {\n    this.workspace_.markFocused();\n    this.workspace_.zoomCenter(amount);\n    this.fireZoomEvent_();\n    Touch.clearTouchIdentifier();  // Don't block future drags.\n    e.stopPropagation();           // Don't start a workspace scroll.\n    e.preventDefault();            // Stop double-clicking from selecting text.\n  }\n  /**\n   * Create the zoom reset icon and its event handler.\n   * @param {string} rnd The random string to use as a suffix in the clip path's\n   *     ID.  These IDs must be unique in case there are multiple Blockly\n   *     instances on the same page.\n   * @private\n   */\n  createZoomResetSvg_(rnd) {\n    /* This markup will be generated and added to the .svgGroup_:\n    <g class=\"blocklyZoom\">\n      <clipPath id=\"blocklyZoomresetClipPath837493\">\n        <rect width=\"32\" height=\"32\"></rect>\n      </clipPath>\n      <image width=\"96\" height=\"124\" x=\"-32\" y=\"-92\"\n    xlink:href=\"media/sprites.png\"\n          clip-path=\"url(#blocklyZoomresetClipPath837493)\"></image>\n    </g>\n    */\n    this.zoomResetGroup_ =\n        dom.createSvgElement(Svg.G, {'class': 'blocklyZoom'}, this.svgGroup_);\n    const clip = dom.createSvgElement(\n        Svg.CLIPPATH, {'id': 'blocklyZoomresetClipPath' + rnd},\n        this.zoomResetGroup_);\n    dom.createSvgElement(Svg.RECT, {'width': 32, 'height': 32}, clip);\n    const zoomresetSvg = dom.createSvgElement(\n        Svg.IMAGE, {\n          'width': SPRITE.width,\n          'height': SPRITE.height,\n          'y': -92,\n          'clip-path': 'url(#blocklyZoomresetClipPath' + rnd + ')',\n        },\n        this.zoomResetGroup_);\n    zoomresetSvg.setAttributeNS(\n        dom.XLINK_NS, 'xlink:href',\n        this.workspace_.options.pathToMedia + SPRITE.url);\n\n    // Attach event listeners.\n    this.onZoomResetWrapper_ = browserEvents.conditionalBind(\n        this.zoomResetGroup_, 'mousedown', null, this.resetZoom_.bind(this));\n  }\n  /**\n   * Handles a mouse down event on the reset zoom button on the workspace.\n   * @param {!Event} e A mouse down event.\n   * @private\n   */\n  resetZoom_(e) {\n    this.workspace_.markFocused();\n\n    // zoom is passed amount and computes the new scale using the formula:\n    // targetScale = currentScale * Math.pow(speed, amount)\n    const targetScale = this.workspace_.options.zoomOptions.startScale;\n    const currentScale = this.workspace_.scale;\n    const speed = this.workspace_.options.zoomOptions.scaleSpeed;\n    // To compute amount:\n    // amount = log(speed, (targetScale / currentScale))\n    // Math.log computes natural logarithm (ln), to change the base, use\n    // formula: log(base, value) = ln(value) / ln(base)\n    const amount = Math.log(targetScale / currentScale) / Math.log(speed);\n    this.workspace_.beginCanvasTransition();\n    this.workspace_.zoomCenter(amount);\n    this.workspace_.scrollCenter();\n\n    setTimeout(this.workspace_.endCanvasTransition.bind(this.workspace_), 500);\n    this.fireZoomEvent_();\n    Touch.clearTouchIdentifier();  // Don't block future drags.\n    e.stopPropagation();           // Don't start a workspace scroll.\n    e.preventDefault();            // Stop double-clicking from selecting text.\n  }\n  /**\n   * Fires a zoom control UI event.\n   * @private\n   */\n  fireZoomEvent_() {\n    const uiEvent = new (eventUtils.get(eventUtils.CLICK))(\n        null, this.workspace_.id, 'zoom_controls');\n    eventUtils.fire(uiEvent);\n  }\n}\n\n/**\n * CSS for zoom controls.  See css.js for use.\n */\nCss.register(`\n.blocklyZoom>image, .blocklyZoom>svg>image {\n  opacity: .4;\n}\n\n.blocklyZoom>image:hover, .blocklyZoom>svg>image:hover {\n  opacity: .6;\n}\n\n.blocklyZoom>image:active, .blocklyZoom>svg>image:active {\n  opacity: .8;\n}\n`);\n\nexports.ZoomControls = ZoomControls;\n\nreturn exports; });\ngoog.moduleLoaderState_ = googPreviousLoaderState__;\n\n//# sourceURL=webpack:///./core/zoom_controls.js?")},
"./node_modules/webpack/buildin/global.js":function(c,a){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')}});}).call(this || window)
